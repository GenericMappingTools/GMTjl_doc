[
  {
    "objectID": "examples/projections.html",
    "href": "examples/projections.html",
    "title": "Map Projections",
    "section": "",
    "text": "Explore various map projection types and coordinate systems available in GMT.jl.\n\n\n\n\n\nA foundational example demonstrating basic projection functionality with the orthographic projection.\n\n\n\nComprehensive guide showcasing 30+ different cartographic projection examples including conic, azimuthal, cylindrical, and miscellaneous projections.\n\n\n\nDemonstrates optimal rectangular projection methods for global visualizations.\n\n\n\nShows how to combine UTM and geographic coordinate system annotations on the same map.\n\n\n\nExamples utilizing the Lee oblated stereographic projection method for Pacific region mapping.\n\n\n\nDemonstrates this unique ocean-focused map projection type ideal for oceanographic applications.\n\n\n\nStereographic net visualizations commonly used in structural geology and geophysics applications."
  },
  {
    "objectID": "examples/projections.html#examples",
    "href": "examples/projections.html#examples",
    "title": "Map Projections",
    "section": "",
    "text": "A foundational example demonstrating basic projection functionality with the orthographic projection.\n\n\n\nComprehensive guide showcasing 30+ different cartographic projection examples including conic, azimuthal, cylindrical, and miscellaneous projections.\n\n\n\nDemonstrates optimal rectangular projection methods for global visualizations.\n\n\n\nShows how to combine UTM and geographic coordinate system annotations on the same map.\n\n\n\nExamples utilizing the Lee oblated stereographic projection method for Pacific region mapping.\n\n\n\nDemonstrates this unique ocean-focused map projection type ideal for oceanographic applications.\n\n\n\nStereographic net visualizations commonly used in structural geology and geophysics applications."
  },
  {
    "objectID": "examples/misc/orbits.html",
    "href": "examples/misc/orbits.html",
    "title": "Plotting orbits",
    "section": "",
    "text": "This example shows how we can plot data above the Earth (or any other celestial body) surface. The orbits will take care of the hardest part, which is the hiding of points that lay on the backside of the sphere. This function normally expects data in Earth Centered Earth Fixed (ECEF) coordinates but is has also a demo mode where user doesn’t need to provide any data.\n\nusing GMT\norbits(show=true)\n\n\n\n\n\n\n\n\nBut a more realistic example is one where we plot the orbits of a satellite. Next example shows a couple track of the Aqua satellite. To compute the orbits, we need the help of the RemoteS package, that in turn use the so called Two-Line Elements orbit descriptor.\n\nusing GMT, RemoteS, SatelliteToolboxTle, SatelliteToolboxPropagators, SatelliteToolboxTransformations\n\n# Compute some Aqua orbits for ... \norb = sat_tracks(tle=[\"1 27424U 02022A   23229.43455053  .00001116  00000-0  25175-3 0  9994\";\n                      \"2 27424  98.2892 173.6510 0001539  53.4328  93.9112 14.58243961132289\"],\n                 start=\"2023-09-03T08:00:00\", duration=300, geocentric=true);\n\norbits(orb, lon0=45, land=:tomato, show=true)\n\n\n[ Info: Precompiling RemoteS [26020ff4-e92a-488e-a723-09c28e89e04a]\n\n[ Info: Precompiling RemoteSSatTbxExt [ac2b0e66-2933-5069-b1b2-b3480851cfcc]\n\n\n\n\n\n\n\n\n\n\n\norbits(gmtread(TESTSDIR * \"assets/orbits_aqua.dat\"), lon0=45, land=:tomato, show=true)"
  },
  {
    "objectID": "examples/misc/gadm.html",
    "href": "examples/misc/gadm.html",
    "title": "GADM",
    "section": "",
    "text": "Plot countries administrative units\nWe start by download and save in cache the geopackage file with Mozambique data. Note, a downloading message will be printed only once, and in this case it will say\nDownloading geographic data for country MOZ provided by the https://gadm.org project. It may take a while. The file gadm36_MOZ.gpkg (after uncompressing) will be stored in your home dir/.gmt/cache\n\nusing GMT\nmozambique = gadm(\"MOZ\");\n\nimshow(mozambique, proj=:guess, title=\"Moçambique\")\n\n\n\n\n\n\n\n\nNext let us add all the provincies of Moçambique. For that we’ll use the country code as parent and the option children=true to indicate that we want all provincies boundaries.\n\nusing GMT\nmozambique = gadm(\"MOZ\", children=true);\nimshow(mozambique, proj=:guess, title=\"Provinces of Moçambique\")\n\n\n\n\n\n\n\n\nTo know the provinces names such that we can use them individually for example, we use the option names=true\ngadm(\"MOZ\", names=true)\n\"Cabo Delgado\"\n\"Gaza\"\n\"Inhambane\"\n\"Manica\"\n\"Maputo\"\n\"Maputo City\"\n\"Nampula\"\n\"Nassa\"\n\"Sofala\"\n\"Tete\"\n\"Zambezia\"\nNow we can plot only one of those provinces and its children\n\nusing GMT\nCD = gadm(\"MOZ\", \"Cabo Delgado\", children=true);\nimshow(CD, proj=:guess, title=\"Cabo Delgado\")"
  },
  {
    "objectID": "examples/images/05_wms.html",
    "href": "examples/images/05_wms.html",
    "title": "Web Map Service",
    "section": "",
    "text": "{{doc wmsread}}"
  },
  {
    "objectID": "examples/images/05_wms.html#download-and-display-a-sentinel-2-image",
    "href": "examples/images/05_wms.html#download-and-display-a-sentinel-2-image",
    "title": "Web Map Service",
    "section": "Download and display a Sentinel 2 image",
    "text": "Download and display a Sentinel 2 image\nFirst we have to start by fetching the information provided by this Web Map Server\njulia&gt; wms = wmsinfo(\"http://tiles.maps.eox.at/wms?\")\nserverURL:      http://tiles.maps.eox.at/wms?\nOnlineResource: http://tiles.maps.eox.at/?\nversion:        1.1.1\nrequest:        GetMap\nlayernames:     [\"s2cloudless-2018_3857\", \"coastline\", \"s2cloudless-2020\", \"osm_3857\", \"s2cloudless_3857\", \"terrain_3857\", \"overlay_base_bright_3857\", \"hydrography\", \"graticules\", \"overlay_3857\", \"bluemarble\", \"coastline_black\", \"s2cloudless-2017_3857\", \"streets_3857\", \"overlay_bright\", \"s2cloudless-2019_3857\", \"overlay\", \"blackmarble_3857\", \"hydrography_3857\", \"s2cloudless-2017\", \"streets\", \"s2cloudless-2018\", \"s2cloudless-2019\", \"osm\", \"blackmarble\", \"terrain-light_3857\", \"s2cloudless-2020_3857_512\", \"bluemarble_3857\", \"overlay_base_3857\", \"s2cloudless\", \"terrain\", \"overlay_bright_3857\", \"coastline_3857\", \"s2cloudless-2020_3857\", \"magnetic_graticules\", \"terrain-light\", \"overlay_base_bright\", \"overlay_base\"]\n\nlayer:  38 Layers. Use layer[k] to see the contents of layer k\nNext, let’s look at the contents of the layer 3\njulia&gt; wms.layer[3]\nname:   s2cloudless-2020\ntitle:  Sentinel-2 cloudless layer for 2020 by EOX - 4326\nsrs:    EPSG:4326\ncrs:\nbbox:   (-180.0, 180.0, -90.0, 90.0)\nimgformat:      image/jpeg\ntilesize:       256\noverviewcount:  17\nresolution:     5.3644180298e-6\ntiled:  true\ntransparent:    false\nAnd finaly download and display a low-resolution image of that layer 3 at 1500 m/pixel.\n\nusing GMT\nwms = wmsinfo(\"http://tiles.maps.eox.at/wms?\");\nimg = wmsread(wms, layer=3, region=(-10,-5,37,44), pixelsize=1500);\nimshow(img, proj=:guess, title=\"Sentinel 2\")"
  },
  {
    "objectID": "examples/images/05_wms.html#download-and-display-a-modis-image",
    "href": "examples/images/05_wms.html#download-and-display-a-modis-image",
    "title": "Web Map Service",
    "section": "Download and display a MODIS image",
    "text": "Download and display a MODIS image\nUse the a WMS from NASA and download a MODIS Terra reflectance image from 29 October 2021\n\nusing GMT\nwms = wmsinfo(\"https://gibs-c.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi\");\nimg = wmsread(wms, layer=\"MODIS_Terra_CorrectedReflectance_TrueColor\", region=(9,22,32,43), time=\"2021-10-29T00:00:00\", pixelsize=1500);\nimshow(img, proj=:guess, title=\"MODIS Terra\")"
  },
  {
    "objectID": "examples/images/03_hexbin.html",
    "href": "examples/images/03_hexbin.html",
    "title": "Hexagonal binning",
    "section": "",
    "text": "{{doc gmtbinstats}}"
  },
  {
    "objectID": "examples/images/03_hexbin.html#binhex",
    "href": "examples/images/03_hexbin.html#binhex",
    "title": "Hexagonal binning",
    "section": "Binhex",
    "text": "Binhex\nTo do hexagonal binning of a random data and counting the number of points inside each hexagon, try:\n\nusing GMT\nxy = rand(100,2) .* [5 3];\nD = binstats(xy, region=(0,5,0,3), inc=1, tiling=:hex, stats=:number);\nimshow(D, hexbin=true, ml=0.5, colorbar=true)"
  },
  {
    "objectID": "examples/images/01c_funs3d.html",
    "href": "examples/images/01c_funs3d.html",
    "title": "Plot surfaces",
    "section": "",
    "text": "Ackley\ngrdview can plot 3-D surfaces with them provided as grids or as function equations or some predefined function names. Note that the view option controls the azimuth and elevation angle of the view.\nThere are a couple of predefined functions that can plotted for demonstration purposes. For example the ackley function\n\nusing GMT\nimshow(\"ackley\", view=(159,30), shade=true)\n\n\n\n\n\n\n\n\n\n\nRosenbrock\nOr the rosenbrock that looks like a manta ray (other options are parabola, eggbox, sombrero)”\n\nusing GMT\nimshow(\"rosenbrock\", view=(159,30), shade=true)\n\n\n\n\n\n\n\n\nBut besides these predefined functions one can any function that defines a surface. For example a parabola can be plotted with the code bellow. First argument can be an anonymous function (like the example) of a function. Second and third args contain the plotting domain and step used to evaluate the function.\n\nusing GMT\nimshow((x,y) -&gt; sqrt(x^2 + y^2), -5:0.05:5, -5:0.05:5, view=(159,30), shade=true, frame=:autoXYZg)\n\n\n\n\n\n\n\n\nAnd we can plot 3D lines too. Same thing, give a parametric equation and\n\nusing GMT\nplot3d(x -&gt; sin(x)*cos(10x), y -&gt; sin(y)*sin(10y), z -&gt; cos(z), 0:pi/200:pi, lt=2, lc=:brown, frame=:autoXYZg, show=true)"
  },
  {
    "objectID": "examples/embellish/03_insets.html",
    "href": "examples/embellish/03_insets.html",
    "title": "Map insets",
    "section": "",
    "text": "Inset of a Japan area\ninsets adds an inset figure inside a larger figure. Because the inset is a GMT so called modern mode feature in this example we will use the gmtbegin() ... gmtend() form.\n\n\nusing GMT\n\ngmtbegin()\n    coast(region=[137.5, 141, 34, 37], proj=\"UTM54\", frame=(axes=:WSen, annot=:auto, ticks=:auto),\n          land=:lightbrown, water=:azure1, shorelines=1, area=1000)\n    # Create an inset map, setting it at bottom right with a x- and y-offsets of 0.1 cm.\n    inset(inset_box=(anchor=:BR, width=3, offset=0.1), box=(fill=:white, pen=1))\n        coast(region=[129, 146, 30, 46], proj=\"UTM54\", figsize=3,\n              DCW=(country=:JP, fill=:lightbrown, pen=0.2), area=10000)\n        plot([137.5 34 141 37], marker=\"r+s\", ml=(1, :blue))    # A blue rectangle\n    inset(:end)\ngmtend(:show)"
  },
  {
    "objectID": "examples/contours/02_polar_contours.html",
    "href": "examples/contours/02_polar_contours.html",
    "title": "Polar Contours",
    "section": "",
    "text": "Simple contours\nAs an example of this projection we will create a gridded data set in polar coordinates using grdmath, a RPN calculator that operates on or creates grid files.\nWe will use grdcontour to make a contour map of this data. Because the data file only contains values with 2 =&lt; r &lt;= 4, a donut shaped plot appears in the example figure shown below.\n\nusing GMT\nGMT.resetGMT()  # hide\n\nG = grdmath(\"-R0/360/2/4 -I6/0.1 X 4 MUL PI MUL 180 DIV COS Y 2 POW MUL\");\ngrdcontour(G, proj=:polar, frame=(annot=30, axes=:Ns, fill=:honeydew),\n           cont=2, smooth=4, par=(FORMAT_GEO_MAP=\"+ddd\",), show=true)"
  },
  {
    "objectID": "examples/art/art_examples.html",
    "href": "examples/art/art_examples.html",
    "title": "Art",
    "section": "",
    "text": "Draw a flower filled from a pattern in a .jpg file.\n\n\nusing GMT\n\nt = GMT.linspace(0,2pi,360);\nx = cos.(4*t) .* cos.(t);\ny = cos.(4*t) .* sin.(t);\n\nlines([-0.7 -0.25 0], [-1.5 -0.8 0], # The flower stem\n      limits=(-1,1,-1.5,1),          # Fig limits\n      lw=9,                          # Stem's line width in points\n      lc=:darkgreen,                 # Stem's line color\n      bezier=true,                   # Smooth the stem polyline as a Bezier curve\n      figsize=(14,0),                # Fig size. Second arg = 0 means compute the height keeping aspect ratio\n      frame=:none)                   # Do not plot the frame\nplot!(x, y,\n      fill=(pattern=TESTSDIR * \"assets/tiling2.jpg\",  # Fill pattern file\n      dpi=200), show=true)           # The pattern DPI\n\n\n\n\n\n\n\n\n\n\n\nA imitation of the original car made by @cormullion in this Julia forum post\n\nusing GMT, GMT.Drawing\n\nellipse(300,201,0, 200, 50, units=:points, first=true, fill=:purple, pen=1);\nellipse(340,206, 0,130, 66, fill=:purple, pen=1);\nellipse(318,222,0, 60, 26, fill=:blue);\nbox(200, 173, 205, 26, fill=:purple, pen=1);\ncircle(305,185,56, fill=:black);\ncircle(305,185,36, fill=:gray50);\ncircle(400,185,56, fill=:black);\ncircle(400,185,36, fill=:gray50, show=true);\n\n\n\n\n\n\n\n\n\n\n\nThis example was presented by @FedericoStra in the Seven Lines of Julia but the GMT figure is clearly nicer (at least IMO).\n\nusing GMT\nfunction mandelbrot(z)\n    w = z\n    for n in 1:74\n        abs2(w) &lt; 4 ? w = w^2 + z : return n\n    end\n    75\nend\nx, y = range(-0.65, -0.45; length=1600), range(0.51, 0.71; length=1600);\nimshow(-log.(mandelbrot.(x' .+ y .* im)), frame=:none, title=\"Mandelbrot painting\", figsize=12)"
  },
  {
    "objectID": "examples/art/art_examples.html#examples",
    "href": "examples/art/art_examples.html#examples",
    "title": "Art",
    "section": "",
    "text": "Draw a flower filled from a pattern in a .jpg file.\n\n\nusing GMT\n\nt = GMT.linspace(0,2pi,360);\nx = cos.(4*t) .* cos.(t);\ny = cos.(4*t) .* sin.(t);\n\nlines([-0.7 -0.25 0], [-1.5 -0.8 0], # The flower stem\n      limits=(-1,1,-1.5,1),          # Fig limits\n      lw=9,                          # Stem's line width in points\n      lc=:darkgreen,                 # Stem's line color\n      bezier=true,                   # Smooth the stem polyline as a Bezier curve\n      figsize=(14,0),                # Fig size. Second arg = 0 means compute the height keeping aspect ratio\n      frame=:none)                   # Do not plot the frame\nplot!(x, y,\n      fill=(pattern=TESTSDIR * \"assets/tiling2.jpg\",  # Fill pattern file\n      dpi=200), show=true)           # The pattern DPI\n\n\n\n\n\n\n\n\n\n\n\nA imitation of the original car made by @cormullion in this Julia forum post\n\nusing GMT, GMT.Drawing\n\nellipse(300,201,0, 200, 50, units=:points, first=true, fill=:purple, pen=1);\nellipse(340,206, 0,130, 66, fill=:purple, pen=1);\nellipse(318,222,0, 60, 26, fill=:blue);\nbox(200, 173, 205, 26, fill=:purple, pen=1);\ncircle(305,185,56, fill=:black);\ncircle(305,185,36, fill=:gray50);\ncircle(400,185,56, fill=:black);\ncircle(400,185,36, fill=:gray50, show=true);\n\n\n\n\n\n\n\n\n\n\n\nThis example was presented by @FedericoStra in the Seven Lines of Julia but the GMT figure is clearly nicer (at least IMO).\n\nusing GMT\nfunction mandelbrot(z)\n    w = z\n    for n in 1:74\n        abs2(w) &lt; 4 ? w = w^2 + z : return n\n    end\n    75\nend\nx, y = range(-0.65, -0.45; length=1600), range(0.51, 0.71; length=1600);\nimshow(-log.(mandelbrot.(x' .+ y .* im)), frame=:none, title=\"Mandelbrot painting\", figsize=12)"
  },
  {
    "objectID": "examples/misc/buffer.html",
    "href": "examples/misc/buffer.html",
    "title": "Geodesic buffers",
    "section": "",
    "text": "Buffers polygons delimite areas that are within some distance of input features. We can have them arround points or lines. We will show here examples of both.\nWe start by computing a great circle, also known as an orthodrome between two points and interpolated at 1000 km increments.\n\nusing GMT\n# Compute the great circle (orthodrome) line\northo = orthodrome([0 0; 70 60], step=1000, unit=:k);\n# Plot the orthodrome on an orthographic projection\ncoast(region=:global, proj=(name=:ortho, center=(0,45)), land=:peru, frame=:g)\nplot!(ortho, lw=0.5, marker=:circ, ms=0.1, fill=:black, show=true)\n\n\n\n\n\n\n\n\nNext we will draw geodesic circles with 500 km radius with center on the orthodrome vertices. And to do it we need ofc to compute those circles. We compute the circles with the circgeo function.\n\nusing GMT\northo = orthodrome([0 0; 70 60], step=1000, unit=:k);\nc = circgeo(ortho, radius=500, unit=:k);\ncoast(region=:global, proj=(name=:ortho, center=(0,45)), land=:peru, frame=:g)\nplot!(c, lw=0.1, fill=:gray)\nplot!(ortho, lw=0.5, marker=:circ, ms=0.1, fill=:black, show=true)\n\n\n\n\n\n\n\n\nNow imagine that we plot many close circles and compute the union of them all. That’s how we get the buffer.\n\nusing GMT\n# Poly-line arround which to compute the buffer. Make it go arround the pole.\nline = [-37. 1; -28 26; -45 35; -19 42; -9 55; 4 64; 32 72; 85 73; 135 73; 172 73; -144 73; -78 77; -27 72; -8 65; 8 54; 18 39; 28 24; 34 1];\nD = buffergeo(line, width=500000);  # Compute the buffer polygon\ncoast(region=:global, land=:peru, frame=:g,\n      proj=(name=:ortho, center=(0,45)),\n      plot=(data=D, fill=:green), show=true)"
  },
  {
    "objectID": "examples/subplot/01_subplots.html",
    "href": "examples/subplot/01_subplots.html",
    "title": "Subplots",
    "section": "",
    "text": "See subplot docs"
  },
  {
    "objectID": "examples/subplot/01_subplots.html#background-images",
    "href": "examples/subplot/01_subplots.html#background-images",
    "title": "Subplots",
    "section": "Background images",
    "text": "Background images\nThe examples in the panels of this subplot are intended to demonstrate the background option that paints the canvas with either an external figure or one created internally, and which is described in the plot manual. Note that in panel (2,2) we are painting with the frame option bg, which does the fill with a pattern repetition instead of filling with a single image.\n\nusing GMT\nx = -2π:0.1:2π\nsubplot(grid=\"2x3\", panels_size=6, region=(-2π, 2π, -1, 1), frame=:WSen, margins=0.2)\n    plot(x, sin.(x), lw=1, lc=:darkgreen, bg=\"@needle.jpg\")\n    plot(x, sin.(x), lw=1, lc=:orange,    bg=:circ, panel=(1,2))\n    plot(x, sin.(x), lw=1, lc=:orange,    bg=\"-circ\", panel=(1,3))\n    plot(x, sin.(x), lw=1, lc=:white,     bg=(:eggs, :lisbon), panel=(2,1))\n    plot(x, sin.(x), lw=2, lc=:blue,      frame=(bg=(pattern=\"@warning.png\",),), panel=(2,2))\n    basemap(region=(-6000,0,0,30), panel=(2,3))\n    histogram(\"@v3206_06.txt\", fill=:orange, pen=0.5, kind=(freq=true,), bin=250, bg=mat2grid(rand(64,64))) \nsubplot(:show)"
  },
  {
    "objectID": "examples/subplot/01_subplots.html#geo-tic-tac-toe",
    "href": "examples/subplot/01_subplots.html#geo-tic-tac-toe",
    "title": "Subplots",
    "section": "Geo Tic-Tac-Toe",
    "text": "Geo Tic-Tac-Toe\n\nusing GMT\nsubplot(grid=\"3x3\", dims=(panels=(5,),divlines=(1,:dashed)), axes=(axes=:lrbt,), margins=0);\n    coast(region=:global, proj=(name=:Ortho, center=(30 ,30)), land=:red, B=:g, panel=(1,1));\n    coast(region=:global, proj=(name=:Ortho, center=(120,30)), land=:red, B=:g, panel=(2,2));\n    coast(region=:global, proj=(name=:Ortho, center=(210,30)), land=:red, B=:g, panel=(3,3));\nsubplot(:show)"
  },
  {
    "objectID": "examples/subplot/01_subplots.html#side-histograms",
    "href": "examples/subplot/01_subplots.html#side-histograms",
    "title": "Subplots",
    "section": "Side histograms",
    "text": "Side histograms\n\nusing GMT\nsubplot(grid=\"2x2\", dims=(size=(15,15), frac=((10,5),(5,10))),\n        col_axes=true, row_axes=true)\n    n = 200;\n    x, y, color = randn(n)/2, randn(n), randn(n);\n    histogram(x, limits=(-4,4,0,40), binmethod=\"sqrt\", panel=(1,1));\n    scatter(x,y, limits=(-4,4,-4,4), marker=:circ, ms=\"10p\", zcolor=color, panel=(2,1));\n    histogram(y, limits=(-4,4,0,40), horizontal=true, binmethod=\"sqrt\", panel=(2,2));\nsubplot(:show)"
  },
  {
    "objectID": "examples/choropleths/choro_examples.html",
    "href": "examples/choropleths/choro_examples.html",
    "title": "Choropleths",
    "section": "",
    "text": "A choropleth is a thematic map where areas are colored in proportion to a variable such as population density. GMT lets us plot choropleth maps but the process is not straightforward because we need to put the color information in the header of a multi-segment file. To facilitate this, some tools were added to the Julia wrapper.\n(But see also the more extended example in [tutorials])"
  },
  {
    "objectID": "examples/choropleths/choro_examples.html#countries-europe-dcw",
    "href": "examples/choropleths/choro_examples.html#countries-europe-dcw",
    "title": "Choropleths",
    "section": "Countries (Europe DCW)",
    "text": "Countries (Europe DCW)\nLoad packages needed to download data and put into a DataFrame\n\nusing GMT, DataFrames, CSV\n\npaises = CSV.File(HTTP.get(\"https://raw.githubusercontent.com/tillnagel/unfolding/master/data/data/countries-population-density.csv\").body, delim=';') |&gt; DataFrame;\nExtract the Europe countries from the DCW file\neu = coast(DCW=\"=EU+z\", dump=true);\nGenerate two vector with country codes (2 chars codes) and the population density for European countries.\ncodes, vals = GMT.mk_codes_values(paises[!, 2], paises[!, 3], region=\"eu\");\nCreate a Categorical CPT that allows plotting the choropleth. Note that we need to limit the CPT range to leave out the very high density states like Monaco otherwise all others would get the same color.\nC = cpt4dcw(codes, vals, range=[10, 500, 10]);\nShow the result\nplot(eu, cmap=C, fill=\"+z\", proj=:guess, R=\"-76/36/26/84\", title=\"Population density\",\n    colorbar=true, show=true)"
  },
  {
    "objectID": "examples/choropleths/choro_examples.html#countries-world",
    "href": "examples/choropleths/choro_examples.html#countries-world",
    "title": "Choropleths",
    "section": "Countries (World)",
    "text": "Countries (World)\nWhile GMT come with the world countries in its DCW data base, those countries polygons have a somewhat too high resolution for world maps and hence produce files unnecessarily, which also makes them slower to create. An alternative is to use a much lower resolution file that can be found here but whose download link is here. And we can read it directly into GMT (and wait a bit while it gets downloaded).\ncountries = gmtread(\"/vsicurl/https://github.com/datasets/geo-countries/raw/main/data/countries.geojson\");\nThe country polygons have attributes like:\nAttributes:  Dict(\"ISO_A2\" =&gt; \"AW\", \"ISO_A3\" =&gt; \"ABW\", \"ADMIN\" =&gt; \"Aruba\")\nLike in the Europe case above, we load the world population into a DataFrame\npop = CSV.File(HTTP.get(\"https://raw.githubusercontent.com/tillnagel/unfolding/master/data/data/countries-population-density.csv\").body, delim=';') |&gt; DataFrame;\nThe contents of that file look like this:\njulia&gt; pop\n248×3 DataFrame\n Row │ Country Name                       Country Code  2010\n     │ String                             String3       Float64?\n─────┼───────────────────────────────────────────────────────────\n   1 │ Arab World                         ARB            26.2725\n   2 │ Caribbean small states             CSS            16.9939\n   3 │ East Asia & Pacific (all income …  EAS            90.5122\n2 │ Caribbean small states CSS 16.9939 3 │ East Asia & Pacific (all income … EAS 90.5122\n\nSo we must now link the countries in `countries` with density in `2010` via the attribute `ISO_A3` in `countries`\nand the third column in `pop`. To make a global choropleth map with the population density we will use first the\npolygonlevels function to get as the population density in the same order as the country polygons are\nstored in the `countries` GMTdataset.\n\n```julia\nzvals = polygonlevels(countries, string.(pop[!,2]), pop[!,3], att=\"ISO_A3\");\nAnd now we are ready to make the map\n# First create the colormap. Limit the maximum range to 500 otherwise states\n# like Monaco would the all the `reds` and the rest of the world would be all blues.\nC = makecpt(range=(0,500,10));\nplot(countries, region=(-180,180,-60,85), level=zvals, cmap=C, proj=:guess,\n     title=\"World population density\", colorbar=true, show=true)"
  },
  {
    "objectID": "examples/choropleths/choro_examples.html#covid-rate-of-infection-in-portugal-2021",
    "href": "examples/choropleths/choro_examples.html#covid-rate-of-infection-in-portugal-2021",
    "title": "Choropleths",
    "section": "Covid rate of infection in Portugal 2021",
    "text": "Covid rate of infection in Portugal 2021\nFirst, download the Portuguese district polygons shape file from this Github repo Next load it with:\nusing GMT, DataFrames, CSV\n\nPt = gmtread(\"C:\\\\programs\\\\compa_libs\\\\covid19pt\\\\extra\\\\mapas\\\\concelhos\\\\concelhos.shp\");\nDownload and load a CSV file from same repo with rate of infection per district. Load it into a DataFrame to simplify data extraction.\nincidence = CSV.read(\"C:\\\\programs\\\\compa_libs\\\\covid19pt\\\\data_concelhos_incidencia.csv\", DataFrame);\nGet the rate of incidence in number of infected per 100_000 habitants for the last reported week.\nr = collect(incidence[end, 2:end]);\nBut the damn polygon names above are all uppercase, Ghrrr. We will have to take care of that.\nids = names(incidence)[2:end];\nEach of the Pt datasets have attributes (e.g., Pt[1].attrib) and the one that is common with the names in ids is the Pt[1].attrib[\"NAME2\"] (the conselho name). But the names in dataconcelhosincidencia.csv (from which the ids are derived) and the concelhos.shp (that we read into Pt) do not use the same case (one is full upper case) so we need to use the nocase=true below. The comparison is made inside the next call to the polygonlevels() function that takes care to return the numerical vector that we need in plot’s level option.\nzvals = polygonlevels(Pt, ids, r, att=\"NAME_2\", nocase=true);\nCreate a Colormap to paint the district polygons\nC = makecpt(range=(0,1500,10), inverse=true, cmap=:oleron, hinge=240, bg=:o);\nGet the date for the data being represented to use in title\ndate = incidence[end,1];\nAnd finaly do the plot\nplot(Pt, level=zvals, cmap=C, pen=0.5, region=(-9.75,-5.9,36.9,42.1), proj=:Mercator,\n     title=\"Infected / 100.000 habitants \" * date)\n\ncolorbar!(pos=(anchor=:MR,length=(12,0.6), offset=(-2.4,-4)), color=C,\n          axes=(annot=100,), show=true)"
  },
  {
    "objectID": "examples/arrows/10_arrows.html",
    "href": "examples/arrows/10_arrows.html",
    "title": "Arrow examples",
    "section": "",
    "text": "{{doc arrows}}\nusing GMT\narrows([0.5 0.5 0 2], limits=(0.,3,0,2.5), figsize=(15,5),\n       arrow=(len=2,), pen=6,\n       frame=(axes=:WSrt, annot=:auto, title=\"Arrow I\"))\n# Add the plotting command to the figure\nT1 = \"arrows([0.5 0.5 0 2], limits=(0,3,0,2.5), figsize=(15,5),\";\nT2 = \"   arrow=(len=2,stop=1,shape=0.5), pen=6\";\npstext!([1.5 2.0], text=T1, font=(18,\"Times-Italic\"), justify=:CB)\npstext!([1.5 1.5], text=T2, font=(18,\"Times-Italic\"), justify=:CB, show=true)\nusing GMT\narrows([0.5 0.5 0 2], limits=(0,3,0,2.5), figsize=(15,5),\n       arrow=(len=2,start=:arrow,stop=:tail,shape=0.5), fill=:red, pen=6,\n       frame=(axes=:WSrt, annot=:auto, title=\"Arrow II\"))\n# Add the plotting command to the figure\nT1 = \"arrows([0.5 0.5 0 2], limits=(0,3,0,2.5), figsize=(15,5),\";\nT2 = \"       arrow=(len=2,start=:arrow,stop=:tail,shape=0.5),\";\nT3 = \"       pen=6, fill=:red\";\npstext!([0.1 2.0], text=T1, font=(18,\"Times-Italic\"), justify=:LB)\npstext!([0.1 1.5], text=T2, font=(18,\"Times-Italic\"), justify=:LB)\npstext!([0.1 1.1], text=T3, font=(18,\"Times-Italic\"), justify=:LB, show=true)"
  },
  {
    "objectID": "examples/arrows/10_arrows.html#gmt4-gmt5-style-arrows",
    "href": "examples/arrows/10_arrows.html#gmt4-gmt5-style-arrows",
    "title": "Arrow examples",
    "section": "GMT4 & GMT5 style arrows",
    "text": "GMT4 & GMT5 style arrows\nPlot GMT4 style arrows. We show here three alternatives to set arrow heads\n\nusing GMT\narrows([1 0 45 2], region=(0,6,-1,1), figscale=\"2.5\",\n       frame=(annot=:auto, grid=1, title=\"GMT4 Vectors\"),\n       pen=(1,:blue), fill=:red, arrow4=(align=:middle,\n       head=(arrowwidth=\"4p\", headlength=\"18p\", headwidth=\"7.5p\"), double=true))\narrows!([3 0 45 2], pen=(1,:blue), fill=:red,\n        arrow4=(align=:middle, head=(\"4p\",\"18p\", \"12p\")))\narrows!([5 0 45 2], pen=(1,:blue), fill=:red,\n        arrow4=(align=:middle, head=\"8p/18p/17.5p\"))\n\n# Now the GMT5 type arrows\narrows!([1 0 45 2], frame=(annot=:auto, grid=1, title=\"GMT5 Vectors\"), lw=2, fill=:red,\n        arrow=(length=\"18p\", start=true, stop=true, pen=(1,:blue),\n               angle=45, justify=:center, shape=0.5), yshift=7)\narrows!([3 0 45 2], lw=2, fill=:red,\n        arrow=(length=\"18p\", stop=true, pen=\"-\", angle=45, justify=:center, shape=0.5))\narrows!([5 0 45 2], lw=2, fill=:red,\n        arrow=(length=\"18p\", stop=true, angle=45, justify=:center, shape=0.5), show=true)"
  },
  {
    "objectID": "examples/arrows/10_arrows.html#mat-angles",
    "href": "examples/arrows/10_arrows.html#mat-angles",
    "title": "Arrow examples",
    "section": "Mat angles",
    "text": "Mat angles\nPlot matangle symbols with vector heads.\n\nusing GMT\nplot([0.5 1 1.75 5 85], region=(0,5,0,5), figsize=12,\n        marker=(matang=true, arrow=(length=0.75, start=true, stop=true, half=:right)),\n        ml=(0.5,:red), fill=:blue)\n# Now add another matangle symbol but transmit the angle parameters via the\n# keyword. Note that in this case the arrow attributes are wrapped in a NamedTuple\nplot!([2.5 2.5], marker=(:matang, [2 50 350], (length=0.75, start=true, stop=true, half=:left)),\n        ml=(0.5,:red), fill=:blue, show=true)"
  },
  {
    "objectID": "examples/arrows/10_arrows.html#vector-heads-and-tails",
    "href": "examples/arrows/10_arrows.html#vector-heads-and-tails",
    "title": "Arrow examples",
    "section": "Vector heads and tails",
    "text": "Vector heads and tails\nThere are many methods to plot vectors with individual heads and tails. For this purpose, several modifiers may be set to the corresponding vector-producing parameters for specifying the placement of vector heads and tails, their shapes, and the justification of the vector, see more at [Vector Attributes].\n\nusing GMT\n\narrows([1 14 0 35], limits=(-5,100,1,15), figsize=(15,10), pen=2, arrow=(len=0,), \n       frame=:none, title=\"Vector heads and tails\")\ntext!([\"arrow=(len=0,)\"], x=40, y=14, font=8, justify=:LM)\narrows!([1 13 0 35], pen=2, arrow=(len=0.6, start=:open_arrow, stop=:open_arrow, angle=50))\ntext!([\"arrow=(len=0.6, start=:open_arrow, stop=:open_arrow, angle=50)\"], x=40, y=13, font=8, justify=:LM)\narrows!([1 12 0 35], pen=2, arrow=(len=0.4, start=:open_tail, stop=:open_tail))\ntext!([\"arrow=(len=0.4, start=:open_tail, stop=:open_tail)\"], x=40, y=12, font=8, justify=:LM)\narrows!([1 11 0 35], pen=2, arrow=(len=0.3, start=:line, stop=:line, angle=80))\ntext!([\"arrow=(len=0.3, start=:line, stop=:line, angle=80)\"], x=40, y=11, font=8, justify=:LM)\narrows!([1 10 0 35], pen=2, arrow=(len=0.6, stop=true), fill=:red3)\ntext!([\"arrow=(len=0.6, stop=true)\"], x=40, y=10, font=8, justify=:LM)\narrows!([1  9 0 35], pen=2, arrow=(len=0.6, start=:circle, stop=true), fill=:red3)\ntext!([\"arrow=(len=0.6, start=:circle, stop=true)\"], x=40, y=9, font=8, justify=:LM)\narrows!([1  8 0 35], pen=2, arrow=(len=0.6, start=:line, stop=true), fill=:red3)\ntext!([\"arrow=(len=0.6, start=:line, stop=true)\"], x=40, y=8, font=8, justify=:LM)\narrows!([1  7 0 35], pen=2, arrow=(len=1, stop=true, shape=0.5), fill=:red3)\ntext!([\"arrow=(len=1, stop=true, shape=0.5)\"], x=40, y=7, font=8, justify=:LM)\narrows!([1  6 0 35], pen=2, arrow=(len=1, start=true, stop=true, shape=0.5), fill=:red3)\ntext!([\"arrow=(len=1, start=true, stop=true, shape=0.5)\"], x=40, y=6, font=8, justify=:LM)\narrows!([1  5 0 35], pen=2, arrow=(len=1, start=:tail, stop=true, shape=0.5), fill=:red3)\ntext!([\"arrow=(len=1, start=:tail, stop=true, shape=0.5)\"], x=40, y=5, font=8, justify=:LM)\narrows!([1  4 0 35], pen=2, arrow=(len=1, start=:right, stop=true, shape=0.5), fill=:red3)\ntext!([\"arrow=(len=1, start=:right, stop=true, shape=0.5)\"], x=40, y=4, font=8, justify=:LM)\narrows!([1  3 0 35], pen=2, arrow=(len=1, start=:right, stop=:left, shape=0.5), fill=:red3)\ntext!([\"arrow=(len=1, start=:right, stop=:left, shape=0.5)\"], x=40, y=3, font=8, justify=:LM)\narrows!([1  2 0 35], pen=2, arrow=(len=1, start=:tail, stop=true, half=:right, shape=0.5, angle=45), fill=:red3)\ntext!([\"arrow=(len=1, start=:tail, stop=true, half=:right, shape=0.5, angle=45)\"], x=40, y=2, font=8, justify=:LM)\nshowfig()"
  },
  {
    "objectID": "examples/arrows/10_arrows.html#cartesian-circular-and-geographic-vectors",
    "href": "examples/arrows/10_arrows.html#cartesian-circular-and-geographic-vectors",
    "title": "Arrow examples",
    "section": "Cartesian, circular, and geographic vectors",
    "text": "Cartesian, circular, and geographic vectors\nPlot Cartesian, circular, and geographic vectors. This example was picked from the PyGMT gallery.\n\nusing GMT\ncoast(region=[-127, -64, 24, 53], proj=:merc, borders=1, area=4000, shore=true)\n\n# Left: plot 12 Cartesian vectors with different lengths\nx = fill(-117, 12);               # x vector coordinates\ny = linspace(33.5, 42.5, 12);     # y vector coordinates\ndirection = zeros(12);            # direction of vectors (horizontal)\nlength = linspace(2, 10, 12);  # length of vectors\narrows!([x y direction length], pen=(1,:red),\n        arrow=(len=\"0.2\", stop=true, fill=:red, angle=40, shape=:triang))\ntext!(text=\"CARTESIAN\", x=-112, y=44.2, font=\"13p,Helvetica-Bold,red\")\n\n# Middle: plot 7 math angle arcs with different radii\nnum = 7\nx, y = fill(-95, 7), fill(37, 7)\nradius = 1.8 .- 0.2 * (0:num-1)\nstartdir = fill(90, num)\nstopdir  = 180 .+ 40 * (0:num-1)\ndata = [x y radius startdir stopdir]\nplot!(data, marker=(matang=true, arrow=(length=0.5, stop=true)), fill=:red3, pen=\"1.5,black\")\ntext!(text=\"CIRCULAR\", x=-95, y=44.2, font=\"13p,Helvetica-Bold,black\")\n\n# Right: plot geographic vectors using endpoints\nNYC = [-74.0060 40.7128]\nCHI = [-87.6298 41.8781]\nSEA = [-122.3321 47.6062]\nNO = [-90.0715 29.9511]\nplot!([NYC CHI; NYC SEA; NYC NO], pen=\"1.0,blue\",\n      geovec=(length=0.5, stop=true, endpoint=true, fill=:blue, angle=30, pen=\"1p,blue\"))\ntext!(text=\"GEOGRAPHIC\", x=-74.5, y=44.2, font=\"13p,Helvetica-Bold,blue\", show=1)"
  },
  {
    "objectID": "examples/arrows/10_arrows.html#quivers",
    "href": "examples/arrows/10_arrows.html#quivers",
    "title": "Arrow examples",
    "section": "Quivers",
    "text": "Quivers\nA (nicer looking) Matlab quiver plot example. To fully reproduce the Matlab example we also use the extremely memory wasting meshgrid. And because we turn U and V into grids before sending them to GMT, not specifying the limits would lose all first/last column/rows because most of the arrows are going out of the grid domain. We could have done it but it looks nicer if we specify a slightly wider domain.\n\nusing GMT\nX,Y = meshgrid(-pi:pi/8:pi,-pi:pi/8:pi);\nU = sin.(Y);\nV = cos.(X);\nquiver(X, Y, U, V, region=(-3.6,3.6,-3.6,3.6), fill=:black, lc=:red, show=true)\n\n\n\n\n\n\n\n\nNext example doesn’t need our help to extend the plotting limits and it uses grids directly. And for simplicity let’s create a grid using grdmath and compute its horizontal derivatives. Then we plot them as an arrow field.\n\nusing GMT\nG = gmt(\"grdmath -R-2/2/-2/2 -I0.1 X Y R2 NEG EXP X MUL\");\ndzdy = gmt(\"grdmath ? DDY\", G);\ndzdx = gmt(\"grdmath ? DDX\", G);\ngrdcontour(G, annot=:none, pen=:gray80)\ngrdvector!(dzdx, dzdy, cmap=:turbo, lw=1, show=true)\n\n\n\n\n\n\n\n\nThe above examples used Cartesian coordinates, but we can use also geographic coordinates where the arrows know where they are on Earth. This example plots the NUVEL1 plate motion model velocities relative to the Eurasian plate. The defaults guess pretty much a good solution for the arrow’s length and header sizes, but we can modify them if we are not satisfied with the default results.\n\nusing GMT\nquiver(TESTSDIR * \"assets/nuvel1_vx.nc\", TESTSDIR * \"assets/nuvel1_vy.nc\", proj=:guess,\n       coast=(shore=:gray70, area=5000), lw=1, C=:turbo, show=true, Vd=1)\n\n    [\"grdvector C:\\\\Users\\\\j\\\\.julia\\\\dev\\\\GMT\\\\test\\\\assets/nuvel1_vx.nc C:\\\\Users\\\\j\\\\.julia\\\\dev\\\\GMT\\\\test\\\\assets/nuvel1_vy.nc -JN0.0/15c -Baf -BWSen -Ve -Ix18/18 -Si146.70682k -Cturbo -W1 -Q0.2518+e+n73.3534k\", \"pscoast  -R -J -A5000 -Wgray70 -Da\"]\n\n\n\n\n\n\n\n\n\nA nice and instructive plot but we may want a somewhat larger arrows. Figuring out a best sized arrows is very tricky and no solution will please all users. The above command used the option Vd=1, which prints the real hard core command that is sent to GMT. Many users get scared with it but fine tuning implies understanding its contents. Specifically the -Si136.92637k part that sets arrows scale factor. Much more information is provided in the grdvector manual page, but as a quick help here we inform that i stands for inverse scale factor (136.92637 in this case) and k means kilometers. So if we want larger arrows we must increase the (inverse) scale factor. A slightly modified version of the above is obtained with:\n\nusing GMT\nquiver(TESTSDIR * \"assets/nuvel1_vx.nc\", TESTSDIR * \"assets/nuvel1_vy.nc\", proj=:guess, lw=1, \n       coast=(shore=:gray70, area=5000), vscale=(inverse=true, scale=\"400k\"), C=:turbo, show=true)\n\n\n\n\n\n\n\n\nHere we exaggerated on the arrow scale to show the other side of the problem. If arrows are too long chances are high that they intersect."
  },
  {
    "objectID": "examples/images/01_grdimage.html",
    "href": "examples/images/01_grdimage.html",
    "title": "Color images",
    "section": "",
    "text": "Color images are made with grdimage which takes the usual common options and a color map. It operates over grids or images. The next example shows how to create a color appropriate for the grid’s z range, plot the image and add a color scale. We use here the data keyword to tell the program to load the grid from a file. The @ before the tut_relief.nc file name instructs GMT to download the file from its server on the first usage and save it in a cache dir. See this GMT tutorial for more details about what the arguments mean.\nusing GMT\n\ntopo = makecpt(color=:rainbow, range=(1000,5000,500), continuous=true);\ngrdimage(\"@tut_relief.nc\", shade=(azimuth=100, norm=\"e0.8\"), proj=:Mercator, frame=:a, color=topo)\ncolorbar!(pos=(outside=:TC,length=(12.5,0.6), horizontal=true, offset=(0,1.0)), region=\"@tut_relief.nc\",\n          color=topo, frame=(ylabel=:m,), show=true)"
  },
  {
    "objectID": "examples/images/01_grdimage.html#a-global-bathymetry",
    "href": "examples/images/01_grdimage.html#a-global-bathymetry",
    "title": "Color images",
    "section": "A global bathymetry",
    "text": "A global bathymetry\nMake a map of the global bathymetry (automatically download it if needed) using the Winkel projection, add coast lines and a color bar\n\nusing GMT\n\ngrdimage(\"@earth_relief_20m_g\", proj=:Winkel, colorbar=true, coast=true, show=true)"
  },
  {
    "objectID": "examples/projections/stereonet.html",
    "href": "examples/projections/stereonet.html",
    "title": "Stereonets",
    "section": "",
    "text": "The stereonet function plots a stereonet map in either Schmidt or Wulff projection. It is useful for visualizing orientations of geological features such as faults and folds.\n\nusing GMT\nresetGMT()      # hide\nstereonet([90 30; 180 45; 270 60; 0 15; 30 45; 120 48; 225 27; 350 80], show=true)"
  },
  {
    "objectID": "examples/projections/leepacific.html",
    "href": "examples/projections/leepacific.html",
    "title": "Lee Oblated Stereographic projection",
    "section": "",
    "text": "The Lee map projection is one that can be used to make maps over the Pacific Ocean with much less distortion than many of the normal map projections. This projection is not one that lieves in the GMT C library, but one whose interface is defined in the GMT Julia package. So the its using syntax is slightly different. For example we cannot add grid lines and annotations with the frame option. Instead, we use the plotgrid! function.\n\nusing GMT\nG, cl = leepacific(\"@earth_relief_20m_p\");\ngrdimage(G, shade=true, plot=(data=cl,), title=\"Lee Pacific\", cmap=:geo, B=:none)\nplotgrid!(G, show=true)\n\n\n\n\n\n\n\n\nStarting with GMT.jl version 1.32, we can use the inner option to make the annotations at the end of grid lines, in the inner side of the map.\n\nusing GMT\nG, cl = leepacific(\"@earth_relief_20m_p\");\ngrdimage(G, shade=true, plot=(data=cl,), title=\"Lee Pacific\", cmap=:geo, B=:none)\nplotgrid!(G, inner=true, show=true)"
  },
  {
    "objectID": "examples/projections/best_rectangular.html",
    "href": "examples/projections/best_rectangular.html",
    "title": "Best rectangular world map projection",
    "section": "",
    "text": "This was born from a question in the GMT forum on how to do a fully fledged, wall-sized map of the world - completely done in GMT. That post serves also to document the implementation details upon which is based the inner workings of the worldrectangular function that now permits to make such kind of maps. And we have to confess that the achieved implementation relies also in features provided by GDAL. But no more talk, appreciate the global rectangular Vand der Grinten projection.\n\nusing GMT\nresetGMT()      # hide\nG, cl = worldrectangular(\"@earth_relief_30m_p\", proj=\"vandg\", latlim=(-70,85), coast=true);\ngrid = worldrectgrid(G);\ngrdimage(G, shade=true, plot=(data=cl,), cmap=:geo, B=:none, title=\"Van der Grinten\")\nplotgrid!(G, grid, show=true)"
  },
  {
    "objectID": "examples/projections/01_hello.html",
    "href": "examples/projections/01_hello.html",
    "title": "The true Hello World",
    "section": "",
    "text": "using GMT\nx = GMT.linspace(0, 2pi, 180);  y = sin.(x/0.2)*45;\ncoast(region=:global, proj=(name=:ortho, center=(300,15)), frame=:g,\n      land=:navy, title=\"Hello Round World\")\nplot!(x*60, y, lw=1, lc=:red, marker=:circle, size=0.2,\n      markeredgecolor=0, markerfacecolor=:cyan, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/50_plot3.html",
    "href": "examples/plotting_functions/50_plot3.html",
    "title": "Plot3d",
    "section": "",
    "text": "Examples\n\n\nFlight path\nDraw a flight path approaching landing with variable line thickness and color depending on airplain height.\n\nusing GMT\nD = gmtread(TESTSDIR * \"assets/track_sample_data.txt\", incols=\"7,6,3\");\nplot3d(D, lc=:gradient, lt=[1,5], par=(PS_LINE_CAP=\"round\",), show=true)"
  },
  {
    "objectID": "examples/plotting_functions/08_rectangles.html",
    "href": "examples/plotting_functions/08_rectangles.html",
    "title": "Patterns & trasparency",
    "section": "",
    "text": "Simple filled rectangle\n\nusing GMT\nrect = [2 2; 2 6; 6 6; 6 2; 2 2];\nplot(rect, region=[0 10 0 10], lw=1, fill=:blue, axes=:a, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\nRectangles with patterns\nNow add some patterns. The full pattern syntax is explained in [GMT patterns] (http://docs.generic-mapping-tools.org/latest/GMT_Docs.html#specifying-area-fill-attributes) but basically we are using pattern number 20 at 200 dpi and a blue background for the left rectangle and pattern 89 also at 200 dpis for the right rectangle.\n\nusing GMT\nrect = [1 1; 1 7; 4 7; 4 1; 1 1];\nplot(rect, region=[0 10 0 10], lw=1, fill=\"p20+bgreen+r200\", axes=:a, aspect=:equal)\nplot!([4 0].+rect, lw=1, fill=\"p89+r200\", show=true)\n\n\n\n\n\n\n\n\n\n\nRectangles with transparency\nThis variation creates rectangles with 0, 30% and 70% transparency as well as different boundary lines.\n\nusing GMT\nrect = [0.5 0.5; 0.5 7; 2.5 7; 2.5 0.5; 0.5 0.5];\nplot(rect, region=[0 10 0 10], lw=0.5, fill=:blue, axes=:a, aspect=:equal)\nplot!([3 0].+rect, lw=1, ls=\"--\", fill=:blue, transparency=30)\nplot!([6 0].+rect, lw=2, lc=:red, fill=:blue, transparency=70, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/06_spirals.html",
    "href": "examples/plotting_functions/06_spirals.html",
    "title": "Spirals",
    "section": "",
    "text": "From https://en.wikipedia.org/wiki/Archimedean_spiral\n\nusing GMT\n# Play arround with these parameters\nT = 1;\nomega = omega = 2pi / T;\nv = 0.2;\nt = 0:0.01:5pi;\nx = v.*t .* cos.(omega .* t);\ny = v.*t .* sin.(omega .* t);\nplot(x, y, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\n\nDraw a Polar scatter plot with variable symbol size, color and transparency. We will use the default color scale (turbo) and fig size (12 cm).\n\nusing GMT\nteta = 0:0.01:5pi;\nxf = sqrt.(teta) .* cos.(teta);\nyf = sqrt.(teta) .* sin.(teta);\nplot(xf,yf, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\n\nFrom This FEX contribution. The author here wanted to reflect the fact that on a sunflower the seeds close to the center are smaller and have a higher density.\n\nusing GMT\nphi = (sqrt(5)-1)/2;\nn = 2618;\nrho = (2:n-1) .^ phi;\ntheta = (2:n-1)*2pi*phi;\nscatter(rho .* cos.(theta), rho .* sin.(theta), marker=:point, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\n\nThis one was reversed from the javascript in this page, which follows the original work of Helmut Vogel inA better Way to Construct the Sunflower Head, where he proposed that spiral branches of seeds in a sunflower head are added from the center at an angle of 137.5∘ from the preceding one.\nThis time we will also color the seed points in function of r, the distance to the center and pain with a dark background.\n\nusing GMT\nangle = 137.5;  # Play with this angle between [137.0 138.0]. Amazing the effect, no?\nalfa = 2pi * angle / 360;\nn_seeds = 1500;\nseeds = 0:n_seeds;\nr = sqrt.(seeds);\nϕ = alfa * seeds;\nC = makecpt(range=(1,sqrt(n_seeds),1), cmap=:buda); # Color map to paint the seeds\nscatter(r .* cos.(ϕ), r .* sin.(ϕ), marker=:point, cmap=C, zcolor=r,\n        frame=(fill=20,), aspect=:equal, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/06_spirals.html#examples",
    "href": "examples/plotting_functions/06_spirals.html#examples",
    "title": "Spirals",
    "section": "",
    "text": "From https://en.wikipedia.org/wiki/Archimedean_spiral\n\nusing GMT\n# Play arround with these parameters\nT = 1;\nomega = omega = 2pi / T;\nv = 0.2;\nt = 0:0.01:5pi;\nx = v.*t .* cos.(omega .* t);\ny = v.*t .* sin.(omega .* t);\nplot(x, y, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\n\nDraw a Polar scatter plot with variable symbol size, color and transparency. We will use the default color scale (turbo) and fig size (12 cm).\n\nusing GMT\nteta = 0:0.01:5pi;\nxf = sqrt.(teta) .* cos.(teta);\nyf = sqrt.(teta) .* sin.(teta);\nplot(xf,yf, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\n\nFrom This FEX contribution. The author here wanted to reflect the fact that on a sunflower the seeds close to the center are smaller and have a higher density.\n\nusing GMT\nphi = (sqrt(5)-1)/2;\nn = 2618;\nrho = (2:n-1) .^ phi;\ntheta = (2:n-1)*2pi*phi;\nscatter(rho .* cos.(theta), rho .* sin.(theta), marker=:point, aspect=:equal, show=true)\n\n\n\n\n\n\n\n\n\n\n\nThis one was reversed from the javascript in this page, which follows the original work of Helmut Vogel inA better Way to Construct the Sunflower Head, where he proposed that spiral branches of seeds in a sunflower head are added from the center at an angle of 137.5∘ from the preceding one.\nThis time we will also color the seed points in function of r, the distance to the center and pain with a dark background.\n\nusing GMT\nangle = 137.5;  # Play with this angle between [137.0 138.0]. Amazing the effect, no?\nalfa = 2pi * angle / 360;\nn_seeds = 1500;\nseeds = 0:n_seeds;\nr = sqrt.(seeds);\nϕ = alfa * seeds;\nC = makecpt(range=(1,sqrt(n_seeds),1), cmap=:buda); # Color map to paint the seeds\nscatter(r .* cos.(ϕ), r .* sin.(ϕ), marker=:point, cmap=C, zcolor=r,\n        frame=(fill=20,), aspect=:equal, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_2_biplots.html",
    "href": "examples/plotting_functions/05_2_biplots.html",
    "title": "PCAs",
    "section": "",
    "text": "The classic analysis of the Iris dataset.\n\nusing GMT\n\nbiplot(TESTSDIR * \"iris.dat\", show=true)\n\n\n\n\n\n\n\n\nPlot a 6 cm fig with included observarion numbers.\n\nusing GMT\n\nbiplot(TESTSDIR * \"iris.dat\", figsize=6, obsnumbers=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_2_biplots.html#examples",
    "href": "examples/plotting_functions/05_2_biplots.html#examples",
    "title": "PCAs",
    "section": "",
    "text": "The classic analysis of the Iris dataset.\n\nusing GMT\n\nbiplot(TESTSDIR * \"iris.dat\", show=true)\n\n\n\n\n\n\n\n\nPlot a 6 cm fig with included observarion numbers.\n\nusing GMT\n\nbiplot(TESTSDIR * \"iris.dat\", figsize=6, obsnumbers=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/040_scatter.html",
    "href": "examples/plotting_functions/040_scatter.html",
    "title": "Scatters",
    "section": "",
    "text": "Draw a Cartesian scatter plot with variable symbol size, color and transparency\n\nusing GMT\nscatter(rand(100),rand(100),   # Generate data\n        markersize=rand(100),  # Symbol sizes\n        marker=:c,             # Plot circles\n        color=:ocean,          # Color scale\n        zcolor=rand(100),      # Assign color to each symbol\n        alpha=50,              # Set transparency to 50%\n        title=\"Scatter\",       # Fig title\n        show=true)             # Display the figure\n\n\n\n\n\n\n\n\n\n\n\nDraw a Polar scatter plot with variable symbol size, color and transparency. We will use the default color scale (turbo) and fig size (12 cm).\n\nusing GMT\nteta = 2pi*rand(150)*180/pi; r = 9*rand(150); ms = r / 10;\n\nscatter(teta, r,                  # The data\n    limits=(0,360,0,10),      # Fig limits\n        xaxis=(annot=45,grid=45), # Annotate and plor grid lines every 45 deg\n        yaxis=(annot=2,grid=2),   # Same but for 2 units in radial direction\n        proj=:Polar,              # Set the polar projection\n        zcolor=teta,              # Assign color to each symbol\n        size=ms,                  # The symbl sizes\n        alpha=25,                 # Set transparency to 50%\n        title=\"Polar scatter\",    # Fig title\n        show=true)                # Display the figure\n\n\n\n\n\n\n\n\n\n\n\nSplit the different species in the iris dataset in its own colored groups. Use the first two columns in dataset and label the axes with their column names.\n\nusing GMT\nscatter(TESTSDIR * \"assets/iris.dat\", xvar=1, yvar=2, hue=\"Species\", xlabel=:auto, ylabel=:auto,\n        legend=(pos=:TC, box=(pen=1, fill=\"gray95\", shade=true, rounded=true)), show=true)"
  },
  {
    "objectID": "examples/plotting_functions/040_scatter.html#examples",
    "href": "examples/plotting_functions/040_scatter.html#examples",
    "title": "Scatters",
    "section": "",
    "text": "Draw a Cartesian scatter plot with variable symbol size, color and transparency\n\nusing GMT\nscatter(rand(100),rand(100),   # Generate data\n        markersize=rand(100),  # Symbol sizes\n        marker=:c,             # Plot circles\n        color=:ocean,          # Color scale\n        zcolor=rand(100),      # Assign color to each symbol\n        alpha=50,              # Set transparency to 50%\n        title=\"Scatter\",       # Fig title\n        show=true)             # Display the figure\n\n\n\n\n\n\n\n\n\n\n\nDraw a Polar scatter plot with variable symbol size, color and transparency. We will use the default color scale (turbo) and fig size (12 cm).\n\nusing GMT\nteta = 2pi*rand(150)*180/pi; r = 9*rand(150); ms = r / 10;\n\nscatter(teta, r,                  # The data\n    limits=(0,360,0,10),      # Fig limits\n        xaxis=(annot=45,grid=45), # Annotate and plor grid lines every 45 deg\n        yaxis=(annot=2,grid=2),   # Same but for 2 units in radial direction\n        proj=:Polar,              # Set the polar projection\n        zcolor=teta,              # Assign color to each symbol\n        size=ms,                  # The symbl sizes\n        alpha=25,                 # Set transparency to 50%\n        title=\"Polar scatter\",    # Fig title\n        show=true)                # Display the figure\n\n\n\n\n\n\n\n\n\n\n\nSplit the different species in the iris dataset in its own colored groups. Use the first two columns in dataset and label the axes with their column names.\n\nusing GMT\nscatter(TESTSDIR * \"assets/iris.dat\", xvar=1, yvar=2, hue=\"Species\", xlabel=:auto, ylabel=:auto,\n        legend=(pos=:TC, box=(pen=1, fill=\"gray95\", shade=true, rounded=true)), show=true)"
  },
  {
    "objectID": "examples/plotting_functions/035_radars.html",
    "href": "examples/plotting_functions/035_radars.html",
    "title": "Radar plots",
    "section": "",
    "text": "A radar plot with two datasets (a polygon for each). This example uses normalized coordinates so it shows the coordinates of only one axis.\n\nusing GMT\nradar([0.5 0.5 0.6 0.9 0.77; 0.6 0.5 0.8 0.2 0.9], marker=:circ, fill=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/035_radars.html#radar-with-normalised-coordinates",
    "href": "examples/plotting_functions/035_radars.html#radar-with-normalised-coordinates",
    "title": "Radar plots",
    "section": "",
    "text": "A radar plot with two datasets (a polygon for each). This example uses normalized coordinates so it shows the coordinates of only one axis.\n\nusing GMT\nradar([0.5 0.5 0.6 0.9 0.77; 0.6 0.5 0.8 0.2 0.9], marker=:circ, fill=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/035_radars.html#radar-with-multiple-coordinates",
    "href": "examples/plotting_functions/035_radars.html#radar-with-multiple-coordinates",
    "title": "Radar plots",
    "section": "Radar with multiple coordinates",
    "text": "Radar with multiple coordinates\nA single dataset with different coordinates for each axis.\n\nusing GMT\nradar([10.5 20.5 30.6 40.9 46], axeslimts=[15, 25, 50, 90, 50],\n      labels=[\"Spoons\",\"Forks\",\"Knifes\",\"Dishes\",\"Oranges\"],\n      annotall=true, marker=:circ, fill=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/02_2stems.html",
    "href": "examples/plotting_functions/02_2stems.html",
    "title": "Stems",
    "section": "",
    "text": "Create a stem plot of 50 data values between −2π and 2π.\n\nusing GMT\nY = linspace(-2*pi,2*pi,50);\nstem(Y, show=true)\n\n\n\n\n\n\n\n\nThe same but now specify the set of x values for the stem plot.\n\nusing GMT\nY = linspace(-2*pi,2*pi,50);\nstem([Y Y], show=true)\n\n\n\n\n\n\n\n\nTwo of them and with some variations.\n\nusing GMT\nY = linspace(-2*pi,2*pi,50);\nstem(Y,[Y -Y], multicol=true, fill=true, ms=\"10p\", nobaseline=true, ls=:DashDot, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/02_1filledlines.html",
    "href": "examples/plotting_functions/02_1filledlines.html",
    "title": "Filled curves",
    "section": "",
    "text": "The GMT plot module has a huge number of options. The polygon (-L in original) option in itself is what other packages call band, so we wrapped another avatar around it and with that name too.\nusing GMT\nx = -10:0.11:10;\nband(x, sin.(x)./x, width=0.1, fill=\"green@80\", show=true)\nWe could have obtained the same plot using a function as argument.\nNext example hides the line and plots only the bands. Since when we ask for a color fill the lines is always plotted, the trick to no see it is to assign it full transparency. We use also a theme to change the default tick orientation and add automatic grid lines.\nusing GMT\nx = -10:0.1:10;\nband(x, sin.(x), region=(-10,10,-1.5,1.5), width=0.3, pen=(0,\"blue@100\"),\n     fill=\"blue@80\", theme=(\"A2atgIT\"))\nband!(x, cos.(x), width=0.3, pen=(0,\"red@100\"), fill=\"red@80\", show=true)\nAnd another example where the band is asymetric and grows in width. We had to add eps() to first x to not have a NaN in first element of y.\nusing GMT\nx = 0+eps():0.05:4π\ny =  sin.(3x) ./ (cos.(x) .+ 2)./x\nband([x y], y .- 0.1 .- 0.015x, y .+ 0.1 .+ 0.03x, fill=\"blue@80\", show=true)\nA papillon\nusing GMT\nplot(sin, x-&gt;sin(2x), [0 2pi], fill=\"blue@70\", pen=(1,\"blue@40\"), show=1)"
  },
  {
    "objectID": "examples/plotting_functions/02_1filledlines.html#fill-between",
    "href": "examples/plotting_functions/02_1filledlines.html#fill-between",
    "title": "Filled curves",
    "section": "Fill between",
    "text": "Fill between\nFill the area between the two sinc functions. Here we use the default values for line thickness and fill color but all of that can be changed. We also add a thin white border arround tke lines.\n\nusing GMT\ntheta = linspace(-2π, 2π, 150);\ny1 = sin.(theta) ./ theta;\ny2 = sin.(2*theta) ./ theta;\nfill_between([theta y1], [theta y2], white=true, legend=\"Sinc1,Sinc2\", show=1)\n\n\n\n\n\n\n\n\n\nusing GMT\nD = gmtread(TESTSDIR * \"assets/1635541200000.dat\");\nD.attrib[\"Timecol\"] = \"1\";         # Inform that first column has Time\nfill_between(D, figsize=(16,9), yaxis=(annot=20,), theme=\"A0XYag\", show=true)"
  },
  {
    "objectID": "examples/plotting_functions/index.html",
    "href": "examples/plotting_functions/index.html",
    "title": "Plotting Functions",
    "section": "",
    "text": "Plotting Functions\nA collection of examples demonstrating GMT.jl plotting functions.\n\n\n\n\nLine Plots \n\n\n\n\nFilled Curves \n\n\n\n\nStairs \n\n\n\n\nStems \n\n\n\n\nPlotyy \n\n\n\n\nRadar Plots \n\n\n\n\nBar Plots \n\n\n\n\nScatters \n\n\n\n\nStatistical Plots \n\n\n\n\nPCAs & Biplots \n\n\n\n\nError Bars \n\n\n\n\nSpirals \n\n\n\n\nSymbols & Linestyles \n\n\n\n\nPatterns & Transparency \n\n\n\n\nHistograms \n\n\n\n\nPlot3D"
  },
  {
    "objectID": "geophysics/weather/01_weather.html",
    "href": "geophysics/weather/01_weather.html",
    "title": "Weather Maps",
    "section": "",
    "text": "This example, originates in this GMT Forum post, and computes the relative humidity of the air from grids of temperature and dew-point temperature. Some meteorological models only provide the temperature and dew-point temperature, so if one wants relative humidity, it is necessary to compute it from these two related variables.\n\nusing GMT\nGMT.resetGMT() # hide\n\n# Download air temperature at 2 meters and dew point temperature at 2 meters\necmwf(:forecast, vars=\"2t\", filename=\"2td.grd\")   # Temperature\nT  = gmtread(\"2td.grd\");\necmwf(:forecast, vars=\"2d\", filename=\"2td.grd\")   # Dew point temperature\nTd = gmtread(\"2td.grd\");\n\nrm(\"2td.grd\") # Hide remove the temporary file\n\n# Function to compute the relative humidity\nesat(x) = 6.0178*exp.(17.27*x ./ (x .+ 237.3))\n\nGrh = 100*esat(Td) / esat(T);\nviz(Grh, proj=:guess, title=\"Relative humidity\", colorbar=true)\n\n\n[ Info: Downloading 2t and saving to 2td.grd\n\n[ Info: Downloading 2d and saving to 2td.grd"
  },
  {
    "objectID": "geophysics/weather/01_weather.html#a-relative-humidity-map",
    "href": "geophysics/weather/01_weather.html#a-relative-humidity-map",
    "title": "Weather Maps",
    "section": "",
    "text": "This example, originates in this GMT Forum post, and computes the relative humidity of the air from grids of temperature and dew-point temperature. Some meteorological models only provide the temperature and dew-point temperature, so if one wants relative humidity, it is necessary to compute it from these two related variables.\n\nusing GMT\nGMT.resetGMT() # hide\n\n# Download air temperature at 2 meters and dew point temperature at 2 meters\necmwf(:forecast, vars=\"2t\", filename=\"2td.grd\")   # Temperature\nT  = gmtread(\"2td.grd\");\necmwf(:forecast, vars=\"2d\", filename=\"2td.grd\")   # Dew point temperature\nTd = gmtread(\"2td.grd\");\n\nrm(\"2td.grd\") # Hide remove the temporary file\n\n# Function to compute the relative humidity\nesat(x) = 6.0178*exp.(17.27*x ./ (x .+ 237.3))\n\nGrh = 100*esat(Td) / esat(T);\nviz(Grh, proj=:guess, title=\"Relative humidity\", colorbar=true)\n\n\n[ Info: Downloading 2t and saving to 2td.grd\n\n[ Info: Downloading 2d and saving to 2td.grd"
  },
  {
    "objectID": "geophysics/weather/01_weather.html#wind-barbs",
    "href": "geophysics/weather/01_weather.html#wind-barbs",
    "title": "Weather Maps",
    "section": "Wind barbs",
    "text": "Wind barbs\n\nusing GMT\nGMT.resetGMT() # hide\n\n# Download the ecmwf forcasts for the _u_ and _v_ components of the wind at 10 meters above the surface\necmwf(:forecast, var=\"10u\", limits=\"IHO23\", filename=\"u10.grd\")\necmwf(:forecast, var=\"10v\", limits=\"IHO23\", filename=\"v10.grd\")\n\nwindbarbs(\"u10.grd\", \"v10.grd\", Q=\"0.25c+s20+w0.15c\", I=\"x10\", proj=:guess)\nrm(\"u10.grd\") # Hide\nrm(\"v10.grd\") # Hide\ncoast!(shore=true, show=true)\n\n\n[ Info: Downloading 10u and saving to u10.grd\n\n[ Info: Downloading 10v and saving to v10.grd"
  },
  {
    "objectID": "geophysics/seismicity/ThreeD_vp_vs.html",
    "href": "geophysics/seismicity/ThreeD_vp_vs.html",
    "title": "3D models with side walls",
    "section": "",
    "text": "These examples show a GMT.jl version of a PyGMT post in the GMT forum and that can be found at the original author’s, JiahongLuo, Github site\nThe function let us easily plot images on the sides of a cube. That function can also be used to create those side figures directly from a 3D cube grid.\n\nusing GMT\n\n# Download data from:\nmodel = gmtread(\"https://github.com/ShouchengHan/USTClitho2.0/blob/main/USTClitho2.0.wrst.sea_level.txt\");\n\n# Create two data cubes (grids) with the Vp and Vs velocities\nCvp = xyzw2cube(model);\nCvs = xyzw2cube(model, zcol=5);\n\n# Add names to the cube layers to be used as titles in next figure\nCvp.names = [\"Depth = $(Int(i)) km\" for i in Cvp.v];\nCvs.names = [\"Depth = $(Int(i)) km\" for i in Cvs.v];\n\n\ngmtread [WARNING]: Long input record (4646 bytes) was truncated to first 4094 bytes!\n\ngmtread [WARNING]: Long input record (4497 bytes) was truncated to first 4094 bytes!\n\n┌ Warning:  file \"https://github.com/ShouchengHan/USTClitho2.0/blob/main/USTClitho2.0.wrst.sea_level.txt\" is empty or has no data after the header.\n\n└ @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmtreadwrite.jl:242\n\n\n\n\n\nThe dataset must contain at least 4 columns (x,y,z,w)\n\nStacktrace:\n [1] error(s::String)\n   @ Base .\\error.jl:35\n [2] xyzw2cube(D::GMTdataset{Float64, 2}; zcol::Int64, datatype::DataType, tit::String, names::Vector{String}, varnames::Vector{String})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\utils_types.jl:1818\n [3] xyzw2cube(D::GMTdataset{Float64, 2})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\utils_types.jl:1815\n [4] top-level scope\n   @ In[2]:4\n\n\n\nShow all 12 layers of the P-waves velocity in a figure. We use a diffent colormap for each layer to avoid that layers become too monochromatic.\nviz(Cvp, colorbar=true, cmap=:same, title=\"Vp model\")\n\nShow the P and S velocities with a slight variation of the top layer. For the P-velocity we plot the topography on top and for the S-velocity we show the superficial S velocity but apply a shading effect calculated from the topography grid.\n\nusing GMT   # Hide\ncubeplot(Cvp, top=\"@earth_relief_05m\", colorbar=(\"xlabel=P-wave velocity\", \"ylabel=km/s\"), zdown=true, title=\"Vp model\")\ncubeplot!(Cvs, top=\"@earth_relief_05m\", topshade=true, zdown=true, colorbar=(\"xlabel=S-wave velocity\", \"ylabel=km/s\"), xshift=18, title=\"Vs model\", show=true)\n\n\nUndefVarError: `Cvp` not defined\n\nStacktrace:\n [1] top-level scope\n   @ In[3]:2\n\n\n\n\nTo finish we show how to make an inset view in the 3D model.\n\nusing GMT   # Hide\ncubeplot(Cvp, top=\"@earth_relief\", inset=(lon=100, lat=35), topshade=true, zdown=true,\n         colorbar=(\"xlabel=P-wave velocity\", \"ylabel=km/s\"), show=true)\n\n\nUndefVarError: `Cvp` not defined\n\nStacktrace:\n [1] top-level scope\n   @ In[4]:2"
  },
  {
    "objectID": "geophysics/seismicity/01_focalmec.html",
    "href": "geophysics/seismicity/01_focalmec.html",
    "title": "Focal mechanisms",
    "section": "",
    "text": "Plotting beach balls (seismic focal mechanisms) in Julia using GMT."
  },
  {
    "objectID": "geophysics/seismicity/01_focalmec.html#plotting-beach-balls",
    "href": "geophysics/seismicity/01_focalmec.html#plotting-beach-balls",
    "title": "Focal mechanisms",
    "section": "Plotting beach balls",
    "text": "Plotting beach balls\nIn this synthetic example we will use the Aki-Richards convention and pass the data via a \n\nusing GMT\nresetGMT()  # hide\n\n# Right lateral Strike Slip\nD = mat2ds([0.0 5.0 0.0 0 90 0 5 0 0],[\"Right Strike Slip\"]);\nmeca(D, region=(-1,4,1,6), proj=:Mercator, aki=2.5, fill=:black)\n\n# Left lateral Strike Slip\nD = mat2ds([2.0 5.0 0.0 0 90 180 5 0 0],[\"Left Strike Slip\"]);\nmeca!(D, aki=2.5, fill=:black)\n\n# Thrust (two fault orientations)\nD = mat2ds([0.0 3.5 0.0 0 45 90 5 0 0; 2.0 3.5 0.0 45 45 90 5 0 0],[\"Thrust\", \"Thrust\"]);\nmeca!(D, aki=2.5, fill=:black)\n\n# Normal (two fault orientations)\nD = mat2ds([0.0 2.0 0.0 0 45 -90 5 0 0; 2.0 2.0 0.0 45 45 -90 5 0 0],[\"Normal\", \"Normal\"]);\nmeca!(D, aki=2.5, fill=:black)\n\n# Mixed\nD = mat2ds([3.4 2.0 0.0 10 35 129 5 0 0],[\"Mixed\"]);\nmeca!(D, aki=2.5, fill=:black)\n\nshowfig()\n\n\n\n\n\n\n\n\n\nSome Venezuela beach balls\nThis example was presented by Leonardo Alvarado in the Showcase section of GMT forum under the title Map of focal mechanism with Pygmt. The example was slightly reworked and it now ues the GMT’s automatic grid selection service that by using the grid name @earth_relief downloads the best resolution grid for the job.\nThe “mff_bb.txt” file contains a couple of focal mechanisms for the Venezuela region specified in the CMT convention format.\nusing GMT, PrettyTables   # hide\nresetGMT()  # hide\n#getpath4docs(file::String) = joinpath(\"..\", \"..\", \"..\", \"..\", \"..\", file) # hide\nio = IOBuffer() # hide\n#D = gmtread(getpath4docs(\"mff_bb.txt\"))\nD = gmtread(GMT.TESTSDIR * \"mff_bb.txt\")\nPrettyTables.pretty_table(io, D.data; header=D.colnames, backend=Val(:html))    # hide\nprintln(\"~~~\" * String(take!(io)) * \"~~~\") # hide\n\nusing GMT\nresetGMT()  # hide\n\n# Background map\ngrdimage(\"@earth_relief\", region=(-74,-59,5,15), proj=:guess, figsize=10, shade=true)\ncoast!(shorelines=true, borders=((type=1, pen=0.8),(type=2, pen=0.1)), map_scale=\"-68.5/7.0/7.0/200\")\n\n# Epicenters\nplot!(GMT.TESTSDIR * \"mff_bb.txt\", marker=:circ, ms=0.1, fill=:yellow, markerline=:black)\ntext!(txt=\"Mar Caribe\", x=-68, y=13.5, font=(15, \"Helvetica-Bold\", :white), justify=:LM)\n\n# Focal mechanisms\nmeca!(GMT.TESTSDIR * \"mff_bb.txt\", CMT=(scale=0.4, font=6), offset=true, fill=:black, show=true)"
  },
  {
    "objectID": "tutorials/vector_shp/vector_shp.html",
    "href": "tutorials/vector_shp/vector_shp.html",
    "title": "Reading, filtering and visualizing geospatial vector data",
    "section": "",
    "text": "This tutorial is based on a similar one for R and shows how simpler and cleanly we can do this in Julia with GMT.jl. Vector data are composed of discrete geometric locations (x, y values) known as vertices that define the “shape” of the spatial object. There are three types of vector data: Points, Lines and Polygons (see more at, for example, GIS in Python). Geospatial vector data is often stored in the shapefile format and that is the format that we will use is this tutorial, but other formats could have been used without fundamental changes to the procedures shown below."
  },
  {
    "objectID": "tutorials/vector_shp/vector_shp.html#reading-vector-data",
    "href": "tutorials/vector_shp/vector_shp.html#reading-vector-data",
    "title": "Reading, filtering and visualizing geospatial vector data",
    "section": "Reading vector data",
    "text": "Reading vector data\nRead a shapefile representing Colombian departments which has been previously downloaded from DIVA-GIS, and not forgetting to load the package first.\n\nusing GMT\ndeptos = gmtread(GMT.TESTSDIR * \"COL_adm1.shp.zip\");\n\nWe can see what the contents of the deptos object are, but because there are many polygons we will restrict to show only the first 7 from the attribute table. For that we use the info function that plots several types of information depending on the input data type. For [GMTdataset]s the attribs keyword lets us limit the number of table rows that are printed.\ninfo(deptos, attribs=7)\n\nAttribute table (Dict{String, String})\n┌─────┬───────────┬──────┬─────────────┬───────────┬─────┬──────┬──────────────┬──────────┬───────────┐\n│ Row │ NAME_1    │ ID_1 │ ENGTYPE_1   │ NL_NAME_1 │ ISO │ ID_0 │ TYPE_1       │ NAME_0   │ VARNAME_1 │\n├─────┼───────────┼──────┼─────────────┼───────────┼─────┼──────┼──────────────┼──────────┼───────────┤\n│   1 │ Amazonas  │ 1    │ Commissiary │           │ COL │ 53   │ Comisaría    │ Colombia │           │\n│   2 │ Amazonas  │ 1    │ Commissiary │           │ COL │ 53   │ Comisaría    │ Colombia │           │\n│   3 │ Antioquia │ 2    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n│   4 │ Antioquia │ 2    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n│   5 │ Antioquia │ 2    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n│   6 │ Arauca    │ 3    │ Intendancy  │           │ COL │ 53   │ Intendencia  │ Colombia │           │\n│   7 │ Atlántico │ 4    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n└─────┴───────────┴──────┴─────────────┴───────────┴─────┴──────┴──────────────┴──────────┴───────────┘\n```2    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n│   5 │ Antioquia │ 2    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n│   6 │ Arauca    │ 3    │ Intendancy  │           │ COL │ 53   │ Intendencia  │ Colombia │           │\n│   7 │ Atlántico │ 4    │ Department  │           │ COL │ 53   │ Departamento │ Colombia │           │\n└─────┴───────────┴──────┴─────────────┴───────────┴─────┴──────┴──────────────┴──────────┴───────────┘\nIt is always useful to know the coordinate reference system of the data object. For that we will use again the info function, but this time with the crs keyword.\ninfo(deptos, crs=true)\n\nPROJ: +proj=longlat +datum=WGS84 +no_defs\nWKT: GEOGCS[\"WGS 84\",\n    DATUM[\"WGS_1984\",\n        SPHEROID[\"WGS 84\",6378137,298.257223563]],\n    PRIMEM[\"Greenwich\",0],\n    UNIT[\"degree\",0.0174532925199433]]\nA fundamental starting point to understand data is to plot it. GMT can do it with great simplicity.\n\nusing GMT   # Hide\ndeptos = gmtread(GMT.TESTSDIR * \"COL_adm1.shp.zip\");  # Hide\nviz(deptos)\n\n\n\n\n\n\n\n\nThe somewhat large blank part on the upper part of the figure is due to small islands that are barely visible at this scale but also due to the automatic determination of the region boundaries. Also, since Colombia is close to equator the deformation implied by plotting geographical coordinates is not easily visible, but we can do better. We can tell GMT to guess a good projection for this region and automatically apply it.\n\nusing GMT   # Hide\ndeptos = gmtread(GMT.TESTSDIR * \"COL_adm1.shp.zip\");  # Hide\nviz(deptos, proj=:guess)"
  },
  {
    "objectID": "tutorials/vector_shp/vector_shp.html#filtering-geospatial-data-based-on-attributes",
    "href": "tutorials/vector_shp/vector_shp.html#filtering-geospatial-data-based-on-attributes",
    "title": "Reading, filtering and visualizing geospatial vector data",
    "section": "Filtering geospatial data based on attributes",
    "text": "Filtering geospatial data based on attributes\nIn this demonstration we are interested only in one departament, so we will filter the data to fulfill a department name condition. Review the following code and change it to match your department.\nantioquia = filter(deptos, NAME_1 = \"Antioquia\");\nNex, plot the new object.\n\nusing GMT   # Hide\ndeptos = gmtread(GMT.TESTSDIR * \"COL_adm1.shp.zip\");  # Hide\nantioquia = filter(deptos, NAME_1 = \"Antioquia\");     # Hide\nviz(antioquia, proj=:guess)\n\n\n\n\n\n\n\n\nWe can repeat the previous steps to load the Colombian municipalities and filter the Antioquian ones.\n\nusing GMT   # Hide\nmunic = gmtread(GMT.TESTSDIR * \"COL_adm2.shp.zip\");\nmun_antioquia = filter(munic, NAME_1=:Antioquia);    # Symbols are as good as strings for attribute values\nviz(mun_antioquia, proj=:guess)\n\n\n\n\n\n\n\n\nNow we are going to compute the centroids of the Antioquia municipes and use them as placers to contents of the ID_2 attribute (that are numbers, though confess that I don’t know what they represent).\n\nusing GMT   # Hide\nmunic = gmtread(GMT.TESTSDIR * \"COL_adm2.shp.zip\");     # Hide\nmun_antioquia = filter(munic, NAME_1=:Antioquia);       # Hide\nantioquia_points = centroid(mun_antioquia);\nt = info(mun_antioquia, att=\"ID_2\");        # Get the values of the ID_2 attribute\nantioquia_points.text = t;                  # Add the tex column to the centroids object\nviz(mun_antioquia, proj=:guess, fill=:beige, lw=0, text=(data=antioquia_points, font=4))\n\n\n\n\n\n\n\n\nAnd as an example, we can use the numeric information contained in the ID_2 attribute (which comes out as string but we can easily convert it to numbers) and paint the municipe polygons according to those numbers. That is, make a choropleth map.\n\nusing GMT   # Hide\nmunic = gmtread(GMT.TESTSDIR * \"COL_adm2.shp.zip\");     # Hide\nmun_antioquia = filter(munic, NAME_1=:Antioquia);       # Hide\nantioquia_points = centroid(mun_antioquia);             # Hide\nt = info(mun_antioquia, att=\"ID_2\");                    # Hide\nantioquia_points.text = t;                              # Hide\n# Convert t to numeric. Needed for creating a color map and make the choropleth style plot.\ntn = parse.(Int,t);\n\n# Create a color map\nC = makecpt(range=(minimum(tn),maximum(tn)), C=:bamako);\n\n# Vizualize \nviz(mun_antioquia, proj=:guess, levels=tn, cmap=C, lw=0, title=\"Another Map of Antioquia\", text=(data=antioquia_points, font=5), colorbar=true)\n\n\n\n\n\n\n\n\nThe examples shown here use vector data in the shapefile format, but the same could have been obtained using for example the geopackage format. In fact, as indicated in the SAGA-GIS site from where the shapefiles were downloaded, the original data originates from the GADM project where data was in gpkg format. We can access the data from that site using the gadm function (see examples in [GADM]). For example, the Antioquia municipes can be downloaded with:\nantioquia = gadm(\"COL\", \"Antioquia\", children=true);\nBut that object does not contain the ID_2 attribute so in fact we couldn’t have made the same choropleth map."
  },
  {
    "objectID": "tutorials/signal/tide_smooth/tide_smooth.html",
    "href": "tutorials/signal/tide_smooth/tide_smooth.html",
    "title": "Smooth a tide record",
    "section": "",
    "text": "Download the tide data. In this case 2 days of tides at the Cascais tide gauge station.\n\nusing GMT\n\nD = maregrams(code=\"casc\", starttime=\"2025-03-05T13:26:00\")\n\nAttribute table\n┌─────────┬─────────┬──────────┬─────────┐\n│ ST_name │ ST_code │  Country │ Timecol │\n├─────────┼─────────┼──────────┼─────────┤\n│ Cascais │    casc │ Portugal │       1 │\n└─────────┴─────────┴──────────┴─────────┘\nBoundingBox: [1.74118116e9, 1.74135396e9, -0.679, 1.441]\n\n30189×2 GMTdataset{Float64, 2}\n Row │                time  rad(m) \n─────┼─────────────────────────────\n   1 │ 2025-03-05T13:26:00  -0.508\n   2 │ 2025-03-05T13:26:05  -0.519\n   3 │ 2025-03-05T13:26:10  -0.507\n   4 │ 2025-03-05T13:26:15  -0.502\n   5 │ 2025-03-05T13:26:20  -0.517\n   6 │ 2025-03-05T13:26:25  -0.529\n   7 │ 2025-03-05T13:26:30  -0.501\n   8 │ 2025-03-05T13:26:35  -0.515\n  ⋮  │          ⋮             ⋮\n\nLoadError: UndefVarError: `Attribute` not defined\nUndefVarError: `Attribute` not defined\n\n\n\nD = maregrams(code=\"casc\", starttime=\"2025-03-05T13:26:00\") # Hide\nviz(D, title=\"Raw data at 5 s\")\n\n\n\n\n\n\n\n\nResample data to 60 seconds intervals and break at gaps &gt; 300 s. The nonans option is used to remove rows with NaN values that otherwise would be present inside the gaps.\nDs = sample1d(D, T=\"2025-03-05T13:26:00/2025-03-07T13:24:05/60s\", g=\"x300s\", nonans=1);\n\n# The above Dataset is made up of 9 segments. _size(Ds)_ shows just that.\nsize(Ds)\n\n(9,)\nLet’s stack them up to get a single segment using the stack function.\nA plot of the data is similar to that of the raw data, but with much less points (points every 60 s instead of every 5 s).\n\nDs = sample1d(D, T=\"2025-03-05T13:26:00/2025-03-07T13:24:05/60s\", g=\"x300s\", nonans=1);   # Hide\nDt = stack(Ds);\nviz(Dt, title=\"Resampled data at 60 s\")\n\n\n\n\n\n\n\n\nNow we are going to do the first step of the filtering process using the lowess function. This function fits a non-parametric regression model to the data using locally weighted linear regression. The span parameter is a factor that controls the smoothing and delta helps speeding up the calculus but experience have show that it also affects curvature of the obtained curve. Note: obtaining the values for these parameters is a trial and error process.\n\nDl = lowess(Dt, span=0.02, delta=200);\nviz(Dl, title=\"Lowess smoothed data at 60 s\")\n\n\n\n\n\n\n\n\nMuch nicer and we almost there but not yet because we can see that the curve still has the gaps. To fill them we are going to use the sample1d function again.\n\nDfinal = sample1d(Dl, T=\"2025-03-05T13:26:00/2025-03-07T13:24:05/60s\");\n\nAnd now we have a nice curve that we could use to calculate the derivatives or feed to an FFT to get the frequency components of the signal.\nShow both original and smoothed data as points. It is not perfect at the top of the second creast but this was a tough case.\n\nplot(D, legend= \"Raw data\")\nplot!(Dfinal, lc=:red, lt=1, legend=\"Smoothed data\", show=true)"
  },
  {
    "objectID": "tutorials/signal/fft_tide/fft_tide.html",
    "href": "tutorials/signal/fft_tide/fft_tide.html",
    "title": "FFT tide components.",
    "section": "",
    "text": "Example showing how to extract the two principal tide components, M2 & S2, with Fourier analysis of a one month tide record.\nGet a one month maregram from a station in Galicia.\n\nusing GMT\n\nD = maregrams(code=\"fer1\", days=30, starttime=\"2025-04-01T00:00:00\");\nviz(D, figsize=(14, 6))\n\n\n\n\n\n\n\n\nResample the data to a constant time step of 60 seconds.\n\nDs = sample1d(D, T=\"2025-04-01T00:00:00/2025-05-01T00:00:00/60s\");\nviz(D, figsize=(14, 6))\n\n\n\n\n\n\n\n\nSet the parameters for this time series.\n\nFs = 1 / 60;        # Sampling frequency (1 sample per 60 seconds)\nL = size(Ds,1);     # Length of signal\n\nFind the fundamental periods (tide components) in this tide record.\n\nusing GMT, FFTW\n\nY = fft(Ds[:,2] .- mean(Ds[:,2]));      # FFTs require that we remove the mean (the zero frequency).\nP = abs.(Y/L);\nf = Fs * (0:(L/2)-1)/L;\n\nviz(1 ./ f ./ 3600, 2*P[1:length(f)], limits=(0,25,0,1.5), lc=:red, marker=:point, figsize=(15,6))\n\n\n\n\n\n\n\n\nThe two frequencies can be found with:\nfindpeaks(P, min_height=0.2, xsorted=true)\n\n4-element Vector{Int64}:\n    59\n    61\n 43142\n 43144\nNote that we got four but the last two are repeated as the FFT signal is symetric with respect to the N/2 position.\nWe can optain the periods in hours with\nff = fftfreq(L, 1/60);\nT1 = 1/(ff[59])/3600\n\n12.41408\n\nT1 = 1/(ff[69])/3600\n\n12.000278\nWhich are the Principal Lunar (M2) and Principal Solar (S2) components."
  },
  {
    "objectID": "tutorials/signal/clean_outliers/clean_outliers.html",
    "href": "tutorials/signal/clean_outliers/clean_outliers.html",
    "title": "Remove outliers",
    "section": "",
    "text": "The examples in this tutorial show some ways in which we can easily remove the outliers of a time series.\ny = [57, 59, 60, 100, 59, 58, 57, 58, 300, 61, 62, 60, 62, 58, 57];\nIndentify the outliers positions with the help of the MAD estimator (MAD = median absolute deviation = 1.4826 * median(|xi−median(x)|))\nzi = (y .- median(y)) ./ mad(y)[1];\n\nind = abs.(zi) .&gt; 2.5\n\n15-element BitVector:\n 0\n 0\n 0\n 1\n 0\n ...\nThe outliers positions are at:\noutliers\n\n2-element Vector{Int64}:\n 100\n 300\n\nusing GMT\nimport Random\nRandom.seed!(1234);\n\nx = -50.0:50;\ny = x / 50 .+ 3 .+ 0.25 * rand(length(x));\n# Add 3 outliers\ny[[30,50,60]] = [4,-3,6];\n\nviz(x, y, figsize=(15, 5))\n\n\n\n\n\n\n\n\nFilter out the outliers with a median filter.\n\nD = filter1d([x y], filter=(type=:median, width=5), ends=true);\nviz(D, figsize=(15, 5))\n\n\n\n\n\n\n\n\nBut what if we want to locale the outliers?\nWe can use the median filter but this time we ask filter1d do return the residues. We do that by setting the highpass option.\n\nDres = filter1d([x y], filter=(type=:median, width=5, highpass=true), ends=true);\nviz(Dres, figsize=(15, 5))\n\n\n\n\n\n\n\n\n\n_mad = mad(Dres[:, 2])[1] # Median Absolute Deviation\n\n0.07313706508952521\n\n0.07313706508952521\n\n\n\nind = abs.(Dres[:,2]) .&gt; 3 * _mad;\nviz([x y], plot=(data=[x[ind] y[ind]], marker=:point), figsize=(15, 5))\n\n\n\n\n\n\n\n\n\nAnother way\nFit a linear model and analyze the residues. The rin the out=:xmr option tells to output the residues too.\nD = trend1d([x y], model=(polynome=1), out=:xmr)\n\nBoundingBox: [-50.0, 50.0, 2.1219925238508743, 4.121792763622711, -6.101894641339074, 2.698125334683742]\n\n101×3 GMTdataset{Float64, 2}\n Row │     x    model      residues\n─────┼──────────────────────────────\n   1 │ -50.0  2.12199   0.022973\n   2 │ -49.0  2.14199  -0.019167\n   3 │ -48.0  2.16199   0.121045\n   4 │ -47.0  2.18199  -0.118259\n   5 │ -46.0  2.20198   0.00810421\n   6 │ -45.0  2.22198   0.0379079\n   7 │ -44.0  2.24198   0.0879249\n   8 │ -43.0  2.26198   0.119807\n  ⋮  │   ⋮       ⋮          ⋮\n\nD = trend1d([x y], model=(polynome=1), out=:xmr);\n\nplot([x y], figsize=(15, 5))\nplot!(D, lc=:blue, show=true)\n\n\n\n\n\n\n\n\nShow the residues\n\nRandom.seed!(1234);\nx = -50.0:50;\ny = x / 50 .+ 3 .+ 0.25 * rand(length(x));\ny[[30,50,60]] = [4,-3,6];\nD = trend1d([x y], model=(polynome=1), out=:xmr)\n\nviz(D[:, [1,3]], figsize=(15, 5))\n\n\n\n\n\n\n\n\nmad_res, med_res = mad(D[:,3])\n\n(0.0803265039051275, 0.0412274796762353)\n\nRandom.seed!(1234);\nx = -50.0:50;\ny = x / 50 .+ 3 .+ 0.25 * rand(length(x));\ny[[30,50,60]] = [4,-3,6];\nD = trend1d([x y], model=(polynome=1), out=:xmr)\nmad_res, med_res = mad(D[:,3])\n\nzi = (D[:,3] .- med_res) ./ mad_res;\nind = abs.(zi) .&gt; 3 * mad_res;\nviz([x y], plot=(data=[x[ind] y[ind]], marker=:point), figsize=(15, 5))\n\n\n\n\n\n\n\n\nLet’s replace the outliers by NaNs.\ny[ind] .= NaN;\nAnd now replace the NaNs by interpolated values.\n\nRandom.seed!(1234);\nx = -50.0:50;\ny = x / 50 .+ 3 .+ 0.25 * rand(length(x));\ny[ind] .= NaN;\n\nDfill = sample1d([x y], fill_nans=true);\nviz(Dfill, figsize=(15, 5), title=\"Outliers replaced by interpolation\")\n\n\n\n\n\n\n\n\n\n\nYet another example but this time with a quadratic curve.\n\nRandom.seed!(1243);\n\nx = -50.0:50;\ny = 4 * (x / 50) .^3 .+ 3 .+ 0.25 * rand(length(x));\nD = trend1d([x y], model=((polynome=0,single=1),(polynome=3,single=true)), out=:xm);\nplot(x,y, region=(-50,50,0,6), figsize=(15, 5), marker=:point)\nplot!(D, lc=:blue, show=true)\n\n\n\n\n\n\n\n\nPolute it at positions [15, 40, 90].\n\ny[[15, 40, 90]] = [3, 4, 3];\nviz(x,y, region=(-50,50,0,6), figsize=(15, 5), marker=:point)\n\n\n\n\n\n\n\n\nCompute and show the residues.\n\nRandom.seed!(1243);\nx = -50.0:50;\ny = 4 * (x / 50) .^3 .+ 3 .+ 0.25 * rand(length(x));\ny[[15, 40, 90]] = [3, 4, 3];\n\nD2 = trend1d([x y], model=((polynome=0,single=1),(polynome=3,single=true)), out=:xr);\nviz(D2, figsize=(15, 5))\n\n\n\n\n\n\n\n\nAnd now find the outliers positions and confirm that we obtain the locations used at the polution step.\nfindall(isoutlier(D2[:,2]))\n\n3-element Vector{Int64}:\n 15\n 40\n 90"
  },
  {
    "objectID": "tutorials/signal/autocorr_chloro/autocorr_chloro.html",
    "href": "tutorials/signal/autocorr_chloro/autocorr_chloro.html",
    "title": "Find Periodicity in Chlorophyl time series",
    "section": "",
    "text": "Another example on how to detect periodicities in a Chlorophyl time series.\nLoad the data file with the chlorophyll concentration file.\n\nusing GMT\n\nD1 = gmtread(TESTSDIR * \"assets/cmems_mod_blk_bgc-plankton.csv\");\nviz(D1, figsize=(15,6))\n\n\n\n\n\n\n\n\nCreate the lags vector. This case is simple as data points were collected one every day (less the missing days), so we use a lag interval of 1, extended over 3 years.\nlags = 0:3*365;\nNow, compute the autocorrelation of the data using the autocor function. But, we want to pass it only the chlorophyll data that is stored in the second column of D1\nac = GMT.autocor(D1[:,2], lags)\nShow the autocorrelation values in a plot. The x-axis represent be the lags, and the y-axis should be the autocorrelation value.\n\nD1 = gmtread(TESTSDIR * \"assets/cmems_mod_blk_bgc-plankton.csv\");   # Hide\nlags = 0:3*365; # Hide\n\nac = GMT.autocor(D1[:,2], lags)\nviz(ac, figsize=(15,6), grid=true)"
  },
  {
    "objectID": "tutorials/remote_datasets/remote_datasets.html",
    "href": "tutorials/remote_datasets/remote_datasets.html",
    "title": "GMT Remote Datasets",
    "section": "",
    "text": "GMT Remote Datasets\nA remote data set is a data set that is stored on one or more remote servers. It may be a single grid file or a collection of subset tiles making up a larger grid. They are not distributed with GMT or installed during the installation procedures. GMT offers several remote global data grids that you can access via our remote file mechanism. The first time you access one of these files, GMT will download the file (or a subset tile) from the selected GMT server and save it to the server directory under your GMT user directory [~/.gmt]. From then on we read the local file from there.\nWe have processed and reformatted publicly available global data sets (grids and images) and standardized their file names. In GMT, you may access such data (or a subset only by using the region option) by specifying the special name\n``@remote_name_rru[_reg]``\nPlease refer to the GMT page for details of what is the remote, name, rru and reg parts of the name. Another very important aspect is that given the file sizes of the higher resolution versions (can reach out 41 GB), grids with resolutions higher or equal “5m” (five arc-minutes) are tilled to minimize the amount of necessary download data.\nBut in order to simplify accessing these data sets we have a helper function, remotegrid, that facilitates the name composability. For example, remotegrid(\"relief\", res=\"6m\") returns the string\"@earth_relief_06m\" that can be passed to modules that create images (viz, grdimage, gmtread, grdcut, grdcontour, etc..)\nThe examples in next pages show the available dataset and use the remotegrid function to compose their names but your, ofc, free to use the full dataset name if you feel comfortable with it.\n\n\n\nIGPP Earth Relief \n\n\n\n\nEGM2008 Earth Geoid \n\n\n\n\nSeafloor Crustal Age \n\n\n\n\nGSHHG Earth Mask \n\n\n\n\nGSHHG Earth Distace to Shoreline \n\n\n\n\nWorld Digital Magnetic Anomaly Map \n\n\n\n\nIGPP Earth Free-Air Anomaly \n\n\n\n\nIGPP Earth West-East Defections \n\n\n\n\nIGPP Earth South-North Defections \n\n\n\n\nIGPP Earth Vertical Gravity Gradient \n\n\n\n\nIGPP Earth Free-Air Anomaly Error \n\n\n\n\nGEBCO Earth Relief \n\n\n\n\nCNES Earth Mean Sea Surface \n\n\n\n\nCNES Earth Mean Dynamic Topography \n\n\n\n\nEarth Magnetic Anomaly Model (EMAG2) \n\n\n\n\nNASA Earth Day/Night Images \n\n\n\n\nNASA Mars Relief \n\n\n\n\nUSGS Mercury Relief \n\n\n\n\nUSGS Moon Relief \n\n\n\n\nUSGS Pluto Relief \n\n\n\n\nUSGS Venus Relief"
  },
  {
    "objectID": "tutorials/longest_sail/longestsail.html",
    "href": "tutorials/longest_sail/longestsail.html",
    "title": "The longest sail",
    "section": "",
    "text": "GMT uses the coast utility to access a version of the GSHHG data specially formatted for GMT. The GSHHG data have strengths and weaknesses. It is global and open source, but is based on relatively old datasets and hence may not be accurate enough for very large-scale mapping projects. For more information about the coastlines data-set see the GSHHG repository. We are referring this because the GMT coastlines were used to refine the solutions for the departing and arrival points of the longest sail.\nQuoting Rohan Chabukswar and Kushal Mukherjee\n\nThere has been some interest recently in determining the longest distance one can sail for on the earth without hitting land, as well as in the converse problem of determining the longest distance one could drive for on the earth without encountering a major body of water.\n\nThose authors have developed an algorithm for calculating the longest straight-line path on land or sea and came out with a solution for the maritime path that starts in Pakistan (66:40 E; 25:17 N) and ends in the Kamchatka Peninsula (162:14 E; 58:37 N) following a great circle of 32,090 kilometers long. However, as they acknowledge, the computation was performed using a topo-bathymetric grid with a grid step of 1 arc minute (~1.8 km) and on a spherical Earth.\nThe first effect, that of the grid spacing, adds only a very small error in the total length because the start and end points actually fall on land. Moving them to the intersection of the great circle with the GMT coastlines data-set ((66:39:49 E; 25:16:45 N), (162:20:44 E; 58:35:50 N)) leads to slightly shorter path of 32,083.3 km. Here we used authalic sphere computed from the WGS84 ellipsoid. The second effect, that of the spherical vs ellipsoidal approximation, is what we will see here. We will show that the proposed locations still works for an ellipsoidal Earth but that we can find a slightly longer geodesic line in the vicinity of the spherical solution, though not mathematically prove it is the longest possible geodesic.\n\n\nTo start with, let us look how close to land the great circle solution has come. On its closest approach in the Aleutian archipelago a check with GoogleEarth imagery shown that it came as close as ~250 meters from land. Another location where it also came very close was in the Comoros archipelago (~750 m).\nThe following script produces the map below. To obtain the other solutions, also shown below, change the Booleans in the first three lines.\nbest = false        # First precedence (if true computes the ellipsoidal solution)   \nsphere = true       # Second precedence (if true computes the spherical solution)\nPakKam = false      # If all 3 are false ==&gt; KamPak (compute geodesics with original points moved to shore)\n\n# Set titles, fig names and regions for the insets depending on the selected solution.\nif (best)\n    ptPak = [66.6424435 25.2972055];        ptKam = [162.34545111 58.59724279];     # New ~Best [66:38:32.8 25:17:49.9]\n    x = geodesic(ptKam, ptPak, longest=true, step=10000);\n    title, fname = \"~Best Ellipsoidal\", \"Longest_best_ellipse.png\"\n    subtit = \"Length = $(round(parse(Float64, x.attrib[\"Length\"]) / 1000, digits=3)) km\"\nelse\n    ptPak = [66.66366872 25.27917480];      ptKam = [162.34545111 58.59724279];     # Intersect Orig with shoreline\n    if (sphere)\n        x = geodesic(ptPak, ptKam, longest=true, step=10000, proj=\"+proj=lonlat +a=6371007 +b=6371007\");\n        title, fname = \"Spherical\", \"Longest_sphere\"\n        subtit = \"Length = $(round(parse(Float64, x.attrib[\"Length\"]) / 1000, digits=3)) km\"\n    else\n        x = geodesic(ptPak, ptKam, longest=true, step=10000);\n        title, fname = \"Ellipsoidal Pak-&gt;Kam\", \"Longest_ellipse_PakKam.png\"\n        subtit = \"Length = $(round(parse(Float64, x.attrib[\"Length\"]) / 1000, digits=3)) km\"\n    end\nend\n\n# Make the plot\ngmtbegin(fname)\n    coast(region=:global, proj=:guess, shore=0.5, land=:gray, frame=:auto, area=(500,1), title=title, subtitle=subtit)\n    plot(x, lw=0.5, lc=:red)\n\n    # Comoros\n    plot([42.0 -14.0 46.0 -10.0], marker=\"r+s\", ml=(0.2, :blue))    # A blue rectangle\n    inset(inset_box=(map=true, anchor=(56,0), justify=:TL, width=1.4), box=(fill=:white, pen=(0.5, :blue)))\n        coast(region=[43.1, 44.6, -12.7, -11.2], frame=:none, shore=0.5, land=:orange, figsize=1.4)\n        plot(x, lw=0.5, lc=:red)\n        if (best || sphere)\n            plot([43.8 -12.45 44.00 -12.25], marker=\"r+s\", ml=(0.2, :darkblue))    # A blue rectangle for 2nd zoom\n        end\n    inset(:end)\n    inset(inset_box=(map=true, anchor=(62,-40), justify=:TL, width=(1.5,1.0)), box=(fill=:white, pen=(0.5, :darkblue)))\n        coast(region=[43.850, 43.93, -12.41, -12.32], frame=:none, shore=0.5, land=:darkorange, figsize=1.5)\n        plot(x, lw=0.5, lc=:red)\n        just = (PakKam) ? :BL : :BR\n        basemap(map_scale=(anchor=just, scale_at_lat=-12.35, length=\"4k\", label=true, fancy=true, offset=(0.1,0.3)),)\n    inset(:end)\n\n    # Kamchatka\n    inset(inset_box=(map=true, anchor=(140,48), justify=:TL, width=1.5), box=(fill=:white, pen=(0.5, :blue)))\n        coast(region=[161.7, 164.0, 57.67, 59.5], frame=:none, shore=0.5, land=:orange, figsize=1.5)\n        plot(x, lw=0.5, lc=:red)\n        plot(ptKam, marker=:circ, ms=0.1, fill=:darkred)    # Orig pt\n    inset(:end)\n\n    # Aleutian\n    plot([-178.2 50.49 -173.3 52.77], marker=\"r+s\", ml=(0.2, :blue))    # A blue rectangle\n    inset(inset_box=(map=true, anchor=(-158,40), justify=:TR, width=(1.5,1)), box=(fill=:white, pen=(0.5, :blue)))\n        R = (best || sphere || PakKam) ? [-175.7, -175.3, 51.90, 52.1] : [-175.325, -175.08, 51.97, 52.067]\n        coast(region=R, frame=:none, shore=0.5, res=:full, land=:orange, figsize=1.5)\n        plot(x, lw=0.5, lc=:red)\n    inset(:end)\n    if (false && best || sphere)\n        inset(inset_box=(map=true, anchor=(-175,5), justify=:TL, width=(1.6,1.4)), box=(fill=:white, pen=(0.5, :darkblue)))\n            R = (best) ? [-175.6, -175.48, 51.945, 52.05] : [-175.60, -175.538, 51.950, 52.07] \n            coast(region=R, frame=:none, shore=0.5, res=:full, land=:darkorange, figsize=1.6)\n            plot(x, lw=0.5, lc=:red)\n            if (best)\n                basemap(map_scale=(anchor=:BC, scale_at_lat=52, length=\"2k\", label=true, fancy=true, offset=(-0.1,0.3)),)\n            else\n                basemap(map_scale=(anchor=:BR, scale_at_lat=52, length=\"2k\", label=true, fancy=true, offset=(0.1,0.3)),)\n            end\n        inset(:end)\n    end\n\n    # Pakistan\n    inset(inset_box=(map=true, anchor=(63,30), justify=:BL, width=1.4), box=(fill=:white, pen=(0.5, :blue)))\n        coast(region=[66.0, 66.8, 25.1, 25.9], frame=:none, shore=0.5, res=:full, land=:orange, figsize=1.4)\n        plot(x, lw=0.5, lc=:red)\n        plot(ptPak, marker=:circ, ms=0.1, fill=:darkred)    # Orig pt\n    inset(:end)\ngmtend(:show)\n\\figenv{The caption}{/tutorials/longest_sail/Longest_sphere.png}{width:90%;}\n\n\n\nNow let’s see how it behaves if we compute the path along the shortest distance on an ellipsoid (a geodesic line), the WGS84 ellipsoid in this case. Good, but the case not so simple as a geodesic, except for along a meridian or the equator, is not a closed line. That means, following a geodesic that starts at a certain azimuth different from +/-90 or 0 degrees we don’t return to starting point, see this Wiki page. So this means we cannot simply compute the other way around as the complement of the shortest path between A and B as that is a too crude aproximation. For more details on this problem see this discussion in the GMT forum that shows also the history on how this problem was solved. But the take of this is that one can obtain a geodesic line that very closely (at the decimeter level) can go from A to B and be a reversible solution. That is, if we swapp A and B we get the same solution.\nNext figure shows that the proposed geocentric solution still holds for the ellipsoidal case. Well, the figure doesn’t show that because we can see an interruption due to a hit in one of the Comoro’s islet. However, this is not really true because the GMT shorelines at this levels show the effect of having been digitized from last century charts and are off often off by ~250-300 m. And in fact, checking with GoogleEarth we would see that the path manages to go through those rocks without hitting them.\n\\figenv{The caption}{/tutorials/longest_sail/Longest_ellipse_PakKam.png}{width:90%;}\n\n\n\nAlthough the solution proposed by Chabukswar and Mukherjee still holds on the ellipsoidal Earth, it is possible to find a nearby alternative that is slightly longer. With trial an error it was possible to find one that adds ~0.5 km to the that path. That solution, that starts at [66:38:32.8 E; 25:17:49.9 N] and ends at the same Kamachatka point of [162:20:44 E; 58:35:50 N] is shown in the figure below and has a length of ~32,064.31 km.\n\\figenv{The caption}{/tutorials/longest_sail/Longest_best_ellipse.png}{width:90%;}"
  },
  {
    "objectID": "tutorials/longest_sail/longestsail.html#sherical-great-circle-path",
    "href": "tutorials/longest_sail/longestsail.html#sherical-great-circle-path",
    "title": "The longest sail",
    "section": "",
    "text": "To start with, let us look how close to land the great circle solution has come. On its closest approach in the Aleutian archipelago a check with GoogleEarth imagery shown that it came as close as ~250 meters from land. Another location where it also came very close was in the Comoros archipelago (~750 m).\nThe following script produces the map below. To obtain the other solutions, also shown below, change the Booleans in the first three lines.\nbest = false        # First precedence (if true computes the ellipsoidal solution)   \nsphere = true       # Second precedence (if true computes the spherical solution)\nPakKam = false      # If all 3 are false ==&gt; KamPak (compute geodesics with original points moved to shore)\n\n# Set titles, fig names and regions for the insets depending on the selected solution.\nif (best)\n    ptPak = [66.6424435 25.2972055];        ptKam = [162.34545111 58.59724279];     # New ~Best [66:38:32.8 25:17:49.9]\n    x = geodesic(ptKam, ptPak, longest=true, step=10000);\n    title, fname = \"~Best Ellipsoidal\", \"Longest_best_ellipse.png\"\n    subtit = \"Length = $(round(parse(Float64, x.attrib[\"Length\"]) / 1000, digits=3)) km\"\nelse\n    ptPak = [66.66366872 25.27917480];      ptKam = [162.34545111 58.59724279];     # Intersect Orig with shoreline\n    if (sphere)\n        x = geodesic(ptPak, ptKam, longest=true, step=10000, proj=\"+proj=lonlat +a=6371007 +b=6371007\");\n        title, fname = \"Spherical\", \"Longest_sphere\"\n        subtit = \"Length = $(round(parse(Float64, x.attrib[\"Length\"]) / 1000, digits=3)) km\"\n    else\n        x = geodesic(ptPak, ptKam, longest=true, step=10000);\n        title, fname = \"Ellipsoidal Pak-&gt;Kam\", \"Longest_ellipse_PakKam.png\"\n        subtit = \"Length = $(round(parse(Float64, x.attrib[\"Length\"]) / 1000, digits=3)) km\"\n    end\nend\n\n# Make the plot\ngmtbegin(fname)\n    coast(region=:global, proj=:guess, shore=0.5, land=:gray, frame=:auto, area=(500,1), title=title, subtitle=subtit)\n    plot(x, lw=0.5, lc=:red)\n\n    # Comoros\n    plot([42.0 -14.0 46.0 -10.0], marker=\"r+s\", ml=(0.2, :blue))    # A blue rectangle\n    inset(inset_box=(map=true, anchor=(56,0), justify=:TL, width=1.4), box=(fill=:white, pen=(0.5, :blue)))\n        coast(region=[43.1, 44.6, -12.7, -11.2], frame=:none, shore=0.5, land=:orange, figsize=1.4)\n        plot(x, lw=0.5, lc=:red)\n        if (best || sphere)\n            plot([43.8 -12.45 44.00 -12.25], marker=\"r+s\", ml=(0.2, :darkblue))    # A blue rectangle for 2nd zoom\n        end\n    inset(:end)\n    inset(inset_box=(map=true, anchor=(62,-40), justify=:TL, width=(1.5,1.0)), box=(fill=:white, pen=(0.5, :darkblue)))\n        coast(region=[43.850, 43.93, -12.41, -12.32], frame=:none, shore=0.5, land=:darkorange, figsize=1.5)\n        plot(x, lw=0.5, lc=:red)\n        just = (PakKam) ? :BL : :BR\n        basemap(map_scale=(anchor=just, scale_at_lat=-12.35, length=\"4k\", label=true, fancy=true, offset=(0.1,0.3)),)\n    inset(:end)\n\n    # Kamchatka\n    inset(inset_box=(map=true, anchor=(140,48), justify=:TL, width=1.5), box=(fill=:white, pen=(0.5, :blue)))\n        coast(region=[161.7, 164.0, 57.67, 59.5], frame=:none, shore=0.5, land=:orange, figsize=1.5)\n        plot(x, lw=0.5, lc=:red)\n        plot(ptKam, marker=:circ, ms=0.1, fill=:darkred)    # Orig pt\n    inset(:end)\n\n    # Aleutian\n    plot([-178.2 50.49 -173.3 52.77], marker=\"r+s\", ml=(0.2, :blue))    # A blue rectangle\n    inset(inset_box=(map=true, anchor=(-158,40), justify=:TR, width=(1.5,1)), box=(fill=:white, pen=(0.5, :blue)))\n        R = (best || sphere || PakKam) ? [-175.7, -175.3, 51.90, 52.1] : [-175.325, -175.08, 51.97, 52.067]\n        coast(region=R, frame=:none, shore=0.5, res=:full, land=:orange, figsize=1.5)\n        plot(x, lw=0.5, lc=:red)\n    inset(:end)\n    if (false && best || sphere)\n        inset(inset_box=(map=true, anchor=(-175,5), justify=:TL, width=(1.6,1.4)), box=(fill=:white, pen=(0.5, :darkblue)))\n            R = (best) ? [-175.6, -175.48, 51.945, 52.05] : [-175.60, -175.538, 51.950, 52.07] \n            coast(region=R, frame=:none, shore=0.5, res=:full, land=:darkorange, figsize=1.6)\n            plot(x, lw=0.5, lc=:red)\n            if (best)\n                basemap(map_scale=(anchor=:BC, scale_at_lat=52, length=\"2k\", label=true, fancy=true, offset=(-0.1,0.3)),)\n            else\n                basemap(map_scale=(anchor=:BR, scale_at_lat=52, length=\"2k\", label=true, fancy=true, offset=(0.1,0.3)),)\n            end\n        inset(:end)\n    end\n\n    # Pakistan\n    inset(inset_box=(map=true, anchor=(63,30), justify=:BL, width=1.4), box=(fill=:white, pen=(0.5, :blue)))\n        coast(region=[66.0, 66.8, 25.1, 25.9], frame=:none, shore=0.5, res=:full, land=:orange, figsize=1.4)\n        plot(x, lw=0.5, lc=:red)\n        plot(ptPak, marker=:circ, ms=0.1, fill=:darkred)    # Orig pt\n    inset(:end)\ngmtend(:show)\n\\figenv{The caption}{/tutorials/longest_sail/Longest_sphere.png}{width:90%;}"
  },
  {
    "objectID": "tutorials/longest_sail/longestsail.html#ellipsoidal-geodesics",
    "href": "tutorials/longest_sail/longestsail.html#ellipsoidal-geodesics",
    "title": "The longest sail",
    "section": "",
    "text": "Now let’s see how it behaves if we compute the path along the shortest distance on an ellipsoid (a geodesic line), the WGS84 ellipsoid in this case. Good, but the case not so simple as a geodesic, except for along a meridian or the equator, is not a closed line. That means, following a geodesic that starts at a certain azimuth different from +/-90 or 0 degrees we don’t return to starting point, see this Wiki page. So this means we cannot simply compute the other way around as the complement of the shortest path between A and B as that is a too crude aproximation. For more details on this problem see this discussion in the GMT forum that shows also the history on how this problem was solved. But the take of this is that one can obtain a geodesic line that very closely (at the decimeter level) can go from A to B and be a reversible solution. That is, if we swapp A and B we get the same solution.\nNext figure shows that the proposed geocentric solution still holds for the ellipsoidal case. Well, the figure doesn’t show that because we can see an interruption due to a hit in one of the Comoro’s islet. However, this is not really true because the GMT shorelines at this levels show the effect of having been digitized from last century charts and are off often off by ~250-300 m. And in fact, checking with GoogleEarth we would see that the path manages to go through those rocks without hitting them.\n\\figenv{The caption}{/tutorials/longest_sail/Longest_ellipse_PakKam.png}{width:90%;}"
  },
  {
    "objectID": "tutorials/longest_sail/longestsail.html#a-slightly-longer-geodesic-solution",
    "href": "tutorials/longest_sail/longestsail.html#a-slightly-longer-geodesic-solution",
    "title": "The longest sail",
    "section": "",
    "text": "Although the solution proposed by Chabukswar and Mukherjee still holds on the ellipsoidal Earth, it is possible to find a nearby alternative that is slightly longer. With trial an error it was possible to find one that adds ~0.5 km to the that path. That solution, that starts at [66:38:32.8 E; 25:17:49.9 N] and ends at the same Kamachatka point of [162:20:44 E; 58:35:50 N] is shown in the figure below and has a length of ~32,064.31 km.\n\\figenv{The caption}{/tutorials/longest_sail/Longest_best_ellipse.png}{width:90%;}"
  },
  {
    "objectID": "tutorials/insets/insets.html",
    "href": "tutorials/insets/insets.html",
    "title": "Figure insets",
    "section": "",
    "text": "The inset function can be used as an option to the plot, basemap and grdimage functions. While not all the possibilities offered by the inset function are available in this case, because all functionalities must be requested via a nested call, it offers quite nice features that allow creating elaborated figures with very short commands.\nFirst example shows how to make a zoom over a region of a synthetic plot. Notice how we use here the inset command as if it was just another option of the plot function. The location of the inset window is found with a heuristic that tries to place them above the zoom window (to avoid overlapping the plotted line) or in one corner when previous condition is not possible.\n\nusing GMT\n\nt = 0:0.01:2pi;\nplot(t, cos.(t).+rand(length(t))*0.1, inset=(zoom=(pi,pi/4), box=(fill=:lightblue,)), show=true)\n\n\n\n\n\n\n\n\nIf we select the zooming interval over a region where the zoom window has a different aspect ratio (such that as in this case it would overlap the inset located above it) the inset location jumps to another location. In case of need the inset size is scaled down such that it doesn’t go out of the main figure dimensions. But all of this can be manually controlled by using the pos or position sub-options.\n\nusing GMT\n\nt = 0:0.01:2pi;\nplot(t, cos.(t).+rand(length(t))*0.1, inset=(zoom=(pi/2,pi/6), box=(fill=:lightblue,)), show=true)\n\n\n\n\n\n\n\n\nWe can make zooms on more than one line but for it to work we must plot them as a multi-column dataset. That is, we must plot all the lines in one command like the next example. Lines existing in the figure resulting from previous plot commands (case in which we should have used the plot! form) are ignored.\n\nusing GMT\n\nt = 0:0.1:2pi;\nplot([t cos.(t) cos.(t.+0.1)], multi=true, inset=(zoom=(pi,pi/4), box=(fill=:lightblue,)), show=true)\n\n\n\n\n\n\n\n\nIf we want to plot another curve instead of zooming a part of the one in the main figure we pass the data of that second curve as argument to the inset option. Here, for simplicity, we will show a sinusoid over the same domain.\n\nusing GMT\n\nt = 0:0.1:2pi;\nplot(t, cos.(t), inset=([t sin.(t)]), lc=:red, ls=:dash, show=true)\n\n\n\n\n\n\n\n\nIn the above examples, selecting the zoom coordinates was simple but when the xx axis represents time, things get a bit more complicated because time is in fact stored as a number of seconds since a reference epoch. And there are lots of seconds in an interval. So, when xx axis has time, we must provide the zooming interval in a date or date-time format. Currently the program accepts time in the ISO “yyyy-mm-ddTHH:MM:SS”, “dd-o-yyyy” or “dd-o-yy” formats. When using the ISO format the time, that is the part that includes and follows the T...., is optional\n\nusing GMT\n\nD = gmtread(\"@RHAT_price.csv\", o=\"0,2\", par=(FORMAT_DATE_IN=\"dd-o-yy\",))\nviz(D, inset=(zoom=(\"2004-01-01\",\"2005-01-01\"),))\n\n\n\n\n\n\n\n\nFor an inset with a rectangle showing the zone that is displayed in main figure, use the rect (or rectangle) option. Arguments in this example mean a line thickness of 2 points and a red line color. rect=true would have plotted a thinner (0.75 pt) blue rectangle.\n\nusing GMT\n\nG = grdcut(\"@earth_relief_04m\", limits=(-48, -43, -26, -20));\nviz(G, cmap=:world, J=:merc, inset=(coast, limits=(-80,-28,-43,10), J=:merc, shore=true, ocean=:blue, rect=(2,:red)))\n\n\n\n\n\n\n\n\nBut if instead of a rectangle we want to plot a symbol, let’s say, a red circle, we can call the plot function inside inset. In next example we also ask to plot the inset at bottom right (:BR) instead of the default top right (:TR) default position. If wished, things can be made more complex by passing a full featured GMTdataset to the plot function. e.g., plot=(data=D, ...)\n\nusing GMT\n\nG = grdcut(\"@earth_relief_04m\", limits=(-48, -43, -26, -20));\nviz(G, J=:merc,\n    inset=(coast, limits=(-80,-28,-43,10), J=:merc, shore=true, pos=(anchor=:BR,),\n           plot=(data=[-45.5 -23], marker=:circ, fill=:red))\n   )\n\n\n\n\n\n\n\n\nNext examples show how we can zoom out a region of an image and show it in the inset. We will use as example the image containing the “Finger of God” Bok globule in the Carina Nebula. We download the images directly from the Wikipedia site. The first example lets the inset location algorithm choose where to put the inset window. In the second we decide that ourselves.\n\nusing GMT\n\nim = gmtread(\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/NGC_3372a-full.jpg/2560px-NGC_3372a-full.jpg\");\nviz(im, inset=(zoom=(910,980,350,430),))\n\n\n\n\n\n\n\n\nHmm, the above figure is nice, but the finger is a bit fuzzy. The issue is the image is somewhat low resolution. The Wikipedia page has a high-resolution image but it’s a 200 MB jpeg compressed image. Too big to use in these examples. But we can download only the finger and add it as the inset. In this case we don’t have a rectangle to zoom out (because we are using a different image in the inset) but still want to indicate what zone of the base image is shown in higher resolution. For that, we use the pzoom option (that stands for pseudo-zoom), which expects a x,y location only. Since these images are not referenced, we use rows and column numbers (counting from lower left corner) as coordinates.\n\nusing GMT\n\nim = gmtread(\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/NGC_3372a-full.jpg/2560px-NGC_3372a-full.jpg\");\ndedo = gdaltranslate(\"https://upload.wikimedia.org/wikipedia/commons/f/f8/NGC_3372a-full.jpg\", srcwin=1,\n                     limits=(10580, 11360, 9410, 10270));\nviz(im, inset=(dedo, pzoom=(945, 390), pos=(anchor=:MR,)))"
  },
  {
    "objectID": "tutorials/choropleths/choropleths.html",
    "href": "tutorials/choropleths/choropleths.html",
    "title": "Choropleths",
    "section": "",
    "text": "What color is your State?\nThis example shows an adaptation of the Average color of World examples. It differs slightly for the also shown US case likely due to the different data used. Here we retrieve the image data (Sentinel 2) from the EOX WMS server and use the year 2020. And, as a side note, realize how incredibly simpler this example is as comparing to the codes used to generate the figures in that blog.\nNote how the sates polygons are read directly from source, without any previous download, uncompressing file format conversions, etc… We will also filter the states polygons to use only those inside the US continental zone and limit them by number of points and with that dropping those polygons of small islands (smaller in area than 10 km^2).\n\nusing GMT\n\n# Fetch the state polygons from the US Census Bureau \nD = gmtread(\"/vsizip//vsicurl/https://www2.census.gov/geo/tiger/GENZ2024/shp/cb_2024_us_state_500k.zip\");\n\n# Filter to keep only the continental US states (except Alaska), with an area larger than 10 km^2.\nDf = filter(D, _region=(-125,-66,24,50), _area=10);\n\n# Fetch the Sentinel 2 image that is used to calculate the average color. Restrain to pixel size of 2000 m.\nwms = wmsinfo(\"http://tiles.maps.eox.at/wms?\");\nimg = wmsread(wms, layer=4, region=(-125,-66,24,50), pixelsize=2000);\n\n# Calculate the average color per State.\ncolorzones!(Df, median, img=img)\n\nviz(Df, region=img, proj=:guess, plot=(data=Df, lw=0), title=\"Sate Color (median)\")\n\n\n\n\n\n\n\n\n\n\nRepresent colors by average altitude\nWe can also use the same polygons to represent some other variable, such as the average altitude of each state. We will use the Earth Relief 06m dataset\n\nusing GMT   # Hide\nD = gmtread(\"/vsizip//vsicurl/https://www2.census.gov/geo/tiger/GENZ2024/shp/cb_2024_us_state_500k.zip\");  # Hide\n\nG = gmtread(\"@earth_relief_06m\");\n\n# Calculate the mean elevation per State.\nDh = zonal_statistics(G, D, mean);\n\n# Create a color table for the mean elevation values.\nC = makecpt(range=(0, ceil(Dh.ds_bbox[2])), cmap=:bamako);\n\nviz(D, region=(-125,-66,24,50), proj=:guess, levels=Dh, cmap=C,\n               plot=(data=D,lw=0), title=\"Mean Elevation\", colorbar=true)\n\n\n\n\n\n\n\n\nThe case above was relatively easy because the data was already prepared in a form that GMT could use. That is, the zvals vector, which together with the colorscale, determines the color of the polygons was already in the same order as the polygons themselves (in the GMTdataset D). However, often that is not the case, and we have the variable that contains the information that we want to colorize in a different source and with a different order than that of the polygons in D. So, we need to do a kind of join operation. That can be done with join functions or use the internal polygonlevels function that links the polygon names provide by a stored attribute in D and the values in a vector or a table that must also have some text information (a name) associated with each value. It is that we will do in the next example.\n\nusing GMT   # Hide\nD = gmtread(\"/vsizip//vsicurl/https://www2.census.gov/geo/tiger/GENZ2024/shp/cb_2024_us_state_500k.zip\");  # Hide\n\n# Read a simple text file that has population and State name, one per row.\npop = gmtread(TESTSDIR * \"assets/uspop.csv\");\n\n# Use the polygonlevels function to get the values in the same order as the polygons in D.\nzvals = polygonlevels(D, pop, att=\"NAME\") / 1e6;\n\n# Create a color table for the values in zvals.\nC = makecpt(zvals, auto=:r, reverse =true, cmap=:bamako);\n\nviz(D, region=(-125,-66,24,50), level=zvals, cmap=C, proj=:guess,\n    plot=(data=D,lw=0), title=\"Population (Millions)\", colorbar=true)\n\n\n\n\n\n\n\n\n\n\nChoropleths by symbol color\nTo avoid the perceptual problem of over-enphasize the polygon’s are we can alternatively use colored symbols (or symbols of different sizes). That can be done with the bubblechart program. One issue, though, that we have to deal in this case is that a state can have multiple polygons (for example Hawaii has many islands, and Michigan has two main landmasses). So, we need to calculate the largest polygon of each state and its centroid to place the symbol there.\n\nusing GMT   # Hide\nD = gmtread(\"/vsizip//vsicurl/https://www2.census.gov/geo/tiger/GENZ2024/shp/cb_2024_us_state_500k.zip\");  # Hide\n\nDf = filter(D, _region=(-125,-66,24,50), _unique=true);  # Keep only the largest polygon per state\n\npop = gmtread(TESTSDIR * \"assets/uspop.csv\");\nzvals = polygonlevels(Df, pop, att=\"NAME\") / 1e6;\nC = makecpt(zvals, auto=:r, reverse =true, cmap=:bamako);\n\nbubblechart(Df, labels=\"attrib=STUSPS\", proj=:guess, zcolor=zvals,\n            cmap=C, colorbar=true, show=true)\n\n\n\n\n\n\n\n\nIn all the examples above we have used the US states polygons from a downloaded file, but we actually no not need that as the internal GMT coasts database has the US states polygons. So, we can use the coast function to get extract the states polygons and use them in the same way as above. Here is an example that would produce the exactly same image. But note how attribute names are different now as state names are stored under the “CODE” attribute.\n\nusing GMT   # Hide\n\nD = coast(DCW=(states=\"US\",))   # Or simply D = coast(DCW=\"+US\");\nDf = filter(D, _region=(-125,-66,24,50), _unique=true);\n\npop = gmtread(TESTSDIR * \"assets/uspop.csv\");\nzvals = polygonlevels(Df, pop, att=\"NAME\", contains=true) / 1e6;\nC = makecpt(zvals, auto=:r, reverse =true, cmap=:bamako);\n\nbubblechart(Df, labels=\"attrib=CODE\", proj=:guess, zcolor=zvals,\n            cmap=C, colorbar=true, show=true)\n\n\n\n\n\n\n\n\nNote the contains=true option in the polygonlevels function call. That is needed because the state names in the Df dataset are like “Alabama (United States)” while in the pop table they are simply “Alabama”. So, to do the joining operation, we had to be more relaxed and not impose an quality comparions (like the cases above) but to satisfy that the name in pop is contained in the name in Df.\nDf\n\nAttribute table\n┌─────┬──────┬──────────────────────────────────────┐\n│ Row │ CODE │ NAME                                 │\n├─────┼──────┼──────────────────────────────────────┤\n│   1 │ AL   │ Alabama (United States)              │\n│   2 │ AR   │ Arkansas (United States)             │"
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Step-by-step tutorials for common GMT.jl workflows and advanced techniques.\n\n\n\nISC seismicity \n\n\n\n\n\n\n\nLandsat 8 \n\n\n\n\n\n\n\nCoastlines \n\n\n\n\n\n\n\nUS Choropleths \n\n\n\n\n\n\n\n@dlakelan choropleths \n\n\n\n\n\n\n\nLongest Sail \n\n\n\n\n\n\n\nGeospatial vector \n\n\n\n\n\n\n\nTexture Shading \n\n\n\n\n\n\n\nMosaics \n\n\n\n\n\n\n\nInsets \n\n\n\n\n\n\n\nRemote Grids \n\n\n\n\n\n\n\nBlender \n\n\n\n\n\n\n\nSignal"
  },
  {
    "objectID": "gallery/ex46.html",
    "href": "gallery/ex46.html",
    "title": "(46) Day-light terminators and other sunlight parameters",
    "section": "",
    "text": "In this example show how the module [solar] is used to plot several terminator lines that depend on the location of the sun with respect to Earth. We also show how an EPS illustration can serve as a custom symbol to be plotted with [plot].\n\nusing GMT\nresetGMT() # hide\n\ncoast(limits=:global, frame=(annot=:a,ticks=:a,grid=:a), proj=:EckertVI,\n      area=5000, shore=0.5, borders=(type=1, pen=(0.5,:gray)), water=[175 210 255])\nsolar!(terminators=(term=:d, date=\"2016-02-09T16:00:00\"), fill=\"navy@95\")\nsolar!(terminators=(term=:c, date=\"2016-02-09T16:00:00\"), fill=\"navy@85\")\nsolar!(terminators=(term=:n, date=\"2016-02-09T16:00:00\"), fill=\"navy@80\")\nsolar!(terminators=(term=:a, date=\"2016-02-09T16:00:00\"), fill=\"navy@80\")\n\nt = solar(sun=(date=\"2016-02-09T16:00:00\",), format=true);\nplot!(t, symbol=\"k@sunglasses/1.5\", fill=:yellow, show=true)"
  },
  {
    "objectID": "gallery/ex44.html",
    "href": "gallery/ex44.html",
    "title": "(44) Map insets",
    "section": "",
    "text": "In this example show how [inset] can be used to place map insets on top of your map. The map inset is usually intended for placing a smaller-scale version of the larger geographical context of your main plot, so that reader unfamiliar with the detailed map can see what region we are looking at. The inset module automatically determines the possible extent of the map hence we simply pass ? for the unknown map sizes.\n\nusing GMT\nresetGMT() # hide\n\ncoast(region=\"110E/170E/44S/9S\", proj=:merc, figsize=15, shore=:faint, borders=(type=2, pen=1),\n      DCW=(country=\"AU\", fill=:bisque), land=:brown, water=:azure1)\nbasemap!(inset=(inside=true, anchor=:TR, width=3.8, offset=(0.4, 0.25), save=\"xx000.dat\"),\n         box=(fill=:white, pen=1, clearance=0.1, shaded=true))\nt = gmtread(\"xx000.dat\").data   # x0 y0 w h\n\ncoast!(region=:global360, proj=(name=:ortho, center=(120,-30), parallel=t[3]),\n       land=:brown, area=5000, frame=(grid=:auto,), shore=:faint, DCW=(country=\"AU\", fill=:bisque),\n       xshift=t[1], yshift=t[2]);\n\n# Determine size of insert map of Europe\ntt = mapproject(region=(-15,35,30,48), proj=:merc, figsize=5, map_size=true); # w h\nmapW = tt.data[1];   mapH = tt.data[2]\ncoast!(region=(-10,5,35,44), proj=:merc, figsize=15, frame=(axes=:WSne, annot=:auto, ticks=:auto),\n       DCW=(country=\"ES\", fill=:bisque), land=:brown, shore=:faint, borders=(type=1,pen=1),\n       water=:azure1, res=:full, xshift=-t[1], yshift=11.5-t[2], par=(:FORMAT_GEO_MAP, :dddF))\nbasemap!(inset=(inside=true, anchor=:TR, size=(mapW, mapH), offset=(0.4, 0.25), save=\"xx000.dat\"),\n         box=(fill=:white, pen=1, clearance=0.1, shaded=true))\nt = gmtread(\"xx000.dat\").data   # x0 y0 w h\ncoast!(region=(-15,35,30,48), proj=:merc, figsize=t[3], land=:brown, frame=:bare,\n       DCW=(country=\"ES\", fill=:bisque), par=(:MAP_FRAME_TYPE, :plain),\n       xshift=t[1], yshift=t[2], show=true)\nrm(\"xx000.dat\")\n\n\nMethodError: no method matching inset_nested(::Bool, ::Int64; offset::Tuple{Float64, Float64}, save::String, anchor::Symbol, width::Float64)\n\nClosest candidates are:\n  inset_nested(::String, ::Any; kwargs...)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmtbegin.jl:142\n  inset_nested(::Function, ::Any; kwargs...)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmtbegin.jl:189\n  inset_nested(::GDtype, ::Any; kwargs...)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmtbegin.jl:171\n  ...\n\n\nStacktrace:\n [1] inset_nested(nt::@NamedTuple{inside::Bool, anchor::Symbol, width::Float64, offset::Tuple{Float64, Float64}, save::String}, n::Int64)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmtbegin.jl:136\n [2] add_opt_module(d::Dict{Symbol, Any})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\finish_PS_nested.jl:65\n [3] finish_PS_nested(d::Dict{Symbol, Any}, cmd::Vector{String})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\finish_PS_nested.jl:7\n [4] helper_basemap(O::Bool, K::Bool, d::Dict{Symbol, Any})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\psbasemap.jl:67\n [5] #helper_basemap#919\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\psbasemap.jl:49 [inlined]\n [6] helper_basemap\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\psbasemap.jl:47 [inlined]\n [7] #basemap!#918\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\psbasemap.jl:46 [inlined]\n [8] top-level scope\n   @ In[2]:6"
  },
  {
    "objectID": "gallery/ex41.html",
    "href": "gallery/ex41.html",
    "title": "(41) Legend with tables",
    "section": "",
    "text": "In this example we demonstrate how one can use the tool legend to typeset a table within a [legend]. It also shows how one would set up variable-width columns and fill the cells with a background color.\n\nusing GMT\nresetGMT() # hide\n\nC = makecpt(color=\"red,orange,yellow,green,bisque,cyan,magenta,white,gray\", range=(1,10,1))\ncoast(region=\"130W/50W/8N/56N\", proj=:Mercator, figsize=14, frame=:noannot,\n      land=:lightgray, water=:azure1, area=1000, shore=:faint, yshift=3,\n      par=(:MAP_FRAME_TYPE, :plain))\ncoast!(DCW=((country=\"US\", pen=:faint, fill=:lightyellow), (country=\"CU\", pen=:faint, fill=:lightred),\n       (country=\"MX\", pen=:faint, fill=:lightgreen), (country=\"CA\", pen=:faint, fill=:lightblue)) )\ncoast!(borders=(type=1, pen=(1,:darkred)), area=\"1000/2/2\", shore=:faint, river_fill=:azure1)\nplot!(\"@data_41.txt\", marker=\"k@symbol_41\", ms=0.25, C=C, ml=0.25, yx=true)\nlegend!(\"@table_41.txt\", region=(0,15,0,23), pos=(paper=true, anchor=(7.5,11.5), width=14, justify=:BC,\n        spacing=1.2), clearance=0.12, box=(pen=true, fill=:snow1), proj=:linear, figscale=1,\n        xshift=-0.5, yshift=-0.5, par=(FONT_ANNOT_PRIMARY=12, FONT_LABEL=12), frame=:bare, show=true)"
  },
  {
    "objectID": "gallery/ex36.html",
    "href": "gallery/ex36.html",
    "title": "(36) Spherical gridding using Renka’s algorithms",
    "section": "",
    "text": "The next script produces the plot in Figure. Here we demonstrate how [sphinterpolate] can be used to perform spherical gridding. Our example uses early measurements of the radius of Mars from Mariner 9 and Viking Orbiter spacecrafts. The middle panels shows the data distribution while the top and bottom panel are images of the interpolation using a piecewise linear interpolation and a smoothed spline interpolation, respectively. For spherical gridding with large volumes of data we recommend [sphinterpolate] while for small data sets (such as this one, actually) you have more flexibility with [greenspline].\n\nusing GMT\nresetGMT() # hide\n\n# Interpolate data of Mars radius from Mariner9 and Viking Orbiter spacecrafts\nmakecpt(cmap=:rainbow, range=(-7000,15000))\n\n# Piecewise linear interpolation; no tension\nGtt = sphinterpolate(\"@mars370d.txt\", region=:global, inc=1, tension=0)\ngrdimage(Gtt, proj=:Hammer, figsize=15, frame=(annot=:auto, grid=:auto), yshift=18)\nplot!(\"@mars370d.txt\", marker=:circle, ms=0.1, fill=0, frame=(annot=30, grid=30), yshift=-8)\n\n# Smoothing\nGtt = sphinterpolate(\"@mars370d.txt\", region=:global, inc=1, tension=3)\ngrdimage!(Gtt, frame=(annot=30, grid=30), yshift=-8, show=true)"
  },
  {
    "objectID": "gallery/ex34.html",
    "href": "gallery/ex34.html",
    "title": "(34) Using country polygons for plotting and shading",
    "section": "",
    "text": "The script produces the plot in Figure. Here we demonstrate how [coast] can be used to extract and plot country polygons from the optional DCW dataset. We show two panels; one in which we do a basic basemap and another where we lay down a color topography image and then place a transparent layer identifying the future Franco-Italian Union, whose untimely breakup in 2045 the historians will continue to debate for some time.\n\nusing GMT\nresetGMT() # hide\n\npscoast(region=(-6,20,35,52), DCW=(country=\"FR,IT\", fill=(inv_pattern=8, dpi=300)),\n        land=:lightgray, proj=:Mercator, figsize=11, xshift=5)\n\n# Extract a subset of ETOPO2m for this part of Europe\nmakecpt(cmap=:globe, range=(-5000,5000,50), continuous=true)\ngrdimage!(\"@FR+IT.nc\", shade=(azim=15, norm=\"e0.75\"),\n          frame=(axes=:WsnE, annot=:auto, title=\"Franco-Italian Union, 2042-45\"), yshift=11)\ncoast!(DCW=(country=\"FR,IT\", fill=\"red@60\"),  show=true)"
  },
  {
    "objectID": "gallery/ex30.html",
    "href": "gallery/ex30.html",
    "title": "(30) Trigonometric functions plotted in graph mode",
    "section": "",
    "text": "Next, we continue with a simple mathematical illustration of sine and cosine, highlighting the graph mode for linear projections and the new curved vectors for angles.\nThe script simply draws a graph basemap, computes sine and cosine and plots them as lines, then indicates on a circle that these quantities are simply the projections of an unit vector on the x- and y-axis, at the given angle.\n\nusing GMT\nresetGMT() # hide\n\nbasemap(region=(0,360,-1.25,1.75), frame=(axes=:WS, title=\"Two Trigonometric Functions\"), xaxis=(annot=90, ticks=30, suffix=\"@.\"), yaxis=(annot=1, grid=10), par=(MAP_FRAME_TYPE=:graph, MAP_VECTOR_SHAPE=0.5), figsize=(20,15), portrait=false)\n\n# Draw sine an cosine curves\nplot!(cosd.(linspace(0,360,360)), lw=3)\nplot!(sind.(linspace(0,360,360)), pen=\"3p,0_6:0\", par=(:PS_LINE_CAP,:round))\n\n# Indicate the x-angle = 120 degrees\nplot!([120 -1.25; 120 1.25], pen=(0.5, :dash))\n\nT = mat2ds([360 1; 360 0; 120 -1.25; 370 -1.35; -5 1.85],\n    [\"18p,Times-Roman RB x = cos(@%12%a@%%)\", \"18p,Times-Roman RB y = sin(@%12%a@%%)\", \n    \"14p,Times-Roman LB 120@.\", \"24p,Symbol LT a\", \"24p,Times-Roman RT x,y\"])\n\ntext!(T, offset=(away=true, shift=0.2), noclip=true, font=\"\", justify=\"\")\n\n# Draw a circle and indicate the 0-70 degree angle\nplot!([0 0], region=(-1,1,-1,1), proj=:linear, figscale=3.81, marker=:circle, ms=5.1, ml=1, noclip=true, xshift=9, yshift=7)\nplot!(lw=\"\",\n    [NaN NaN\n#     &gt; x-gridline  -Wdefault\n    -1 0\n    1 0\n    NaN NaN\n#     &gt; y-gridline  -Wdefault\n    0 -1\n    0 1\n    NaN NaN\n#     &gt; angle = 0\n    0 0\n    1 0\n    NaN NaN\n#     &gt; angle = 120\n    0 0\n    -0.5 0.866025])\nplot!(lw=2,\n    [NaN NaN\n#     &gt; x-gmt projection -W2p\n    -0.3333 0\n    0 0\n    NaN NaN\n#     &gt; y-gmt projection -W2p\n    -0.3333 0.57735\n    -0.3333 0])\n\nT = mat2ds([-0.16666 0 0; -0.3333 0.2888675 0; 0.22 0.27 -30; -0.33333 0.6 30],\n    [\"12p,Times-Roman CT x\", \"12p,Times-Roman RM y\", \"12p,Symbol CB a\", \"12p,Times-Roman LB 120@.\"])\ntext!(T, offset=(away=true, shift=0.1), font=\"\", angle=\"\", justify=\"\")\n\nplot!([0 0 1.25 0 120], marker=:matang, ms=\"0.4+e\", ml=1, fill=:black, show=true)\n\nError: /undefined in nan\nOperand stack:   0   0   0\nExecution stack:   %interp_exit   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--   --nostringval--   --nostringval--   false   1   %stopped_push   1944   1   3   %oparray_pop   1943   1   3   %oparray_pop   1928   1   3   %oparray_pop   1801   1   3   %oparray_pop   --nostringval--   %errorexec_pop   .runexec2   --nostringval--   --nostringval--   --nostringval--   2   %stopped_push   --nostringval--\nDictionary stack:   --dict:758/1123(ro)(G)--   --dict:0/20(G)--   --dict:85/200(L)--   --dict:171/250(L)--\nCurrent allocation mode is local\nLast OS error: No such file or directoryCurrent file position is 29970\n\n\npsconvert [ERROR]: System call [@\"C:\\programs\\gs\\bin\\gswin64c.exe\" -q -dNOSAFER -dNOPAUSE -dBATCH -sDEVICE=bbox -DPSL_no_pagefill -dMaxBitmap=2147483647 -dUseFastColor=true \"c:\\TMP/GMTjl_j.ps\" 2&gt; \"./psconvert_19300c.bb\"] returned error 1.\n\n\n\nSomething went wrong when calling the module. GMT error number = 79\n\nStacktrace:\n  [1] error(s::String)\n    @ Base .\\error.jl:35\n  [2] gmt(::String)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmt_main.jl:166\n  [3] showfig(d::Dict{Symbol, Any}, fname_ps::String, fname_ext::String, opt_T::String, K::Bool, fname::String)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4195\n  [4] finish_PS_module_barr_last(d::Dict{Symbol, Any}, cmd::Vector{String}, fname::String, fname_ext::String, opt_extra::String, output::String, opt_T::String, K::Bool, P::Nothing)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4577\n  [5] finish_PS_module(d::Dict{Symbol, Any}, cmd::Vector{String}, opt_extra::String, K::Bool, O::Bool, finish::Bool, args::GMTdataset{Float64, 2})\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4515\n  [6] prep_and_call_finish_PS_module\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4420 [inlined]\n  [7] prep_and_call_finish_PS_module(d::Dict{Symbol, Any}, cmd::Vector{String}, opt_extra::String, K::Bool, O::Bool, finish::Bool, arg1::GMTdataset{Float64, 2}, arg2::Nothing, arg3::Nothing, arg4::Nothing)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4418\n  [8] _common_plot_xyz(cmd0::String, arg1::GMTdataset{Float64, 2}, caller::String, O::Bool, K::Bool, is3D::Bool, d::Dict{Symbol, Any})\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\psxy.jl:257\n  [9] #invokelatest#2\n    @ .\\essentials.jl:892 [inlined]\n [10] invokelatest\n    @ .\\essentials.jl:889 [inlined]\n [11] common_plot_xyz\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\psxy.jl:19 [inlined]\n [12] _plot\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\plot.jl:125 [inlined]\n [13] plot(arg1::Matrix{Float64}; first::Bool, kw::@Kwargs{marker::Symbol, ms::String, ml::Int64, fill::Symbol, show::Bool})\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\plot.jl:103\n [14] plot\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\plot.jl:101 [inlined]\n [15] #plot!#738\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\plot.jl:127 [inlined]\n [16] top-level scope\n    @ In[2]:52"
  },
  {
    "objectID": "gallery/ex28.html",
    "href": "gallery/ex28.html",
    "title": "(28) Mixing UTM and geographic data sets",
    "section": "",
    "text": "Like the [(22) World-wide seismicity of last month] case, the GMT.jl interface offers a much handier way of achieving what otherwise had to be the translation of Example 28\n\nusing GMT\nresetGMT() # hide\n\nG = gmtread(\"@Kilauea.utm.nc\");\nC = makecpt(cmap=\"copper\", range=(0,1500));\nimshow(G, cmap=C, shade=true, frame=(axes=\"WS\", annot=true),\n       coast=(shore=true, ocean=:lightblue, frame=(axes=\"EN\", annot=true, grid=true)), show=true)"
  },
  {
    "objectID": "gallery/ex26.html",
    "href": "gallery/ex26.html",
    "title": "(26) General vertical perspective projection",
    "section": "",
    "text": "Next, we present a extension to the Orthographic projection option which allows the user to specify a particular altitude (this was always at infinity before), as well as several further parameters to limit the view from the chosen vantage point. In this example we show a view of the eastern continental US from a height of 160 km. Below we add a view with a specific tilt of 55 and azimuth 210; here we have chosen a boresight twist of 45. We view the land from New York towards Washington, D.C.\nAt this point the full projection has not been properly optimized and the map annotations will need additional work. Also, note that the projection is only implemented in [coast] and [grdimage]. We hope to refine this further and extend the availability of the full projection to all of the GMT mapping programs.\n\nusing GMT\nresetGMT() # hide\n\nlat = 41.5; lon = -74;  alt = 160;  tilt = 0; azim = 0; twist = 0;  width = 0;  height = 0;\ncoast(region=:global360, proj=(name=:ortho, center=[lon, lat], parallels=[alt, azim, tilt, twist, width, height]), xshift=2.5, frame=(annot=5, grid=5), land=:lightbrown, water=:lightblue, shore=true, borders=((level=1,pen=(1,:red)), (level=2, pen=0.5)), figsize=10, yshift=12)\n\n# Now point from an altitude of 160 km with a specific tilt and azimuth and with a wider restricted\n# view and a boresight twist of 45 degrees\ntilt=55;  azim=210; twist=45; width=30; height=30;\ncoast!(proj=(name=:ortho, center=[lon, lat], parallels=[alt, azim, tilt, twist, width, height]), frame=:same, \n       land=:lightbrown, water=:lightblue, shore=true, rivers=(level=:a, pen=:blue), res=:intermediate,\n       borders=:a, figsize=12, xshift=2.5, yshift=-10, show=true)"
  },
  {
    "objectID": "gallery/ex24.html",
    "href": "gallery/ex24.html",
    "title": "(24) Data selection based on geospatial criteria",
    "section": "",
    "text": "Although we are not seismologists, we have yet another example involving seismicity. We use seismicity data for the Australia/New Zealand region to demonstrate how we can extract subsets of data using geospatial criteria. In particular, we wish to plot the epicenters given in the remote file oz_quakes_24.txt as red or green circles. Green circles should only be used for epicenters that satisfy the following three criteria:\n- They are located in the ocean and not on land\n\n- They are within 3000 km of Hobart\n\n- They are more than 1000 km away from the International Dateline\nAll remaining earthquakes should be plotted in red. Rather that doing the selection process twice we simply plot all quakes as red circles and then replot those that pass our criteria. Most of the work here is done by [gmtselect]; the rest is carried out by the usual [coast] and [plot] workhorses. Note for our purposes the Dateline is just a line along the 180 meridian.\nThe script produces the plot in Figure. Note that the horizontal distance from the dateline seems to increase as we go south; however that is just the projected distance (Mercator distortion) and not the actual distance which remains constant at 1000 km.\n\nusing GMT\nresetGMT() # hide\n\ndateline = [180 0; 180 -90];\npoint = [147.21667 -42.8 6000]\n\nR = gmtinfo(\"@oz_quakes_24.txt\", inc=10);\ncoast(region=R.text[1][3:end], land=:tan, water=:darkblue, shore=(:thin,:white),\n      area=500, frame=(axes=:WeSn, annot=20, ticks=10, grid=10), proj=:Mercator)\nplot!(\"@oz_quakes_24.txt\", marker=:circle, ms=0.07, fill=:red)\nt = gmtselect(\"@oz_quakes_24.txt\", dist2line=(line=dateline, dist=\"1000k\"), mask=\"k/s\",\n              dist2pt=(pts=point, dist=\"3000k\"), colinfo=:g, reverse=:l)\nplot!(t, marker=:circle, ms=0.07, fill=:green)\n\nplot!(point, marker=\"Ellipse-\", ml=(:thick, :white))\ntext!(mat2ds(point, \"Hobart\"), font=(14,\"Helvetica-Bold\",:white),\n      justify=:LT, offset=(0.25, 0.25))\nplot!(point, MarkerLine=(:fat, :white), marker=:plus, ms=0.4)\nplot!(dateline, pen=(:thick, :white), straight_lines=true, show=1)"
  },
  {
    "objectID": "gallery/ex22.html",
    "href": "gallery/ex22.html",
    "title": "(22) World-wide seismicity of last month",
    "section": "",
    "text": "The GMT.jl function [seismicity] allows to reproduce the original Example 22 with great simplicity. It is not exactly equal in terms of the displayed legend but it is dynamic in the sense that it always plot the last month seismicity and, oh boy, much easier to use.\n\nusing GMT\nresetGMT() # hide\n\nseismicity(title=\"World-wide earthquake activity\")"
  },
  {
    "objectID": "gallery/ex20.html",
    "href": "gallery/ex20.html",
    "title": "(20) Custom plot symbols",
    "section": "",
    "text": "One is often required to make special maps that shows the distribution of certain features but one would prefer to use a custom symbol instead of the built-in circles, squares, triangles, etc. in the GMT plotting programs [plot] and [plot3]. Here we demonstrate one approach that allows for a fair bit of flexibility in designing ones own symbols.\nBased on the hotspot locations in the remote file hotspots.txt (with a 3rd column giving the desired symbol sizes in inches) we lay down a world map and overlay red volcano symbols using our custom-built volcano symbol and [plot]. We do something similar with the bulls eye symbols. Without the fill option, however, they get the colors defined in bullseye.def.\n\nusing GMT\n\ncoast(region=:global360, xaxis=(annot=60,), yaxis=(annot=30,), title=\"Hotspot Islands and Hot Cities\",\n      land=:darkgreen, water=:lightblue, area=5000, proj=:Win, figsize=15)\nplot!(\"@hotspots.txt\", symbol=\"kvolcano\", markerline=:thinnest, fill=:red)\n\n# Overlay a few bullseyes at NY, Cairo, and Perth\ncities = [-74 40.45 1.0; 31.15 30.03 1.0; 115.49 -31.58 1.0; -56.16 -34.9 1.0]\nplot!(cities, symbol=\"k@bullseye\", show=true)"
  },
  {
    "objectID": "gallery/ex18.html",
    "href": "gallery/ex18.html",
    "title": "(18) Volumes and Spatial Selections",
    "section": "",
    "text": "To demonstrate potential usage of the programs [gmtspatial], [grdvolume] and [gmtselect] we extract a subset of the Sandwell & Smith altimetric gravity field 1 for the northern Pacific and decide to isolate all seamounts that (1) exceed 50 mGal in amplitude and (2) are within 200 km of the Pratt seamount. We do this by dumping the 50 mGal contours to disk, then use gmtspatial that returns the mean location of the points making up each closed polygon, and then pass these locations to [gmtselect], which retains only the points within 200 km of Pratt. We then mask out all the data outside this radius and use [grdvolume] to determine the combined area and (gravimetric) volumes of the chosen seamounts. Our illustration is presented in Figure 18 which also shows the automatic labeling offered by [subplot].\n\nusing GMT, Printf\n\npratt = [-142.65 56.25 400]\n\n# First generate gravity image w/ shading, label Pratt, and draw a circle\n# of radius = 200 km centered on Pratt.\ngrav_cpt = makecpt(color=:rainbow, range=(-60,60));\ngrdimage(\"@AK_gulf_grav.nc\", shade=:default, frame=(annot=2,ticks=1), proj=:merc, figsize=14, xshift=3.8, yshift=14.9)\ncoast!(region=\"@AK_gulf_grav.nc\", land=:gray, shore=:thinnest)\ncolorbar!(pos=(anchor=:BC, offset=(0,1)), xaxis=(annot=20, ticks=10), ylabel=\"mGal\")\ntext!(text_record(pratt, \"Pratt\"), font=(12,\"Helvetica-Bold\"), justify=:LB, offset=\"8p\")\nplot!(pratt, marker=\"E-\", markerline=:thinnest)\n\n# Then draw 10 mGal contours and overlay 50 mGal contour in green\ngrdcontour!(\"@AK_gulf_grav.nc\", cont=20, frame=(axes=:WSEn, annot=2, ticks=1), yshift=-12.3)\n# Save 50 mGal contours to individual files, then plot them\ngrdcontour!(\"@AK_gulf_grav.nc\", cont=10, range=(49,51), dump=\"sm_%c.txt\")\nplot!(\"sm_C.txt\", lw=:thin, lc=:green)\ncoast!(land=:gray, shore=:thinnest)\nplot!(pratt, marker=\"E-\", markerline=:thinnest)\n\n# Now determine centers of each enclosed seamount &gt; 50 mGal but only plot\n# the ones within 200 km of Pratt seamount.\n\n# First determine mean location of each closed contour and add it to the file centers.txt\ncenters = gmtspatial(\"sm_C.txt\", length=true, colinfo=:g)\n\n# Only plot the ones within 200 km\nt = gmtselect(centers, C=(pratt,\"200k\"), colinfo=:g)\nplot!(t, marker=:Circle, ms=0.2, mc=:red, MarkerLine=:thinnest)\nplot!(pratt, marker=:Triangle, ms=0.25, fill=:yellow, MarkerLine=:thinnest)\n\n# Then report the volume and area of these seamounts only\n# by masking out data outside the 200 km-radius circle\n# and then evaluate area/volume for the 50 mGal contour\n\nGmask = gmt(string(\"grdmath -R@AK_gulf_grav.nc \", pratt[1], \" \", pratt[2], \" SDIST =\"))\nGmask = grdclip(Gmask, above=(200, NaN), below=(200, 1))\nGtmp = gmt(\"grdmath @AK_gulf_grav.nc ? MUL =\", Gmask);\nav   = grdvolume(Gtmp, cont=50, unit=:k);\n\nT = mat2ds([\"Volumes: $(av.data[3]) mGal\\\\264km@+2@+\"\n    \"\"\n    @sprintf(\"Areas: %.2f km@+2@+\", av.data[2])], hdr=\"&gt; -149 52.5 14p 2.6i j\")\n\ntext!(T, paragraph=true, fill=:white, pen=:thin, offset=0.75, font=(14,\"Helvetica-Bold\"),\n      justify=:LB, clearance=0.25, show=true)"
  },
  {
    "objectID": "gallery/ex16.html",
    "href": "gallery/ex16.html",
    "title": "(16) Gridding of data, continued",
    "section": "",
    "text": "[contour] (for contouring) and [triangulate] (for gridding) use the simplest method of interpolating data: a Delaunay triangulation (see Example [(12) Optimal triangulation of data]) which forms z(x, y) as a union of planar triangular facets. One advantage of this method is that it will not extrapolate z(x, y) beyond the convex hull of the input (x, y) data. Another is that it will not estimate a z value above or below the local bounds on any triangle. A disadvantage is that the z(x, y) surface is not differentiable, but has sharp kinks at triangle edges and thus also along contours. This may not look physically reasonable, but it can be filtered later (last panel below). [surface] can be used to generate a higher-order (smooth and differentiable) interpolation of z(x, y) onto a grid, after which the grid may be illustrated ([grdcontour], [grdimage], [grdview]). [surface] will interpolate to all (x, y) points in a rectangular region, and thus will extrapolate beyond the convex hull of the data. However, this can be masked out in various ways (see Example [(15) Gridding, contouring, and masking]).\nA more serious objection is that [surface] may estimate z values outside the local range of the data (note area near x = 0.8, y = 5.3). This commonly happens when the default tension value of zero is used to create a “minimum curvature” (most smooth) interpolant. [surface] can be used with non-zero tension to partially overcome this problem. The limiting value tension = 1 should approximate the triangulation, while a value between 0 and 1 may yield a good compromise between the above two cases. A value of 0.5 is shown in the Figure More ways to grid data. A side effect of the tension is that it tends to make the contours turn near the edges of the domain so that they approach the edge from a perpendicular direction. A solution is to use surface in a larger area and then use [grdcut] to cut out the desired smaller area. Another way to achieve a compromise is to interpolate the data to a grid and then filter the grid using [grdfft] or [grdfilter]. The latter can handle grids containing “NaN” values and it can do median and mode filters as well as convolutions. Shown here is [triangulate] followed by [grdfilter]. Note that the filter has done some extrapolation beyond the convex hull of the original x, y values. The “best” smooth approximation of z(x, y) depends on the errors in the data and the physical laws obeyed by z. GMT cannot always do the “best” thing but it offers great flexibility through its combinations of tools. We illustrate all four solutions using a CPT that contains color fills, predefined patterns for interval (900,925) and NaN, an image pattern for interval (875,900), and a “skip slice” request for interval (700,725). Again, we use subplot to set up and place the four panels, and place the colorbar beneath the subplot.\n\nusing GMT\n\ngmtbegin()\n    subplot(grid=(2,2), panel_size=(8,0), region=(-0.2,6.6,-0.2,6.6), figscale=1, axes=:wesn, row_axes=(left=true, row_title=true), col_axes=:bottom, margins=0.1, title=\"Gridding of Data\")\n\n        T = gmtread(\"@Table_5_11.txt\")\n        gmtset(FONT_ANNOT_PRIMARY=\"9p\", FONT_TITLE=\"18p,Times-Roman\")\n        Graws0 = surface(T, inc=0.2, V=:q)\n        contour(T, color=\"@ex_16.cpt\", fill=true, title=\"contour (triangulate)\")\n\n        grdview(Graws0, color=\"@ex_16.cpt\", Q=:s, title=\"surface (tension = 0)\", panel=(1,2))\n\n        Graws5 = surface(T, region=:same, I=0.2, tension=0.5, V=:q)\n        grdview(Graws5, color=\"@ex_16.cpt\", Q=:s, title=\"surface (tension = 0.5)\", panel=(2,1))\n\n        Grawt = triangulate(T, region=:same, inc=0.2, V=:q)\n        Gfiltered = grdfilter(Grawt, distflag=0, F=\"c1\")\n        grdview(Gfiltered, color=\"@ex_16.cpt\", Q=:s, title=\"triangulate @~\\256@~ grdfilter\", panel=(2,2))\n\n    subplot()\n    colorbar(pos=\"JBC\", color=\"@ex_16.cpt\")\ngmtend(:show)\n\nmakecpt [WARNING]: @ex_16.cpt is a discrete CPT. You can stretch it (-T&lt;min&gt;/&lt;max&gt;) but not interpolate it (-T&lt;min&gt;/&lt;max&gt;/&lt;inc&gt;).\nmakecpt [WARNING]: Selecting the given range and ignoring the increment setting.\nmakecpt [WARNING]: @ex_16.cpt is a discrete CPT. You can stretch it (-T&lt;min&gt;/&lt;max&gt;) but not interpolate it (-T&lt;min&gt;/&lt;max&gt;/&lt;inc&gt;).\nmakecpt [WARNING]: Selecting the given range and ignoring the increment setting.\nmakecpt [WARNING]: @ex_16.cpt is a discrete CPT. You can stretch it (-T&lt;min&gt;/&lt;max&gt;) but not interpolate it (-T&lt;min&gt;/&lt;max&gt;/&lt;inc&gt;).\nmakecpt [WARNING]: Selecting the given range and ignoring the increment setting."
  },
  {
    "objectID": "gallery/ex14.html",
    "href": "gallery/ex14.html",
    "title": "(14) Gridding of data and trend surfaces",
    "section": "",
    "text": "This example shows how one goes from randomly spaced data points to an evenly sampled surface. We arrange for four panels using the [subplot] command. First we plot the distribution and values of our raw data set (same as in Example [(12) Optimal triangulation of data]). We choose an equidistant grid and run [blockmean] which preprocesses the data to avoid aliasing. The dashed lines indicate the logical blocks used by [blockmean]; all points inside a given bin will be averaged. The logical blocks are drawn from a temporary file we make on the fly within the shell script. The processed data is then gridded with the [surface] program and contoured every 25 units. A most important point here is that [blockmean], [blockmedian], or [blockmode] should always be run prior to running surface, and both of these steps must use the same grid interval. We use [grdtrend] to fit a bicubic trend surface to the gridded data, contour it as well, and sample both grid files along a diagonal transect using grdtrack. The bottom panel compares the gridded (solid line) and bicubic trend (dashed line) along the transect using [plot]\n\nusing GMT\n\nplot(\"@Table_5_11.txt\", limits=(0,7,0,7), frame=(axes=:WSNe, annot=2, ticks=1),\n     marker=:circle, ms=0.15, fill=:black, figsize=(8,8), yshift=17)\ntext!(\"@Table_5_11.txt\", offset=(0.1,0), font=6,  justify=:LM, noclip=true)\nmean_xyz = blockmean(\"@Table_5_11.txt\", region=(0,7,0,7), inc=1);\n\n# Then draw gmt blockmean cells\nbasemap!(region=(0.5,7.5,0.5,7.5), frame=(grid=1,), xshift=8.3)\nplot!(mean_xyz, limits=(0,7,0,7), frame=(axes=:eSNw, annot=2, ticks=1),\n      marker=:square, ms=0.15, fill=:black)\n# Label data values using one decimal\ntext!(mean_xyz, font=6, justify=:LM, zvalues=\"%.1f\", offset=(0.15,0),\n      fill=:white, clearance=0.03, pen=true, noclip=true)\n\n# Then gmt surface and contour the data\nGdata = surface(mean_xyz, limits=(0,7,0,7), inc=1, V=:q);\ngrdcontour!(Gdata, frame=(axes=:WSne, annot=2, ticks=1), cont=25, annot=50,\n            labels=(dist=7,), smooth=4, xshift=-8.3, yshift=-9)\nplot!(mean_xyz, marker=:square, ms=0.12, fill=:black)\n\n# Fit bicubic trend to data and compare to gridded gmt surface\nGtrend = grdtrend(Gdata, N=10, T=true);\ntrack  = project(C=(0,0), E=(7,7), G=0.1, flat_earth=true);\ngrdcontour!(Gtrend, frame=(axes=:wSne, annot=2, ticks=1), cont=25, annot=50,\n            smooth=4, labels=(line=\"CT/CB\",), xshift=8.3)\nplot!(track, pen=(:thick, :dot))\n\n# Sample along diagonal\ndata  = grdtrack(track, G=Gdata, outcols=\"2,3\", V=:q);\ntrend = grdtrack(track, G=Gtrend, outcols=\"2,3\", V=:q);\nt = gmtinfo((trend, data), inc=(0.5,25));\nplot!(data, limits=t.text[1][3:end], lw=:thick, xaxis=(axes=:WSne, annot=1),\n      yaxis=(annot=50,), figsize=(16.3,4), xshift=-8.3, yshift=-4.8)\nplot!(trend, pen=(:thinner, :dashed), show=true)"
  },
  {
    "objectID": "gallery/ex12.html",
    "href": "gallery/ex12.html",
    "title": "(12) Optimal triangulation of data",
    "section": "",
    "text": "Our next example operates on a data set of topographic readings non-uniformly distributed in the plane (Table 5.11 in Davis: Statistics and Data Analysis in Geology, J. Wiley). We use [triangulate] to perform the optimal Delaunay triangulation, then use the output to draw the resulting network. We label the node numbers as well as the node values, and call [contour] to make a contour map and image directly from the raw data. Thus, in this example we do not actually make grid files but still are able to contour and image the data. We use the CPT topo.cpt (created via [gmtinfo] and [makecpt]). The script becomes:\n\nusing GMT\n\ntable_5 = gmtread(\"@Table_5_11.txt\")    # The data used in this example\nT = gmtinfo(table_5, nearest_multiple=(dz=25, col=2))\nmakecpt(color=:jet, range=T.text[1][3:end])  # Make it also the current cmap\n\nsubplot(grid=(2,2), limits=(0,6.5,-0.2,6.5), col_axes=(bott=true,), row_axes=(left=true,),\n        figsize=8, margins=0.1, panel_size=(8,0), tite=\"Delaunay Triangulation\")\n    # First draw network and label the nodes\n    net_xy = triangulate(table_5, M=true)\n    plot(net_xy, lw=:thinner)\n    plot(table_5, marker=:circle, ms=0.3, fill=:white, MarkerLine=:thinnest)\n    text(table_5, font=6, rec_number=0)\n\n    # Then draw network and print the node values\n    plot(net_xy, lw=:thinner, panel=(1,2))\n    plot(table_5, marker=:circle, ms=0.08, fill=:black)\n    text(table_5, zvalues=true, font=6, justify=:LM, fill=:white, pen=\"\", clearance=\"1p\", offset=(\"6p\",0), noclip=true)\n\n    # Finally color the topography\n    contour(table_5, pen=:thin, mesh=(:thinnest,:dashed), labels=(dist=2.5,), panel=(2,1))\n    contour(table_5, colorize=true, panel=(2,2))\nsubplot(\"show\")"
  },
  {
    "objectID": "gallery/ex09.html",
    "href": "gallery/ex09.html",
    "title": "(9) Time-series along tracks",
    "section": "",
    "text": "A common application in many scientific disciplines involves plotting one or several time-series as as “wiggles” along tracks. Marine geophysicists often display magnetic anomalies in this manner, and seismologists use the technique when plotting individual seismic traces. In our example we will show how a set of Geosat sea surface slope profiles from the south Pacific can be plotted as “wiggles” using the [wiggle] program. We will embellish the plot with track numbers, the location of the Pacific-Antarctic Ridge, recognized fracture zones in the area, and a “wiggle” scale. The Geosat tracks are stored in the file tracks_09.txt, the ridge in ridge_09.txt, and all the fracture zones are stored in the multiple segment file fz_09.txt. The profile id is contained in the segment headers and we wish to use the last data point in each of the track segments to construct an input file for text that will label each profile with the track number. We know the profiles trend approximately N40E so we want the labels to have that same orientation (i.e., the angle with the baseline must be 50). We do this by extracting the last record from each track and select segment header as textstring when running the output through text. Note we offset the text positions in order to have a small gap between the profile and the label:\n\nusing GMT\n\nwiggle(\"@tracks_09.txt\", limits=(185,250,-68,-42), proj=:Mercator, figscale=0.27,\n       frame=(axes=:WSne, annot=10, ticks=5, fill=[240 255 240]), G=\"+red -G-blue\",\n       D=\"jBR+w500+l@~m@~rad+o0.5\", ampscale=800, pen=:thinnest, par=(:FORMAT_GEO_MAP,:dddF))\nplot!(\"@ridge_09.txt\", pen=:thicker)\nplot!(\"@fz_09.txt\", pen=\"thinner,-\")\n    \n# Take label from segment header and plot near coordinates of last record of each track\nt = gmtconvert(\"@tracks_09.txt\", E=:l)\nfor k = 1:length(t)   t[k].text = [t[k].header] end\ntext!(t, font=(8,\"Helvetica-Bold\"), angle=50, justify=:RM, header=true,\n      offset=(-0.1,-0.1), show=true)"
  },
  {
    "objectID": "gallery/ex07.html",
    "href": "gallery/ex07.html",
    "title": "(7) A simple location map",
    "section": "",
    "text": "Many scientific papers start out by showing a location map of the region of interest. This map will typically also contain certain features and labels. This example will present a location map for the equatorial Atlantic ocean, where fracture zones and mid-ocean ridge segments have been plotted. We also would like to plot earthquake locations and available isochrons. We have obtained one file, quakes_07.txt, which contains the position and magnitude of available earthquakes in the region. We choose to use magnitude/40 for the symbol-size in cm. The digital fracture zone traces (fz_07.txt) and isochrons (0 isochron as ridge_07.txt, the rest as isochron_07.txt) were digitized from available maps 1. We create the final location map with the following script:\n\nusing GMT\n\ncoast(region=(-50,0,-10,20), water=:lightblue, land=\"P300/26:FtanBdarkbrown\",\n      res=:low, shore=:thinnest, frame=(annot=10,), proj=:Mercator, figsize=18,\n      par=(:FORMAT_GEO_MAP, :dddF))\nplot!(\"@fz_07.txt\", pen=\"thinner,-\")\nscatter!(\"@quakes_07.txt\", h=1, i=\"0,1,2s0.01\", marker=:circle, fill=:red,\n         markerline=:thinnest, MarkerSize=\"3p\")\nplot!(\"@isochron_07.txt\", pen=\"thin,blue\")\nplot!(\"@ridge_07.txt\", pen=(:thicker,:orange))\nlegend!(mat2ds(\"S 0.25 c 0.2 red thinnest 0.5 ISC Earthquakes\"),\n        pos=(inside=true, anchor=:TR, width=5.0, offset=0.5),\n        box=(pen=:thick,inner=:thinner,fill=:white),\n        par=(:FONT_ANNOT_PRIMARY, \"16p,Times-Italic\"))\ntext!(mat2ds([-43 -5; -43 -8; -7 11], [\"SOUTH\", \"AMERICA\", \"AFRICA\"]),\n      font=(20,\"Helvetica-Bold\",\"white=thin\"), show=true)\n\npsxy [WARNING]: Number of input columns required [2] is less that implied by -i [3]"
  },
  {
    "objectID": "gallery/ex05.html",
    "href": "gallery/ex05.html",
    "title": "(5) A 3-D illuminated surface (in bw)",
    "section": "",
    "text": "Instead of a mesh plot we may choose to show 3-D surfaces using artificial illumination. For this example we will use grdmath to make a grid file that contains the surface given by the function , where . The illumination is obtained by passing the grid file to [grdview] and requesting that artificial shading be derived from the horizontal gradients in the direction of the artificial light source. The [makecpt] command creates a simple color scheme for a constant gray level of 128. Thus, variations in shade are entirely due to variations in gradients, or illuminations. We choose to illuminate from the SW and view the surface from SE:\nThe variations in intensity could be made more dramatic by using grdmath to scale the intensity file before running [grdview]. For very rough data sets one may improve the smoothness of the intensities by computing them first with [grdgradient] and then pass them to [grdhisteq]. The shell-script above will result in a plot like the one in Figure.\n\nusing GMT\nresetGMT() # hide\n\nGsombrero = gmt(\"grdmath -R-15/15/-15/15 -I0.3 X Y HYPOT DUP 2 MUL PI MUL 8 DIV COS EXCH NEG 10 DIV EXP MUL =\");\nC = makecpt(color=128, range=(-5,5), no_bg=true);\ngrdview(Gsombrero, limits=(-15,15,-15,15,-1,1), frame=(axes=\"SEwnZ\", annot=5),\n        zaxis=(annot=0.5,), plane=(-1, :white), surftype=:surface,\n        shade=(azim=225, norm=\"t0.75\"), figsize=12, zsize=5, view=(120,30))\ntit = mat2ds([7.5 12], \"z(r) = cos (2@~p@~r/8) @~\\\\327@~e@+-r/10@+\");\ntext!(tit, limits=(0,21,0,28), proj=:linear, view=:none,\n      font=(50,\"ZapfChancery-MediumItalic\"), justify=:CB, scale=1, show=true)"
  },
  {
    "objectID": "gallery/ex03.html",
    "href": "gallery/ex03.html",
    "title": "(3) Spectral estimation and xy-plots",
    "section": "",
    "text": "In this example we will show how to use the GMT programs [fitcircle], [project], [sample1d], [spectrum1d], and [plot]. Suppose you have (lon, lat, gravity) along a satellite track in a file called sat.xyg, and (lon, lat, gravity) along a ship track in a file called ship.xyg. You want to make a cross-spectral analysis of these data. First, you will have to get the two data sets into equidistantly sampled time-series form. To do this, it will be convenient to project these along the great circle that best fits the sat track. We must use [fitcircle] to find this great circle and choose the L2 estimates of best pole. We project the data using [project] to find out what their ranges are in the projected coordinate. The script computes the common range. We can then resample the projected data, and carry out the cross-spectral calculations, assuming that the ship is the input and the satellite is the output data. The final plot example_03.ps shows the ship and sat power in one diagram and the coherency on another diagram, both on the same page, with an auto-generated legend. Thus, the complete automated script reads:\nThe final illustration shows that the ship gravity anomalies have more power than altimetry derived gravity for short wavelengths and that the coherency between the two signals improves dramatically for wavelengths &gt; 20 km.\n\nusing GMT\n\n# First, we use \"fitcircle\" to find the parameters of a great circle\n# most closely fitting the x,y points in \"sat_03.txt\":\ncpos = fitcircle(\"@sat_03.txt\", norm=2, coordinates=:mean,  par=(IO_COL_SEPARATOR=\"/\",))\nppos = fitcircle(\"@sat_03.txt\", norm=2, coordinates=:north, par=(IO_COL_SEPARATOR=\"/\",))\n\n# Now we use \"project\" to project the data in both sat_03.txt and ship_03.txt\n# into data.pg, where g is the same and p is the oblique longitude around\n# the great circle. We use \"km\" to get the p distance in kilometers, and \"sort\"\n# to sort the output into increasing p values.\nsat_pg  = project(\"@sat_03.txt\",  origin=cpos, pole=ppos, sort=true, outvars=:pz, km=true)\nship_pg = project(\"@ship_03.txt\", origin=cpos, pole=ppos, sort=true, outvars=:pz, km=true)\n\n# Get the common extrema values rounded to 1 km\nbounds = round.([max(sat_pg.bbox[1], ship_pg.bbox[1]) min(sat_pg.bbox[2], ship_pg.bbox[2])], digits=0)\n\nsamp_x = collect(bounds[1]:bounds[2])\n# Now we can resample the gmt projected satellite data:\nsamp_sat_pg = sample1d(sat_pg, range=samp_x)\n\n# For reasons above, we use filter1d to pre-treat the ship data. We also need to sample\n# it because of the gaps &gt; 1 km we found. So we use filter1d | sample1d. We also\n# use the \"ends\" on filter1d to use the data all the way out to bounds :\nD = filter1d(ship_pg, filter=:m1, range=(bounds[1], bounds[2], 1), ends=true)\nsamp_ship_pg = sample1d(D, range=samp_x)\n\n# Now to do the cross-spectra, assuming that the ship is the input and the sat is the output\n# data, we do this:\nD = spectrum1d([samp_ship_pg[:,2] samp_sat_pg[:,2]], size=256, sample_dist=1,\n               wavelength=true, outputs=(:xpower, :ypower, :coherence))\n\n# Time to plot spectra\nsubplot(grid=(2,1), margins=\"0.3c\", col_axes=(bott=true, label=\"Wavelength (km)\"),\n        autolabel=(anchor=:TR, offset=\"8p\"), title=\"Ship and Satellite Gravity\",\n        panel_size=10, frame=(axes=\"WeSn\", bg=\"240/255/240\"))\n    gmtset(FONT_TAG=\"18p,Helvetica-Bold\",)\n\n    subplot(:set, panel=(1,1), autolabel=\"Input Power\")\n    plot(D[:Wavelength, :Xpower, :σ_Xpow], proj=:loglog, flip_axes=:x, xaxis=(annot=1, ticks=3, scale=:pow),\n         yaxis=(annot=1, ticks=3, scale=:pow, label=\"Power (mGal@+2@+km)\"), fill=\"red\", marker=:Triangle,\n         ms=\"5p\", region=(1,1000,0.1,10000), error_bars=(y=true, pen=0.5), legend=\"Ship\")\n\n    plot(D[:Wavelength, :Ypower, :σ_Ypow], fill=\"blue\", marker=:circ, ms=\"5p\",\n         error_bars=(y=true, pen=0.5), legend=\"Satellite\")\n\n    legend(pos=(anchor=\"BL\", offset=0.5), box=\"+gwhite+pthicker\", par=(FONT_ANNOT_PRIMARY=\"14p,Helvetica-Bold\",))\n    subplot(:set, panel=(2,1), autolabel=\"Coherency@+2@+\")\n\n    plot(D[:Wavelength, :Coher, :σ_Coher], region=(1,1000,0,1), proj=:logx, flip_axes=:x,\n           xaxis=(annot=1, ticks=3, scale=:pow, label=\"Wavelength (km)\"),\n           yaxis=(annot=0.25, ticks=0.05, label=\"Coherency@+2@+\"), marker=:circ, ms=\"5p\",\n           fill=:purple, error_bars=(y=true, pen=0.5))\nsubplot(:show)\n\nWarning: the following options were not consumed in spectrum1d =&gt; [:outputs]\n\n\n\nColumn name - Ypower - not found in this dataset\n\nStacktrace:\n  [1] error(s::String)\n    @ Base .\\error.jl:35\n  [2] getcolumn(D::GMTdataset{Float64, 2}, name::String)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\tables_gmt.jl:14\n  [3] getcolumn\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\tables_gmt.jl:9 [inlined]\n  [4] #11\n    @ .\\none:0 [inlined]\n  [5] iterate\n    @ .\\generator.jl:47 [inlined]\n  [6] collect_to!(dest::Vector{Vector{Float64}}, itr::Base.Generator{Tuple{Symbol, Symbol, Symbol}, GMT.var\"#11#13\"{GMTdataset{Float64, 2}}}, offs::Int64, st::Int64)\n    @ Base .\\array.jl:892\n  [7] collect_to_with_first!\n    @ .\\array.jl:870 [inlined]\n  [8] collect(itr::Base.Generator{Tuple{Symbol, Symbol, Symbol}, GMT.var\"#11#13\"{GMTdataset{Float64, 2}}})\n    @ Base .\\array.jl:844\n  [9] getindex(::GMTdataset{Float64, 2}, ::Symbol, ::Symbol, ::Symbol)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmt_types.jl:252\n [10] top-level scope\n    @ In[2]:44"
  },
  {
    "objectID": "gallery/ex01.html",
    "href": "gallery/ex01.html",
    "title": "Contour maps",
    "section": "",
    "text": "We want to create two contour maps of the low order geoid using the Hammer equal area projection. Our gridded data file is called osu91a1f_16.nc and contains a global 1 by 1 gridded geoid (we will see how to make gridded files later). We would like to show one map centered on Greenwich and one centered on the dateline. Positive contours should be drawn with a solid pen and negative contours with a dashed pen. Annotations should occur for every 50 m contour level, and both contour maps should show the continents in light brown in the background. This is how it is done:\n\nusing GMT\n\nsubplot(grid=(2,1), region=:global, autolabel=true, margins=0.5,\n        title=\"Low Order Geoid\", panel_size=(16,0), frame=\"lrtb\", proj=:Hammer, figsize=16)\n    gmtset(MAP_GRID_CROSS_SIZE_PRIMARY=0, FONT_ANNOT_PRIMARY=10, PS_CHAR_ENCODING=\"Standard+\")\n    coast(frame=\"afg\", land=:lightbrown, water=:lightblue)\n    grdcontour(\"@osu91a1f_16.nc\", cont=10, annot=(int=50,labels=(font=7,)), labels=(dist=10,),\n                range=(-1000,-1), pen=((contour=1,pen=\"thinnest,-\"), (annot=1, pen=\"thin,-\")),\n                ticks=(gap=(0.25,0.05),labels=\"\"))\n    grdcontour(\"@osu91a1f_16.nc\", cont=10, annot=(int=50,labels=(font=7,)), labels=(dist=10,),\n                range=(-1,100), ticks=(gap=(0.25,0.05),labels=\"\"))\n\n    coast(frame=\"afg\", land=:lightbrown, water=:lightblue, panel=(2,1))\n    grdcontour(\"@osu91a1f_16.nc\", cont=10, annot=(int=50,labels=(font=7,)), labels=(dist=10,),\n                range=(-1000,-1), pen=((contour=1,pen=\"thinnest,-\"), (annot=1, pen=\"thin,-\")),\n                ticks=(gap=(0.25,0.05),))\n    grdcontour(\"@osu91a1f_16.nc\", cont=10, annot=(int=50,labels=(font=7,)), labels=(dist=10,),\n                range=(-1,1000), ticks=(gap=(0.25,0.05),))\nsubplot(\"show\")\n\n\n\n\n\n\n\n\nThe first command sets up a 2 by 1 subplot layout. The subplot determines the size of what map can fit so we use? when specifying map widths in the commands below. This initial setup is followed by two sequences of [coast] [grdcontour], [grdcontour]. They differ in that the first is centered on the dateline, while the second on Greenwich. We use the range option in grdcontour to select negative contours only and plot those with a dashed pen, then positive contours only and draw with a solid pen [Default]. The ticks option causes tick marks pointing in the downhill direction to be drawn on the innermost, closed contours. For the upper panel we also added - and + to the local lows and highs. The labeling of the two plots with a) and b) is automatically done by [subplot]."
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "Explore various examples showcasing GMT.jl capabilities across different plotting types and techniques.\n\n\n\n\nFrames Layout \n\n\n\n\nPlot Examples \n\n\n\n\nProjections \n\n\n\n\nColor maps \n\n\n\n\nImages \n\n\n\n\nContours \n\n\n\n\nArrows \n\n\n\n\nLegends \n\n\n\n\nChoropleth Maps \n\n\n\n\nTernary Plots \n\n\n\n\nSubplots \n\n\n\n\nThemes \n\n\n\n\nMiscellaneous \n\n\n\n\nEmbellishments \n\n\n\n\nArt"
  },
  {
    "objectID": "documentation/imgproc/rgb2ycbcr.html",
    "href": "documentation/imgproc/rgb2ycbcr.html",
    "title": "rgb2YCbCr",
    "section": "",
    "text": "YCbCr = rgb2YCbCr(I::GMTimage{UInt8, 3}; Y=false, Cb=false, Cr=false, BT709=false)\n\nor\n\nY,Cb,Cr = rgb2YCbCr(I::GMTimage{UInt8, 3}; Y=false, Cb=false, Cr=false, BT709=false)\nConvert RGB color values to luminance (Y) and chrominance (Cb and Cr) values of a YCbCr image.\nOptionally, return only one to three of Y, Cb and Cr in separate images. For that use the keywords: Y, Cb or Cr. Each true occurence makes it return that component, otherwise it returns an empty image. The alternative rgb2ycbcr alias (all lowercase) is also accepted."
  },
  {
    "objectID": "documentation/imgproc/rgb2ycbcr.html#example",
    "href": "documentation/imgproc/rgb2ycbcr.html#example",
    "title": "rgb2YCbCr",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\n# Read an RGB image\nI = gmtread(GMT.TESTSDIR * \"assets/seis_section_rgb.jpg\");\nIycbcr = rgb2YCbCr(I);\n\n# The Cb and Cr components\n_,Cb,Cr = rgb2YCbCr(I, Cb=true, Cr=true);\n\n# Show the four.\ngrdimage(I, figsize=6)\ngrdimage!(Iycbcr, figsize=6, yshift=-2.84)\ngrdimage!(Cb, figsize=6, yshift=-2.84)\ngrdimage!(Cr, figsize=6, yshift=-2.84, show=true)"
  },
  {
    "objectID": "documentation/imgproc/rgb2ycbcr.html#source-code",
    "href": "documentation/imgproc/rgb2ycbcr.html#source-code",
    "title": "rgb2YCbCr",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/rgb2ycbcr.html#see-also",
    "href": "documentation/imgproc/rgb2ycbcr.html#see-also",
    "title": "rgb2YCbCr",
    "section": "See Also",
    "text": "See Also\nrgb2lab"
  },
  {
    "objectID": "documentation/imgproc/rgb2gray.html",
    "href": "documentation/imgproc/rgb2gray.html",
    "title": "rgb2gray",
    "section": "",
    "text": "Igray = rgb2gray(I::GMTimage{UInt8, 3}) -&gt; GMTimage{UInt8, 2}\nConvert an RGB image to a grayscale image applying the television YMQ transformation."
  },
  {
    "objectID": "documentation/imgproc/rgb2gray.html#example",
    "href": "documentation/imgproc/rgb2gray.html#example",
    "title": "rgb2gray",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\nI = gmtread(GMT.TESTSDIR * \"assets/bunny_cenora.jpg\");\nIgray = rgb2gray(I)\n\n# Show the two side-by-side\ngrdimage(I, figsize=6)\ngrdimage!(Igray, figsize=6, xshift=6.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/rgb2gray.html#source-code",
    "href": "documentation/imgproc/rgb2gray.html#source-code",
    "title": "rgb2gray",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/isodata.html",
    "href": "documentation/imgproc/isodata.html",
    "title": "isodata",
    "section": "",
    "text": "level = isodata(I::GMTimage; band=1) -&gt; Int\nCompute global image threshold using iterative isodata method.\nIt can be used to convert an intensity image to a binary image with binarize. level is a normalized intensity value that lies in the range [0 255]. This iterative technique for choosing a threshold was developed by Ridler and Calvard. The histogram is initially segmented into two parts using a starting threshold value such as 0 = 2B-1, half the maximum dynamic range. The sample mean (mf,0) of the gray values associated with the foreground pixels and the sample mean (mb,0) of the gray values associated with the background pixels are computed. A new threshold value 1 is now computed as the average of these two sample means. The process is repeated, based upon the new threshold, until the threshold value does not change any more.\nOriginaly from MATLAB http://www.mathworks.com/matlabcentral/fileexchange/3195 (BSD, Licenced)"
  },
  {
    "objectID": "documentation/imgproc/isodata.html#example",
    "href": "documentation/imgproc/isodata.html#example",
    "title": "isodata",
    "section": "Example",
    "text": "Example\nI = gmtread(GMT.TESTSDIR * \"assets/coins.jpg\");\nlevel = isodata(I, band=1)\n119"
  },
  {
    "objectID": "documentation/imgproc/isodata.html#source-code",
    "href": "documentation/imgproc/isodata.html#source-code",
    "title": "isodata",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imsobel.html",
    "href": "documentation/imgproc/imsobel.html",
    "title": "imsobel",
    "section": "",
    "text": "J = imsobel(I::GMTimage{&lt;:UInt8, 2}; direction::Int=2)::GMTimage\nSobel edge detecting filter.\nReturns a binary GMTimage containing 1s where the function finds edges in the grayscale or binary image I and 0s elsewhere."
  },
  {
    "objectID": "documentation/imgproc/imsobel.html#example",
    "href": "documentation/imgproc/imsobel.html#example",
    "title": "imsobel",
    "section": "Example",
    "text": "Example\nLet us vectorize the rice grains in the image “rice.png”. The result is not perfect because the grains in the image’s edge are not closed and therefore not filled. And those get poligonized twice (in and outside) making the red lines look thicker (but they are not, they are just doubled).\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/rice.png\");\nJ = imsobel(I);\nBW = binarize(J);\nBW = bwskell(BW);   # Skeletize to get a better approximation of the shapes.\nBW = imfill(BW);    # Fill to avoid \"double\" vectorization (outside and inside grain outline)\nD = polygonize(BW);\ngrdimage(I, figsize=5)\ngrdimage!(J, figsize=5, xshift=5.05)\ngrdimage!(BW, figsize=5, xshift=-5.05, yshift=-5.05)\ngrdimage!(I, figsize=5, xshift=5.05, plot=(data=D, lc=:red), show=true)"
  },
  {
    "objectID": "documentation/imgproc/imsobel.html#source-code",
    "href": "documentation/imgproc/imsobel.html#source-code",
    "title": "imsobel",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imsobel.html#see-also",
    "href": "documentation/imgproc/imsobel.html#see-also",
    "title": "imsobel",
    "section": "See Also",
    "text": "See Also\nimfill, bwskell, imerode, imfilter"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html",
    "href": "documentation/imgproc/imregionalmin.html",
    "title": "imregionalmin",
    "section": "",
    "text": "Regional minima"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#description",
    "href": "documentation/imgproc/imregionalmin.html#description",
    "title": "imregionalmin",
    "section": "Description",
    "text": "Description\nBW = imregionalmin(I)\nReturns the binary image BW that identifies the regional minima in the 2-D grayscale image I. Regional minima are connected components of pixels with a constant intensity value, surrounded by pixels with a higher value.\nBW = imregionalmin(I, conn)\nComputes the regional minima using the specified connectivity conn."
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#input-arguments",
    "href": "documentation/imgproc/imregionalmin.html#input-arguments",
    "title": "imregionalmin",
    "section": "Input Arguments",
    "text": "Input Arguments\n\nI — GMTgrid|image or Matrix\nGrayscale 2-D image, specified as a numeric matrix.\nData Types: UInt8 and Floating point types. In this later case an UInt8 representation is used internally.\n\n\nconn — Pixel connectivity\nPixel connectivity, specified as one of the values in this table. The default connectivity is 8 for 2-D images.\n\nTwo-Dimensional Connectivities\n\n\n\n\n\n\n\nValue\nMeaning\n\n\n\n\n4\nPixels are connected if their edges touch. The neighborhood of a pixel are the adjacent pixels in the horizontal or vertical direction.\n\n\n8\nPixels are connected if their edges or corners touch. The neighborhood of a pixel are the adjacent pixels in the horizontal, vertical, or diagonal direction.\n\n\n\nConnectivity can also be defined by specifying a 3-by-3 matrix of 0s and 1s. The 1-valued elements define neighborhood locations relative to the center element of conn. Note that conn must be symmetric about its center element.\nData Types: Int, or array of Bool"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#output-arguments",
    "href": "documentation/imgproc/imregionalmin.html#output-arguments",
    "title": "imregionalmin",
    "section": "Output Arguments",
    "text": "Output Arguments\n\nBW — GMTimage with locations of regional minima\nLocations of regional minima, returned as a logical array of the same size as I. Pixels with the value true (or 1) indicate regional minima; all other pixels are set to false (or 0).\nData Types: Bool"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#examples",
    "href": "documentation/imgproc/imregionalmin.html#examples",
    "title": "imregionalmin",
    "section": "Examples",
    "text": "Examples\n\nFind Regional Minima in Simple Array\nCreate a simple sample array with several regional minima:\nA = 10 * ones(10, 10)\nA[2:4, 2:4] .= 3\nA[6:8, 6:8] .= 8\nOutput:\n10×10 Matrix{Float64}:\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0   3.0   3.0   3.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0   3.0   3.0   3.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0   3.0   3.0   3.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0   8.0   8.0   8.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0   8.0   8.0   8.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0   8.0   8.0   8.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\nCalculate the regional minima. The function returns a binary image, the same size as the input image, in which pixels with the value true (or 1) represent the regional minima. imregionalmin sets all other pixels to false (or 0):\nregmin = imregionalmin(A)\nOutput:\n10×10 BitMatrix:\n 0  0  0  0  0  0  0  0  0  0\n 0  1  1  1  0  0  0  0  0  0\n 0  1  1  1  0  0  0  0  0  0\n 0  1  1  1  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  1  1  1  0  0\n 0  0  0  0  0  1  1  1  0  0\n 0  0  0  0  0  1  1  1  0  0\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0\n\n\nFind Regional Minima in Grayscale Image\nLoad a grayscale image:\nI = gmtread(\"coins.png\")\nimshow(I)\nFind the regional minima:\nBW = imregionalmin(I)\nimshow(BW)\nOverlay the regional minima on the original image:\n# Create an overlay showing minima in red\nimshow(I)\n# Mark regional minima\noverlay!(BW, color=:red)\n\n\nCompare Different Connectivity Settings\nCreate a test image with a saddle point:\n# Create an image with a valley structure\nI = zeros(15, 15)\nI[8, :] .= 5  # Horizontal ridge\nI[:, 8] .= 5  # Vertical ridge\nI[8, 8] = 3   # Saddle point\nCompute regional minima with different connectivity:\n# 4-connectivity (edges only)\nBW4 = imregionalmin(I, 4)\n\n# 8-connectivity (edges and corners)\nBW8 = imregionalmin(I, 8)\n\n# Display results\nsubplot(1, 3, 1)\nimshow(I)\ntitle!(\"Original Image\")\n\nsubplot(1, 3, 2)\nimshow(BW4)\ntitle!(\"4-Connectivity\")\n\nsubplot(1, 3, 3)\nimshow(BW8)\ntitle!(\"8-Connectivity\")\n\nshowfig()\n\n\nDetect Valleys in Elevation Data\n(These are Claude.ai dreams but maybe worth including)\nUse regional minima to find valleys in a digital elevation model:\n# Load elevation data\nDEM = gmtread(\"elevation.tif\")\n\n# Find regional minima (valleys, depressions)\nvalleys = imregionalmin(DEM)\n\n# Remove small spurious minima\nvalleys_clean = bwareaopen(valleys, 50)\n\n# Overlay valleys on elevation map\nimshow(DEM, cmap=:terrain)\noverlay!(valleys_clean, color=:blue, alpha=0.7)\ncolorbar!()\ntitle!(\"Valleys in Elevation Data\")\n\n\nPre-process Image with H-Minima Transform\nSuppress shallow minima before finding regional minima:\n# Load image\nI = gmtread(\"rice.png\")\n\n# Original regional minima (many spurious minima)\nminima_orig = imregionalmin(I)\n\n# Apply H-minima transform to suppress shallow minima\nI_hmin = imhmin(I, 10)\n\n# Find regional minima after suppression\nminima_filtered = imregionalmin(I_hmin)\n\n# Compare results\nsubplot(1, 3, 1)\nimshow(I)\ntitle!(\"Original\")\n\nsubplot(1, 3, 2)\nimshow(minima_orig)\ntitle!(\"Original Minima ($(sum(minima_orig)) regions)\")\n\nsubplot(1, 3, 3)\nimshow(minima_filtered)\ntitle!(\"Filtered Minima ($(sum(minima_filtered)) regions)\")\n\nshowfig()"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#notes",
    "href": "documentation/imgproc/imregionalmin.html#notes",
    "title": "imregionalmin",
    "section": "Notes",
    "text": "Notes\n\nRegional Minima vs. Local Minima: A regional minimum is a connected component of pixels with constant intensity, all of whose neighbors have a strictly greater value. This is different from a local minimum, which is a single pixel whose value is less than or equal to all its neighbors.\n\n\nFlat Regions: If an image contains large flat regions at the minimum intensity level, the entire flat region will be marked as a regional minimum.\n\n\nConnectivity Impact: Higher connectivity values (e.g., 8 vs 4 in 2-D) can merge what would be separate regional minima under lower connectivity, reducing the total number of detected minima.\n\n\nNoise Sensitivity: imregionalmin can be sensitive to noise and may detect many spurious minima. Consider preprocessing with imhmin (h-minima transform) or post-processing with bwareaopen to remove small or shallow minima."
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#tips",
    "href": "documentation/imgproc/imregionalmin.html#tips",
    "title": "imregionalmin",
    "section": "Tips",
    "text": "Tips\n\nUse imhmin to suppress shallow regional minima before detection\nApply bwareaopen to remove small spurious regional minima\nCombine with watershed for marker-based image segmentation\nFor elevation data, regional minima identify valleys, sinks, and depressions\nUse imimposemin to force specific minima before watershed segmentation\nThe complement operation can be used to find regional maxima: imregionalmin(-I) or use imregionalmax(I)"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#source-code",
    "href": "documentation/imgproc/imregionalmin.html#source-code",
    "title": "imregionalmin",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimregionalmin(G::Union{GMTgrid, Matrix{&lt;:AbstractFloat}}; maxmin) - lepto_funs.jl:1095\nimregionalmin(I; maxmin) - lepto_funs.jl:1100"
  },
  {
    "objectID": "documentation/imgproc/imregionalmin.html#see-also",
    "href": "documentation/imgproc/imregionalmin.html#see-also",
    "title": "imregionalmin",
    "section": "See Also",
    "text": "See Also\nimregionalmax, imhmin, [watershed], imreconstruct, bwareaopen"
  },
  {
    "objectID": "documentation/imgproc/imreconstruct.html",
    "href": "documentation/imgproc/imreconstruct.html",
    "title": "imreconstruct",
    "section": "",
    "text": "I = imreconstruct(marker::Union{Matrix{Bool}, Matrix{UInt8}}, Imask::GMTimage{&lt;:UInt8, 2}; conn=4, insitu=true)\nPerform morphological reconstruction of the image marker under the image mask.\nThe elements of marker must be less than or equal to the corresponding elements of mask. If the values in marker are greater than corresponding elements in mask, then imreconstruct clips the values to the mask level before starting the procedure. The worphological work is done by the Leptonica function pixSeedfillGray."
  },
  {
    "objectID": "documentation/imgproc/imreconstruct.html#example",
    "href": "documentation/imgproc/imreconstruct.html#example",
    "title": "imreconstruct",
    "section": "Example",
    "text": "Example\nUse reconstruction to segment an image.\n\nusing GMT\n\ntext([\"Hello World\"], region=(1.92,2.08,1.97,2.02), x=2.0, y=2.0,\n     font=(30, \"Helvetica-Bold\", :white),\n     frame=(axes=:none, bg=:black), figsize=(6,0), name=\"tmp.png\")\n\n# Read only one band (althouh gray scale, the \"tmp.png\" is actually RGB)\nI = gmtread(\"tmp.png\", band=1);\n\n# Create a marker image that identifies the object in the image you want to extract through segmentation.\n# For this example, identify the \"W\" in the word \"World\".\nmarker = fill(UInt8(0),(size(I)));\nmarker[390,130] = UInt8(255);\n\n# Perform segmentation of the mask image using the marker image.\nIr = imreconstruct(marker, I);\ngrdimage(I, figsize=8)\ngrdimage!(Ir, figsize=8, yshift=-2.57, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imreconstruct.html#source-code",
    "href": "documentation/imgproc/imreconstruct.html#source-code",
    "title": "imreconstruct",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimreconstruct(seed::Union{Matrix{Bool}, Matrix{UInt8}}, mask::Union{Matrix{Bool}, Matrix{UInt8}}; conn, layout, insitu, is_transposed) - lepto_funs.jl:254\nimreconstruct(Iseed::GMTimage{&lt;:Integer, 2}, Imask::Union{GMTimage{&lt;:Integer, 2}, Matrix{&lt;:Integer}}; conn, insitu) - lepto_funs.jl:245\nimreconstruct(seed::Union{Matrix{Bool}, Matrix{UInt8}}, Imask::GMTimage{&lt;:UInt8, 2}; conn, insitu) - lepto_funs.jl:240\nimreconstruct(marker::AbstractArray{T, N}, mask::AbstractArray{&lt;:Real, N}; conn) where {T, N} - graydist.jl:162"
  },
  {
    "objectID": "documentation/imgproc/imreconstruct.html#see-also",
    "href": "documentation/imgproc/imreconstruct.html#see-also",
    "title": "imreconstruct",
    "section": "See Also",
    "text": "See Also\nfillsinks, imfill"
  },
  {
    "objectID": "documentation/imgproc/imopen.html",
    "href": "documentation/imgproc/imopen.html",
    "title": "imopen",
    "section": "",
    "text": "J = imopen(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3, sel=nothing)::GMTimage\nOpen the grayscale or binary image I.\nThe morphological opening operation is an erosion followed by a dilation, using the same structuring element for both operations. The opening is performed with a matrix of 0’s and 1’s with width hsize and height vsize, or, if possible, with the structuring element strel. Later case is faster but it is only available for binary images, where by binary images we mean Boolean images or images with only 0’s and 1’s of UInt8 type."
  },
  {
    "objectID": "documentation/imgproc/imopen.html#example",
    "href": "documentation/imgproc/imopen.html#example",
    "title": "imopen",
    "section": "Example",
    "text": "Example\nIllustration of opening with a structuring box of width 20\nI = gmtread(TESTSDIR * \"assets/packman.png\");\nJ = imopen(I, sel=strel(\"box\", 20));\ngrdimage(I, figsize=7)\ngrdimage!(J, figsize=7, xshift=7.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imopen.html#source-code",
    "href": "documentation/imgproc/imopen.html#source-code",
    "title": "imopen",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimopen(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize, vsize, sel) - lepto_funs.jl:564\nimopen(G::GMTgrid{&lt;:AbstractFloat, 2}; hsize, vsize, sel) - lepto_funs.jl:562\n\n\nSee Also\nimdilate, imerode, imclose, strel"
  },
  {
    "objectID": "documentation/imgproc/imhmin.html",
    "href": "documentation/imgproc/imhmin.html",
    "title": "imhmin",
    "section": "",
    "text": "J = imhmin(I::GMTimage{&lt;:UInt8, 2}, H; conn=4)::GMTimage\nSuppress regional minima in image using H-minima transform.\nThe H-minima transform decreases the depth of all regional minima by an amount up to H. As a result, the transform fully suppresses regional minima whose depth is less than H. Regional minima are connected pixels with the same intensity value, t, that are surrounded by pixels with an intensity value greater than t."
  },
  {
    "objectID": "documentation/imgproc/imhmin.html#example",
    "href": "documentation/imgproc/imhmin.html#example",
    "title": "imhmin",
    "section": "Example",
    "text": "Example\nThe result will look like the outline of the object.\n\nusing GMT\n\na = fill(UInt8(10),10,10);\na[2:4,2:4] .= 7;  \na[6:8,6:8] .= 2;\na[1:3,7:9] .= 13;\na[2,8] = 10;\nI = imhmin(mat2img(a), 4);"
  },
  {
    "objectID": "documentation/imgproc/imhmin.html#source-code",
    "href": "documentation/imgproc/imhmin.html#source-code",
    "title": "imhmin",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imhmin.html#see-also",
    "href": "documentation/imgproc/imhmin.html#see-also",
    "title": "imhmin",
    "section": "See Also",
    "text": "See Also\nimhdome, imhmax"
  },
  {
    "objectID": "documentation/imgproc/imhdome.html",
    "href": "documentation/imgproc/imhdome.html",
    "title": "imhdome",
    "section": "",
    "text": "J = imhdome(I::GMTimage{&lt;:UInt8, 2}, H; conn=4)::GMTimage\nSuppress regional minima in image using H-minima transform.\nThe H-minima transform decreases the depth of all regional minima by an amount up to H. As a result, the transform fully suppresses regional minima whose depth is less than H. Regional minima are connected pixels with the same intensity value, t, that are surrounded by pixels with an intensity value greater than t."
  },
  {
    "objectID": "documentation/imgproc/imhdome.html#source-code",
    "href": "documentation/imgproc/imhdome.html#source-code",
    "title": "imhdome",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imhdome.html#see-also",
    "href": "documentation/imgproc/imhdome.html#see-also",
    "title": "imhdome",
    "section": "See Also",
    "text": "See Also\nimhmax, imhmin"
  },
  {
    "objectID": "documentation/imgproc/imfill.html",
    "href": "documentation/imgproc/imfill.html",
    "title": "imfill",
    "section": "",
    "text": "I2 = imfill(I; conn=4, is_transposed=true, layout=\"TRBa\")\nFill holes in the grayscale GMTimage I or UInt8 matrix I.\nHere, a hole is defined as an area of dark pixels surrounded by lighter pixels."
  },
  {
    "objectID": "documentation/imgproc/imfill.html#examples",
    "href": "documentation/imgproc/imfill.html#examples",
    "title": "imfill",
    "section": "Examples",
    "text": "Examples\nExample from Matlab imfill.\n\nusing GMT\n\nI = gdalread(TESTSDIR * \"assets/coins.jpg\");\nIbw1 = binarize(I);\nIbw2 = imfill(Ibw1);\ngrdimage(I, figsize=5)\ngrdimage!(Ibw1, figsize=5, xshift=5.1)\ngrdimage!(Ibw2, figsize=5, xshift=5.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imfill.html#source-code",
    "href": "documentation/imgproc/imfill.html#source-code",
    "title": "imfill",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimfill(mat::BitMatrix; conn, is_transposed, layout) - lepto_funs.jl:316\nimfill(G::GMTgrid; conn) - lepto_funs.jl:322\nimfill(I::GMTimage; conn) - lepto_funs.jl:313\nimfill(mat::Matrix{&lt;:Integer}; conn, is_transposed, layout) - lepto_funs.jl:300"
  },
  {
    "objectID": "documentation/imgproc/imfill.html#see-also",
    "href": "documentation/imgproc/imfill.html#see-also",
    "title": "imfill",
    "section": "See Also",
    "text": "See Also\nfillsinks, binarize"
  },
  {
    "objectID": "documentation/imgproc/imdilate.html",
    "href": "documentation/imgproc/imdilate.html",
    "title": "imdilate",
    "section": "",
    "text": "J = imdilate(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3, sel=nothing)::GMTimage\nDilate the grayscale or binary image I.\nThe dilation is performed with a matrix of 0’s and 1’s with width hsize and height vsize, or, if possible, with the structuring element strel. Later case is faster but it is only available for binary images, where by binary images we mean Boolean images or images with only 0’s and 1’s of UInt8 type."
  },
  {
    "objectID": "documentation/imgproc/imdilate.html#examples",
    "href": "documentation/imgproc/imdilate.html#examples",
    "title": "imdilate",
    "section": "Examples",
    "text": "Examples\nDilation with a square of width 3 (the default when neither sel, nor hsize or vsize are specified)\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/fig_text_bw.png\");\nJ = imdilate(I);\ngrdimage(I, figsize=7)\ngrdimage!(J, figsize=7, xshift=7.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imdilate.html#source-code",
    "href": "documentation/imgproc/imdilate.html#source-code",
    "title": "imdilate",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimdilate(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize, vsize, sel) - lepto_funs.jl:523\nimdilate(G::AbstractMatrix{T}, sel::Matrix{&lt;:Real}) where T&lt;:Union{AbstractFloat, Integer} - lepto_funs.jl:521\nimdilate(G::AbstractMatrix{T}; hsize, vsize, sel) where T&lt;:Union{AbstractFloat, Integer} - lepto_funs.jl:517"
  },
  {
    "objectID": "documentation/imgproc/imdilate.html#see-also",
    "href": "documentation/imgproc/imdilate.html#see-also",
    "title": "imdilate",
    "section": "See Also",
    "text": "See Also\nimerode, imopen, imclose, strel"
  },
  {
    "objectID": "documentation/imgproc/imclose.html",
    "href": "documentation/imgproc/imclose.html",
    "title": "imclose",
    "section": "",
    "text": "J = imclose(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3, sel=nothing)::GMTimage\nClose the grayscale or binary image I.\nThe morphological close operation is a dilation followed by an erosion, using the same structuring element for both operations. The closing is performed with a matrix of 0’s and 1’s with width hsize and height vsize, or, if possible, with the structuring element strel. Later case is faster but it is only available for binary images, where by binary images we mean Boolean images or images with only 0’s and 1’s of UInt8 type."
  },
  {
    "objectID": "documentation/imgproc/imclose.html#example",
    "href": "documentation/imgproc/imclose.html#example",
    "title": "imclose",
    "section": "Example",
    "text": "Example\nIllustration of closing with a structuring box of width 20\nI = gmtread(TESTSDIR * \"assets/packman.png\");\nJ = imclose(I, sel=strel(\"box\", 20));\ngrdimage(I, figsize=7)\ngrdimage!(J, figsize=7, xshift=7.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imclose.html#source-code",
    "href": "documentation/imgproc/imclose.html#source-code",
    "title": "imclose",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimclose(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize, vsize, sel) - lepto_funs.jl:605\nimclose(G::GMTgrid{&lt;:AbstractFloat, 2}; hsize, vsize, sel) - lepto_funs.jl:603\n\n\nSee Also\nimdilate, imerode, imopen, strel"
  },
  {
    "objectID": "documentation/imgproc/graydist.html",
    "href": "documentation/imgproc/graydist.html",
    "title": "graydist",
    "section": "",
    "text": "Gray-weighted distance transform of grayscale image"
  },
  {
    "objectID": "documentation/imgproc/graydist.html#description",
    "href": "documentation/imgproc/graydist.html#description",
    "title": "graydist",
    "section": "Description",
    "text": "Description\nT = graydist(I, mask)\nComputes the gray-weighted distance transform of the grayscale image I. Locations where mask is true are seed locations.\nT = graydist(I, C, R)\nUses vectors C and R to specify the column and row coordinates of seed locations.\nT = graydist(I, ind)\nSpecifies the linear indices of seed locations using the vector ind.\nT = graydist(I, ___, method)\nSpecifies an alternate distance metric. The method determines the chamfer weights that are assigned to the local neighborhood during outward propagation. Each pixel’s contribution to the geodesic time is based on the chamfer weight in a particular direction multiplied by the pixel intensity."
  },
  {
    "objectID": "documentation/imgproc/graydist.html#input-arguments",
    "href": "documentation/imgproc/graydist.html#input-arguments",
    "title": "graydist",
    "section": "Input Arguments",
    "text": "Input Arguments\n\nI — GMTimage/GMTgrid or Matrix grayscale image\nGrayscale image, specified as a numeric or logical array. Can be of any numeric type and must be nonsparse.\nData Types: Float64, Float32, Int, UInt8, Bool\n\n\nmask — Binary mask that specifies seed locations\nBinary mask that specifies seed locations, specified as a logical array the same size as I. Locations where mask is true are treated as seed locations.\nData Types: Bool\n\n\nC, R — Column and row coordinates of seed locations\nColumn and row coordinates of seed locations, specified as vectors of positive integers. Coordinate values must be valid subscripts in I.\nData Types: Vector{Int}\n\n\nind — Linear indices of seed locations\nLinear indices of seed locations, specified as a vector of CartesianIndex or integer values that represent valid linear indices in I.\nData Types: Vector{Int} or Vector{CartesianIndex}\n\n\nmethod — Distance metric\nDistance metric, specified as one of the following values:\n\n\n\nValue\nDescription\n\n\n\n\n\"cityblock\"\nCity block distance (4-connected neighborhood)\n\n\n\"chessboard\"\nChessboard distance (8-connected neighborhood)\n\n\n\"quasi-euclidean\"\nQuasi-Euclidean distance (default)\n\n\n\nThe method determines the chamfer weights assigned to the local neighborhood during outward propagation."
  },
  {
    "objectID": "documentation/imgproc/graydist.html#output-arguments",
    "href": "documentation/imgproc/graydist.html#output-arguments",
    "title": "graydist",
    "section": "Output Arguments",
    "text": "Output Arguments\n\nT — Gray-weighted distance transform\nGray-weighted distance transform, returned as an array of the same size as I. Each element represents the gray-weighted geodesic distance from the corresponding pixel to the nearest seed location.\nIf the input numeric type of I is Float64, the output T is Float64. For any other numeric input type, the output T is Float32.\nData Types: Float64, Float32"
  },
  {
    "objectID": "documentation/imgproc/graydist.html#algorithm",
    "href": "documentation/imgproc/graydist.html#algorithm",
    "title": "graydist",
    "section": "Algorithm",
    "text": "Algorithm\ngraydist uses the geodesic time algorithm [1]. The basic equation for geodesic time along a path is:\nτ_f(P) = f(p_0)/2 + f(p_l)/2 + Σ(i=1 to l-1) f(p_i)\nwhere: - τ_f(P) is the geodesic time along path P - f(p_i) is the intensity value at point p_i - The path P consists of points p_0, p_1, ..., p_l\nThe method parameter determines the chamfer weights assigned to the local neighborhood during outward propagation. Each pixel’s contribution to the geodesic time is based on: - The chamfer weight in a particular direction - Multiplied by the pixel intensity\nThis approach finds minimum-cost paths through the image where the cost is weighted by pixel intensities."
  },
  {
    "objectID": "documentation/imgproc/graydist.html#examples",
    "href": "documentation/imgproc/graydist.html#examples",
    "title": "graydist",
    "section": "Examples",
    "text": "Examples\n\nCompute Minimum Path Through Magic Square\nCreate a magic square. Matrices generated by the magic function have equal row, column, and diagonal sums. The minimum path between the upper-left and lower-right corner is along the diagonal:\nA = magic(3)\nOutput:\n3×3 Matrix{Int64}:\n 8  1  6\n 3  5  7\n 4  9  2\nCalculate the gray-weighted distance transform, specifying the upper left corner and the lower right corner of the square as seed locations:\nT1 = graydist(A, 1, 1)\nT2 = graydist(A, 3, 3)\nOutput for T1:\n3×3 Matrix{Float64}:\n 0.0   4.5   8.0\n 5.5   6.5   8.5\n 9.0  11.5  10.0\nSum the two transforms to find the minimum path between the seed locations. As expected, there is a constant-value minimum path along the diagonal:\nT = T1 + T2\nOutput:\n3×3 Matrix{Float64}:\n 13.0  14.5  18.0\n 15.5  13.0  15.5\n 18.0  14.5  13.0\n\n\nFind Least-Cost Path in Terrain\nThis example demonstrates finding a path through steep terrain that minimizes the cumulative gradient:\n# Load a DEM (Digital Elevation Model)\nDEM = gmtread(\"terrain.tif\")\nimshow(DEM)\n\n# Calculate gradient as weights for distance calculation\nG = gradient(DEM)\n\n# Define start and end points\nstart_mask = falses(size(DEM))\nstart_mask[100, 100] = true\nend_mask = falses(size(DEM))\nend_mask[500, 500] = true\n\n# Compute gray-weighted distance from both points\nT1 = graydist(G, start_mask)\nT2 = graydist(G, end_mask)\n\n# Find minimum path\nT_total = T1 + T2\n\n\nUsing Column and Row Coordinates\nSpecify seed locations using coordinate vectors:\n# Load grayscale image\nI = gmtread(\"sample.png\")\n\n# Define multiple seed points\nC = [10, 50, 100]  # Column coordinates\nR = [20, 60, 120]  # Row coordinates\n\n# Compute distance transform\nT = graydist(I, C, R)\nimshow(T)\n\n\nUsing Linear Indices\nSpecify seed locations using linear indices:\nI = gmtread(\"sample.png\")\n\n# Find dark pixels as seed locations\ndark_pixels = findall(I .&lt; 50)\nind = [CartesianIndex(p) for p in dark_pixels]\n\n# Compute distance transform from dark regions\nT = graydist(I, ind)"
  },
  {
    "objectID": "documentation/imgproc/graydist.html#references",
    "href": "documentation/imgproc/graydist.html#references",
    "title": "graydist",
    "section": "References",
    "text": "References\n[1] Soille, P. “Generalized geodesy via geodesic time.” Pattern Recognition Letters. Vol. 15, December 1994, pp. 1235–1240."
  },
  {
    "objectID": "documentation/imgproc/graydist.html#tips",
    "href": "documentation/imgproc/graydist.html#tips",
    "title": "graydist",
    "section": "Tips",
    "text": "Tips\n\nUse graydist to find least-cost paths through images where pixel values represent costs (e.g., elevation gradients, edge strengths)\nFor routing through flat areas or topographic depressions in digital elevation models\nTo create distance transforms that account for the underlying image structure\nCombine distance transforms from multiple seed points to find optimal paths between locations"
  },
  {
    "objectID": "documentation/imgproc/graydist.html#source-code",
    "href": "documentation/imgproc/graydist.html#source-code",
    "title": "graydist",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngraydist(I::AbstractMatrix{T}, mask::AbstractMatrix{Bool}, method) where T - graydist.jl:31\ngraydist(I::AbstractMatrix{T}, mask::AbstractMatrix{Bool}) where T - graydist.jl:31\ngraydist(I::AbstractMatrix, i::Integer, j::Integer, method) - graydist.jl:8\ngraydist(I::AbstractMatrix, i::Integer, j::Integer) - graydist.jl:8\ngraydist(I::AbstractMatrix, ind::Union{Int64, Vector{Int64}}, method) - graydist.jl:3\ngraydist(I::AbstractMatrix, ind::Union{Int64, Vector{Int64}}) - graydist.jl:3"
  },
  {
    "objectID": "documentation/imgproc/graydist.html#see-also",
    "href": "documentation/imgproc/graydist.html#see-also",
    "title": "graydist",
    "section": "See Also",
    "text": "See Also\nbwdist, [watershed]"
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html",
    "href": "documentation/imgproc/cc2bw.html",
    "title": "cc2bw",
    "section": "",
    "text": "Convert connected components to binary image"
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html#description",
    "href": "documentation/imgproc/cc2bw.html#description",
    "title": "cc2bw",
    "section": "Description",
    "text": "Description\nBW = cc2bw(CC)\nConverts a connected components structure CC returned by bwconncomp into a binary image BW.\nBW = cc2bw(CC, obj2keep=indices)\nCreates a binary image containing only the connected components specified by indices."
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html#input-arguments",
    "href": "documentation/imgproc/cc2bw.html#input-arguments",
    "title": "cc2bw",
    "section": "Input Arguments",
    "text": "Input Arguments\n\nCC — Connected components (objects)\nConnected components, specified as a structure with the following fields:\n\n\n\nField\nDescription\n\n\n\n\nconnectivity\nConnectivity of the connected components\n\n\nimage_size\nSize of the binary image\n\n\nnum_objects\nNumber of connected components in the binary image\n\n\nrange\nRange of the image coordinates\n\n\ninc\nImage’s increment (!= 1 whem image is referenced)\n\n\nregistration\nRegistration of the image\n\n\nx\nX coordinates of the image\n\n\ny\nY coordinates of the image\n\n\nlayout\nMemory layout of the image\n\n\nproj4\nProjection definition (optional)\n\n\nwkt\nWell-known text definition (optional)\n\n\nepsg\nEPSG code of the image\n\n\nbbox\nThe bounding boxes as a vector of GMTdataset\n\n\npixel_list\nVector where each element contains the linear indices of the pixels in each object\n\n\ncentroid\nA Float64 Matrix with the x,y coordinates of the centroids for each component\n\n\narea\nA vector of Float64 with the areas of each component\n\n\n\n\n\nobj2keep — Objects to keep\nObjects to keep, specified as one of these values:\n\nPositive integer or vector of positive integers — Keep the object or objects whose index is included in obj2keep. The length of obj2keep is less than or equal to CC.num_objects.\nLogical vector — Keep the objects whose corresponding element in obj2keep is true. The length of obj2keep must be equal to CC.num_objects."
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html#output-arguments",
    "href": "documentation/imgproc/cc2bw.html#output-arguments",
    "title": "cc2bw",
    "section": "Output Arguments",
    "text": "Output Arguments\n\nBW — Binary image\nA new GMTimage, returned as a logical array of the same size as CC.image_size."
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html#examples",
    "href": "documentation/imgproc/cc2bw.html#examples",
    "title": "cc2bw",
    "section": "Examples",
    "text": "Examples\n\nKeep Largest Connected Components\nRead a binary image and detect the connected components:\nBW = gmtread(TESTSDIR * \"assets/text.png\");\nCC = bwconncomp(BW);\nCreate a binary image that contains only the 2nd through 10th largest connected components:\n\nusing GMT\nI = gmtread(TESTSDIR * \"assets/text.png\");  # Hide\nCC = bwconncomp(I); # Hide\n\n# Sort by area in descending order\nidx = sortperm(CC.area, rev=true);\nIfilt = cc2bw(CC, obj2keep=idx[2:10])\ngrdimage(I, figsize=6)\ngrdimage!(Ifilt, figsize=6, xshift=6.2, show=true)\n\n\n\n\n\n\n\n\n\n\nSelect Connected Components Based on Multiple Criteria\nRead a grayscale image of grains of rice, then convert the image to binary:\nI = gmtread(TESTSDIR * \"assets/rice.png\");\nBW = binarize(I);\nimshow(BW)\nSelect regions for whom these conditions apply: - The area is greater than 50 pixels - The bounding box is less than 15 pixels wide and is greater than or equal to 20 pixels tall\nThis example uses the filter function to get the indices of the connected components that satisfy these criteria. The ind2bool function is used to convert the vector of indices returned by filter into into a vector of Boolean that can be combined with the area andition and te result passed to cc2bw.\nThis example also shows a problem with the bwconncomp function when the BoundingBoxes of components overlap. In such cases it may happen that parts of one component are included in the another component. This can lead to wrong results in some areas (as can be seen with the help of the red rectangles drawn around each component).\n\nusing GMT   # Hide\nI = gmtread(TESTSDIR * \"assets/rice.png\");  # Hide\nBW = binarize(I);   # Hide\nCC = bwconncomp(BW);\nselection = (CC.area .&gt; 50) .&& ind2bool(filter(CC.bbox, true, _aspect=15/20), CC.num_objects);\nBW2 = cc2bw(CC, obj2keep=selection)\n\n# Display the original and filtered images\ngrdimage(BW, figsize=6, plot=(data=CC.bbox, lc=:red))\ngrdimage!(BW2, figsize=6, xshift=6.2, show=true)"
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html#source-code",
    "href": "documentation/imgproc/cc2bw.html#source-code",
    "title": "cc2bw",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/cc2bw.html#see-also",
    "href": "documentation/imgproc/cc2bw.html#see-also",
    "title": "cc2bw",
    "section": "See Also",
    "text": "See Also\nbwconncomp, binarize"
  },
  {
    "objectID": "documentation/imgproc/bwperim.html",
    "href": "documentation/imgproc/bwperim.html",
    "title": "bwperim",
    "section": "",
    "text": "J = bwperim(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3, sel=nothing)::GMTimage\nFind perimeter of objects in binary image I.\nA pixel is part of the perimeter if it is nonzero and it is connected to at least one zero-valued pixel. To detect the image’s perimeter, the structuring element should a box of size 3 x 3 (or, better, use the defaults), but a different sizes can be provided. This operation, consisting on subtracting an erosion of I from I, is alsoknown as a morphological internal gradient."
  },
  {
    "objectID": "documentation/imgproc/bwperim.html#example",
    "href": "documentation/imgproc/bwperim.html#example",
    "title": "bwperim",
    "section": "Example",
    "text": "Example\nThe result will look like the outline of the object.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/circles.png\");\nJ = bwperim(I);\ngrdimage(I, figsize=6)\ngrdimage!(J, figsize=6, xshift=6, show=true)"
  },
  {
    "objectID": "documentation/imgproc/bwperim.html#source-code",
    "href": "documentation/imgproc/bwperim.html#source-code",
    "title": "bwperim",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/bwperim.html#see-also",
    "href": "documentation/imgproc/bwperim.html#see-also",
    "title": "bwperim",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode, strel"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html",
    "href": "documentation/imgproc/bwdist.html",
    "title": "bwdist",
    "section": "",
    "text": "Distance transform of binary image"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#description",
    "href": "documentation/imgproc/bwdist.html#description",
    "title": "bwdist",
    "section": "Description",
    "text": "Description\nD = bwdist(BW; weights=nothing, nthreads=Threads.nthreads())\nComputes the Euclidean distance transform of the binary image BW. For each pixel in BW, the distance transform assigns a number that is the distance between that pixel and the nearest nonzero pixel of BW.\nOptionally specify the weight w assigned to each coordinate. For example, if BW corresponds to an image where voxels are anisotropic, w could be the voxel spacing along each coordinate axis. The default value of nothing is equivalent to w=(1,1,...).\nidx = bwdist_idx(BW)\nComputes the closest-pixel map (also called the feature map, feature transform, or nearest-neighbor transform) and returns it as an index array. Each element of idx contains the linear index of the nearest nonzero pixel of BW."
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#input-arguments",
    "href": "documentation/imgproc/bwdist.html#input-arguments",
    "title": "bwdist",
    "section": "Input Arguments",
    "text": "Input Arguments\n\nBW — GMTimage/GMTgrid or Matrix Binary image\nBinary image, specified as a numeric or logical array. Can be of any numeric type and must be nonsparse.\nData Types: Float64, Float32, Int, UInt8, Bool"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#output-arguments",
    "href": "documentation/imgproc/bwdist.html#output-arguments",
    "title": "bwdist",
    "section": "Output Arguments",
    "text": "Output Arguments\n\nD — Distance transform\nDistance transform, returned as an GMTgrid/array the same size as BW. Each element represents the distance from the corresponding pixel to the nearest nonzero pixel of BW.\n\n\nidx — Closest-pixel map\nClosest-pixel map, returned as an array of linear indices with the same size as BW. Each element contains the linear index of the nearest nonzero pixel of BW.\nData Types: Int or CartesianIndex"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#references",
    "href": "documentation/imgproc/bwdist.html#references",
    "title": "bwdist",
    "section": "References",
    "text": "References\nThis implementation was slightly adapted from the ImageMorphology.jl package.\nMaurer, Calvin R., Rensheng Qi, and Vijay Raghavan. “A Linear Time Algorithm for Computing Exact Euclidean Distance Transforms of Binary Images in Arbitrary Dimensions.” IEEE Transactions on Pattern Analysis and Machine Intelligence. Vol. 25, No. 2, February 2003, pp. 265-270."
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#examples",
    "href": "documentation/imgproc/bwdist.html#examples",
    "title": "bwdist",
    "section": "Examples",
    "text": "Examples\n\nCompute Distance Transform and Closest-Pixel Map\nCreate a binary image:\nbw = zeros(5, 5)\nbw[2, 2] = 1\nbw[4, 4] = 1\nOutput:\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0\nCalculate the distance transform:\nD = bwdist(bw)\nOutput:\n5×5 Matrix{Float32}:\n 1.41421  1.0      1.41421  2.23607  3.16228\n 1.0      0.0      1.0      2.0      2.23607\n 1.41421  1.0      1.41421  1.0      1.41421\n 2.23607  2.0      1.0      0.0      1.0\n 3.16228  2.23607  1.41421  1.0      1.41421\nCalculate the closest-pixel map:\nidx = bwdist_idx(bw)\nOutput:\n5×5 Matrix{Int}:\n 7  7   7   7  19\n 7  7   7   7  19\n 7  7   7  19  19\n 7  7  19  19  19\n 7 19  19  19  19\nIn the closest-pixel map idx, the values 7 and 19 represent the position of the nonzero elements using linear matrix indexing. If a pixel contains a 7, its closest nonzero neighbor is at linear position 7 (which is bw[2, 2]), and a pixel containing 19 has its closest nonzero neighbor at linear position 19 (which is bw[4, 4]).\n\n\nUse Closest-Pixel Map to Find Nearest Features\nCreate a binary image with multiple features:\n# Create an image with some objects\nbw = zeros(100, 100)\nbw[20:25, 20:25] .= 1\nbw[50:55, 70:75] .= 1\nbw[75:80, 40:45] .= 1\n\n# Compute distance and indices\nD = bwdist(bw)\nidx = bwdist_idx(bw)\n\n# Create a test point at (60, 60)\ntest_point_idx = 60 + (60-1)*100  # Linear index for [60, 60]\n\n# Find which feature is closest\nclosest_feature_idx = idx[60, 60]\nprintln(\"Closest feature is at linear index: $closest_feature_idx\")\n\n\nComputing Distance to Background Pixels\nBy default, bwdist computes distances to nonzero (foreground) pixels. To compute distances to zero (background) pixels, invert the image:\n# Load binary image\nBW = gmtread(\"text.png\")\n\n# Distance to foreground pixels\nD_foreground = bwdist(BW)\n\n# Distance to background pixels (invert first)\nD_background = bwdist(.!BW)\n\n# Visualize both\nsubplot(1, 2, 1)\nimshow(D_foreground)\ntitle!(\"Distance to Foreground\")\n\nsubplot(1, 2, 2)\nimshow(D_background)\ntitle!(\"Distance to Background\")\n\nshowfig()"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#tips",
    "href": "documentation/imgproc/bwdist.html#tips",
    "title": "bwdist",
    "section": "Tips",
    "text": "Tips\n\nUse the Euclidean metric for most applications requiring accurate distance measurements\nThe quasi-Euclidean method provides a good approximation to Euclidean distance with comparable performance\nCity block and chessboard metrics can be faster for large multidimensional images\nInvert binary images (.!BW) to compute distances to background pixels instead of foreground pixels\nCombine with watershed for image segmentation applications\nUse bwdist_idx to track which feature each pixel is closest to\nThe closest-pixel map is useful for Voronoi tessellation and nearest-neighbor classification"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#source-code",
    "href": "documentation/imgproc/bwdist.html#source-code",
    "title": "bwdist",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbwdist(img::AbstractArray{Bool, N}; weights, nthreads) where N - bwdist.jl:4\nbwdist(mat::AbstractArray{T, N}; weights, nthreads) where {T, N} - bwdist.jl:12"
  },
  {
    "objectID": "documentation/imgproc/bwdist.html#see-also",
    "href": "documentation/imgproc/bwdist.html#see-also",
    "title": "bwdist",
    "section": "See Also",
    "text": "See Also\ngraydist, [watershed]"
  },
  {
    "objectID": "documentation/imgproc/bwareaopen.html",
    "href": "documentation/imgproc/bwareaopen.html",
    "title": "bwareaopen",
    "section": "",
    "text": "bwareaopen(I::Union{GMTimage{UInt8,2}, GMTimage{Bool,2}}; keepwhites::Bool=false, keepblacks::Bool=false, kwargs...)::GMTimage\nRemove all connected components (groups of pixels) that have fewer than P pixels from the binary image Ibw.\nRemove groups of pixels in the image that are smaller than a provided threshold size (in pixels) and replaces them with the pixel value of the largest neighbor polygon. This operation is known as an area opening.\nPolygons are determined as regions of the image where the pixels all have the same value, and that are contiguous (connected). The work is done by the GDAL GDALSieveFilter function."
  },
  {
    "objectID": "documentation/imgproc/bwareaopen.html#example",
    "href": "documentation/imgproc/bwareaopen.html#example",
    "title": "bwareaopen",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\n# Read the test image\nI = gmtread(TESTSDIR * \"assets/face_bw.png\");\n\n# Remove the small blobs using the default threshold size (10 pixels)\nIc = bwareaopen(I);\ngrdimage(I, figsize=6)\ngrdimage!(Ic, figsize=6, xshift=6, show=true)\n\n\n\n\n\n\n\n\nThe result is almos good as all salt-&-pepper noise has gone, buy two outer white patches survived cleaning. We could have used a larger than 10 pixes threshold value in bwareaopen call but that would have removed the mouth as well. To solve this we are going to take a more brute force approach. We will remove all patches smaller than 1000 pixels, which removes also the eyes, eyebrows and mouth but restore them in the same step by invoking the option keepblacks.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/face_bw.png\");  #Hide\n\n# Brute cleaning\nIc1 = bwareaopen(I, thresh=1000);\n\n# Retain the \"blacks\"\nIc2 = bwareaopen(I, thresh=1000, keepblacks=true);\n\n# But this still leaves some noise over the eyes, so clean it again\nIc3 = bwareaopen(Ic2)\n\ngrdimage(Ic1, figsize=5)\ngrdimage!(Ic2, figsize=5, xshift=5)\ngrdimage!(Ic3, figsize=5, xshift=5, show=true)"
  },
  {
    "objectID": "documentation/imgproc/bwareaopen.html#source-code",
    "href": "documentation/imgproc/bwareaopen.html#source-code",
    "title": "bwareaopen",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbwareaopen(data::String; kwargs...) - gdal_tools.jl:221\nbwareaopen(I::Union{GMTimage{Bool, 2}, GMTimage{UInt8, 2}}; keepwhites, keepblacks, kwargs...) - gdal_tools.jl:206"
  },
  {
    "objectID": "documentation/imgproc.html",
    "href": "documentation/imgproc.html",
    "title": "Image Processing Functions",
    "section": "",
    "text": "Functions for processing and analyzing images including morphological operations, filtering, segmentation, and color space conversions.\n\n\n\nbinarize - Convert image to binary\nbwareaopen - Remove small objects from binary image\nbwconncomp - Find connected components in binary image\nbwdist - Distance transform of binary image\nbwhitmiss - Binary hit-miss transform\nbwperim - Find perimeter of objects in binary image\nbwskell - Skeletonize binary image\ncc2bw - Convert connected components to binary image\n\n\n\n\n\nimdilate - Dilate image\nimerode - Erode image\nimopen - Morphologically open image\nimclose - Morphologically close image\nimtophat - Top-hat filtering\nimbothat - Bottom-hat filtering\nimmorphgrad - Morphological gradient\nstrel - Create morphological structuring element\n\n\n\n\n\nimfilter - Filter image\nimrankfilter - Rank filter for images\nimsobel - Sobel edge detection\ngraydist - Gray-weighted distance transform\npadarray - Pad array with values\n\n\n\n\n\nimfill - Fill image regions\nimreconstruct - Morphological reconstruction\nimsegment - Segment image\nisodata - ISODATA thresholding algorithm\n\n\n\n\n\nimregionalmax - Regional maxima\nimregionalmin - Regional minima\nimhmin - H-minima transform\nimhmax - H-maxima transform\nimhdome - H-dome transform\nfillsinks - Fill sinks in surface\n\n\n\n\n\nrgb2gray - Convert RGB to grayscale\nrgb2lab - Convert RGB to Lab color space\nrgb2ycbcr - Convert RGB to YCbCr color space\n\n\n\n\n\nimcomplement - Complement image"
  },
  {
    "objectID": "documentation/imgproc.html#binary-image-operations",
    "href": "documentation/imgproc.html#binary-image-operations",
    "title": "Image Processing Functions",
    "section": "",
    "text": "binarize - Convert image to binary\nbwareaopen - Remove small objects from binary image\nbwconncomp - Find connected components in binary image\nbwdist - Distance transform of binary image\nbwhitmiss - Binary hit-miss transform\nbwperim - Find perimeter of objects in binary image\nbwskell - Skeletonize binary image\ncc2bw - Convert connected components to binary image"
  },
  {
    "objectID": "documentation/imgproc.html#morphological-operations",
    "href": "documentation/imgproc.html#morphological-operations",
    "title": "Image Processing Functions",
    "section": "",
    "text": "imdilate - Dilate image\nimerode - Erode image\nimopen - Morphologically open image\nimclose - Morphologically close image\nimtophat - Top-hat filtering\nimbothat - Bottom-hat filtering\nimmorphgrad - Morphological gradient\nstrel - Create morphological structuring element"
  },
  {
    "objectID": "documentation/imgproc.html#image-filtering-enhancement",
    "href": "documentation/imgproc.html#image-filtering-enhancement",
    "title": "Image Processing Functions",
    "section": "",
    "text": "imfilter - Filter image\nimrankfilter - Rank filter for images\nimsobel - Sobel edge detection\ngraydist - Gray-weighted distance transform\npadarray - Pad array with values"
  },
  {
    "objectID": "documentation/imgproc.html#image-reconstruction-segmentation",
    "href": "documentation/imgproc.html#image-reconstruction-segmentation",
    "title": "Image Processing Functions",
    "section": "",
    "text": "imfill - Fill image regions\nimreconstruct - Morphological reconstruction\nimsegment - Segment image\nisodata - ISODATA thresholding algorithm"
  },
  {
    "objectID": "documentation/imgproc.html#regional-extrema-geodesic-operations",
    "href": "documentation/imgproc.html#regional-extrema-geodesic-operations",
    "title": "Image Processing Functions",
    "section": "",
    "text": "imregionalmax - Regional maxima\nimregionalmin - Regional minima\nimhmin - H-minima transform\nimhmax - H-maxima transform\nimhdome - H-dome transform\nfillsinks - Fill sinks in surface"
  },
  {
    "objectID": "documentation/imgproc.html#color-space-conversions",
    "href": "documentation/imgproc.html#color-space-conversions",
    "title": "Image Processing Functions",
    "section": "",
    "text": "rgb2gray - Convert RGB to grayscale\nrgb2lab - Convert RGB to Lab color space\nrgb2ycbcr - Convert RGB to YCbCr color space"
  },
  {
    "objectID": "documentation/imgproc.html#image-utilities",
    "href": "documentation/imgproc.html#image-utilities",
    "title": "Image Processing Functions",
    "section": "",
    "text": "imcomplement - Complement image"
  },
  {
    "objectID": "documentation/gdalfuns/xy2lonlat.html",
    "href": "documentation/gdalfuns/xy2lonlat.html",
    "title": "xy2lonlat",
    "section": "",
    "text": "xy2lonlat(xy::Matrix{&lt;:Real}, s_srs=\"\"; s_srs=\"\", t_srs=\"+proj=longlat +datum=WGS84\")\nor\nComputes the inverse projection from XY to LonLat in the given projection. The output is assumed to be in WGS84. If that isn’t right, pass the appropriate projection info via the t_srs option (PROJ4, WKT, EPSG)."
  },
  {
    "objectID": "documentation/gdalfuns/xy2lonlat.html#source-code",
    "href": "documentation/gdalfuns/xy2lonlat.html#source-code",
    "title": "xy2lonlat",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nxy2lonlat(D::Vector{&lt;:GMTdataset}, s_srs_; s_srs, t_srs) - gdal_utils.jl:1093\nxy2lonlat(xy::Vector{&lt;:Real}, s_srs_; s_srs, t_srs) - gdal_utils.jl:1077\nxy2lonlat(D::Vector{&lt;:GMTdataset}; ...) - gdal_utils.jl:1093\nxy2lonlat(xy::Vector{&lt;:Real}; ...) - gdal_utils.jl:1077\nxy2lonlat(xy::Matrix{&lt;:Real}; ...) - gdal_utils.jl:1082\nxy2lonlat(xy::Matrix{&lt;:Real}, s_srs_; s_srs, t_srs) - gdal_utils.jl:1082\nxy2lonlat(D::GMTdataset, s_srs_; s_srs, t_srs) - gdal_utils.jl:1092\nxy2lonlat(D::GMTdataset; ...) - gdal_utils.jl:1092\nxy2lonlat(x::Real, y::Real; ...) - gdal_utils.jl:1080\nxy2lonlat(x::Real, y::Real, s_srs_; s_srs, t_srs) - gdal_utils.jl:1080"
  },
  {
    "objectID": "documentation/gdalfuns/within.html",
    "href": "documentation/gdalfuns/within.html",
    "title": "within",
    "section": "",
    "text": "within(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/within.html#source-code",
    "href": "documentation/gdalfuns/within.html#source-code",
    "title": "within",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nwithin(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:393\nwithin(D1, D2) - gdal_extensions.jl:394"
  },
  {
    "objectID": "documentation/gdalfuns/symdifference.html",
    "href": "documentation/gdalfuns/symdifference.html",
    "title": "symdifference",
    "section": "",
    "text": "symdifference(geom1, geom2; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/symdifference.html#source-code",
    "href": "documentation/gdalfuns/symdifference.html#source-code",
    "title": "symdifference",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsymdifference(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:185\nsymdifference(D1, D2; gdataset) - gdal_extensions.jl:186"
  },
  {
    "objectID": "documentation/gdalfuns/setproj.html",
    "href": "documentation/gdalfuns/setproj.html",
    "title": "setproj",
    "section": "",
    "text": "setproj!(type, proj)\nSet a referencing system to the type object. This object can be a GMTgrid, a GMTimage, a GMTdataset or an AbstractDataset.\n\nproj Is either a Proj4 string or a WKT. Alternatively, it can also be another grid, image or dataset type, in which case its referencing system is copied into type"
  },
  {
    "objectID": "documentation/gdalfuns/polyunion.html",
    "href": "documentation/gdalfuns/polyunion.html",
    "title": "polyunion",
    "section": "",
    "text": "polyunion(geom1, geom2; gdataset=false)\nComputes a new geometry representing the union of the geometries."
  },
  {
    "objectID": "documentation/gdalfuns/polyunion.html#source-code",
    "href": "documentation/gdalfuns/polyunion.html#source-code",
    "title": "polyunion",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npolyunion(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:146\npolyunion(D1, D2; gdataset) - gdal_extensions.jl:147"
  },
  {
    "objectID": "documentation/gdalfuns/pointalongline.html",
    "href": "documentation/gdalfuns/pointalongline.html",
    "title": "pointalongline",
    "section": "",
    "text": "pointalongline(geom, distance::Real; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/pointalongline.html#source-code",
    "href": "documentation/gdalfuns/pointalongline.html#source-code",
    "title": "pointalongline",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npointalongline(geom::GMT.Gdal.AbstractGeometry, distance::Real) - gdal_extensions.jl:486\npointalongline(D, distance::Real; gdataset) - gdal_extensions.jl:487"
  },
  {
    "objectID": "documentation/gdalfuns/ogr2ogr.html",
    "href": "documentation/gdalfuns/ogr2ogr.html",
    "title": "ogr2ogr",
    "section": "",
    "text": "function gdalgrid(indata, opts::Union{String, Vector{String}}=““; dest=”/vsimem/tmp”, method::Union{AbstractString, Symbol}=““, kwargs…) if (method ==”“) _mtd = “-a invdist:nodata=NaN” else _mtd = isa(method, Symbol) ? string(method) : method (!startswith(_mtd, “invdist”) && !startswith(_mtd, “invdistnn”) && !startswith(_mtd, “average”) && !startswith(_mtd, “nearest”) && !startswith(_mtd, “linear”) && !startswith(_mtd, “minimum”) && !startswith(_mtd, “maximum”) && !startswith(_mtd, “range”) && !startswith(_mtd, “count”) && !startswith(_mtd, “average_distance”) && !startswith(_mtd, “average_distance_pts”)) && error(“Bad interpolation algorithm $_mtd”) _mtd = “-a” * _mtd !occursin(“nodata”, _mtd) && (_mtd *= “:nodata=NaN”) end _opts = isa(opts, Vector) ? join(opts, ” “) : opts # Let’s make a string to reduce confusion !occursin(”-ot”, _opts) && (_opts *= ” -ot Float32”) _mtd = ” ”  _opts helper_run_GDAL_fun(gdalgrid, indata, dest, _mtd, ““, kwargs…) end"
  },
  {
    "objectID": "documentation/gdalfuns/ogr2ogr.html#source-code",
    "href": "documentation/gdalfuns/ogr2ogr.html#source-code",
    "title": "ogr2ogr",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngdalvectortranslate(ds::Vector{GMTdataset}, opts::Vector{String}; dest, gdataset, save) - gdal.jl:1829\ngdalvectortranslate(ds::Vector{GMTdataset}; ...) - gdal.jl:1829\ngdalvectortranslate(datasets::Vector{GMT.Gdal.Dataset}; ...) - gdal.jl:1812\ngdalvectortranslate(datasets::Vector{GMT.Gdal.Dataset}, options::Vector{String}; dest, gdataset, save) - gdal.jl:1812\ngdalvectortranslate(ds::GMT.Gdal.IDataset; ...) - gdal.jl:1825\ngdalvectortranslate(ds::GMT.Gdal.IDataset, opts::Vector{String}; dest, gdataset, save) - gdal.jl:1825\ngdalvectortranslate(ds::GMT.Gdal.Dataset; ...) - gdal.jl:1823\ngdalvectortranslate(ds::GMT.Gdal.Dataset, opts::Vector{String}; dest, gdataset, save) - gdal.jl:1823\ngdalvectortranslate(ds::GMTdataset, opts::Vector{String}; dest, gdataset, save) - gdal.jl:1827\ngdalvectortranslate(ds::GMTdataset; ...) - gdal.jl:1827\ngdalvectortranslate(indata, opts; dest, kwargs...) - gdal_tools.jl:323\ngdalvectortranslate(indata; ...) - gdal_tools.jl:323"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome_direct.html",
    "href": "documentation/gdalfuns/loxodrome_direct.html",
    "title": "loxodrome_direct",
    "section": "",
    "text": "function loxodrome_inverse(lon1, lat1, lon2, lat2, a=6378137.0, f=0.0033528106647474805)\nCompute the inverse problem of a loxodrome on the ellipsoid.\nGiven latitudes and longitudes of P1 and P2 on the ellipsoid, compute the azimuth a12 of the loxodrome P1P2, the arc length s along the loxodrome curve.\nArgs:"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome_direct.html#example",
    "href": "documentation/gdalfuns/loxodrome_direct.html#example",
    "title": "loxodrome_direct",
    "section": "Example",
    "text": "Example\nCompute the distance and azimuth beyween points (0,0) and (5,5)\ndist, azim = loxodrome_inverse(0,0,5,5)"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome_direct.html#source-code",
    "href": "documentation/gdalfuns/loxodrome_direct.html#source-code",
    "title": "loxodrome_direct",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nloxodrome_direct(lon, lat, azim, dist, a, f) - loxodromics.jl:70\nloxodrome_direct(lon, lat, azim, dist, a) - loxodromics.jl:70\nloxodrome_direct(lon, lat, azim, dist) - loxodromics.jl:70"
  },
  {
    "objectID": "documentation/gdalfuns/lonlat2xy.html",
    "href": "documentation/gdalfuns/lonlat2xy.html",
    "title": "lonlat2xy",
    "section": "",
    "text": "imresize(mat::Matrix{&lt;:Integer}, _newdims::Union{Real, Tuple{Real, Real}, Vector{&lt;:Real}}=Int[]; newdims::Union{Real, Tuple{Real, Real}, Vector{&lt;:Real}}=Int[], method::Union{String, Symbol}=“cubic”) = imresize(mat2img(mat), _newdims; newdims=newdims, method=method).image function imresize(I::GMTimage{T,N}, _newdims::Union{Real, Tuple{Real, Real}, Vector{&lt;:Real}}=Int[]; newdims::Union{Real, Tuple{Real, Real}, Vector{&lt;:Real}}=Int[], method::Union{String, Symbol}=“cubic”)::GMTimage{T,N} where {T,N}\nend"
  },
  {
    "objectID": "documentation/gdalfuns/lonlat2xy.html#source-code",
    "href": "documentation/gdalfuns/lonlat2xy.html#source-code",
    "title": "lonlat2xy",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlonlat2xy(D::Vector{&lt;:GMTdataset{T, 2}}, t_srs_; t_srs, s_srs) where T&lt;:Real - gdal_utils.jl:1042\nlonlat2xy(xy::Vector{&lt;:Real}, t_srs_; t_srs, s_srs) - gdal_utils.jl:1025\nlonlat2xy(D::Vector{&lt;:GMTdataset{T, 2}}; ...) where T&lt;:Real - gdal_utils.jl:1042\nlonlat2xy(xy::Vector{&lt;:Real}; ...) - gdal_utils.jl:1025\nlonlat2xy(xy::Matrix{T}; ...) where T&lt;:Real - gdal_utils.jl:1030\nlonlat2xy(xy::Matrix{T}, t_srs_; t_srs, s_srs) where T&lt;:Real - gdal_utils.jl:1030\nlonlat2xy(D::GMTdataset, t_srs_; t_srs, s_srs) - gdal_utils.jl:1041\nlonlat2xy(D::GMTdataset; ...) - gdal_utils.jl:1041\nlonlat2xy(x::Real, y::Real; ...) - gdal_utils.jl:1028\nlonlat2xy(x::Real, y::Real, t_srs_; t_srs, s_srs) - gdal_utils.jl:1028"
  },
  {
    "objectID": "documentation/gdalfuns/intersects.html",
    "href": "documentation/gdalfuns/intersects.html",
    "title": "intersects",
    "section": "",
    "text": "intersects(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/intersects.html#source-code",
    "href": "documentation/gdalfuns/intersects.html#source-code",
    "title": "intersects",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nintersects(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:325\nintersects(D1, D2) - gdal_extensions.jl:326"
  },
  {
    "objectID": "documentation/gdalfuns/gmt2gd.html",
    "href": "documentation/gdalfuns/gmt2gd.html",
    "title": "gmt2gd",
    "section": "",
    "text": "ds = gmt2gd(GI)\nCreate GDAL dataset from the contents of GI that can be either a Grid or an Image\nCreate GDAL dataset from the contents of D, which can be a GMTdataset, a vector of GMTdataset ir a MxN array. The save keyword instructs GDAL to save the contents as an OGR file. Format is determined by file estension. geometry can be a string with “polygon”, where file will be converted to polygon/multipolygon depending on D is a single or a multi-segment object, or “point” to convert to a multipoint geometry."
  },
  {
    "objectID": "documentation/gdalfuns/gmt2gd.html#source-code",
    "href": "documentation/gdalfuns/gmt2gd.html#source-code",
    "title": "gmt2gd",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmt2gd(D::Vector{&lt;:GMTdataset}; save, geometry) - gdal_utils.jl:670\ngmt2gd(D::GMTdataset; save, geometry) - gdal_utils.jl:669\ngmt2gd(D::Matrix{&lt;:Real}; save, geometry) - gdal_utils.jl:668\ngmt2gd(GI) - gdal_utils.jl:592"
  },
  {
    "objectID": "documentation/gdalfuns/geomarea.html",
    "href": "documentation/gdalfuns/geomarea.html",
    "title": "geomarea",
    "section": "",
    "text": "geomarea(geom)"
  },
  {
    "objectID": "documentation/gdalfuns/geomarea.html#source-code",
    "href": "documentation/gdalfuns/geomarea.html#source-code",
    "title": "geomarea",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngeomarea(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:210\ngeomarea(D) - gdal_extensions.jl:211"
  },
  {
    "objectID": "documentation/gdalfuns/geodesic.html",
    "href": "documentation/gdalfuns/geodesic.html",
    "title": "geodesic",
    "section": "",
    "text": "geodesic(D; step=0, unit=:m, np=0, proj::String=\"\", epsg::Integer=0, longest::Bool=false)\nor\nGenerate geodesic line(s) (shortest distace) on an ellipsoid. Input data can be two or more points. In later case each line segment is descretized at step increments,"
  },
  {
    "objectID": "documentation/gdalfuns/geodesic.html#example",
    "href": "documentation/gdalfuns/geodesic.html#example",
    "title": "geodesic",
    "section": "Example",
    "text": "Example\nCompute an geodesic between points (0,0) and (30,50) discretized at 100 km steps.\nmat = geodesic([0 0; 30 50], step=100, unit=:k);"
  },
  {
    "objectID": "documentation/gdalfuns/geodesic.html#source-code",
    "href": "documentation/gdalfuns/geodesic.html#source-code",
    "title": "geodesic",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngeodesic(fname::String; step, unit, np, proj, epsg, longest) - proj_utils.jl:424\ngeodesic(line::Matrix{&lt;:Real}; step, unit, np, proj, epsg, longest) - proj_utils.jl:451\ngeodesic(D::GMTdataset; step, unit, np, proj, epsg, longest) - proj_utils.jl:446\ngeodesic(D::Vector{&lt;:GMTdataset}; step, unit, np, proj, epsg, longest) - proj_utils.jl:437\ngeodesic(ds::GMT.Gdal.AbstractDataset; step, unit, np, proj, epsg, longest) - proj_utils.jl:434\ngeodesic(lon1::Real, lat1::Real, lon2::Real, lat2::Real; step, unit, np, proj, epsg, longest) - proj_utils.jl:430\ngeodesic(ll1::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, ll2::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}; step, unit, np, proj, epsg, longest) - proj_utils.jl:427"
  },
  {
    "objectID": "documentation/gdalfuns/gdalwrite.html",
    "href": "documentation/gdalfuns/gdalwrite.html",
    "title": "gdalwrite",
    "section": "",
    "text": "gdalwrite(fname::AbstractString, data, opts=String[]; kwargs...)\nWrite a raster or a vector file to disk\nOr\nWrite a MxNxP cube object to disk as a multilayered file."
  },
  {
    "objectID": "documentation/gdalfuns/gdalwrite.html#source-code",
    "href": "documentation/gdalfuns/gdalwrite.html#source-code",
    "title": "gdalwrite",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngdalwrite(cube::GItype, fname::AbstractString, v; dim_name, dim_units, band_name) - gdal_utils.jl:945\ngdalwrite(cube::GItype, fname::AbstractString; ...) - gdal_utils.jl:945\ngdalwrite(fname::AbstractString, data, optsP; opts, kw...) - gdal_utils.jl:934\ngdalwrite(fname::AbstractString, data; ...) - gdal_utils.jl:934"
  },
  {
    "objectID": "documentation/gdalfuns/gdaltranslate.html",
    "href": "documentation/gdalfuns/gdaltranslate.html",
    "title": "gdaltranslate",
    "section": "",
    "text": "gdaltranslate(indata, options=String[]; dest=“/vsimem/tmp”, kwargs…)\nConvert raster data between different formats.\nOperations provided by the GDAL ‘gdal_translate’ tool. Namely sub-region extraction and resampling. The kwargs options accept the GMT region (-R), increment (-I), target SRS (-J). Any of the keywords outgrid, outfile or save = outputname options to make this function save the result on a file designated by ‘outputname’. The file format is picked from the ‘outputname’ file extension. When no output file name is provided it returns a GMT object (either a grid or an image, depending on the input type). To force the return of a GDAL dataset use the option gdataset=true."
  },
  {
    "objectID": "documentation/gdalfuns/gdaltranslate.html#source-code",
    "href": "documentation/gdalfuns/gdaltranslate.html#source-code",
    "title": "gdaltranslate",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngdaltranslate(ds::GMT.Gdal.IDataset; ...) - gdal.jl:1620\ngdaltranslate(dataset::GMT.Gdal.Dataset; ...) - gdal.jl:1608\ngdaltranslate(ds::GMT.Gdal.IDataset, opts; dest, gdataset, save) - gdal.jl:1620\ngdaltranslate(dataset::GMT.Gdal.Dataset, options; dest, gdataset, save, layout) - gdal.jl:1608\ngdaltranslate(indata, opts; dest, kwargs...) - gdal_tools.jl:28\ngdaltranslate(indata; ...) - gdal_tools.jl:28"
  },
  {
    "objectID": "documentation/gdalfuns/gdalread.html",
    "href": "documentation/gdalfuns/gdalread.html",
    "title": "gdalread",
    "section": "",
    "text": "gdalread(fname::AbstractString, opts=String[]; gdataset=false, kwargs...)\nRead a raster or a vector file from a disk file and return the result either as a GMT type (the default) or a GDAL dataset."
  },
  {
    "objectID": "documentation/gdalfuns/gdalread.html#source-code",
    "href": "documentation/gdalfuns/gdalread.html#source-code",
    "title": "gdalread",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngdalread(fname::AbstractString, optsP; opts, gdataset, kw...) - gdal_utils.jl:867\ngdalread(fname::AbstractString; ...) - gdal_utils.jl:867"
  },
  {
    "objectID": "documentation/gdalfuns/gd2gmt.html",
    "href": "documentation/gdalfuns/gd2gmt.html",
    "title": "gd2gmt",
    "section": "",
    "text": "O = gd2gmt(dataset; band=0, bands=[], sds=0, pad=0)\nConvert a GDAL raster dataset into either a GMTgrid (if type is Int16 or Float) or a GMTimage type Use band to select a single band of the dataset. When you know that the dataset contains several bands of an image, use the kwarg bands with a vector the wished bands. By default it reads all bands of the image or grid object.\nWhen DATASET is a string it may contain the file name or the name of a subdataset. In former case you can use the kwarg sds to selec the subdataset numerically. Alternatively, provide the full sds name. For files with sds with a scale_factor (e.g. MODIS data), that scale is applyied automaticaly."
  },
  {
    "objectID": "documentation/gdalfuns/gd2gmt.html#source-code",
    "href": "documentation/gdalfuns/gd2gmt.html#source-code",
    "title": "gd2gmt",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngd2gmt(dataset::GMT.Gdal.AbstractDataset) - gdal_utils.jl:256\ngd2gmt(geom::GMT.Gdal.AbstractGeometry) - gdal_utils.jl:216\ngd2gmt(_dataset; band, bands, sds, pad, layout) - gdal_utils.jl:24\ngd2gmt(geom::GMT.Gdal.AbstractGeometry, proj::String) - gdal_utils.jl:216"
  },
  {
    "objectID": "documentation/gdalfuns/equals.html",
    "href": "documentation/gdalfuns/equals.html",
    "title": "equals",
    "section": "",
    "text": "equals(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/equals.html#source-code",
    "href": "documentation/gdalfuns/equals.html#source-code",
    "title": "equals",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nequals(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:341\nequals(D1, D2) - gdal_extensions.jl:342"
  },
  {
    "objectID": "documentation/gdalfuns/epsg2proj.html",
    "href": "documentation/gdalfuns/epsg2proj.html",
    "title": "epsg2proj",
    "section": "",
    "text": "epsg2proj(code::Integer)\nConvert a EPSG code into the PROJ4 form."
  },
  {
    "objectID": "documentation/gdalfuns/epsg2proj.html#source-code",
    "href": "documentation/gdalfuns/epsg2proj.html#source-code",
    "title": "epsg2proj",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/gdalfuns/envelope.html",
    "href": "documentation/gdalfuns/envelope.html",
    "title": "envelope",
    "section": "",
    "text": "envelope(geom)"
  },
  {
    "objectID": "documentation/gdalfuns/envelope.html#source-code",
    "href": "documentation/gdalfuns/envelope.html#source-code",
    "title": "envelope",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nenvelope(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:250\nenvelope(D) - gdal_extensions.jl:255"
  },
  {
    "objectID": "documentation/gdalfuns/distance.html",
    "href": "documentation/gdalfuns/distance.html",
    "title": "distance",
    "section": "",
    "text": "distance(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/distance.html#source-code",
    "href": "documentation/gdalfuns/distance.html#source-code",
    "title": "distance",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndistance(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:198\ndistance(D1, D2) - gdal_extensions.jl:199"
  },
  {
    "objectID": "documentation/gdalfuns/difference.html",
    "href": "documentation/gdalfuns/difference.html",
    "title": "difference",
    "section": "",
    "text": "difference(geom1, geom2; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/difference.html#source-code",
    "href": "documentation/gdalfuns/difference.html#source-code",
    "title": "difference",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndifference(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:165\ndifference(D1, D2; gdataset) - gdal_extensions.jl:166"
  },
  {
    "objectID": "documentation/gdalfuns/crosses.html",
    "href": "documentation/gdalfuns/crosses.html",
    "title": "crosses",
    "section": "",
    "text": "crosses(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/crosses.html#source-code",
    "href": "documentation/gdalfuns/crosses.html#source-code",
    "title": "crosses",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncrosses(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:380\ncrosses(D1, D2) - gdal_extensions.jl:381"
  },
  {
    "objectID": "documentation/gdalfuns/contains.html",
    "href": "documentation/gdalfuns/contains.html",
    "title": "contains",
    "section": "",
    "text": "contains(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/contains.html#source-code",
    "href": "documentation/gdalfuns/contains.html#source-code",
    "title": "contains",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncontains(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:406\ncontains(D1::Union{GDtype, Matrix{&lt;:Real}}, D2::Union{GDtype, Matrix{&lt;:Real}}) - gdal_extensions.jl:407"
  },
  {
    "objectID": "documentation/gdalfuns/circgeo.html",
    "href": "documentation/gdalfuns/circgeo.html",
    "title": "circgeo",
    "section": "",
    "text": "function vecangles(lonlat0::VMr, lonlat1::Matrix{&lt;:Real}; proj::String=““, s_srs::String=”“, epsg::Integer=0, sorted=true) az = invgeod(lonlat1, [lonlat0[1] lonlat0[2]]; proj=proj, s_srs=s_srs, backward=true)[3] [(az[k] &lt; 0) && (az[k] += 360) for k = 1:lastindex(az)] if (sorted) p = sortperm(az) sort!(az) else p = collect(1:length(az)) end difas = append!(diff(az), [az[1] - az[end]].+360) return difas, p end"
  },
  {
    "objectID": "documentation/gdalfuns/circgeo.html#source-code",
    "href": "documentation/gdalfuns/circgeo.html#source-code",
    "title": "circgeo",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncircgeo(lonlat::Matrix{&lt;:Real}; radius, proj, s_srs, epsg, dataset, unit, np, shape) - proj_utils.jl:253\ncircgeo(lonlat::Vector{&lt;:Real}; radius, proj, s_srs, epsg, dataset, unit, np, shape) - proj_utils.jl:250\ncircgeo(lon::Real, lat::Real; radius, proj, s_srs, epsg, dataset, unit, np, shape) - proj_utils.jl:248"
  },
  {
    "objectID": "documentation/gdalfuns/buffergeo.html",
    "href": "documentation/gdalfuns/buffergeo.html",
    "title": "buffergeo",
    "section": "",
    "text": "buffergeo(D::GMTdataset; width=0, unit=:m, np=120, flatstart=false, flatend=false, epsg::Integer=0, tol=0.01)\nor\nor\nComputes a buffer arround a poly-line. This calculation is performed on a ellipsoidal Earth (or other planet) using the GeographicLib (via PROJ4) so it should be very accurate."
  },
  {
    "objectID": "documentation/gdalfuns/buffergeo.html#example-compute-a-buffer-with-50000-m-width",
    "href": "documentation/gdalfuns/buffergeo.html#example-compute-a-buffer-with-50000-m-width",
    "title": "buffergeo",
    "section": "Example: Compute a buffer with 50000 m width",
    "text": "Example: Compute a buffer with 50000 m width\nD = buffergeo([0 0; 10 10; 15 20], width=50000);"
  },
  {
    "objectID": "documentation/gdalfuns/buffergeo.html#source-code",
    "href": "documentation/gdalfuns/buffergeo.html#source-code",
    "title": "buffergeo",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbuffergeo(fname::String; width, unit, np, flatstart, flatend, epsg, tol) - proj_utils.jl:308\nbuffergeo(line::Matrix{&lt;:Real}; width, unit, np, flatstart, flatend, proj, epsg, tol) - proj_utils.jl:326\nbuffergeo(D::Vector{&lt;:GMTdataset}; width, unit, np, flatstart, flatend, epsg, tol) - proj_utils.jl:317\nbuffergeo(D::GMTdataset; width, unit, np, flatstart, flatend, epsg, tol) - proj_utils.jl:314\nbuffergeo(ds::GMT.Gdal.AbstractDataset; width, unit, np, flatstart, flatend, epsg, tol) - proj_utils.jl:311"
  },
  {
    "objectID": "documentation/gdalfuns/boundary.html",
    "href": "documentation/gdalfuns/boundary.html",
    "title": "boundary",
    "section": "",
    "text": "boundary(geom; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/boundary.html#source-code",
    "href": "documentation/gdalfuns/boundary.html#source-code",
    "title": "boundary",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nboundary(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:436\nboundary(D; gdataset) - gdal_extensions.jl:437"
  },
  {
    "objectID": "documentation/gdalfuns/arccircle.html",
    "href": "documentation/gdalfuns/arccircle.html",
    "title": "arccircle",
    "section": "",
    "text": "arccircle(x0, y0, radius, start_angle, end_angle; z0=0, inc=2, gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/arccircle.html#source-code",
    "href": "documentation/gdalfuns/arccircle.html#source-code",
    "title": "arccircle",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/zscores.html",
    "href": "documentation/utilities/zscores.html",
    "title": "zscores",
    "section": "",
    "text": "z = zscores(x::AbstractArray{T}) -&gt; AbstractArray{Float64}\nCompute the z-scores of an array x with mean μ and standard deviation σ. z-scores are the signed number of standard deviations above the mean that an observation lies, i.e. \\((x - μ) / σ\\)."
  },
  {
    "objectID": "documentation/utilities/zscores.html#source-code",
    "href": "documentation/utilities/zscores.html#source-code",
    "title": "zscores",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/zscores.html#see-also",
    "href": "documentation/utilities/zscores.html#see-also",
    "title": "zscores",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/yeardecimal.html",
    "href": "documentation/utilities/yeardecimal.html",
    "title": "yeardecimal",
    "section": "",
    "text": "yeardecimal(date)\nConvert a Date or DateTime or a string representation of them to decimal years, or vice-versa. That is, convert from decimal year to DateTime."
  },
  {
    "objectID": "documentation/utilities/yeardecimal.html#source-code",
    "href": "documentation/utilities/yeardecimal.html#source-code",
    "title": "yeardecimal",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nyeardecimal(years::Real) - utils.jl:394\nyeardecimal(dtm::Union{DateTime, Vector{DateTime}}) - utils.jl:386\nyeardecimal(dtm::Union{Date, Vector{Date}}) - utils.jl:383\nyeardecimal(dtm::Union{String, Vector{String}}) - utils.jl:376"
  },
  {
    "objectID": "documentation/utilities/yeardecimal.html#see-also",
    "href": "documentation/utilities/yeardecimal.html#see-also",
    "title": "yeardecimal",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/xcorr.html",
    "href": "documentation/utilities/xcorr.html",
    "title": "xcorr",
    "section": "",
    "text": "xcorr(x::AbstractVecOrMat{&lt;:Real}, y::AbstractVecOrMat{&lt;:Real}; demean::Bool=true, lags::AbstractVector{&lt;:Integer}=Int[], maxlags=0)\nReturns the cross-correlation of two discrete-time sequences.\nIf x is a matrix, then r is a matrix whose columns contain the autocorrelation and cross-correlation sequences for all combinations of the columns of x.\nReturns the autocorrelation sequence of x.\nCross-correlation measures the similarity between a vector x and shifted (lagged) copies of a vector y as a function of the lag."
  },
  {
    "objectID": "documentation/utilities/xcorr.html#source-code",
    "href": "documentation/utilities/xcorr.html#source-code",
    "title": "xcorr",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nxcorr(x::AbstractMatrix{&lt;:Real}, y::AbstractMatrix{&lt;:Real}; lags, demean, maxlags) - signalcorr.jl:60\nxcorr(x::AbstractVector{&lt;:Real}, y::AbstractMatrix{&lt;:Real}; lags, demean, maxlags) - signalcorr.jl:54\nxcorr(x::AbstractMatrix{&lt;:Real}, y::AbstractVector{&lt;:Real}; lags, demean, maxlags) - signalcorr.jl:48\nxcorr(x::AbstractVector{&lt;:Real}, y::AbstractVector{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:42\nxcorr(x::AbstractMatrix{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:35\nxcorr(x::AbstractVector{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:29"
  },
  {
    "objectID": "documentation/utilities/xcorr.html#see-also",
    "href": "documentation/utilities/xcorr.html#see-also",
    "title": "xcorr",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/VSdisp.html",
    "href": "documentation/utilities/VSdisp.html",
    "title": "VSdisp",
    "section": "",
    "text": "Category: Utilities\nVertical seismic dispersion function."
  },
  {
    "objectID": "documentation/utilities/VSdisp.html#description",
    "href": "documentation/utilities/VSdisp.html#description",
    "title": "VSdisp",
    "section": "Description",
    "text": "Description\nThe VSdisp function Vertical seismic dispersion function."
  },
  {
    "objectID": "documentation/utilities/VSdisp.html#see-also",
    "href": "documentation/utilities/VSdisp.html#see-also",
    "title": "VSdisp",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/vector_attrib.html",
    "href": "documentation/utilities/vector_attrib.html",
    "title": "vector_attrib",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the vector_attrib function."
  },
  {
    "objectID": "documentation/utilities/vector_attrib.html#source-code",
    "href": "documentation/utilities/vector_attrib.html#source-code",
    "title": "vector_attrib",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nvector_attrib(; kwargs...) - common_options.jl:3292\nvector_attrib(d::Dict) - common_options.jl:3296\nvector_attrib(t::NamedTuple) - common_options.jl:3291\nvector_attrib(d::Dict, lixo) - common_options.jl:3290"
  },
  {
    "objectID": "documentation/utilities/vector_attrib.html#see-also",
    "href": "documentation/utilities/vector_attrib.html#see-also",
    "title": "vector_attrib",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/trisurf.html",
    "href": "documentation/utilities/trisurf.html",
    "title": "trisurf",
    "section": "",
    "text": "trisurf(in, kw...)\nPlots the 3-D triangular surface.\nThe triangulation is defined by the points in a Mx3 matrix or a GMTdataset with data x, y, z in the 3 first columns. The triangles are computed with a Delaunay triangulation done internaly. Since this is a plot3d avatar all options in this function are those of the plot3d program."
  },
  {
    "objectID": "documentation/utilities/trisurf.html#source-code",
    "href": "documentation/utilities/trisurf.html#source-code",
    "title": "trisurf",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntrisurf(G::Union{String, GMTgrid}, G2; first, thickness, isbase, downsample, ratio, bottom, wall_only, top_only, geog, kw...) - triangulate.jl:187\ntrisurf(G::Union{String, GMTgrid}; ...) - triangulate.jl:187\ntrisurf(in::Union{GDtype, Matrix}; first, gdal, kw...) - triangulate.jl:166"
  },
  {
    "objectID": "documentation/utilities/trisurf.html#see-also",
    "href": "documentation/utilities/trisurf.html#see-also",
    "title": "trisurf",
    "section": "See also",
    "text": "See also\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/togglemask.html",
    "href": "documentation/utilities/togglemask.html",
    "title": "togglemask",
    "section": "",
    "text": "I = togglemask(I::Union{GMTimage{&lt;:Bool, 2}, GMTimage{&lt;:UInt8, 2}}) -&gt; GMTimage\nConvert between UInt8 and Boolean representations of the mask images. A new object is returned with a copy of the input data."
  },
  {
    "objectID": "documentation/utilities/togglemask.html#source-code",
    "href": "documentation/utilities/togglemask.html#source-code",
    "title": "togglemask",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntogglemask(I::GMTimage{&lt;:UInt8, 2}) - grd_operations.jl:314\ntogglemask(I::GMTimage{&lt;:Bool, 2}) - grd_operations.jl:313"
  },
  {
    "objectID": "documentation/utilities/togglemask.html#see-also",
    "href": "documentation/utilities/togglemask.html#see-also",
    "title": "togglemask",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/tic.html",
    "href": "documentation/utilities/tic.html",
    "title": "tic",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the tic function."
  },
  {
    "objectID": "documentation/utilities/tic.html#source-code",
    "href": "documentation/utilities/tic.html#source-code",
    "title": "tic",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/tic.html#see-also",
    "href": "documentation/utilities/tic.html#see-also",
    "title": "tic",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/terramar.html",
    "href": "documentation/utilities/terramar.html",
    "title": "terramar",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the terramar function."
  },
  {
    "objectID": "documentation/utilities/terramar.html#source-code",
    "href": "documentation/utilities/terramar.html#source-code",
    "title": "terramar",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/terramar.html#see-also",
    "href": "documentation/utilities/terramar.html#see-also",
    "title": "terramar",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/stats.html",
    "href": "documentation/utilities/stats.html",
    "title": "stats",
    "section": "",
    "text": "D = stats(D::GMTdataset, cols=0) -&gt; GMTdataset\nReturn descriptive statistics for a dataset GMTdataset where each row represents the statistics for each column.\nIf cols is a column name, either as a String or a Symbol, or a column number, only the statistics for that column are returned."
  },
  {
    "objectID": "documentation/utilities/stats.html#source-code",
    "href": "documentation/utilities/stats.html#source-code",
    "title": "stats",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nstats(D::GMTdataset{T, 2}, cols::Union{Int64, String, Symbol}) where T&lt;:Real - utils_types.jl:933\nstats(D::GMTdataset{T, 2}) where T&lt;:Real - utils_types.jl:933"
  },
  {
    "objectID": "documentation/utilities/stats.html#see-also",
    "href": "documentation/utilities/stats.html#see-also",
    "title": "stats",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/spinmat.html",
    "href": "documentation/utilities/spinmat.html",
    "title": "spinmat",
    "section": "",
    "text": "R = spinmat(theta, n) -&gt; Matrix{Float64}\nCompute the rotation matrix that rotates by angle theta (in degrees) about the vector n."
  },
  {
    "objectID": "documentation/utilities/spinmat.html#source-code",
    "href": "documentation/utilities/spinmat.html#source-code",
    "title": "spinmat",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/spinmat.html#see-also",
    "href": "documentation/utilities/spinmat.html#see-also",
    "title": "spinmat",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/sortslicesperm.html",
    "href": "documentation/utilities/sortslicesperm.html",
    "title": "sortslicesperm",
    "section": "",
    "text": "p = sortslicesperm(A; dims=1, kws…)\nLike sortslices but return instead the indices p such that A[p, :] == sortslices(A; dims=1, kws...)"
  },
  {
    "objectID": "documentation/utilities/sortslicesperm.html#source-code",
    "href": "documentation/utilities/sortslicesperm.html#source-code",
    "title": "sortslicesperm",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/sortslicesperm.html#see-also",
    "href": "documentation/utilities/sortslicesperm.html#see-also",
    "title": "sortslicesperm",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/scatter3.html",
    "href": "documentation/utilities/scatter3.html",
    "title": "scatter3",
    "section": "",
    "text": "GMT.scatter3 is a Function."
  },
  {
    "objectID": "documentation/utilities/scatter3.html#source-code",
    "href": "documentation/utilities/scatter3.html#source-code",
    "title": "scatter3",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nscatter3(cmd0::String; ...) - plot.jl:413\nscatter3(cmd0::String, arg1; kw...) - plot.jl:413\nscatter3(f1::Function, f2::Function, f3::Function, range_t; first, kw...) - plot.jl:431\nscatter3(f1::Function, f2::Function, f3::Function; ...) - plot.jl:431\nscatter3(f1::Function, f2::Function; ...) - plot.jl:426\nscatter3(f1::Function, f2::Function, range_t; first, kw...) - plot.jl:426\nscatter3(arg1::AbstractArray, arg2::AbstractArray, arg3::AbstractArray; kw...) - plot.jl:419\nscatter3(; ...) - plot.jl:413\nscatter3(arg; kw...) - plot.jl:416"
  },
  {
    "objectID": "documentation/utilities/resetGMT.html",
    "href": "documentation/utilities/resetGMT.html",
    "title": "resetGMT",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the resetGMT function."
  },
  {
    "objectID": "documentation/utilities/resetGMT.html#source-code",
    "href": "documentation/utilities/resetGMT.html#source-code",
    "title": "resetGMT",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nresetGMT(dorestart::Bool) - gmt_main.jl:1491\nresetGMT() - gmt_main.jl:1491"
  },
  {
    "objectID": "documentation/utilities/resetGMT.html#see-also",
    "href": "documentation/utilities/resetGMT.html#see-also",
    "title": "resetGMT",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/radar.html",
    "href": "documentation/utilities/radar.html",
    "title": "radar",
    "section": "",
    "text": "radar(cmd0=\"\", arg1=nothing; axeslimts=Float64[], annotall=false, axeslabels=String[], kwargs...)\nRadar plots are a useful way for seeing which variables have similar values or if there are outliers amongst each variable. By default we expect a matrix, or a GMTdatset (or a vector of them) with normalized values. This is so because a radar plot has multiple axis that each have different limits. So the options are to pass normalized variables or set each axis limits via the axeslimts option.\nBy default the polygons are not filled but that is often not so nice. To fill with the default cyclic color use just fill=true. Other options are to use:\nExamples:"
  },
  {
    "objectID": "documentation/utilities/radar.html#source-code",
    "href": "documentation/utilities/radar.html#source-code",
    "title": "radar",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nradar(cmd0::String; kwargs...) - plot.jl:1316\nradar(arg1; kwargs...) - plot.jl:1317"
  },
  {
    "objectID": "documentation/utilities/quadkey.html",
    "href": "documentation/utilities/quadkey.html",
    "title": "quadkey",
    "section": "",
    "text": "quadkey(lon::Real, lat::Real, zoom::Int; bounds=false, geog=true)\nReturns the x,y,z & the quadtree string or the bounds"
  },
  {
    "objectID": "documentation/utilities/quadkey.html#source-code",
    "href": "documentation/utilities/quadkey.html#source-code",
    "title": "quadkey",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nquadkey(xyz::VecOrMat{&lt;:Int64}; bounds, geog) - imgtiles.jl:41\nquadkey(lon::Real, lat::Real, zoom::Int64; bounds, geog) - imgtiles.jl:34"
  },
  {
    "objectID": "documentation/utilities/quadkey.html#see-also",
    "href": "documentation/utilities/quadkey.html#see-also",
    "title": "quadkey",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/qqplot.html",
    "href": "documentation/utilities/qqplot.html",
    "title": "qqplot",
    "section": "",
    "text": "qqplot(x::AbstractVector{AbstractFloat}, y::AbstractVector{AbstractFloat}; kwargs...)\nThe qqplot function compares the quantiles of two distributions.\nExamples:"
  },
  {
    "objectID": "documentation/utilities/qqplot.html#source-code",
    "href": "documentation/utilities/qqplot.html#source-code",
    "title": "qqplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nqqplot(x; qqline, first, kwargs...) - statplots.jl:953\nqqplot(x, y; qqline, first, kwargs...) - statplots.jl:905"
  },
  {
    "objectID": "documentation/utilities/polyval.html",
    "href": "documentation/utilities/polyval.html",
    "title": "polyval",
    "section": "",
    "text": "y = polyval(p::AbstractArray, x::Union{AbstractArray, Number})\nEvaluates the polynomial p at each point in x. The argument p is a vector of length n+1 whose elements are the coefficients (in ascending order of powers) of an nth-degree polynomial:"
  },
  {
    "objectID": "documentation/utilities/polyval.html#source-code",
    "href": "documentation/utilities/polyval.html#source-code",
    "title": "polyval",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/polyval.html#see-also",
    "href": "documentation/utilities/polyval.html#see-also",
    "title": "polyval",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/pol2cart.html",
    "href": "documentation/utilities/pol2cart.html",
    "title": "pol2cart",
    "section": "",
    "text": "x, y = pol2cart(theta, rho; deg=false)\nTransform polar to Cartesian coordinates. Angles are in radians by default. Use deg=true if angles are in degrees. Input can be scalar, vectors or matrices."
  },
  {
    "objectID": "documentation/utilities/pol2cart.html#source-code",
    "href": "documentation/utilities/pol2cart.html#source-code",
    "title": "pol2cart",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/pol2cart.html#see-also",
    "href": "documentation/utilities/pol2cart.html#see-also",
    "title": "pol2cart",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/peaks.html",
    "href": "documentation/utilities/peaks.html",
    "title": "peaks",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the peaks function."
  },
  {
    "objectID": "documentation/utilities/peaks.html#source-code",
    "href": "documentation/utilities/peaks.html#source-code",
    "title": "peaks",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npeaks(n::Int64; N, grid, pixreg) - utils.jl:456\npeaks(; ...) - utils.jl:456"
  },
  {
    "objectID": "documentation/utilities/peaks.html#see-also",
    "href": "documentation/utilities/peaks.html#see-also",
    "title": "peaks",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/nanstd.html",
    "href": "documentation/utilities/nanstd.html",
    "title": "nanstd",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the nanstd function."
  },
  {
    "objectID": "documentation/utilities/nanstd.html#source-code",
    "href": "documentation/utilities/nanstd.html#source-code",
    "title": "nanstd",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nnanstd(x, y) - utils.jl:327\nnanstd(x) - utils.jl:326"
  },
  {
    "objectID": "documentation/utilities/nanstd.html#see-also",
    "href": "documentation/utilities/nanstd.html#see-also",
    "title": "nanstd",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mksymbol.html",
    "href": "documentation/utilities/mksymbol.html",
    "title": "mksymbol",
    "section": "",
    "text": "mksymbol(f::Function, cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/utilities/mksymbol.html#source-code",
    "href": "documentation/utilities/mksymbol.html#source-code",
    "title": "mksymbol",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmksymbol(f::Function, cmd0::String; ...) - utils_types.jl:2521\nmksymbol(f::Function, arg1; kw...) - utils_types.jl:2538\nmksymbol(f::Function, cmd0::String, arg1; kwargs...) - utils_types.jl:2521\nmksymbol(f::Function; ...) - utils_types.jl:2521"
  },
  {
    "objectID": "documentation/utilities/mksymbol.html#see-also",
    "href": "documentation/utilities/mksymbol.html#see-also",
    "title": "mksymbol",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mbsvplist.html",
    "href": "documentation/utilities/mbsvplist.html",
    "title": "mbsvplist",
    "section": "",
    "text": "mbsvplist(cmd0::String=\"\"; kwargs...)\nList water sound velocity profiles in swath sonar data files."
  },
  {
    "objectID": "documentation/utilities/mbsvplist.html#parameters",
    "href": "documentation/utilities/mbsvplist.html#parameters",
    "title": "mbsvplist",
    "section": "Parameters",
    "text": "Parameters\n\nC | uniquesvp :: [Type =&gt; Bool]\nOutput the number of unique SVPs in each file.\nF | format :: [Type =&gt; Int]\nSets the format for the input swath sonar data.\nM | mode :: [Type =&gt; Int] \\(Arg = 1 or 2 or 3\\)\nSets the SVP output mode..\nS | ssv :: [Type =&gt; Bool]\nSets the minimum speed in km/hr (5.5 kts ~ 10 km/hr) allowed in the input data.\nZ | firstiszero :: [Type =&gt; Bool]\nSets the style of the plot.\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr."
  },
  {
    "objectID": "documentation/utilities/mbsvplist.html#source-code",
    "href": "documentation/utilities/mbsvplist.html#source-code",
    "title": "mbsvplist",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmbsvplist(cmd0::String; kwargs...) - mbsvplist.jl:27\nmbsvplist(; ...) - mbsvplist.jl:27"
  },
  {
    "objectID": "documentation/utilities/mbsvplist.html#see-also",
    "href": "documentation/utilities/mbsvplist.html#see-also",
    "title": "mbsvplist",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mbimport.html",
    "href": "documentation/utilities/mbimport.html",
    "title": "mbimport",
    "section": "",
    "text": "mbimport(cmd0::String=\"\", arg1=nothing, arg2=nothing, arg3=nothing; kwargs...)\nProduces a gray-shaded (or colored) map by plotting rectangles centered on each grid node and assigning them a gray-shade (or color) based on the z-value."
  },
  {
    "objectID": "documentation/utilities/mbimport.html#parameters",
    "href": "documentation/utilities/mbimport.html#parameters",
    "title": "mbimport",
    "section": "Parameters",
    "text": "Parameters\n\nA | footprint :: [Type =&gt; Str | Tuple] \\(Arg = factor/mode/depth\\)\nDetermines how the along-track dimension of the beam or pixel footprints is calculated.\nJ | proj | projection :: [Type =&gt; String]\nSelect map projection. Defaults to 15x10 cm with linear (non-projected) maps.\nC | color | colormap | cmap | colorscale :: [Type =&gt; Str] \\(Arg = [cpt |master[+izinc] |color1,color2[,*color3*,…]]\\)\nGive a CPT name or specify -Ccolor1,color2[,color3,…] to build a linear continuous CPT from those colors automatically.\nD | scaling :: [Type =&gt; Str | Tuple] \\(Arg = mode/scale/min/max\\)\nSets scaling of beam amplitude or sidescan pixel values which can be applied before plotting.\nE | dpi :: [Type =&gt; Int]\nSets the resolution of the projected image that will be created.\nG | bit_color :: [Type =&gt; Str | Tuple] \\(Arg = magnitude/azimuth or magnitude/median\\)\nSets the parameters controlng simulated illumination of bathymetry.\nS | speed :: [Type =&gt; Number]\nSets the minimum speed in km/hr (5.5 kts ~ 10 km/hr) allowed in the input data.\nT | timegap :: [Type =&gt; number]\nSets the maximum time gap in minutes between adjacent pings before being considered a gap.\nZ | type_plot :: [Type =&gt; Str | Number]\nSets the style of the plot.\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nU | time_stamp | timestamp :: [Type =&gt; Str or Bool or []] \\(Arg = [[just]/dx/dy/][c|label]\\)\nDraw GMT time stamp logo on plot.\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr.\nX | x_offset | xshift :: [Type =&gt; Str] \\(Arg = [a|c|f|r][x-shift[u]]\\)\nY | y_offset | yshift :: [Type =&gt; Str] \\(Arg = [a|c|f|r][y-shift[u]]\\)\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally append the length unit (c, i, or p).\nn | interp | interpolation :: [Type =&gt; Str] \\(Arg = [b|c|l|n][+a][+bBC][+c][+tthreshold]\\)\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation, l for bilinear interpolation, or n for nearest-neighbor value.\nt | alpha | transparency :: [Type =&gt; Str] \\(Arg = transp\\)\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]."
  },
  {
    "objectID": "documentation/utilities/mbimport.html#source-code",
    "href": "documentation/utilities/mbimport.html#source-code",
    "title": "mbimport",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmbimport(cmd0::String; kwargs...) - mbimport.jl:40\nmbimport(; ...) - mbimport.jl:40"
  },
  {
    "objectID": "documentation/utilities/mbimport.html#see-also",
    "href": "documentation/utilities/mbimport.html#see-also",
    "title": "mbimport",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mapsize2region.html",
    "href": "documentation/utilities/mapsize2region.html",
    "title": "mapsize2region",
    "section": "",
    "text": "region_opt, proj_opt = mapsize2region(proj=?, scale=?, clon=?, clat=?, width=?, height=0, bnds=\"\", plot=false)\nCompute the region for a map of user specified projection, scale, width and height."
  },
  {
    "objectID": "documentation/utilities/mapsize2region.html#source-code",
    "href": "documentation/utilities/mapsize2region.html#source-code",
    "title": "mapsize2region",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmapsize2region(; proj, scale, clon, clat, width, height, bnds, plot) - mapsize2region.jl:42\nmapsize2region(proj::String, scale::String, clon::Float64, clat::Float64, width::Float64, height::Float64, bnds) - mapsize2region.jl:56"
  },
  {
    "objectID": "documentation/utilities/mapsize2region.html#see-also",
    "href": "documentation/utilities/mapsize2region.html#see-also",
    "title": "mapsize2region",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mad.html",
    "href": "documentation/utilities/mad.html",
    "title": "mad",
    "section": "",
    "text": "MAD, median = mad(x)\nCompute the median absolute deviation (MAD) of collection x around the median\nThe MAD is multiplied by 1 / quantile(Normal(), 3/4) ≈ 1.4826, in order to obtain a consistent estimator of the standard deviation under the assumption that the data is normally distributed. Return also the median of x (used to compute the MAD) as a second output."
  },
  {
    "objectID": "documentation/utilities/mad.html#source-code",
    "href": "documentation/utilities/mad.html#source-code",
    "title": "mad",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/mad.html#see-also",
    "href": "documentation/utilities/mad.html#see-also",
    "title": "mad",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/logspace.html",
    "href": "documentation/utilities/logspace.html",
    "title": "logspace",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the logspace function."
  },
  {
    "objectID": "documentation/utilities/logspace.html#source-code",
    "href": "documentation/utilities/logspace.html#source-code",
    "title": "logspace",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlogspace(start, stop, length) - utils.jl:936\nlogspace(start, stop) - utils.jl:936"
  },
  {
    "objectID": "documentation/utilities/logspace.html#see-also",
    "href": "documentation/utilities/logspace.html#see-also",
    "title": "logspace",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/lazinfo.html",
    "href": "documentation/utilities/lazinfo.html",
    "title": "lazinfo",
    "section": "",
    "text": "lazinfo(fname::AbstractString; veronly=false)\nPrints information about the LAS file fname. If that file is a grid, report the usual grid header info."
  },
  {
    "objectID": "documentation/utilities/lazinfo.html#source-code",
    "href": "documentation/utilities/lazinfo.html#source-code",
    "title": "lazinfo",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/lazinfo.html#see-also",
    "href": "documentation/utilities/lazinfo.html#see-also",
    "title": "lazinfo",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/lasread.html",
    "href": "documentation/utilities/lasread.html",
    "title": "lasread",
    "section": "",
    "text": "out = lazread(FileName::AbstractString; out::String=\"xyz\", do_grid=false, do_image=false,\n              type::DataType=Float64, class=0, startstop=\"1:end\")\nRead data from a LIDAR laz (laszip compressed) or las format file."
  },
  {
    "objectID": "documentation/utilities/lasread.html#source-code",
    "href": "documentation/utilities/lasread.html#source-code",
    "title": "lasread",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlazread(s::GMT.Laszip.lasout_types) - lazread.jl:552\nlazread(fname::String, out::String, type::DataType, class::Int64, startstop::String, do_grid::Bool, do_img::Bool, opt_RI::String) - lazread.jl:72\nlazread(fname::AbstractString; out, type, class, startstop, kw...) - lazread.jl:62"
  },
  {
    "objectID": "documentation/utilities/lasread.html#see-also",
    "href": "documentation/utilities/lasread.html#see-also",
    "title": "lasread",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/ISOtime2unix.html",
    "href": "documentation/utilities/ISOtime2unix.html",
    "title": "ISOtime2unix",
    "section": "",
    "text": "t = ISOtime2unix(ts::AbstractString) -&gt; Float64\nTake a string representing a time and return the equivalent Unix time. The ts string may take one of these forms:"
  },
  {
    "objectID": "documentation/utilities/ISOtime2unix.html#source-code",
    "href": "documentation/utilities/ISOtime2unix.html#source-code",
    "title": "ISOtime2unix",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/ISOtime2unix.html#see-also",
    "href": "documentation/utilities/ISOtime2unix.html#see-also",
    "title": "ISOtime2unix",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/ind2bool.html",
    "href": "documentation/utilities/ind2bool.html",
    "title": "ind2bool",
    "section": "",
    "text": "Category: Utilities\nConvert indices to boolean array."
  },
  {
    "objectID": "documentation/utilities/ind2bool.html#description",
    "href": "documentation/utilities/ind2bool.html#description",
    "title": "ind2bool",
    "section": "Description",
    "text": "Description\nThe ind2bool function Convert indices to boolean array."
  },
  {
    "objectID": "documentation/utilities/ind2bool.html#source-code",
    "href": "documentation/utilities/ind2bool.html#source-code",
    "title": "ind2bool",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nind2bool(indices::Vector{&lt;:Integer}, maxind::Int64) - utils.jl:122\nind2bool(indices::Vector{&lt;:Integer}) - utils.jl:122"
  },
  {
    "objectID": "documentation/utilities/ind2bool.html#see-also",
    "href": "documentation/utilities/ind2bool.html#see-also",
    "title": "ind2bool",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/groupby.html",
    "href": "documentation/utilities/groupby.html",
    "title": "groupby",
    "section": "",
    "text": "Dv = groupby(D::GMTdataset, col)::Vector{GMTdataset}\nSplit a GMTdataset by the unique values of the column selected by col.\ncol can be a column name, either as a String or a Symbol, or a column number. In any case, it must point to a column with integers (normaly a flint (Floating Point Integer)), or a string column. i.e., the last column in a GMTdataset."
  },
  {
    "objectID": "documentation/utilities/groupby.html#source-code",
    "href": "documentation/utilities/groupby.html#source-code",
    "title": "groupby",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/groupby.html#see-also",
    "href": "documentation/utilities/groupby.html#see-also",
    "title": "groupby",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/Gouterjoin.html",
    "href": "documentation/utilities/Gouterjoin.html",
    "title": "Gouterjoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Gouterjoin function."
  },
  {
    "objectID": "documentation/utilities/Gouterjoin.html#source-code",
    "href": "documentation/utilities/Gouterjoin.html#source-code",
    "title": "Gouterjoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Gouterjoin.html#see-also",
    "href": "documentation/utilities/Gouterjoin.html#see-also",
    "title": "Gouterjoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/Ginnerjoin.html",
    "href": "documentation/utilities/Ginnerjoin.html",
    "title": "Ginnerjoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Ginnerjoin function."
  },
  {
    "objectID": "documentation/utilities/Ginnerjoin.html#source-code",
    "href": "documentation/utilities/Ginnerjoin.html#source-code",
    "title": "Ginnerjoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Ginnerjoin.html#see-also",
    "href": "documentation/utilities/Ginnerjoin.html#see-also",
    "title": "Ginnerjoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/getprovider.html",
    "href": "documentation/utilities/getprovider.html",
    "title": "getprovider",
    "section": "",
    "text": "getprovider(name, zoom::Int; variant=\"\", date::String=\"\", key::String=\"\")\nGet information about a tile provider given its name and zoom level. The returned information is only relevant for internal use and is an implementation detail not documented here."
  },
  {
    "objectID": "documentation/utilities/getprovider.html#source-code",
    "href": "documentation/utilities/getprovider.html#source-code",
    "title": "getprovider",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngetprovider(name::Tuple{String, String}, zoom::Int64; date, key) - imgtiles.jl:564\ngetprovider(name::Union{AbstractString, Symbol}, zoom::Int64; variant, format, ZYX, dir_code, date, key) - imgtiles.jl:565\ngetprovider(arg, zoom::Int64; date, key) - imgtiles.jl:624"
  },
  {
    "objectID": "documentation/utilities/getprovider.html#see-also",
    "href": "documentation/utilities/getprovider.html#see-also",
    "title": "getprovider",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/Gantijoin.html",
    "href": "documentation/utilities/Gantijoin.html",
    "title": "Gantijoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Gantijoin function."
  },
  {
    "objectID": "documentation/utilities/Gantijoin.html#source-code",
    "href": "documentation/utilities/Gantijoin.html#source-code",
    "title": "Gantijoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Gantijoin.html#see-also",
    "href": "documentation/utilities/Gantijoin.html#see-also",
    "title": "Gantijoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/fliplr.html",
    "href": "documentation/utilities/fliplr.html",
    "title": "fliplr",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the fliplr function."
  },
  {
    "objectID": "documentation/utilities/fliplr.html#source-code",
    "href": "documentation/utilities/fliplr.html#source-code",
    "title": "fliplr",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfliplr(I::GMTimage) - grd_operations.jl:451\nfliplr(G::GMTgrid) - grd_operations.jl:449\nfliplr(A) - utils.jl:940"
  },
  {
    "objectID": "documentation/utilities/fliplr.html#see-also",
    "href": "documentation/utilities/fliplr.html#see-also",
    "title": "fliplr",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/fileparts.html",
    "href": "documentation/utilities/fileparts.html",
    "title": "fileparts",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the fileparts function."
  },
  {
    "objectID": "documentation/utilities/fileparts.html#source-code",
    "href": "documentation/utilities/fileparts.html#source-code",
    "title": "fileparts",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/fileparts.html#see-also",
    "href": "documentation/utilities/fileparts.html#see-also",
    "title": "fileparts",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/eulermat.html",
    "href": "documentation/utilities/eulermat.html",
    "title": "eulermat",
    "section": "",
    "text": "R = eulermat(a) -&gt; Matrix{Float64}\nCompute the Euler rotation matrix that rotates by angles a (in degrees) about the x, y and z axes."
  },
  {
    "objectID": "documentation/utilities/eulermat.html#source-code",
    "href": "documentation/utilities/eulermat.html#source-code",
    "title": "eulermat",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\neulermat(; rx, ry, rz) - solids.jl:563\neulermat(a) - solids.jl:564"
  },
  {
    "objectID": "documentation/utilities/eulermat.html#see-also",
    "href": "documentation/utilities/eulermat.html#see-also",
    "title": "eulermat",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/ds2df.html",
    "href": "documentation/utilities/ds2df.html",
    "title": "ds2df",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the ds2df function."
  },
  {
    "objectID": "documentation/utilities/ds2df.html#source-code",
    "href": "documentation/utilities/ds2df.html#source-code",
    "title": "ds2df",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/ds2df.html#see-also",
    "href": "documentation/utilities/ds2df.html#see-also",
    "title": "ds2df",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/cubeslice.html",
    "href": "documentation/utilities/cubeslice.html",
    "title": "cubeslice",
    "section": "",
    "text": "slicecube(I::GMTimage, layer::Union{Int, AbstractVector{&lt;:Int}})\nTake a slice of a multylayer GMTimage. Return the result still as a GMTimage. layer is the z slice number.\nExtract a slice from a GMTgrid cube.\nTake a slice of a GMTgrid or GMTimage in an oblique direction. Take the cube’s layer slice and rotate it by angle degrees about the axis. This one can only be axis=:x or axis=:y. Depending on the data type of input a different output is produces. If GI is a GMTgrid, the output is 2 GMTgrids: one with z levels and the other with cube’s z levels along that plane. On the other hand, if GI isa GMTimage the first output is similar to previus case but the second will be a GMTimage. In this case the cmap option may be used to assign a colortable to the image type.\nThe value at the slice point, P(x[i,j], y[i,j], z[i, j)), is the interpolated value of the two nearest voxels on the same vertical."
  },
  {
    "objectID": "documentation/utilities/cubeslice.html#source-code",
    "href": "documentation/utilities/cubeslice.html#source-code",
    "title": "cubeslice",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nslicecube(GI::GItype; slice, α, angle, axis, cmap) - utils_types.jl:1702\nslicecube(G::GMTgrid{T, 3}, slice::AbstractFloat; axis, x, y) where T - utils_types.jl:1661\nslicecube(G::GMTgrid{T, 3}, slice::Union{Int64, AbstractVector{&lt;:Int64}}; axis, x, y) where T - utils_types.jl:1607\nslicecube(I::GMTimage{T, 3}, layer::Union{Int64, AbstractVector{&lt;:Int64}}) where T - utils_types.jl:1589"
  },
  {
    "objectID": "documentation/utilities/cubeslice.html#see-also",
    "href": "documentation/utilities/cubeslice.html#see-also",
    "title": "cubeslice",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/circlepts.html",
    "href": "documentation/utilities/circlepts.html",
    "title": "circlepts",
    "section": "",
    "text": "xy = circlepts(r=1.0; center=(0.0, 0.0), ang1=0.0, ang2=360.0, np=72)\nCreate an circle in 2D space (see ellipse3D if want a circle in the 3D space)."
  },
  {
    "objectID": "documentation/utilities/circlepts.html#source-code",
    "href": "documentation/utilities/circlepts.html#source-code",
    "title": "circlepts",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncirclepts(; ...) - solids.jl:539\ncirclepts(r; center, ang1, ang2, np) - solids.jl:539"
  },
  {
    "objectID": "documentation/utilities/circlepts.html#see-also",
    "href": "documentation/utilities/circlepts.html#see-also",
    "title": "circlepts",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/bezier.html",
    "href": "documentation/utilities/bezier.html",
    "title": "bezier",
    "section": "",
    "text": "Db = bezier(D::GMTdataset; t=nothing, np::Int=0, pure=false, firstcurve=true) -&gt; GMTdataset\nCreate a Bezier curve from a set of control points.\nA function for cubic Bezier interpolation for a given set of control points (knots). Each control point can exist in an N-dimensional space but only tested 2D and 3D cases. Data can be geographic or Cartesian. The default for this function is to compute a curve that passes through the control points. This can be changed by setting pure to true and then we instead compute a curve that passes through the first and last.\nWhen more than 4 control points are provided, we make a curve composition by connecting the first curve, made with points 1,2,3,4, second curve, made with points 2,3,4,5 and so on. The way this connection is made is controlled by the firstcurve argument. With more than 4 control points, the pure option is not allowed."
  },
  {
    "objectID": "documentation/utilities/bezier.html#source-code",
    "href": "documentation/utilities/bezier.html#source-code",
    "title": "bezier",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbezier(p::Matrix{&lt;:Real}; t, np, pure, firstcurve) - beziers.jl:109\nbezier(p1::Vector{T}, p2::Vector{T}, p3::Vector{T}, p4::Vector{T}; t, np, pure) where T&lt;:Real - beziers.jl:80\nbezier(D::GMTdataset; t, np, pure, firstcurve) - beziers.jl:61"
  },
  {
    "objectID": "documentation/utilities/bezier.html#see-also",
    "href": "documentation/utilities/bezier.html#see-also",
    "title": "bezier",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/autocor.html",
    "href": "documentation/utilities/autocor.html",
    "title": "autocor",
    "section": "",
    "text": "autocor(x, [lags]; demean=true)\nCompute the autocorrelation function (ACF) of a vector or matrix x, optionally specifying the lags. demean denotes whether the mean of x should be subtracted from x before computing the ACF.\nIf x is a vector, return a vector of the same length as lags. If x is a matrix, return a matrix of size (length(lags), size(x,2)), where each column in the result corresponds to a column in x.\nWhen left unspecified, the lags used are the integers from 0 to min(size(x,1)-1, 10*log10(size(x,1))).\nThe output is normalized by the variance of x, i.e. so that the lag 0 autocorrelation is 1. See autocov for the unnormalized form."
  },
  {
    "objectID": "documentation/utilities/autocor.html#source-code",
    "href": "documentation/utilities/autocor.html#source-code",
    "title": "autocor",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nautocor(x::AbstractVecOrMat{&lt;:Real}; demean) - signalcorr.jl:390\nautocor(x::AbstractMatrix{&lt;:Real}, lags::AbstractVector{&lt;:Integer}; demean) - signalcorr.jl:385\nautocor(x::AbstractVector{&lt;:Real}, lags::AbstractVector{&lt;:Integer}; demean) - signalcorr.jl:380"
  },
  {
    "objectID": "documentation/utilities/autocor.html#see-also",
    "href": "documentation/utilities/autocor.html#see-also",
    "title": "autocor",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/zonal_stats.html",
    "href": "documentation/utilities/zonal_stats.html",
    "title": "zonal_stats",
    "section": "",
    "text": "zonal_statistics(GI::GItype, shapes::GDtype, fun::Function; touches=false, byfeatures=false, groupby=\"\")\nor\nor zonal_stats(...)\nCompute the statistics of fun applied to the elements of the grid or image GI that lie inside the polygons of the GMTdataset shapes."
  },
  {
    "objectID": "documentation/utilities/zonal_stats.html#source-code",
    "href": "documentation/utilities/zonal_stats.html#source-code",
    "title": "zonal_stats",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nzonal_statistics(GI::GItype, shapes::GDtype, fun::Function; touches, byfeatures, groupby) - rasterpolygonfuns.jl:192\nzonal_statistics(fun::Function, GI::GItype, shapes::GDtype; touches, byfeatures, groupby) - rasterpolygonfuns.jl:190"
  },
  {
    "objectID": "documentation/utilities/worldrectgrid.html",
    "href": "documentation/utilities/worldrectgrid.html",
    "title": "worldrectgrid",
    "section": "",
    "text": "grat = worldrectgrid(GI; width=(30,20), grid=nothing, annot_x=nothing)\n\nor\n\ngrat = worldrectgrid(; proj=\"projection\", width=(30,20), grid=nothing, annot_x=nothing)\nCreate a grid of lines (graticules) in projected coordinates. The projection system is extracted from the GI metadata."
  },
  {
    "objectID": "documentation/utilities/worldrectgrid.html#returns",
    "href": "documentation/utilities/worldrectgrid.html#returns",
    "title": "worldrectgrid",
    "section": "Returns",
    "text": "Returns\nA Vector of GMTdataset containing the projected meridians and parallels. grat[i] attributes store information about that element lon,lat."
  },
  {
    "objectID": "documentation/utilities/worldrectgrid.html#see-also",
    "href": "documentation/utilities/worldrectgrid.html#see-also",
    "title": "worldrectgrid",
    "section": "See Also",
    "text": "See Also\ncoastlinesproj, graticules, [plotgrid!], worldrectangular, worldrectcoast, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/worldrectgrid.html#source-code",
    "href": "documentation/utilities/worldrectgrid.html#source-code",
    "title": "worldrectgrid",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nworldrectgrid(; proj, width, grid, annot_x, pm, worldrect, pad) - utils_project.jl:344\nworldrectgrid(D::GDtype; width, grid, annot_x, worldrect) - utils_project.jl:339\nworldrectgrid(G_I::GItype; width, grid, annot_x, worldrect) - utils_project.jl:334"
  },
  {
    "objectID": "documentation/utilities/worldrectangular.html",
    "href": "documentation/utilities/worldrectangular.html",
    "title": "worldrectangular",
    "section": "",
    "text": "GI[,coast] = worldrectangular(fname::String|GI::GItype; proj::String=\"+proj=vandg\", pm=0, latlim=:auto, coast=false)\nTry to create a rectangular map out miscellaneous and not cylindrical projections. We say try because only some projections are supported and those depend on the GDAL version. So a (slow) moving target."
  },
  {
    "objectID": "documentation/utilities/worldrectangular.html#returns",
    "href": "documentation/utilities/worldrectangular.html#returns",
    "title": "worldrectangular",
    "section": "Returns",
    "text": "Returns\nA grid or a image and optionally the coastlines … or errors. Not many projections support the procedure implemented in this function. The working or not is controlled by PROJ’s +over option"
  },
  {
    "objectID": "documentation/utilities/worldrectangular.html#example",
    "href": "documentation/utilities/worldrectangular.html#example",
    "title": "worldrectangular",
    "section": "Example",
    "text": "Example\n\nusing GMT\nresetGMT()  # hide\nG = worldrectangular(\"@earth_relief_10m\");\nviz(G)"
  },
  {
    "objectID": "documentation/utilities/worldrectangular.html#see-also",
    "href": "documentation/utilities/worldrectangular.html#see-also",
    "title": "worldrectangular",
    "section": "See Also",
    "text": "See Also\ncoastlinesproj, graticules, leepacific, [plotgrid!], worldrectgrid, worldrectcoast, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/worldrectangular.html#source-code",
    "href": "documentation/utilities/worldrectangular.html#source-code",
    "title": "worldrectangular",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nworldrectangular(fname::String; proj, pm, latlim, latlims, pad, coast) - utils_project.jl:71\nworldrectangular(GI::GItype; proj, pm, latlim, latlims, pad, coast) - utils_project.jl:73"
  },
  {
    "objectID": "documentation/utilities/wmsread.html",
    "href": "documentation/utilities/wmsread.html",
    "title": "wmsread",
    "section": "",
    "text": "wmsread(wms::WMS; layer, kwargs...)\nRead the layer number provided by the service from which the wms type was created."
  },
  {
    "objectID": "documentation/utilities/wmsread.html#returns",
    "href": "documentation/utilities/wmsread.html#returns",
    "title": "wmsread",
    "section": "Returns",
    "text": "Returns\nA GMTimage"
  },
  {
    "objectID": "documentation/utilities/wmsread.html#examples",
    "href": "documentation/utilities/wmsread.html#examples",
    "title": "wmsread",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nwms = wmsinfo(\"http://tiles.maps.eox.at/wms?\")\nimg = wmsread(wms, layer=3, region=(-10,-5,37,44), pixelsize=500);\n\n# Retrieve and display a MODIS image\nwms = wmsinfo(\"https://gibs-c.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi\");\nimg = wmsread(wms, layer=\"MODIS_Terra_CorrectedReflectance_TrueColor\", region=(9,22,32,43), time=\"2021-10-29T00:00:00\", pixelsize=750);\nimshow(img, proj=:guess)\n\n\n\n\n\n\n\n\nSee the result of the above example at Web Map Service"
  },
  {
    "objectID": "documentation/utilities/wmsread.html#see-also",
    "href": "documentation/utilities/wmsread.html#see-also",
    "title": "wmsread",
    "section": "See Also",
    "text": "See Also\nwmsinfo, wmstest"
  },
  {
    "objectID": "documentation/utilities/wmsread.html#source-code",
    "href": "documentation/utilities/wmsread.html#source-code",
    "title": "wmsread",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/whereami.html",
    "href": "documentation/utilities/whereami.html",
    "title": "whereami",
    "section": "",
    "text": "D = whereami() -&gt; GMTdataset\nShows your current location plus some additional information (Timezone, Country, City, Zip, IP address)."
  },
  {
    "objectID": "documentation/utilities/whereami.html#examples",
    "href": "documentation/utilities/whereami.html#examples",
    "title": "whereami",
    "section": "Examples",
    "text": "Examples\njulia&gt; whereami()\nAttribute table\n┌───────────┬───────────────┬───────────────┬──────────┬──────────┬────────┐\n│      City │      Timezone │            IP │      Zip │  Country │ Region │\n├───────────┼───────────────┼───────────────┼──────────┼──────────┼────────┤\n│ Quarteira │ Europe/Lisbon │ 95.92.214.205 │ 8125-168 │ Portugal │   Faro │\n└───────────┴───────────────┴───────────────┴──────────┴──────────┴────────┘\nBoundingBox: [-8.1026, -8.1026, 37.0658, 37.0658]\n\n1×2 GMTdataset{Float64, 2}\n Row │     Lon      Lat\n─────┼──────────────────\n   1 │ -8.1026  37.0658\n│ Quarteira │ Europe/Lisbon │ 95.92.214.205 │ 8125-168 │ Portugal │ Faro │ └───────────┴───────────────┴───────────────┴──────────┴──────────┴────────┘ BoundingBox: [-8.1026, -8.1026, 37.0658, 37.0658]\n1×2 GMTdataset{Float64, 2} Row │ Lon Lat ─────┼────────────────── 1 │ -8.1026 37.0658 ```"
  },
  {
    "objectID": "documentation/utilities/whereami.html#source-code",
    "href": "documentation/utilities/whereami.html#source-code",
    "title": "whereami",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/vlines.html",
    "href": "documentation/utilities/vlines.html",
    "title": "vlines",
    "section": "",
    "text": "vlines(arg; decorated=(...), xmin=NaN, xmax=NaN, percent=false, kwargs...)\nPlots one or a collection of vertical lines with eventual decorations"
  },
  {
    "objectID": "documentation/utilities/vlines.html#examples",
    "href": "documentation/utilities/vlines.html#examples",
    "title": "vlines",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nplot(rand(5,3), region=[0,1,0,1])\nvlines!([0.2, 0.6], pen=(1, :red), show=true)"
  },
  {
    "objectID": "documentation/utilities/vlines.html#see-also",
    "href": "documentation/utilities/vlines.html#see-also",
    "title": "vlines",
    "section": "See Also",
    "text": "See Also\nhlines, plot"
  },
  {
    "objectID": "documentation/utilities/vlines.html#source-code",
    "href": "documentation/utilities/vlines.html#source-code",
    "title": "vlines",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nvlines(; ...) - plot.jl:1484\nvlines(arg1; first, ymin, ymax, percent, kwargs...) - plot.jl:1484"
  },
  {
    "objectID": "documentation/utilities/uniqueind.html",
    "href": "documentation/utilities/uniqueind.html",
    "title": "uniqueind",
    "section": "",
    "text": "ind = uniqueind(x)\nReturn the index ind such that x[ind] gets the unique values of x. No sorting is done"
  },
  {
    "objectID": "documentation/utilities/uniqueind.html#source-code",
    "href": "documentation/utilities/uniqueind.html#source-code",
    "title": "uniqueind",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/theme.html",
    "href": "documentation/utilities/theme.html",
    "title": "theme",
    "section": "",
    "text": "theme(name; kwrgs...)\nOffer themes support. name is the theme name. So far the three options are:\nOn top of the modern mode variations (so far dark only) one can set the following kwargs options:\nNote: Except save and reset, the changes operated by the kwargs are temporary and operate only until an image is show(n) or saved.\nThis function can be called alone, e.g. theme(\"dark\") or as an option in the plot module."
  },
  {
    "objectID": "documentation/utilities/theme.html#source-code",
    "href": "documentation/utilities/theme.html#source-code",
    "title": "theme",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntheme(; ...) - themes.jl:32\ntheme(name; kwargs...) - themes.jl:32"
  },
  {
    "objectID": "documentation/utilities/surf2fv.html",
    "href": "documentation/utilities/surf2fv.html",
    "title": "surf2fv",
    "section": "",
    "text": "FV = surf2fv(X::Matrix{T}, Y::Matrix{T}, Z::Matrix{T}; type=:tri, bfculling=true,\n             proj=\"\", proj4=\"\", wkt=\"\", epsg=0, top=nothing, bottom=nothing)::GMTfv\nCreate a three-dimensional FacesVertices object.\nThis function is suitable for 3D plotting either of closed bodies or 3D surfaces. The values in matrix Z represent the heights above a grid in the x-y plane defined by X and Y"
  },
  {
    "objectID": "documentation/utilities/surf2fv.html#example",
    "href": "documentation/utilities/surf2fv.html#example",
    "title": "surf2fv",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\nX,Y = meshgrid(1:0.5:10,1.:20);\nZ = sin.(X) .+ cos.(Y);\nFV = surf2fv(X, Y, Z);\nviz(FV)\n\n\n┌ Warning: More than 2/3 of the faces found invisible (actually: 74.26900584795322%). This often indicates that the Z and X,Y units are not the same. Consider setting `bfculling` to false or use the `nocull=true` option, or using the `zscale` field of the `FV` input.\n\n└ @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\psxy.jl:1567"
  },
  {
    "objectID": "documentation/utilities/surf2fv.html#see-also",
    "href": "documentation/utilities/surf2fv.html#see-also",
    "title": "surf2fv",
    "section": "See Also",
    "text": "See Also\nextrude, flatfv, fv2fv, loft, grid2tri, revolve"
  },
  {
    "objectID": "documentation/utilities/surf2fv.html#source-code",
    "href": "documentation/utilities/surf2fv.html#source-code",
    "title": "surf2fv",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/stereonet.html",
    "href": "documentation/utilities/stereonet.html",
    "title": "stereonet",
    "section": "",
    "text": "stereonet(mat::AbstractArray{T,2}; schmidt=true, wulff=false, kw...) where T&lt;:Real\nPlot a stereonet map in either Schmidt or Wulff projection.\nIn case the produced figure is still not satisfactory, you can make one by yourself. For that use the Dv, Dp = stereonet_data(mat) function to get the fault planes and poles. A good place to start is the stereonet function itself. Type @edit GMT.stereonet([0 0]) to see the code."
  },
  {
    "objectID": "documentation/utilities/stereonet.html#example",
    "href": "documentation/utilities/stereonet.html#example",
    "title": "stereonet",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\nstereonet([90 30; 180 45; 270 60; 0 15; 30 45; 120 48; 225 27; 350 80], show=true)"
  },
  {
    "objectID": "documentation/utilities/stereonet.html#see-also",
    "href": "documentation/utilities/stereonet.html#see-also",
    "title": "stereonet",
    "section": "See Also",
    "text": "See Also\nmeca"
  },
  {
    "objectID": "documentation/utilities/stereonet.html#source-code",
    "href": "documentation/utilities/stereonet.html#source-code",
    "title": "stereonet",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/sphere.html",
    "href": "documentation/utilities/sphere.html",
    "title": "sphere",
    "section": "",
    "text": "FV = sphere(r=1; radius=1.0, n=1, center=(0.0, 0.0, 0.0))::GMTfv\nCreate a triangulated geodesic sphere.\nGenerates a geodesic sphere triangulation based on the number of refinement iterations n and the radius r. Geodesic spheres (aka Buckminster-Fuller spheres) are triangulations of a sphere that have near uniform edge lenghts. The algorithm starts with a regular icosahedron. Next this icosahedron is refined n times, while nodes are pushed to a sphere surface with radius r at each iteration."
  },
  {
    "objectID": "documentation/utilities/sphere.html#example",
    "href": "documentation/utilities/sphere.html#example",
    "title": "sphere",
    "section": "Example",
    "text": "Example\nCreate a sphere with radius = 1, and two iterations.\n\nusing GMT\n\nFV = sphere(n=2);\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/sphere.html#see-also",
    "href": "documentation/utilities/sphere.html#see-also",
    "title": "sphere",
    "section": "See Also",
    "text": "See Also\ncube, cylinder, dodecahedron, icosahedron, octahedron, replicant, tetrahedron, torus,"
  },
  {
    "objectID": "documentation/utilities/sphere.html#source-code",
    "href": "documentation/utilities/sphere.html#source-code",
    "title": "sphere",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsphere(; ...) - solids.jl:262\nsphere(r; n, radius, center) - solids.jl:262"
  },
  {
    "objectID": "documentation/utilities/slicecube.html",
    "href": "documentation/utilities/slicecube.html",
    "title": "slicecube",
    "section": "",
    "text": "slicecube(I::GMTimage, layer::Union{Int, AbstractVector{&lt;:Int}})\nTake a slice of a multi-layer GMTimage. Return the result still as a GMTimage. layer is the z slice number.\nExtract a slice from a GMTgrid cube.\nTake a slice of a GMTgrid or GMTimage in an oblique direction. Take the cube’s layer slice and rotate it by angle degrees about the axis. This one can only be axis=:x or axis=:y. Depending on the data type of input a different output is produces. If GI is a GMTgrid, the output is 2 GMTgrids: one with z levels and the other with cube’s z levels along that plane. On the other hand, if GI isa GMTimage the first output is similar to previus case but the second will be a GMTimage. In this case the cmap option may be used to assign a colortable to the image type.\nThe value at the slice point, P(x[i,j], y[i,j], z[i,j]), is the interpolated value of the two nearest voxels on the same vertical."
  },
  {
    "objectID": "documentation/utilities/slicecube.html#examples",
    "href": "documentation/utilities/slicecube.html#examples",
    "title": "slicecube",
    "section": "Examples",
    "text": "Examples\nGet the fourth layer of the multi-layered I GMTimage object\nI = slicecube(I, 4)"
  },
  {
    "objectID": "documentation/utilities/slicecube.html#see-also",
    "href": "documentation/utilities/slicecube.html#see-also",
    "title": "slicecube",
    "section": "See Also",
    "text": "See Also\ncubeplot, xyzw2cube"
  },
  {
    "objectID": "documentation/utilities/slicecube.html#source-code",
    "href": "documentation/utilities/slicecube.html#source-code",
    "title": "slicecube",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nslicecube(GI::GItype; slice, α, angle, axis, cmap) - utils_types.jl:1702\nslicecube(G::GMTgrid{T, 3}, slice::AbstractFloat; axis, x, y) where T - utils_types.jl:1661\nslicecube(G::GMTgrid{T, 3}, slice::Union{Int64, AbstractVector{&lt;:Int64}}; axis, x, y) where T - utils_types.jl:1607\nslicecube(I::GMTimage{T, 3}, layer::Union{Int64, AbstractVector{&lt;:Int64}}) where T - utils_types.jl:1589"
  },
  {
    "objectID": "documentation/utilities/revolve.html",
    "href": "documentation/utilities/revolve.html",
    "title": "revolve",
    "section": "",
    "text": "FV = revolve(curve::Matrix{Real}; extent = 360, ang1=0, ang2=360, dir=:positive, n=[0.0,0.0,1.0], n_steps=0, closed=true, type=:quad)::GMTfv\nRevolve curves to build surfaces.\nThis function rotates the curve curve by the angle extent, in the direction defined by direction (:positive, :negative, :both), around the vector n, to build the output mesh defined as a Faces-Vertices type."
  },
  {
    "objectID": "documentation/utilities/revolve.html#example",
    "href": "documentation/utilities/revolve.html#example",
    "title": "revolve",
    "section": "Example",
    "text": "Example\nCreate a surface by revolving a curve.\n\nusing GMT\n    \nns=15; x=linspace(0,2*pi,ns).+1; y=zeros(size(x)); z=-cos.(x); curve=[x[:] y[:] z[:]];\nFV = revolve(curve)\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/revolve.html#see-also",
    "href": "documentation/utilities/revolve.html#see-also",
    "title": "revolve",
    "section": "See Also",
    "text": "See Also\nextrude, flatfv, fv2fv, loft, grid2tri, surf2fv"
  },
  {
    "objectID": "documentation/utilities/revolve.html#source-code",
    "href": "documentation/utilities/revolve.html#source-code",
    "title": "revolve",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/replicant.html",
    "href": "documentation/utilities/replicant.html",
    "title": "replicant",
    "section": "",
    "text": "D = replicant(FV, kwargs...)::Vector{GMTdataset}\nTake a Faces-Vertices dataset describing a 3D body and replicate it N number of times with the option of assigning different colors and scales to each copy. The end result is a single Vector{GMTdataset} with the replicated body."
  },
  {
    "objectID": "documentation/utilities/replicant.html#example",
    "href": "documentation/utilities/replicant.html#example",
    "title": "replicant",
    "section": "Example",
    "text": "Example\n\nusing GMT\n    \nFV = sphere();\nD  = replicant(FV, replicate=(centers=rand(10,3), scales=0.1));\n\n# or, to plot them\nviz(FV, replicate=(centers=rand(10,3)*10, scales=0.2))"
  },
  {
    "objectID": "documentation/utilities/replicant.html#see-also",
    "href": "documentation/utilities/replicant.html#see-also",
    "title": "replicant",
    "section": "See Also",
    "text": "See Also\nextrude, flatfv, fv2fv, grid2tri, revolve, surf2fv"
  },
  {
    "objectID": "documentation/utilities/replicant.html#source-code",
    "href": "documentation/utilities/replicant.html#source-code",
    "title": "replicant",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nreplicant(FV::GMTfv, d::Dict{Symbol, Any}) - psxy.jl:1685\nreplicant(FV::GMTfv; kwargs...) - psxy.jl:1678"
  },
  {
    "objectID": "documentation/utilities/regiongeog.html",
    "href": "documentation/utilities/regiongeog.html",
    "title": "regiongeog",
    "section": "",
    "text": "regiongeog(GI) --&gt; Tuple{Float64}\nReturns a tuple with (lonmin, lonmax, latmin, latmax) of the projected GI object limits converted to geographic coordinates. Returns an empty tuple if GI has no registered referencing system. GI can either a GMTgrid, a GMTimage or a file name (String) of one those types."
  },
  {
    "objectID": "documentation/utilities/regiongeog.html#source-code",
    "href": "documentation/utilities/regiongeog.html#source-code",
    "title": "regiongeog",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nregiongeog(fname::String) - common_options.jl:4630\nregiongeog(GI::GItype) - common_options.jl:4625"
  },
  {
    "objectID": "documentation/utilities/polygonlevels.html",
    "href": "documentation/utilities/polygonlevels.html",
    "title": "polygonlevels",
    "section": "",
    "text": "zvals = polygonlevels(D::GDtype, ids::VecOrMat{String}, vals::Vector{&lt;:Real}; kw...) -&gt; Vector{Float64}\n\nor\n\nzvals = polygonlevels(D::GDtype, idvals::GMTdataset; kw...) -&gt; Vector{Float64}\nCreates a vector with zvals to use in plot when creating choropleth maps and where length(zvals) == length(D).\nReturns a Vector{Float64} with the same length as the number of segments in D. Its content are made up from the contents of vals but may be repeated such that each polygon of the same family, i.e. with the same ids, has the same value."
  },
  {
    "objectID": "documentation/utilities/polygonlevels.html#examples",
    "href": "documentation/utilities/polygonlevels.html#examples",
    "title": "polygonlevels",
    "section": "Examples",
    "text": "Examples\nRealy need to provide one"
  },
  {
    "objectID": "documentation/utilities/polygonlevels.html#see-also",
    "href": "documentation/utilities/polygonlevels.html#see-also",
    "title": "polygonlevels",
    "section": "See Also",
    "text": "See Also\ninwhichpolygon, getbyattrib, coast, [plot3]"
  },
  {
    "objectID": "documentation/utilities/polygonlevels.html#source-code",
    "href": "documentation/utilities/polygonlevels.html#source-code",
    "title": "polygonlevels",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npolygonlevels(D::Vector{&lt;:GMTdataset}, user_ids::Matrix{&lt;:AbstractString}, vals::Vector{&lt;:Real}; kw...) - spatial_funs.jl:79\npolygonlevels(D::Vector{&lt;:GMTdataset}, user_ids::Vector{&lt;:AbstractString}, vals::Vector{&lt;:Real}; kw...) - spatial_funs.jl:51\npolygonlevels(D::Vector{&lt;:GMTdataset}, user_ids::VecOrMat{&lt;:AbstractString}, vals; kw...) - spatial_funs.jl:42\npolygonlevels(D::Vector{&lt;:GMTdataset}, id_vals::GMTdataset; kw...) - spatial_funs.jl:37"
  },
  {
    "objectID": "documentation/utilities/plotlinefit.html",
    "href": "documentation/utilities/plotlinefit.html",
    "title": "plotlinefit",
    "section": "",
    "text": "plotlinefit(D::GMTdataset, kwargs...)\nPlot the line fit of the points in the D GMTdataset type including confidence intervals and error ellipses. The D input is the result of having run your data through the linearfitxy function. See its docs for the meaning of the parameters mentioned below.\nOther than the above options you can use most of the plot options that control line and marker symbol."
  },
  {
    "objectID": "documentation/utilities/plotlinefit.html#examples",
    "href": "documentation/utilities/plotlinefit.html#examples",
    "title": "plotlinefit",
    "section": "Examples",
    "text": "Examples\nusing GMT\n\nplotlinefit(D, band_ab=true, band_ci=true, legend=true, show=1)"
  },
  {
    "objectID": "documentation/utilities/plotlinefit.html#source-code",
    "href": "documentation/utilities/plotlinefit.html#source-code",
    "title": "plotlinefit",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nplotlinefit(D::GMTdataset; first, grp, kw...) - linefit.jl:218\nplotlinefit(m::Matrix{&lt;:Real}; first, grp, kw...) - linefit.jl:217\nplotlinefit(D::Vector{&lt;:GMTdataset}; first, kw...) - linefit.jl:177"
  },
  {
    "objectID": "documentation/utilities/plotlinefit.html#see-also",
    "href": "documentation/utilities/plotlinefit.html#see-also",
    "title": "plotlinefit",
    "section": "See Also",
    "text": "See Also\nlinearfitxy, plot\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/pcolor.html",
    "href": "documentation/utilities/pcolor.html",
    "title": "pcolor",
    "section": "",
    "text": "pcolor(X, Y, C::Matrix{&lt;:Real}; kwargs...)\nCreates a colored cells plot using the values in matrix C. The color of each cell depends on the value of each value of C after consulting a color table (cpt). If a color table is not provided via option cmap=xxx we compute a default one.\nThis form, that is without a color matrix, accepts X and Y as before but returns the tiles in a vector of GMTdatasets. Use the kwargs option to pass for example a projection setting (as for example proj=:geo).\nThis form takes a grid (or the file name of one) as input an paints it’s cell with a constant color."
  },
  {
    "objectID": "documentation/utilities/pcolor.html#examples",
    "href": "documentation/utilities/pcolor.html#examples",
    "title": "pcolor",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nG = GMT.peaks(N=21);  # Create an example grid\npcolor(G, outline=(0.5,:dot), show=true)\n\n\n\n\n\n\n\n\nNow use the G x,y coordinates in the non-regular form\n\nusing GMT\n\npcolor(G.x, G.y, G.z, show=true)\n\n\n\n\n\n\n\n\nAdd labels to cells using default settings (font size = 6p)\n\nusing GMT\n\npcolor(G.x, G.y, G.z, labels=:y, show=true)\n\n\n\n\n\n\n\n\nSimilar to above but now set the number of decimlas in labels as well as it font settings\n\nusing GMT\n\npcolor(G.x, G.y, G.z, labels=2, font=(angle=45, font=(5,:red)), show=1)\n\n\n\n\n\n\n\n\nDisplay a Pearson’s correlation matrix\n\nusing GMT\n\npcolor(GMT.cor(rand(4,4)), labels=:y, colorbar=1, show=true)\n\n\n\n\n\n\n\n\nAn irregular grid\n\nusing GMT\n\nX,Y = GMT.meshgrid(-3:6/17:3);\nXX = 2*X .* Y;  YY = X.^2 .- Y.^2;\npcolor(XX,YY, reshape(repeat([1:18; 18:-1:1], 9,1), size(XX)), lc=:black, show=true)"
  },
  {
    "objectID": "documentation/utilities/pcolor.html#see-also",
    "href": "documentation/utilities/pcolor.html#see-also",
    "title": "pcolor",
    "section": "See Also",
    "text": "See Also\ngrdview, plot"
  },
  {
    "objectID": "documentation/utilities/pcolor.html#source-code",
    "href": "documentation/utilities/pcolor.html#source-code",
    "title": "pcolor",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npcolor(cmd0::String; ...) - pcolor.jl:154\npcolor(cmd0::String, arg1; first, kwargs...) - pcolor.jl:154\npcolor(D::GMTdataset; first, kwargs...) - pcolor.jl:166\npcolor(G::GMTgrid, first::Bool, d::Dict{Symbol, Any}) - pcolor.jl:189\npcolor(; ...) - pcolor.jl:154\npcolor(X_::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, Y_::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}; ...) - pcolor.jl:79\npcolor(X_::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, Y_::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, C::Union{Nothing, AbstractMatrix{&lt;:Real}}; first, kwargs...) - pcolor.jl:79\npcolor(X_::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, Y_::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, C::Union{Nothing, AbstractMatrix{&lt;:Real}}, first::Bool, d) - pcolor.jl:82\npcolor(arg1; kw...) - pcolor.jl:230"
  },
  {
    "objectID": "documentation/utilities/pastplates.html",
    "href": "documentation/utilities/pastplates.html",
    "title": "pastplates",
    "section": "",
    "text": "pastplates(; time=100, proj=\"\", title=\"time\", coastlines=true, fmt=\"png\", name=\"\", data=false, show=true)\nPlots the reconstruction of the past plates at a given time. Data is extracted from the GPLATES https://gws.gplates.org website."
  },
  {
    "objectID": "documentation/utilities/pastplates.html#source-code",
    "href": "documentation/utilities/pastplates.html#source-code",
    "title": "pastplates",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/parkergrav.html",
    "href": "documentation/utilities/parkergrav.html",
    "title": "parkergrav",
    "section": "",
    "text": "G = parkergrav(G, dir::String=\"dir\"; nnx=0, nny=0, nterms=6, depth=0.0, zobs=0.0,\n               pct=30, wshort=25.0, rho=1000.0, maxiter=50, min_err=1e-4, padtype::String=\"taper\",\n               isKm::Bool=false, verbose=false)::GMTgrid\nCalculate the gravity direct or inverse problem using Parker’s [1973] Fourier series summation approach.\nDepending on the value of dir it will calculate the direct or inverse problem. The direct problem calculates gravity anomaly given the topography of an interface. The inverse calculates interface (in meters) from the gravity anomaly and a mean depth of that interface.\nThis function, for the direct problem, is equivalent to the GMT’s gravfft module. The inverse problem follows the aproach of the magnetic case and the description in Parker’s paper and should give the ~same results of the 3DINVER.M program (https://doi.org/10.1016/j.cageo.2004.11.004) although I did not check it (couldn’t find the package). It does, however, reproduce very well the tests from the Grav3D.m program (https://github.com/PhamLT/Grav3D), of which we are using its test synthetic interface grid."
  },
  {
    "objectID": "documentation/utilities/parkergrav.html#example",
    "href": "documentation/utilities/parkergrav.html#example",
    "title": "parkergrav",
    "section": "Example",
    "text": "Example\nA synthetic example. Make a Kaba like magnetization distribution of 10 A/m, compute the magnetic field created by it and invert this field.\n\nusing GMT, FFTW\n\nGbat = gmtread(TESTSDIR * \"/assets/model_interface_4parker.grd\");\n\n# Compute the gravity due to the interface. The direct problem\nGgrv = parkergrav(Gbat, rho=400, nterms=10)\n\n# Compute the interface from the gravity. The inverse problem.\nGbat_inv = parkergrav(Ggrv, \"inv\", rho=400, depth=20.0)\n\n# Recompute the gravity from inverted topography\nGgrv_rec = parkergrav(Gbat_inv, rho=400, nterms=10)\n\n# The residues \nGres = Ggrv - Ggrv_rec;\n\n# Plot the results\ngrdimage(Gbat, figsize=7, title=\"Initial topography (m)\", contour=true, colorbar=true)\ngrdimage!(Ggrv, figsize=7, xshift=9, title=\"Gravity anomaly (mGal)\",\n          cmap=:auto, contour=true, colorbar=true)\ngrdimage!(Gbat_inv, figsize=7, xshift=-9, yshift=-9.0, title=\"Calculated Interface (m)\",\n          cmap=:auto, contour=true, colorbar=true)\ngrdimage!(Gres, figsize=7, xshift=9, title=\"Residues (mGal)\", cmap=:auto,\n          contour=true, colorbar=true, show=true)\n\n\n┌ Warning: Stop iteration because latest interface has NaN\n\n└ @ GMTParkerFFTExt C:\\Users\\j\\.julia\\dev\\GMT\\ext\\GMTParkerFFTExt\\parker.jl:409"
  },
  {
    "objectID": "documentation/utilities/parkergrav.html#see-also",
    "href": "documentation/utilities/parkergrav.html#see-also",
    "title": "parkergrav",
    "section": "See Also",
    "text": "See Also\nparkermag, gravfft"
  },
  {
    "objectID": "documentation/utilities/parkergrav.html#source-code",
    "href": "documentation/utilities/parkergrav.html#source-code",
    "title": "parkergrav",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nparkergrav(x, y; kw...) - utils.jl:1503\nparkergrav(x; ...) - utils.jl:1503"
  },
  {
    "objectID": "documentation/utilities/ODE2ds.html",
    "href": "documentation/utilities/ODE2ds.html",
    "title": "ODE2ds",
    "section": "",
    "text": "D = ODE2ds(sol; interp=0)\nExtract data from a DifferentialEquations solution type and return it into a GMTdataset."
  },
  {
    "objectID": "documentation/utilities/ODE2ds.html#source-code",
    "href": "documentation/utilities/ODE2ds.html#source-code",
    "title": "ODE2ds",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/mosaic.html",
    "href": "documentation/utilities/mosaic.html",
    "title": "mosaic",
    "section": "",
    "text": "I = mosaic(lon, lat; pt_radius=6371007.0, provider=\"\", zoom::Int=0, cache::String=\"\",\n           mapwidth=15, dpi=96, verbose::Int=0, kw...)\nGet image tiles from a web map tiles provider for given longitude, latitude coordinates."
  },
  {
    "objectID": "documentation/utilities/mosaic.html#returns",
    "href": "documentation/utilities/mosaic.html#returns",
    "title": "mosaic",
    "section": "Returns",
    "text": "Returns\n\nI: A GMTimage element or the output of the quadonly or mesh options explained above."
  },
  {
    "objectID": "documentation/utilities/mosaic.html#examples",
    "href": "documentation/utilities/mosaic.html#examples",
    "title": "mosaic",
    "section": "Examples",
    "text": "Examples\n\nMake a figure with OpenStreetMap over Iberia maintaining the original spherical Mercator projection.\n\n\nusing GMT\n\nI = mosaic([-9.5, 3.3], [36.0, 43.8], provider=:OSM, zoom=7, merc=true)\nviz(I)\n\n\n\n\n\n\n\n\n\nMake a figure of the Big Island of Hawaii using the default Bing images. In this case we use the geocoder function to give us the map limits\n\n\nusing GMT\n\n# Get the geographical limits of the Big Island in Hawaii\nD = geocoder(\"Big Island Hawaii, USA\");\n\n# Get the image tiles of the Big Island in Hawaii using the Bing provider and automatic zoom level\nI = mosaic(D, bbox=true);\n\nviz(I)\n\n\n\n\n\n\n\n\n\nShow only the tilles limits over a selected zone/zoom level.\n\n\nusing GMT\n\nD = mosaic(region=(-10, -8, 37, 39), zoom=9, mesh=true);\nviz(D, coast=true)\n\n\n\n\n\n\n\n\n\nPrint a table with the zoom level 10 basic characteristics.\n\nusing GMT\n\nmosaic(zoom=10)\n┌───────┬────────────────┬────────────┬────────────────┬────────────────────┐\n│ Level │     Tile width │  m / pixel │         ~Scale │        Examples of │\n│       │ ° of longitude │ on Equator │                │ areas to represent │\n├───────┼────────────────┼────────────┼────────────────┼────────────────────┤\n│    10 │          0.352 │    153.054 │ 1:500 thousand │  metropolitan area │\n└───────┴────────────────┴────────────┴────────────────┴────────────────────┘"
  },
  {
    "objectID": "documentation/utilities/mosaic.html#see-also",
    "href": "documentation/utilities/mosaic.html#see-also",
    "title": "mosaic",
    "section": "See Also",
    "text": "See Also\ngeocoder"
  },
  {
    "objectID": "documentation/utilities/mosaic.html#source-code",
    "href": "documentation/utilities/mosaic.html#source-code",
    "title": "mosaic",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimshow(arg1::Symbol; horizontal, kw...) - imshow.jl:235\nimshow(arg1::GMTcpt; horizontal, kw...) - imshow.jl:236\nimshow(arg1::GMT.Gdal.AbstractDataset; kw...) - imshow.jl:241\nimshow(x::AbstractVector{Float64}, f::String; kw...) - imshow.jl:270\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::String; kw...) - imshow.jl:269\nimshow(x::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:266\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:246\nimshow(f::Function, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:268\nimshow(f::Function, x::AbstractVector{Float64}; kw...) - imshow.jl:267\nimshow(arg1::GItype; kw...) - imshow.jl:124\nimshow(arg1; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:36"
  },
  {
    "objectID": "documentation/utilities/mat2img.html",
    "href": "documentation/utilities/mat2img.html",
    "title": "mat2img",
    "section": "",
    "text": "I = mat2img(mat::Array{&lt;:Unsigned}; x=[], y=[], hdr=nothing, proj4=\"\", wkt=\"\", cmap=nothing, kw...)\nTake a 2D mat array and a hdr 1x9 [xmin xmax ymin ymax zmin zmax reg xinc yinc] header descriptor and return a GMTimage type. Alternatively to hdr, provide a pair of vectors, x & y, with the X and Y coordinates. Optionally, the hdr arg may be omitted and it will computed from mat alone, but then x=1:ncol, y=1:nrow When mat is a 3D UInt16 array we automatically compute a UInt8 RGB image. In that case cmap is ignored. But if no conversion is wanted use option noconv=true\nThe method\nTake a mat array of UInt16 and scale it down to UInt8. Input can be 2D or 3D. If the kw variable stretch is used, we stretch the intervals in stretch to [0 255]. Use this option to stretch the image histogram. If stretch is a scalar, scale the values &gt; stretch to [0 255] - stretch = [v1 v2] scales all values &gt;= v1 && &lt;= v2 to [0 255] - stretch = [v1 v2 v3 v4 v5 v6] scales first band &gt;= v1 && &lt;= v2 to [0 255], second &gt;= v3 && &lt;= v4, same for third - stretch = :auto | \"auto\" | true | 1 will do an automatic stretching from values obtained from histogram thresholds\nThe kw... kwargs search for [:layout :mem_layout], [:names] and [:metadata]"
  },
  {
    "objectID": "documentation/utilities/mat2img.html#see-also",
    "href": "documentation/utilities/mat2img.html#see-also",
    "title": "mat2img",
    "section": "See Also",
    "text": "See Also\nmat2ds, mat2grid"
  },
  {
    "objectID": "documentation/utilities/mat2img.html#source-code",
    "href": "documentation/utilities/mat2img.html#source-code",
    "title": "mat2img",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmat2img(mat, G::GMTgrid; names, metadata) - utils_types.jl:1543\nmat2img(mat, I::GMTimage; names, metadata) - utils_types.jl:1539\nmat2img(mat::Union{GMTgrid, Matrix{&lt;:AbstractFloat}}; x, y, hdr, proj4, wkt, GI, clim, cmap, kw...) - utils_types.jl:1454\nmat2img(img::GMTimage; kw...) - utils_types.jl:1440\nmat2img(mat::Union{AbstractArray{UInt16, 3}, AbstractMatrix{UInt16}}; x, y, v, hdr, proj4, wkt, img8, kw...) - utils_types.jl:1373\nmat2img(mat::Union{AbstractArray{&lt;:Unsigned}, AbstractArray{&lt;:Bool}}; x, y, v, hdr, proj4, wkt, cmap, is_transposed, kw...) - utils_types.jl:1272"
  },
  {
    "objectID": "documentation/utilities/mat2ds.html",
    "href": "documentation/utilities/mat2ds.html",
    "title": "mat2ds",
    "section": "",
    "text": "D = mat2ds(mat [,txt]; x=nothing, text=nothing, multi=false, geom=0, kwargs...)\nTake a 2D mat array and convert it into a GMTdataset. x is an optional coordinates vector (must have the same number of elements as rows in mat). Use x=:ny to generate a coords array 1:n_rows of mat. Alternatively, if mat is a string or vector of strings we return a dataset with NaN’s in the place of the coordinates. This form is useful to pass to text when using the region_justify option that does not need explicit coordinates to place the text.\nTake a 2D mat array and convert it into a GMTdataset. Pass in a reference GMTdataset from which we’ll take the georeference info as well as attrib and colnames.\nCreate a multi-segment GMTdataset (a vector of GMTdataset) from matrices passed in a vector-of-matrices mat. The matrices elements of mat do not need to have the same number of rows. Think on this as specifying groups of lines/points each sharing the same settings. KWarg options of this form are more limited in number than in the general case, but can take the form of a Vector{Vector}, Vector or scalars. In the former case (Vector{Vector}) the length of each Vector[i] must equal to the number of rows of each mat[i].\nCut a GMTdataset D with the indices in INDS but updating the colnames and the Timecol info. INDS is a Tuple of 2 with ranges in rows and columns. Ex: (:, 1:3) or (:, [1,4,7]), etc… Attention, if original had attributes other than ‘Timeinfo’ there is no guarentie that they remain correct."
  },
  {
    "objectID": "documentation/utilities/mat2ds.html#example",
    "href": "documentation/utilities/mat2ds.html#example",
    "title": "mat2ds",
    "section": "Example",
    "text": "Example\nCreate a 3 elements vector with a color and transparency each.\n\nusing GMT\nD = mat2ds([rand(6,3), rand(4,3), rand(3,3)], fill=[[:red], [:green], [:blue]], fillalpha=[0.5,0.7,0.8]);\n\n# Now see it\nviz(D)"
  },
  {
    "objectID": "documentation/utilities/mat2ds.html#see-also",
    "href": "documentation/utilities/mat2ds.html#see-also",
    "title": "mat2ds",
    "section": "See Also",
    "text": "See Also\nmat2grid, mat2img"
  },
  {
    "objectID": "documentation/utilities/mat2ds.html#source-code",
    "href": "documentation/utilities/mat2ds.html#source-code",
    "title": "mat2ds",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmat2ds(text::Vector{String}; hdr, kw...) - utils_types.jl:85\nmat2ds(mat::Nothing) - utils_types.jl:82\nmat2ds(mat::Array{T, N}, txt::Union{String, Vector{String}}; hdr, geom, kwargs...) where {T&lt;:Real, N} - utils_types.jl:206\nmat2ds(mat::Vector{&lt;:AbstractMatrix}; hdr, kwargs...) - utils_types.jl:141\nmat2ds(mat::GDtype) - utils_types.jl:83\nmat2ds(text::Union{AbstractString, Vector{&lt;:AbstractString}}) - utils_types.jl:84\nmat2ds(mat::Array{T, N}; ...) where {T&lt;:Real, N} - utils_types.jl:206\nmat2ds(mat::Array{T, N}, ref::GMTdataset) where {T&lt;:Real, N} - utils_types.jl:203\nmat2ds(mat::Vector{&lt;:AbstractMatrix{T}}, hdr::Vector{String}, d::Dict) where T&lt;:Real - utils_types.jl:145\nmat2ds(D::GMTdataset{T, N}, inds) where {T&lt;:Real, N} - utils_types.jl:422\nmat2ds(mat::AbstractMatrix{T}; hdr, geom, kwargs...) where T&lt;:Real - utils_types.jl:87\nmat2ds(X; kw...) - utils_types.jl:113"
  },
  {
    "objectID": "documentation/utilities/magic.html",
    "href": "documentation/utilities/magic.html",
    "title": "magic",
    "section": "",
    "text": "M = magic(n::Int) =&gt; Matrix{Int}\nM = magic(n) returns an n-by-n matrix constructed from the integers 1 through n^2 with equal row and column sums. The order n must be a scalar greater than or equal to 3 in order to create a valid magic square."
  },
  {
    "objectID": "documentation/utilities/magic.html#source-code",
    "href": "documentation/utilities/magic.html#source-code",
    "title": "magic",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/loft.html",
    "href": "documentation/utilities/loft.html",
    "title": "loft",
    "section": "",
    "text": "FV = loft(C1, C2; n_steps::Int=0, closed=true, type=:quad)::GMTfv\nLoft (linearly) a surface mesh between two input 3D curves."
  },
  {
    "objectID": "documentation/utilities/loft.html#example",
    "href": "documentation/utilities/loft.html#example",
    "title": "loft",
    "section": "Example",
    "text": "Example\n\nusing GMT\n    \nns=75; t=linspace(0,2*pi,ns); r=5; x=r*cos.(t); y=r*sin.(t); z=zeros(size(x));\nC1=[x[:] y[:] z[:]];\n\nf(t) = r + 2.0.* sin(6.0*t)\nC2 = [(f(t)*cos(t),f(t)*sin(t),3) for t in range(0, 2pi, ns)];\nC2 = stack(C2)'\n\nFV = loft(C1, C2);\nviz(FV, pen=0)"
  },
  {
    "objectID": "documentation/utilities/loft.html#see-also",
    "href": "documentation/utilities/loft.html#see-also",
    "title": "loft",
    "section": "See Also",
    "text": "See Also\nextrude, flatfv, fv2fv, grid2tri, revolve, surf2fv"
  },
  {
    "objectID": "documentation/utilities/loft.html#source-code",
    "href": "documentation/utilities/loft.html#source-code",
    "title": "loft",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/linearfitxy.html",
    "href": "documentation/utilities/linearfitxy.html",
    "title": "linearfitxy",
    "section": "",
    "text": "linearfitxy(X, Y; σX=0, σY=0, r=0, ci=95)\nPerforms 1D linear fitting of experimental data with uncertainties in X and Y: - Linear fit: Y = a + b*X [1] - Errors: X ± σX;  Y ± σY [2] - Errors’ correlation: r =  = cov(σX, σY) / (σX * σY) [3]"
  },
  {
    "objectID": "documentation/utilities/linearfitxy.html#examples",
    "href": "documentation/utilities/linearfitxy.html#examples",
    "title": "linearfitxy",
    "section": "Examples",
    "text": "Examples\nD = linearfitxy(X, Y)    # no errors in X and Y, no plot displayed\n\nD = linearfitxy(X, Y; σX, σY) # XY errors not correlated (r=0);\n\nD = linearfitxy([91., 104, 107, 107, 106, 100, 92, 92, 105, 108], [9.8, 7.4, 7.9, 8.3, 8.3, 9.0, 9.7, 8.8, 7.6, 6.9]);\n\nD = linearfitxy([0.0, 0.9, 1.8, 2.6, 3.3, 4.4, 5.2, 6.1, 6.5, 7.4], [5.9, 5.4, 4.4, 4.6, 3.5, 3.7, 2.8, 2.8, 2.4, 1.5], sx=1 ./ sqrt.([1000., 1000, 500, 800, 200, 80,  60, 20, 1.8, 1]), sy=1 ./ sqrt.([1., 1.8, 4, 8, 20, 20, 70, 70, 100, 500]));\n\nD = linearfitxy([0.037 0.0080; 0.035 0.0084; 0.032 0.0100; 0.040 0.0085; 0.013 0.0270; 0.038 0.0071; 0.042 0.0043; 0.030 0.0160], sx=0.03, sy=0.1, r=0.7071);"
  },
  {
    "objectID": "documentation/utilities/linearfitxy.html#see-also",
    "href": "documentation/utilities/linearfitxy.html#see-also",
    "title": "linearfitxy",
    "section": "See Also",
    "text": "See Also\nplotlinefit, plot"
  },
  {
    "objectID": "documentation/utilities/linearfitxy.html#source-code",
    "href": "documentation/utilities/linearfitxy.html#source-code",
    "title": "linearfitxy",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlinearfitxy(X, Y; sx, sy, r, ci) - linefit.jl:63\nlinearfitxy(D::GMTdataset; sx, sy, r, ci) - linefit.jl:56\nlinearfitxy(XY::Matrix{&lt;:Real}; sx, sy, r, ci) - linefit.jl:52"
  },
  {
    "objectID": "documentation/utilities/leepacific.html",
    "href": "documentation/utilities/leepacific.html",
    "title": "leepacific",
    "section": "",
    "text": "GI[,coast] = leepacific(fname::String|GI::GItype; latlims=nothing, lonlims=nothing, coast=true)\nProject a geographical grid/image in the Lee Oblated Stereographic projection centered on the Pacific Ocean.\nNote: This function uses worldrectangular with the +proj=lee_os projection. If one wants to add other elements to the map (points, lines, etc) one must projectem first with the +proj=lee_os projection (use [lonlat2xy] or mapproject to that purpose)."
  },
  {
    "objectID": "documentation/utilities/leepacific.html#returns",
    "href": "documentation/utilities/leepacific.html#returns",
    "title": "leepacific",
    "section": "Returns",
    "text": "Returns\nA grid or a image and optionally the coastlines ."
  },
  {
    "objectID": "documentation/utilities/leepacific.html#example",
    "href": "documentation/utilities/leepacific.html#example",
    "title": "leepacific",
    "section": "Example",
    "text": "Example\n\nusing GMT\nG,cl = leepacific(\"@earth_relief_20m_g\");\ngrdimage(G, shade=true, plot=(data=cl,), cmap=:geo, B=:none)\nplotgrid!(G, show=true)"
  },
  {
    "objectID": "documentation/utilities/leepacific.html#see-also",
    "href": "documentation/utilities/leepacific.html#see-also",
    "title": "leepacific",
    "section": "See Also",
    "text": "See Also\ncoastlinesproj, graticules, [plotgrid!], worldrectangular, worldrectgrid, worldrectcoast, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/leepacific.html#source-code",
    "href": "documentation/utilities/leepacific.html#source-code",
    "title": "leepacific",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nleepacific(fname::String; region, latlims, lonlims, coast) - utils_project.jl:187\nleepacific(GI::GItype; latlims, coast) - utils_project.jl:195"
  },
  {
    "objectID": "documentation/utilities/lazread.html",
    "href": "documentation/utilities/lazread.html",
    "title": "lazread",
    "section": "",
    "text": "out = lazread(FileName::AbstractString; out::String=\"xyz\", do_grid=false, do_image=false,\n              type::DataType=Float64, class=0, startstop=\"1:end\")\nRead data from a LIDAR laz (laszip compressed) or las format file."
  },
  {
    "objectID": "documentation/utilities/lazread.html#see-also",
    "href": "documentation/utilities/lazread.html#see-also",
    "title": "lazread",
    "section": "See Also",
    "text": "See Also\nlazwrite, gmtread"
  },
  {
    "objectID": "documentation/utilities/lazread.html#source-code",
    "href": "documentation/utilities/lazread.html#source-code",
    "title": "lazread",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlazread(s::GMT.Laszip.lasout_types) - lazread.jl:552\nlazread(fname::String, out::String, type::DataType, class::Int64, startstop::String, do_grid::Bool, do_img::Bool, opt_RI::String) - lazread.jl:72\nlazread(fname::AbstractString; out, type, class, startstop, kw...) - lazread.jl:62"
  },
  {
    "objectID": "documentation/utilities/isnodata.html",
    "href": "documentation/utilities/isnodata.html",
    "title": "isnodata",
    "section": "",
    "text": "isnodata(array::AbstractArray, val=0)\nReturn a boolean array with the same size a array with 1’s (true) where array[i] == val."
  },
  {
    "objectID": "documentation/utilities/isnodata.html#source-code",
    "href": "documentation/utilities/isnodata.html#source-code",
    "title": "isnodata",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nisnodata(array::AbstractArray, val) - utils.jl:578\nisnodata(array::AbstractArray) - utils.jl:578"
  },
  {
    "objectID": "documentation/utilities/inpolygon.html",
    "href": "documentation/utilities/inpolygon.html",
    "title": "inpolygon",
    "section": "",
    "text": "in = inpolygon(x, y, polygon)\n\nor\n\nin = inpolygon(point, polygon)\nReturns in indicating if the query points specified by x and y are inside of the polygon area defined by: - polygon: a GMTdatset defining the polygon or a Mx2 matrix of reals that should have the first and last elements equal."
  },
  {
    "objectID": "documentation/utilities/inpolygon.html#reference",
    "href": "documentation/utilities/inpolygon.html#reference",
    "title": "inpolygon",
    "section": "Reference",
    "text": "Reference\n\nHao et al. 2018. [Optimal Reliable Point-in-Polygon Test and Differential Coding Boolean Operations on Polygons] (https://www.mdpi.com/2073-8994/10/10/477)"
  },
  {
    "objectID": "documentation/utilities/inpolygon.html#see-also",
    "href": "documentation/utilities/inpolygon.html#see-also",
    "title": "inpolygon",
    "section": "See Also",
    "text": "See Also\ninwhichpolygon"
  },
  {
    "objectID": "documentation/utilities/inpolygon.html#source-code",
    "href": "documentation/utilities/inpolygon.html#source-code",
    "title": "inpolygon",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ninpolygon(pt::VecOrMat, poly::Matrix{T}) where T - spatial_funs.jl:531\ninpolygon(pt::GMTdataset, D::GMTdataset) - spatial_funs.jl:530\ninpolygon(pt::VecOrMat, D::GMTdataset) - spatial_funs.jl:529\ninpolygon(x, y, poly::Matrix{T}) where T - spatial_funs.jl:528\ninpolygon(x, y, D::GMTdataset) - spatial_funs.jl:527"
  },
  {
    "objectID": "documentation/utilities/ind2rgb.html",
    "href": "documentation/utilities/ind2rgb.html",
    "title": "ind2rgb",
    "section": "",
    "text": "I = ind2rgb(I::GMTimage, cmap::GMTcpt=GMTcpt(), layout=\"BRPa\")\nConvert an indexed GMTimage I to RGB. If cmap is not provided, it uses the internal colormap to do the conversion. If neither them exists, the layer is replicated 3 times thus resulting in a gray scale image.\nThis function mimics the Matlab’s ind2rgb cousin."
  },
  {
    "objectID": "documentation/utilities/ind2rgb.html#see-also",
    "href": "documentation/utilities/ind2rgb.html#see-also",
    "title": "ind2rgb",
    "section": "See Also",
    "text": "See Also\nimagesc, [image_cpt!], [image_alpha!], makecpt"
  },
  {
    "objectID": "documentation/utilities/ind2rgb.html#source-code",
    "href": "documentation/utilities/ind2rgb.html#source-code",
    "title": "ind2rgb",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nind2rgb(I::GMTimage, cpt::GMTcpt, layout; cmap) - utils_types.jl:2119\nind2rgb(I::GMTimage, cpt::GMTcpt; ...) - utils_types.jl:2119\nind2rgb(I::GMTimage; ...) - utils_types.jl:2119"
  },
  {
    "objectID": "documentation/utilities/imagesc.html",
    "href": "documentation/utilities/imagesc.html",
    "title": "imagesc",
    "section": "",
    "text": "I = imagesc(mat; x=, y=, hdr=, proj4=, wkt=, GI=, clim=, cmap=, kw...) --&gt; GMTimage\nimagesc takes a Float matrix or a GMTgrid type and scales it (by default) to the [0, 255] interval. In the process it creates a GMTimage type. Those types can account for coordinates and projection information, hence the optional arguments. Contrary to its Matlab cousin, it doesn’t display the result (that we easily do with imshow(mat)) but return instead a GMTimage object.\nIf mat is instead a UInt16 GMTimage type we call rescale(I, stretch=true, type=UInt8) instead of issuing an error. In this case clim can be a two elements vector to specify the desired stretch range. The default is to let histogram guess these values."
  },
  {
    "objectID": "documentation/utilities/imagesc.html#examples",
    "href": "documentation/utilities/imagesc.html#examples",
    "title": "imagesc",
    "section": "Examples",
    "text": "Examples\nCreate a grayscale image out of the peaks function.\n\nusing GMT\n\nviz(imagesc(GMT.peaks()))"
  },
  {
    "objectID": "documentation/utilities/imagesc.html#see-also",
    "href": "documentation/utilities/imagesc.html#see-also",
    "title": "imagesc",
    "section": "See Also",
    "text": "See Also\ngrdimage, grdview, rescale"
  },
  {
    "objectID": "documentation/utilities/imagesc.html#source-code",
    "href": "documentation/utilities/imagesc.html#source-code",
    "title": "imagesc",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimagesc(I::GMTimage{&lt;:UInt16}; clim) - utils_types.jl:1531\nimagesc(mat::Union{GMTgrid, Matrix{&lt;:AbstractFloat}}; x, y, hdr, proj4, wkt, GI, clim, cmap, kw...) - utils_types.jl:1523"
  },
  {
    "objectID": "documentation/utilities/image_alpha.html",
    "href": "documentation/utilities/image_alpha.html",
    "title": "image_alpha!",
    "section": "",
    "text": "I = image_alpha!(img::GMTimage; alpha_ind::Integer, alpha_vec::Vector{Integer}, alpha_band::UInt8)\nChange the alpha transparency of the GMTimage object img. If the image is indexed, one can either change just the color index that will be made transparent by using alpha_ind=n or provide a vector of transaparency values in the range [0 255]; This vector can be shorter than the orginal number of colors. Use alpha_band to change, or add, the alpha of true color images (RGB)."
  },
  {
    "objectID": "documentation/utilities/image_alpha.html#examples",
    "href": "documentation/utilities/image_alpha.html#examples",
    "title": "image_alpha!",
    "section": "Examples",
    "text": "Examples\nChange to the third color in cmap to represent the new transparent color\nimage_alpha!(img, alpha_ind=3)\nChange to the first 6 colors in cmap by assigning them random values\nimage_alpha!(img, alpha_vec=round.(Int32,rand(6).*255))"
  },
  {
    "objectID": "documentation/utilities/image_alpha.html#see-also",
    "href": "documentation/utilities/image_alpha.html#see-also",
    "title": "image_alpha!",
    "section": "See Also",
    "text": "See Also\n[image_cpt!], ind2rgb"
  },
  {
    "objectID": "documentation/utilities/image_alpha.html#source-code",
    "href": "documentation/utilities/image_alpha.html#source-code",
    "title": "image_alpha!",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/hlines.html",
    "href": "documentation/utilities/hlines.html",
    "title": "hlines",
    "section": "",
    "text": "hlines(arg; decorated=(...), xmin=NaN, xmax=NaN, percent=false, kwargs...)\nPlots one or a collection of horizontal lines with eventual decorations"
  },
  {
    "objectID": "documentation/utilities/hlines.html#examples",
    "href": "documentation/utilities/hlines.html#examples",
    "title": "hlines",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nplot(rand(5,3))\nhlines!([0.2, 0.6], pen=(1, :red), show=true)"
  },
  {
    "objectID": "documentation/utilities/hlines.html#see-also",
    "href": "documentation/utilities/hlines.html#see-also",
    "title": "hlines",
    "section": "See Also",
    "text": "See Also\nvlines, plot"
  },
  {
    "objectID": "documentation/utilities/hlines.html#source-code",
    "href": "documentation/utilities/hlines.html#source-code",
    "title": "hlines",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nhlines(; ...) - plot.jl:1456\nhlines(arg1; first, xmin, xmax, percent, kwargs...) - plot.jl:1456"
  },
  {
    "objectID": "documentation/utilities/gunique.html",
    "href": "documentation/utilities/gunique.html",
    "title": "gunique",
    "section": "",
    "text": "u, ind = gunique(x::AbstractVector; sorted=false)\nReturn an array containing only the unique elements of x and the indices ind such that u = x[ind]. If sorted is true the output is sorted (default is not)"
  },
  {
    "objectID": "documentation/utilities/gunique.html#source-code",
    "href": "documentation/utilities/gunique.html#source-code",
    "title": "gunique",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngunique(x::AbstractMatrix; sorted, rows) - utils.jl:168\ngunique(x::AbstractVector; sorted) - utils.jl:146"
  },
  {
    "objectID": "documentation/utilities/grid2tri.html",
    "href": "documentation/utilities/grid2tri.html",
    "title": "grid2tri",
    "section": "",
    "text": "D = grid2tri(G, G2=nothing; bottom=false, downsample=0, isbase=false, ratio=0.01,\n             thickness=0.0, wall_only=false, top_only=false, geog=false)::GMTfv\nTriangulate the surface defined by the grid G, and optionally the bottom surface G2.\nOther than the triangulation, this function computes also a vertical wall between G and G2, or between G and constant level or a constant thickness. Optionally, computes only the vertical wall or the full closed bodie (that is, including the bottom surface).\nThe output of this function can be used in plot3d to create 3D views of volume layer.\nNOTE: The G grid should have a out-skirt of NaNs, otherwise just use grdview with the N option."
  },
  {
    "objectID": "documentation/utilities/grid2tri.html#example",
    "href": "documentation/utilities/grid2tri.html#example",
    "title": "grid2tri",
    "section": "Example",
    "text": "Example\nA 3D view of the subduction in Central America.\n\nusing GMT\n\n# Get the depth of these three cities\nGm, Gt, SJ = grdtrack(\"cam_slab2_dep_02.24.18.grd\", [260.862 19.4326; 269.492 14.64; 275.925 9.908], f=:g).data[:,3]\n\n# Create cylinder markers\nFV_Mx = cylinder(0.2, 140, np=18, center=(260.862, 19.4326, Gm));\nFV_Gt = cylinder(0.2, -Gt, np=18, center=(269.492, 14.64, Gt));\nFV_SJ = cylinder(0.2, -SJ, np=18, center=(275.925, 9.908, SJ));\n\n# Convert the subduction slab grids into a triangular mesh\nD = grid2tri(\"cam_slab2_dep_02.24.18.grd\", \"cam_slab2_thk_02.24.18.grd\", geog=true);\n\nplot3(D, p=(70,30), zlabel=\"Depth (km)\", title=\"Subduction in Central America\", frame=:autoXYZg)\ncolorbar!(pos=(justify=:TR, horizontal=true, offset=(1,-2)),)\n\n# Plot the coastlines drapped on the subducting slab\nplot3!(coast(region=D, dump=true, Z=\"cam_slab2_dep_02.24.18.grd\"), f=:g)\n\nplot3!(FV_Mx);  plot3!(FV_SJ);  plot3!(FV_Gt)\ntext!(mat2ds([260.862 19.4326 10; 275.925 9.908 10; 269.492 14.64 10],\n             [\"Mexico City\", \"San José\", \"Guatemala\"]),\n             f=:g, font=14, angle=110, noclip=true, outline=true, show=true)\n\ngrdtrack [ERROR]: Cannot find file cam_slab2_dep_02.24.18.grd\ngrdtrack [ERROR]: Must specify -G at least once\n\n\n\nSomething went wrong when calling the module. GMT error number = 72\n\nStacktrace:\n [1] error(s::String)\n   @ Base .\\error.jl:35\n [2] gmt(::String, ::Matrix{Float64}, ::Vararg{Any})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmt_main.jl:166\n [3] common_grd(::Dict{Symbol, Any}, ::String, ::Matrix{Float64}, ::Nothing)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4094\n [4] grdtrack(cmd0::String, arg1::Matrix{Float64}, arg2::Nothing; kwargs::@Kwargs{f::Symbol})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\grdtrack.jl:52\n [5] grdtrack\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\grdtrack.jl:12 [inlined]\n [6] top-level scope\n   @ In[2]:4"
  },
  {
    "objectID": "documentation/utilities/grid2tri.html#see-also",
    "href": "documentation/utilities/grid2tri.html#see-also",
    "title": "grid2tri",
    "section": "See Also",
    "text": "See Also\nextrude, flatfv, fv2fv, loft, revolve, surf2fv"
  },
  {
    "objectID": "documentation/utilities/grid2tri.html#source-code",
    "href": "documentation/utilities/grid2tri.html#source-code",
    "title": "grid2tri",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrid2tri(G::Union{String, GMTgrid}, G2; thickness, isbase, downsample, ratio, bottom, wall_only, top_only, geog) - triangulate.jl:254\ngrid2tri(G::Union{String, GMTgrid}; ...) - triangulate.jl:254"
  },
  {
    "objectID": "documentation/utilities/gmtwrite.html",
    "href": "documentation/utilities/gmtwrite.html",
    "title": "gmtwrite",
    "section": "",
    "text": "gmtwrite(fname::AbstractString, data; kwargs...)\nWrite a GMT object to file. The object is one of grd or grid, image or img, dataset or table, cmap or cpt and ps (for postscript). For the datasets case if the file name ends in .arrow, .shp, .json, .feather, .geojson, .gmt, .gpkg, .gpx, .gml or .parquet then it automatically selects gdalwrite and saves the GMT dataset in that OGR vector format. The .kml is treated as a special case because there are GMT modules (e.g. gmt2kml) that produce KML formatted data and so we write it directly as a text file.\nWhen saving grids we have a panoply of formats at our disposal."
  },
  {
    "objectID": "documentation/utilities/gmtwrite.html#parameters",
    "href": "documentation/utilities/gmtwrite.html#parameters",
    "title": "gmtwrite",
    "section": "Parameters",
    "text": "Parameters\n\nbinary: Applyes only when saving a stl file. By default it is true. Use binary=false to save in ascii.\nid: Use an id code when not not saving a grid into a standard COARDS-compliant netCDF grid. This id is made up of two characters like ef to save in ESRI Arc/Info ASCII Grid Interchange format (ASCII float). See the full list of ids at grdconvert\nscale | offset: You may optionally ask to scale the data and then offset them with the specified amounts. These modifiers are particularly practical when storing the data as integers, by first removing an offset and then scaling down the values. The scale factor can also be applied when saving to stl (scales the z values).\nnan | novalue | invalid | missing: Lets you supply a value that represents an invalid grid entry, i.e., NaN.\ngdal: Boolean. Force the use of the GDAL library to write the grid (to be used only with grids).\ndriver: When saving in other than the netCDF format we must tell the GDAL library what is the wished format. That is done by specifying the driver name used by GDAL itself (e.g., “netCDF”, “GTiFF”, etc…).\ndatatype: When saving with GDAL we can specify the data type from “u8|u16|i16|u32|i32|float32” where ‘i’ and ‘u’ denote signed and unsigned integers respectively.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at"
  },
  {
    "objectID": "documentation/utilities/gmtwrite.html#examples",
    "href": "documentation/utilities/gmtwrite.html#examples",
    "title": "gmtwrite",
    "section": "Examples",
    "text": "Examples\nwrite the GMTgrid ‘G’ object into a netCDF file called ‘lixo.grd’\ngmtwrite(\"lixo.grd\", G)\nTo save the Norway country borders in shapefile format, do:\nNo = coast(DCW=:NO, dump=true);\ngmtwrite(\"Norway.shp\", No)"
  },
  {
    "objectID": "documentation/utilities/gmtwrite.html#see-also",
    "href": "documentation/utilities/gmtwrite.html#see-also",
    "title": "gmtwrite",
    "section": "See Also",
    "text": "See Also\ngmtread, [gdalread]"
  },
  {
    "objectID": "documentation/utilities/gmtwrite.html#source-code",
    "href": "documentation/utilities/gmtwrite.html#source-code",
    "title": "gmtwrite",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtwrite(data; kwargs...) - gmtreadwrite.jl:569\ngmtwrite(fname::AbstractString, data; kwargs...) - gmtreadwrite.jl:570"
  },
  {
    "objectID": "documentation/utilities/getbyattrib.html",
    "href": "documentation/utilities/getbyattrib.html",
    "title": "getbyattrib",
    "section": "",
    "text": "getbyattrib(D::Vector{&lt;:GMTdataset}[, index::Bool=false]; kw...)\n\nor\n\nfilter(D::Vector{&lt;:GMTdataset}; kw...)\n\nor\n\nfindall(D::Vector{&lt;:GMTdataset}; kw...)\nTake a GMTdataset vector and return only its elements that match the condition(s) set by the kw keywords. Note, this assumes that D has its attrib fields set with usable information.\nNOTE: Instead of getbyattrib one can use instead filter (…, index=false) or findall (…, index=true)"
  },
  {
    "objectID": "documentation/utilities/getbyattrib.html#returns",
    "href": "documentation/utilities/getbyattrib.html#returns",
    "title": "getbyattrib",
    "section": "Returns",
    "text": "Returns\nEither a vector of GMTdataset, or a vector of Int with the indices of the segments that match th query condition. Or nothing if the query results in an empty GMTdataset"
  },
  {
    "objectID": "documentation/utilities/getbyattrib.html#examples",
    "href": "documentation/utilities/getbyattrib.html#examples",
    "title": "getbyattrib",
    "section": "Examples",
    "text": "Examples\nD = filter(D, NAME_2=\"Porto\");\nD = filter(D, _region=\"(-8.0, -7.0, 37.0, 38.0)\", _nps=100);"
  },
  {
    "objectID": "documentation/utilities/getbyattrib.html#see-also",
    "href": "documentation/utilities/getbyattrib.html#see-also",
    "title": "getbyattrib",
    "section": "See Also",
    "text": "See Also\ninwhichpolygon, polygonlevels"
  },
  {
    "objectID": "documentation/utilities/getbyattrib.html#source-code",
    "href": "documentation/utilities/getbyattrib.html#source-code",
    "title": "getbyattrib",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngetbyattrib(D::Vector{&lt;:GMTdataset}; indices, kw...) - spatial_funs.jl:341\ngetbyattrib(D::Vector{&lt;:GMTdataset}, ind_::Bool; kw...) - spatial_funs.jl:213"
  },
  {
    "objectID": "documentation/utilities/geocoder.html",
    "href": "documentation/utilities/geocoder.html",
    "title": "geocoder",
    "section": "",
    "text": "D = geocoder(address::String; options=String[])\nGet the geocoder info for a given address by calling the GDAL/OGR geocoding functions."
  },
  {
    "objectID": "documentation/utilities/geocoder.html#returns",
    "href": "documentation/utilities/geocoder.html#returns",
    "title": "geocoder",
    "section": "Returns",
    "text": "Returns\nA GMTdataset with the longitude, latitude, and full attribute dictionary returned by the geocoder for the input address. This dataset contains only one point but geocoding service resturns also a BoundingBox containing that point. When the address is very specific that BB is tiny arround the point, but when the query is general (for example,just the name of a city or even a country), the BB is large and may be very useful to use in the mosaic program. For that purpose, the returned BB is sored in the GMTdatset ds_bbox field."
  },
  {
    "objectID": "documentation/utilities/geocoder.html#examples",
    "href": "documentation/utilities/geocoder.html#examples",
    "title": "geocoder",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\ngeocoder(\"Paris, France\")\n\nAttribute table\n┌────────────┬────────┬──────────┬───────────────┬───────────────┬──────────────┬──────────┬────────────────┬────────┬─────────┬───────┬──────────────┬────────────┬──────────┬────────────────────┬───────────────────────┬──────────┬───────┬─────────────────────────────────────────────────────┬───────────────────────────────────────────┬────────────────┬────────────────┐\n│        lat │ suburb │      lon │ city_district │         state │ address_rank │ place_id │ ISO3166-2-lvl6 │ osm_id │ country │   ref │ country_code │ place_rank │    class │         importance │                region │ osm_type │  city │                                        display_name │                               boundingbox │           type │ ISO3166-2-lvl4 │\n├────────────┼────────┼──────────┼───────────────┼───────────────┼──────────────┼──────────┼────────────────┼────────┼─────────┼───────┼──────────────┼────────────┼──────────┼────────────────────┼───────────────────────┼──────────┼───────┼─────────────────────────────────────────────────────┼───────────────────────────────────────────┼────────────────┼────────────────┤\n│ 48.8588897 │  Paris │ 2.320041 │         Paris │ Île-de-France │           20 │ 88595109 │         FR-75C │   7444 │  France │ Paris │           fr │         15 │ boundary │ 0.8845663630228834 │ France métropolitaine │ relation │ Paris │ Paris, Île-de-France, France métropolitaine, France │ 48.8155755,48.9021560,2.2241220,2.4697602 │ administrative │         FR-IDF │\n└────────────┴────────┴──────────┴───────────────┴───────────────┴──────────────┴──────────┴────────────────┴────────┴─────────┴───────┴──────────────┴────────────┴──────────┴────────────────────┴───────────────────────┴──────────┴───────┴─────────────────────────────────────────────────────┴───────────────────────────────────────────┴────────────────┴────────────────┘\n\n\n\n\n\nBoundingBox: [2.320041, 2.320041, 48.8588897, 48.8588897]\nGlobal BoundingBox: [2.224122, 2.4697602, 48.8155755, 48.902156]\nPROJ: +proj=longlat +datum=WGS84 +units=m +no_defs\n\n1×2 GMTdataset{Float64, 2}\n Row │     Lon      Lat\n─────┼──────────────────\n   1 │ 2.32004  48.8589"
  },
  {
    "objectID": "documentation/utilities/geocoder.html#see-also",
    "href": "documentation/utilities/geocoder.html#see-also",
    "title": "geocoder",
    "section": "See Also",
    "text": "See Also\nmosaic"
  },
  {
    "objectID": "documentation/utilities/geocoder.html#source-code",
    "href": "documentation/utilities/geocoder.html#source-code",
    "title": "geocoder",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/fv2fv.html",
    "href": "documentation/utilities/fv2fv.html",
    "title": "fv2fv",
    "section": "",
    "text": "FV = fv2fv(F, V; proj=\"\", proj4=\"\", wkt=\"\", epsg=0)::GMTfv\nCreate a FacesVertices object from a matrix of faces indices and another matrix of vertices (a Mx3 matrix)."
  },
  {
    "objectID": "documentation/utilities/fv2fv.html#example",
    "href": "documentation/utilities/fv2fv.html#example",
    "title": "fv2fv",
    "section": "Example",
    "text": "Example\nusing GMT, Meshing\n\ngyroid(v) = cos(v[1])*sin(v[2])+cos(v[2])*sin(v[3])+cos(v[3])*sin(v[1]);\ngyroid_shell(v) = max(gyroid(v)-0.4,-gyroid(v)-0.4);\nxr,yr,zr = ntuple(_ -&gt; LinRange(0,pi*4,50), 3);\nA = [gyroid_shell((x,y,z)) for x in xr, y in yr, z in zr];\nA[1,:,:] .= 1e10; A[:,1,:] .= 1e10; A[:,:,1] .= 1e10; A[end,:,:] .= 1e10; A[:,end,:] .= 1e10; A[:,:,end] .= 1e10;\nvts, fcs = isosurface(A, MarchingCubes());\nFV = fv2fv(fcs, vts)\nviz(FV, cmap=makecpt(T=\"0/1\", cmap=\"darkgreen,lightgreen\"))"
  },
  {
    "objectID": "documentation/utilities/fv2fv.html#see-also",
    "href": "documentation/utilities/fv2fv.html#see-also",
    "title": "fv2fv",
    "section": "See Also",
    "text": "See Also\nextrude, flatfv, loft, grid2tri, revolve, surf2fv"
  },
  {
    "objectID": "documentation/utilities/findpeaks.html",
    "href": "documentation/utilities/findpeaks.html",
    "title": "findpeaks",
    "section": "",
    "text": "findpeaks(y, x=1:length(y); min_height=minimum(y), min_prom=minimum(y), min_dist=0, threshold=0; xsorted::Bool=false)\nor\n    \nfindpeaks(D::GMTdataset; min_height=D.bbox[1], min_prom=zero(D[1]), min_dist=0, threshold=0; xsorted::Bool=false)\nReturns indices of local maxima (sorted from highest peaks to lowest) in 1D array of real numbers. Similar to MATLAB’s findpeaks().\nA local peak is a data sample that is either larger than its two neighboring samples or is equal to Inf. The peaks are output in order of occurrence. This function is from the Findpeaks.jl package."
  },
  {
    "objectID": "documentation/utilities/findpeaks.html#source-code",
    "href": "documentation/utilities/findpeaks.html#source-code",
    "title": "findpeaks",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfindpeaks(D::GMTdataset; min_height, min_prom, min_dist, threshold) - findpeaks.jl:50\nfindpeaks(y::AbstractVecOrMat{T}, x::AbstractVecOrMat; min_height, min_prom, min_dist, threshold, xsorted) where T&lt;:Real - findpeaks.jl:41\nfindpeaks(y::AbstractVecOrMat{T}; ...) where T&lt;:Real - findpeaks.jl:41"
  },
  {
    "objectID": "documentation/utilities/era5vars.html",
    "href": "documentation/utilities/era5vars.html",
    "title": "era5vars",
    "section": "",
    "text": "era5vars(varID; single::Bool=true, pressure::Bool=false) -&gt; String\nSelec one or more variables from a CDS ERA5 dataset.\nThis function returns a JSON formatted string that can be used as an input to the ecmwf function params option. See the listecmwfvars function for a list of available variables."
  },
  {
    "objectID": "documentation/utilities/era5vars.html#examples",
    "href": "documentation/utilities/era5vars.html#examples",
    "title": "era5vars",
    "section": "Examples",
    "text": "Examples\n# \"t2m\" is the 2m temperature and \"skt\" is the skin temperature\nvar = era5vars([\"t2m\", \"skt\"])\n\"\\\"variable\\\": [\\n\\t\\\"2m_temperature\\\",\\n\\t\\\"skin_temperature\\\"\\n],\""
  },
  {
    "objectID": "documentation/utilities/era5vars.html#see-also",
    "href": "documentation/utilities/era5vars.html#see-also",
    "title": "era5vars",
    "section": "See Also",
    "text": "See Also\necmwf, era5time, listecmwfvars"
  },
  {
    "objectID": "documentation/utilities/era5vars.html#source-code",
    "href": "documentation/utilities/era5vars.html#source-code",
    "title": "era5vars",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nera5vars(varID::Union{Vector{String}, Vector{Symbol}}; single, pressure) - weather.jl:695\nera5vars(varID::Union{String, Symbol}; single, pressure) - weather.jl:694"
  },
  {
    "objectID": "documentation/utilities/ellipse3D.html",
    "href": "documentation/utilities/ellipse3D.html",
    "title": "ellipse3D",
    "section": "",
    "text": "xyz = ellipse3D(a=1.0, b=a; center=(0.0, 0.0, 0.0), ang1=0.0, ang2=360.0, rot=0.0, e=0.0, f=0.0, plane=:xy, is2D=false, np=72)::Matrix{Float64}\nCreate an ellipse in 2D or 3D space. Attention, this is a 2D body, not an ellipsoid."
  },
  {
    "objectID": "documentation/utilities/ellipse3D.html#source-code",
    "href": "documentation/utilities/ellipse3D.html#source-code",
    "title": "ellipse3D",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nellipse3D(; ...) - solids.jl:484\nellipse3D(a, b; center, ang1, ang2, rot, e, f, plane, is2D, np) - solids.jl:484\nellipse3D(a; ...) - solids.jl:484"
  },
  {
    "objectID": "documentation/utilities/doy2date.html",
    "href": "documentation/utilities/doy2date.html",
    "title": "doy2date",
    "section": "",
    "text": "doy2date(doy[, year]) -&gt; Date\nCompute the date from the Day-Of-Year doy. If year is ommited we take it to mean the current year. Both doy and year can be strings or integers."
  },
  {
    "objectID": "documentation/utilities/doy2date.html#source-code",
    "href": "documentation/utilities/doy2date.html#source-code",
    "title": "doy2date",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndoy2date(doy, year) - utils.jl:349\ndoy2date(doy) - utils.jl:349"
  },
  {
    "objectID": "documentation/utilities/df2ds.html",
    "href": "documentation/utilities/df2ds.html",
    "title": "df2ds",
    "section": "",
    "text": "D = df2ds(df)\nExtract numeric data from a DataFrame type and return it into a GMTdataset. Works only with ‘simple’ DataFrames."
  },
  {
    "objectID": "documentation/utilities/df2ds.html#source-code",
    "href": "documentation/utilities/df2ds.html#source-code",
    "title": "df2ds",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/date2doy.html",
    "href": "documentation/utilities/date2doy.html",
    "title": "date2doy",
    "section": "",
    "text": "date2doy(date) -&gt; Integer\nCompute the Day-Of-Year (DOY) from date that can be a string or a Date/DateTime type. If ommited, returns today’s DOY"
  },
  {
    "objectID": "documentation/utilities/date2doy.html#source-code",
    "href": "documentation/utilities/date2doy.html#source-code",
    "title": "date2doy",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndate2doy(date::String) - utils.jl:364\ndate2doy() - utils.jl:362\ndate2doy(date::Dates.TimeType) - utils.jl:363"
  },
  {
    "objectID": "documentation/utilities/cubeplot.html",
    "href": "documentation/utilities/cubeplot.html",
    "title": "cubeplot",
    "section": "",
    "text": "cubeplot(img1::Union{GMTimage, String}, img2::Union{GMTimage, String}=\"\", img3::Union{GMTimage, String}=\"\";\n         back::Bool=false, show=false, notop::Bool=false, kw...)\nPlot images on the sides of a cube. Those images can be provided as file names, or GMTimage objects.\nThe kw... keyword/value options may be used to pass:\nusing GMT\n\ncubeplot(GMT.TESTSDIR * \"assets/seila_gray.jpg\",\n         GMT.TESTSDIR * \"assets/seis_section_rgb.jpg\",\n         GMT.TESTSDIR * \"assets/seis_section_gray.jpg\",\n         zsize=6, show=true)"
  },
  {
    "objectID": "documentation/utilities/cubeplot.html#see-also",
    "href": "documentation/utilities/cubeplot.html#see-also",
    "title": "cubeplot",
    "section": "See Also",
    "text": "See Also\nslicecube, xyzw2cube"
  },
  {
    "objectID": "documentation/utilities/cubeplot.html#source-code",
    "href": "documentation/utilities/cubeplot.html#source-code",
    "title": "cubeplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncubeplot(G::GMTgrid; top, topshade, zdown, xlabel, ylabel, zlabel, title, show, interp, first, coast, kw...) - utils_project.jl:823\ncubeplot(fname1::Union{String, GMTimage}, fname2::Union{String, GMTimage}, fname3::Union{String, GMTimage}; back, notop, xlabel, ylabel, zlabel, title, first, show, coast, kw...) - utils_project.jl:621\ncubeplot(fname1::Union{String, GMTimage}, fname2::Union{String, GMTimage}; ...) - utils_project.jl:621\ncubeplot(fname1::Union{String, GMTimage}; ...) - utils_project.jl:621"
  },
  {
    "objectID": "documentation/utilities/crop.html",
    "href": "documentation/utilities/crop.html",
    "title": "crop",
    "section": "",
    "text": "GI = crop(arg::GItype; kw...)\nCrop a subregion of a grid (GMTgrid) or a image (GMTimage). The subregion is specified with the limits or region keyword; the specified range must not exceed the range of the input. This function differs from grdcut in the sense that it doesn’t call the GMT lib and works only on in-memory array (i.e., no disk files)."
  },
  {
    "objectID": "documentation/utilities/crop.html#returns",
    "href": "documentation/utilities/crop.html#returns",
    "title": "crop",
    "section": "Returns",
    "text": "Returns\nA grid or an image, depending on the input type, plus two 1x2 matrices with the indices of the cropped zone."
  },
  {
    "objectID": "documentation/utilities/crop.html#examples",
    "href": "documentation/utilities/crop.html#examples",
    "title": "crop",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nG = GMT.peaks();\nGc = crop(G, region=(-2,2,-2,2));"
  },
  {
    "objectID": "documentation/utilities/crop.html#see-also",
    "href": "documentation/utilities/crop.html#see-also",
    "title": "crop",
    "section": "See Also",
    "text": "See Also\ngrdcut"
  },
  {
    "objectID": "documentation/utilities/crop.html#source-code",
    "href": "documentation/utilities/crop.html#source-code",
    "title": "crop",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/colorzones.html",
    "href": "documentation/utilities/colorzones.html",
    "title": "colorzones!",
    "section": "",
    "text": "colorzones!(shapes::Vector{GMTdataset}[, fun::Function]; img::GMTimage=nothing,\n              url::AbstractString=\"\", layer=0, pixelsize::Int=0, append::Bool=true)\nPaint the polygons in the shapes with the average color that those polygons ocupy in the img image. When the shapes are plotted the resulting image looks like a choropleth map. Alternatively, instead of transmitting the img image one can provide a WMS URL, layer number and pixelsize to download images from the Web Map Server service, covering each one the bounding box of each of the shapes polygons. This option is much slower than passing the entire image at once but consumes much less memory. Important when the total area is large (think Russia size) because even at a moderately resultion it can imply downloading a huge file."
  },
  {
    "objectID": "documentation/utilities/colorzones.html#returns",
    "href": "documentation/utilities/colorzones.html#returns",
    "title": "colorzones!",
    "section": "Returns",
    "text": "Returns\nIt does’t return anything but the input GI is modified."
  },
  {
    "objectID": "documentation/utilities/colorzones.html#examples",
    "href": "documentation/utilities/colorzones.html#examples",
    "title": "colorzones!",
    "section": "Examples",
    "text": "Examples\nRead the 2020 Sentinel2 Earth color for Portugal at 100 m resolution. Load the administrative regions and compute their median colors.\nwms = wmsinfo(\"http://tiles.maps.eox.at/wms?\");\nimg = wmsread(wms, layer=3, region=(-9.6,-6,36.9,42.2), pixelsize=100);\nPt = gmtread(\"C:/programs/compa_libs/covid19pt/extra/mapas/concelhos/concelhos.shp\");\ncolorzones!(Pt, median, img=img);\nimshow(Pt, proj=:guess)"
  },
  {
    "objectID": "documentation/utilities/colorzones.html#see-also",
    "href": "documentation/utilities/colorzones.html#see-also",
    "title": "colorzones!",
    "section": "See Also",
    "text": "See Also\n[rasterzones!], gmtread, wmsinfo, wmsread"
  },
  {
    "objectID": "documentation/utilities/colorzones.html#source-code",
    "href": "documentation/utilities/colorzones.html#source-code",
    "title": "colorzones!",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncolorzones!(shapes::GDtype, fun::Function; img, url, layer, pixelsize, append) - rasterpolygonfuns.jl:249\ncolorzones!(shapes::GDtype; img, url, layer, pixelsize, append) - rasterpolygonfuns.jl:247"
  },
  {
    "objectID": "documentation/utilities/cart2sph.html",
    "href": "documentation/utilities/cart2sph.html",
    "title": "cart2sph",
    "section": "",
    "text": "az, elev, rho = cart2sph(x, y, z; deg=false)\nTransform Cartesian coordinates to spherical. Angles are returned in radians by default. Use deg=true to return the angles in degrees. Input can be scalar, vectors or matrices."
  },
  {
    "objectID": "documentation/utilities/cart2sph.html#source-code",
    "href": "documentation/utilities/cart2sph.html#source-code",
    "title": "cart2sph",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/blendimg.html",
    "href": "documentation/utilities/blendimg.html",
    "title": "blendimg!",
    "section": "",
    "text": "blendimg!(img1::GMTimage, img2::GMTimage; new=false, transparency=0.5)\nBlend the RGB color GMTimage with the shade intensity image (normally obtained with [gdaldem]). The new argument determines if we return a new RGB image or update the color argument.\nOr, blend two 2D UInt8 or 2 RGB images using transparency.\nThe blending method is the one explained in https://gis.stackexchange.com/questions/255537/merging-hillshade-dem-data-into-color-relief-single-geotiff-with-qgis-and-gdal/255574#255574\nReturns nothing if new option has not been used or a GMTimage, either RGB or indexed depending on the options used."
  },
  {
    "objectID": "documentation/utilities/blendimg.html#source-code",
    "href": "documentation/utilities/blendimg.html#source-code",
    "title": "blendimg!",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/anaglyph.html",
    "href": "documentation/utilities/anaglyph.html",
    "title": "anaglyph",
    "section": "",
    "text": "I = anaglyph(G|fname; vscale=1, sscale=2, kw...)\nGenerate an anaglyph image from the input GMTgrid G or grid’s file name fname.\nAn anaglyph 3D is the stereoscopic 3D effect achieved by means of encoding each eye’s image using filters of different (usually chromatically opposite) colors, typically red and cyan. Anaglyph 3D images contain two differently filtered colored images, one for each eye. When viewed through the “color-coded” “anaglyph glasses”, each of the two images is visible to the eye it is intended for, revealing an integrated stereoscopic image (ref Wiki).\nThis function offers two methods to create anaglyphs from a gridded terrain model. The first one, based on a simple gradient of the surface elevation, is very fast, takes a little while to fool the brain (that is, to make it think it’s looking into a true 3D surface) but gives a very impressive feeling of depth. The second method, that generates 2 3D views using the grdview program and construct the anaglyph from those two images, is slower and creates a less perceptually depth image but it is easier to see and displays more 3D info."
  },
  {
    "objectID": "documentation/utilities/anaglyph.html#examples",
    "href": "documentation/utilities/anaglyph.html#examples",
    "title": "anaglyph",
    "section": "Examples",
    "text": "Examples\nCreate an anaglyph of first type overt the Iberian peninsula.\n\nusing GMT\n\nI = anaglyph(\"@earth_relief_30s\", region=\"-13/-5.5/35/44\")\nviz(I)\n\n\n\n\n\n\n\n\nNow let us see the Tonga Trench using the second method.\n\nusing GMT\n\nI = anaglyph(\"@earth_relief_30s\", R=\"-175.8/-171/-23/-14\", view3d=true)\nviz(I)"
  },
  {
    "objectID": "documentation/utilities/anaglyph.html#source-code",
    "href": "documentation/utilities/anaglyph.html#source-code",
    "title": "anaglyph",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimshow(arg1::Symbol; horizontal, kw...) - imshow.jl:235\nimshow(arg1::GMTcpt; horizontal, kw...) - imshow.jl:236\nimshow(arg1::GMT.Gdal.AbstractDataset; kw...) - imshow.jl:241\nimshow(x::AbstractVector{Float64}, f::String; kw...) - imshow.jl:270\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::String; kw...) - imshow.jl:269\nimshow(x::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:266\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:246\nimshow(f::Function, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:268\nimshow(f::Function, x::AbstractVector{Float64}; kw...) - imshow.jl:267\nimshow(arg1::GItype; kw...) - imshow.jl:124\nimshow(arg1; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:36"
  },
  {
    "objectID": "documentation/modules/xyz2grd.html",
    "href": "documentation/modules/xyz2grd.html",
    "title": "xyz2grd",
    "section": "",
    "text": "xyz2grd(cmd0::String=\"\", arg1=nothing, kwargs...)\nConvert data table to a GMTgrid type."
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#description",
    "href": "documentation/modules/xyz2grd.html#description",
    "title": "xyz2grd",
    "section": "Description",
    "text": "Description\nReads one or more x, y, z or z tables and creates a grid. It will report if some of the nodes are not filled in with data. Such unconstrained nodes are set to a value specified by the user [Default is NaN]. Nodes with more than one value will be set to the mean value. As an option (using flags), a 1-column z table may be read assuming all nodes are present (z tables can be organized in a number of formats, see flags below.) Note: xyz2grd does not grid the data, it simply reformats existing data to a grid structure. For gridding, see surface, greenspline, nearneighbor, or triangulate."
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#required-arguments",
    "href": "documentation/modules/xyz2grd.html#required-arguments",
    "title": "xyz2grd",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nA data table holding z or x, y, z values. The x, y, z triplets do not have to be sorted. One-column z tables must be sorted and the flags option must be set.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#optional-arguments",
    "href": "documentation/modules/xyz2grd.html#optional-arguments",
    "title": "xyz2grd",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or multiple_nodes : – multiple_nodes=true | multiple_nodes=“d|f|l|m|n|r|S|s|u|z”\nBy default we will calculate mean values if multiple entries fall on the same node. Use this option to change this behavior, except it is ignored if flags is given. Append f or s to simply keep the first or last data point that was assigned to each node. Append l or u or d to find the lowest (minimum) or upper (maximum) value or the difference between the maximum and miminum value at each node, respectively. Append m or r or S to compute mean or RMS value or standard deviation at each node, respectively. Append n to simply count the number of data points that were assigned to each node (this only requires two input columns x and y as z is not consulted). Append z to sum multiple values that belong to the same node.\nJ or proj or projection : – proj=\nUse the proj syntax to save the georeferencing info as CF-1 compliant metadata in netCDF grids. Remember also that PROJ syntax can be used directly in proj. This referencing will be recognized by GDAL and increasingly also by GMT.\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nS or swap : – swap=true | swap=zfile\nSwap the byte-order of the z table input only. No grid is produced. You must also supply the flags option. The output is return to Julia or written to zfile\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or flags : – flags=flags\nRead a 1-column table. This assumes that all the nodes are present and sorted according to specified ordering convention contained in flags (a string). If incoming data represents rows, make flags start with T(op) if first row is y = ymax or B(ottom) if first row is y = ymin. Then, append L or R to indicate that first element is at left or right end of row. Likewise for column formats: start with L or R to position first column, and then append T or B to position first element in a row. Note: These two row/column indicators are only required for grids; for other tables they do not apply. For gridline registered grids: If data are periodic in x but the incoming data do not contain the (redundant) column at x = xmax, append x. For data periodic in y without redundant row at y = ymax, append y. Append s n to skip the first n number of bytes (probably a header). If the byte-order or the words needs to be swapped, append w. Select one of several data types (all binary except a):\n\nA ASCII representation of one or more floating point values per record\na ASCII representation of a single item per record\nc int8_t, signed 1-byte character\nu uint8_t, unsigned 1-byte character\nh int16_t, signed 2-byte integer\nH uint16_t, unsigned 2-byte integer\ni int32_t, signed 4-byte integer\nI uint32_t, unsigned 4-byte integer\nl int64_t, long (8-byte) integer\nL uint64_t, unsigned long (8-byte) integer\nf 4-byte floating point single precision\nd 8-byte floating point double precision\n\nDefault format is scanline orientation of numbers: flags=“TLa”. The difference between A and a is that the latter can decode both dateTclock and ddd:mm:ss[.xx] formats but expects each input record to have a single value, while the former can handle multiple values per record but can only parse regular floating point values. Translate incoming z-values via the -i0 option and needed modifiers.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\n\n[Default is 3 input columns]. This option only applies to x, y, z input files; see flags for z tables.\n\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#geographical-and-time-coordinates",
    "href": "documentation/modules/xyz2grd.html#geographical-and-time-coordinates",
    "title": "xyz2grd",
    "section": "Geographical And Time Coordinates",
    "text": "Geographical And Time Coordinates\nWhen the output grid type is netCDF, the coordinates will be labeled “longitude”, “latitude”, or “time” based on the attributes of the input data or grid (if any) or on the colinfo or region options. For example, both colinfo=“0x” colinfo=“1t” and region=“90w/90e/0t/3t” will result in a longitude/time grid. When the x, y, or z coordinate is time, it will be stored in the grid as relative time since epoch as specified by TIME_UNIT and TIME_EPOCH in the gmt.conf file or on the command line. In addition, the unit attribute of the time variable will indicate both this unit and epoch."
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#swapping-limitations",
    "href": "documentation/modules/xyz2grd.html#swapping-limitations",
    "title": "xyz2grd",
    "section": "Swapping Limitations",
    "text": "Swapping Limitations\nAll data types can be read, even 64-bit integers, but internally grids are stored using floats. Hence, integer values exceeding the float type’s 23-bit mantissa may not be represented exactly. When swap is used no grids are implied and we read data into an intermediate double container. This means all but 64-bit integers can be represented using the double type’s 53-bit mantissa."
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#examples",
    "href": "documentation/modules/xyz2grd.html#examples",
    "title": "xyz2grd",
    "section": "Examples",
    "text": "Examples\nTo create a grid file from the raw binary (3-column, single-precision scanline-oriented data raw.b, use\n    G = xyz2grd(\"raw.b\", region=(0,100,0,100), inc=1, flags=true, binary_in=\"3f\")"
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#source-code",
    "href": "documentation/modules/xyz2grd.html#source-code",
    "title": "xyz2grd",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nxyz2grd(cmd0::String; ...) - xyz2grd.jl:44\nxyz2grd(; ...) - xyz2grd.jl:44\nxyz2grd(arg1; kw...) - xyz2grd.jl:68\nxyz2grd(cmd0::String, arg1; kwargs...) - xyz2grd.jl:44"
  },
  {
    "objectID": "documentation/modules/xyz2grd.html#see-also",
    "href": "documentation/modules/xyz2grd.html#see-also",
    "title": "xyz2grd",
    "section": "See Also",
    "text": "See Also\ngrd2xyz, greenspline, nearneighbor, surface, triangulate"
  },
  {
    "objectID": "documentation/modules/wiggle.html",
    "href": "documentation/modules/wiggle.html",
    "title": "wiggle",
    "section": "",
    "text": "wiggle(cmd0::String=\"\", arg1=nothing; kwargs...)\nPlot z = f(x,y) anomalies along tracks"
  },
  {
    "objectID": "documentation/modules/wiggle.html#description",
    "href": "documentation/modules/wiggle.html#description",
    "title": "wiggle",
    "section": "Description",
    "text": "Description\nReads (x, y,z) triplets from file or table and plots z as a function of distance along track. This means that two consecutive (x, y) points define the local distance axis, and the local z axis is then perpendicular to the distance axis, forming a right-handed coordinate system. The user may set a preferred positive anomaly plot direction, and if the positive normal is outside the ±90 degree window around the preferred direction, then 180 degrees are added to the direction. Either the positive or the negative wiggle (or both) may be shaded."
  },
  {
    "objectID": "documentation/modules/wiggle.html#required-arguments",
    "href": "documentation/modules/wiggle.html#required-arguments",
    "title": "wiggle",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax, zmin, zmax) | limits=(BB=(xmin, xmax, ymin, ymax, zmin, zmax),) | …more\nSpecify the region of interest. Default limits are computed from data extents. More at [limits](../common_opts/opt_R.html)\nZ or ampscale or amp_scale : – ampscale=??\nGives anomaly scale in data-units/distance-unit. Append c, i, or p to indicate the distance unit (cm, inch, or point); if no unit is given we use the default unit that is controlled by PROJ_LENGTH_UNIT."
  },
  {
    "objectID": "documentation/modules/wiggle.html#optional-arguments",
    "href": "documentation/modules/wiggle.html#optional-arguments",
    "title": "wiggle",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA azimuth : – azimuth=az\nSets the preferred positive azimuth. Positive wiggles will “gravitate” towards that direction, i.e., azimuths of the normal direction to the track will be flipped into the -90/+90 degree window centered on azimuth and that defines the positive wiggle side. If no azimuth is given the no preferred azimuth is enforced.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or center : – center=??\nSubtract center from the data set before plotting [0].\nD or scale_bar : – pos=(map=(lon,lat), inside=true, outside=true, norm=(x,y), paper=(x,y), justify=code, offset=XX, anchor=XX, label=“the-label”, label_left=true)\nDefines the reference point on the map for the vertical scale bar using one of four coordinate systems:\n\nUse map=true for map (user) coordinates, (2) use inside=true or outside=true (the default) for setting anchor via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). All but paper=true requires both region and proj to be specified.\n\nUse width=(width,height) to set the length (and height) of the scale bar in data (z) units. By default, the anchor point on the legend is assumed to be the bottom left corner (:ML), but this can be changed by appending justify followed by a 2-char justification code justify (see text). Note: If inside is used (the default) then justify defaults to the same as refpoint, if outside is used then justify defaults to the mirror opposite of refpoint. Move scale label to the left side with label_left=true [Default is to the right of the scale]. Use label=\"The label\" to set the z unit label that is used in the scale label [no unit]. The FONT_ANNOT_PRIMARY is used for the font setting, while MAP_TICK_PEN_PRIMARY is used to draw the scale bar.\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nG or fill : – fill=fill[+n][+p]\nSet fill shade, color or pattern for positive and/or negative wiggles [Default is no fill]. Optionally, append +p to fill positive areas (this is the default behavior). Append +n to fill negative areas. Append +n+p to fill both positive and negative areas with the same fill. Note: You will need to repeat this option to select different fills for the positive and negative wiggles, but sie we cannot repeat keywords the solution is to pass in a tuple of tuples or of NamedTuples. For simpler cases one can pass also a 2 elements vector of strings thet will be used as is, that is, without any further parsing. See example below.\nI or fixed_azim : fixed_azim=az\nSet a fixed azimuth projection for wiggles [Default uses track azimuth, but see |-A|]. With this option, the calculated track-normal azimuths are overridden by fixed_az.\nT or track : – track=pen\nDraw track [Default is no track]. Append pen attributes to use [Defaults: width = 0.25p, color = black, style = solid].\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/wiggle.html#examples",
    "href": "documentation/modules/wiggle.html#examples",
    "title": "wiggle",
    "section": "Examples",
    "text": "Examples\nTo demonstrate a basic wiggle plot we create some synthetic data with gmtmath and pipe it through wiggle:\n\nusing GMT\n\nx = -8:0.01:6;\ny = 0.15 .* x;\nz = 50 .* exp.(-((x ./ 3) .^ 2)) .* cos.(2pi .* x) .+ y;\nwiggle([x y z], region=(-10,10,-3,3), proj=:Merc, ampscale=100,\n       scale_bar=(refpoint=:RM, width=100, label=:nT),\n       track=:faint, fill=[\"red+p\", \"blue+n\"], pen=1, show=1)\n\n\n\n\n\n\n\n\nTo plot the magnetic anomaly stored in the file track.xym along track at 500 nTesla/cm (after removing a mean value of 32000 nTesla), using a 15-cm-wide Polar Stereographic map ticked every 5 degrees, with positive anomalies in red on a blue track of width 0.25 points, use\n    wiggle(\"track.xym\", region=(-20,10,-80,-60), proj=(name=:stere, center=(0,90)),\n           ampscale=500, frame=(annot=5,), center=32000, fill=:red, track=(0.25,:blue),\n           scale_bar=(refpoint=:RM, width=100, label=:nT), show=1)\nand the positive anomalies will in general point in the north direction. We used scale_bar to place a vertical scale bar indicating a 1000 nT anomaly. To instead enforce a fixed azimuth of 45 for the positive wiggles, we add fixed_azim and obtain\n    wiggle(\"track.xym\", region=(-20,10,-80,-60), proj=(name=:stere, center=(0,90)),\n           ampscale=1000, frame=(annot=5,), center=32000, fill=:red, track=(0.25,:blue),\n           fixed_azim=45, scale_bar=(refpoint=:RM, width=100, label=:nT), show=1)"
  },
  {
    "objectID": "documentation/modules/wiggle.html#source-code",
    "href": "documentation/modules/wiggle.html#source-code",
    "title": "wiggle",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nwiggle(cmd0::String; kw...) - pswiggle.jl:58\nwiggle(arg1; kw...) - pswiggle.jl:59"
  },
  {
    "objectID": "documentation/modules/wiggle.html#see-also",
    "href": "documentation/modules/wiggle.html#see-also",
    "title": "wiggle",
    "section": "See Also",
    "text": "See Also\nfilter1d, psbasemap, gmtsplit"
  },
  {
    "objectID": "documentation/modules/velo.html",
    "href": "documentation/modules/velo.html",
    "title": "velo",
    "section": "",
    "text": "Plot velocity vectors, crosses, anisotropy bars and wedges"
  },
  {
    "objectID": "documentation/modules/velo.html#synopsis",
    "href": "documentation/modules/velo.html#synopsis",
    "title": "velo",
    "section": "Synopsis",
    "text": "Synopsis\nvelo(cmd0::String=\"\", arg1=nothing; kwargs...)\nReads data values from files or direct inputs and plots geodesy symbols on a map. You may choose from velocity vectors and their uncertainties, rotational wedges and their uncertainties, anisotropy bars, or strain crosses. Symbol fills or their outlines may be colored based on constant parameters or via color lookup tables.\nYou can make four different geodetic symbols: Rotational wedges, velocity error ellipses with vector, anisotropy bars, and strain crosses. The first two symbols allow you to select separate colors and pens for the main symbol and its error component."
  },
  {
    "objectID": "documentation/modules/velo.html#required-arguments",
    "href": "documentation/modules/velo.html#required-arguments",
    "title": "velo",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nData Input\n\nTable data: Provide data as a file name, a GMTdataset, a matrix, or any tabular data format.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\n\n\n\nS?\nSelects the meaning of the columns in the data file and the figure to be plotted. In all cases, the scales are in data units per length unit and sizes are in length units (default length unit is controlled by `PROJ_LENGTH_UNIT` unless **c**, **i**, or **p** is appended).\n\nSe or velo_NE : – *velo_NE=[velscale/]confidence[+ffont]“ : Velocity ellipses in (N,E) convention**\nThe `velscale` sets the scaling of the velocity arrows. If velscale is not given then we read it from the data file as an extra column. The `confidence` sets the 2-dimensional confidence limit for the ellipse, e.g., 0.95 for 95% confidence ellipse. Use **+f** to set the font and size of the text [9p,Helvetica,black]; give **+f0** to deactivate labeling. The arrow will be drawn with the pen attributes specified by the **W** option and arrow-head can be colored via **fill**. The ellipse will be filled with the color or shade specified by the **uncertaintyfill** option [default is transparent], and its outline will be drawn if **L** is selected using the pen selected (by **W** if not given by **L**). \n\nNote: If confidence is nonzero and neither **L** nor **E** are set then we use **W** (or default) to draw ellipse outlines. \n\nParameters are expected to be in the following columns:\n- 1,2: longitude, latitude of station (`yx` option interchanges order)\n- 3,4: eastward, northward velocity (`yx` option interchanges order)\n- 5,6: uncertainty of eastward, northward velocities (1-sigma) (`yx` option interchanges order)\n- 7: correlation between eastward and northward components\n- Trailing text: name of station (optional).\nSn or aniso : – aniso=true | aniso=barscale Anisotropy bars\nThe barscale sets the scaling of the bars. If barscale is not given then we read it from the data file as an extra column. Unless arrow is used to change it via modifier +hshape, the vector shape defaults to 0.1.\nParameters are expected to be in the following columns:\n\n1,2: longitude, latitude of station (yx option interchanges order)\n3,4: eastward, northward components of anisotropy vector (yx option interchanges order)\n\nSr or velo_rotated : – *velo_rotated=[velscale/]confidence[+ffont]“ : Velocity ellipses in rotated convention**\nThe velscale sets the scaling of the velocity arrows. If velscale is not given then we read it from the data file as an extra column. The confidence sets the 2-dimensional confidence limit for the ellipse, e.g., 0.95 for 95% confidence ellipse. Use +f to set the font and size of the text [9p,Helvetica,black]; give +f0 to deactivate labeling. The arrow will be drawn with the pen attributes specified by the W option and arrow-head can be colored via fill. The ellipse will be filled with the color or shade specified by the uncertaintyfill option [default is transparent], and its outline will be drawn if L is selected using the pen selected (by W if not given by L).\nNote: If confidence is nonzero and neither L nor E are set then we use W (or default) to draw ellipse outlines.\nParameters are expected to be in the following columns:\n\n1,2: longitude, latitude, of station (yx option interchanges order)\n3,4: eastward, northward velocity (yx option interchanges order)\n5,6: semi-major, semi-minor axes\n7: counter-clockwise angle, in degrees, from horizontal axis to major axis of ellipse.\nTrailing text: name of station (optional)\n\nSw or wedges : – wedges=wedgemag | wedges=(wedgescale,wedgemag)\n\nThe wedgescale sets the size of the wedges. If wedgescale is not given then we read it from the data file as an extra column. Rotation values are multiplied by wedgemag before plotting. For example, setting wedgemag to 1.e7 works well for rotations of the order of 100 nanoradians/yr. Use fill to set the fill color or shade for the wedge, and uncertaintyfill to set the color or shade for the uncertainty.\nParameters are expected to be in the following columns:\n\n1,2: longitude, latitude, of station (yx option interchanges order)\n3: rotation in radians\n4: rotation uncertainty in radians\n\nSx” or strain : – strain=cross_scale\n\nThe cross_scale sets the size of the cross. If cross_scale is not given then we read it from the data file as an extra column.\nParameters are expected to be in the following columns:\n\n1,2: longitude, latitude, of station (yx option interchanges order)\n3: eps1, the most extensional eigenvalue of strain tensor, with extension taken positive.\n4: eps2, the most compressional eigenvalue of strain tensor, with extension taken positive.\n5: azimuth of eps2 in degrees CW from North."
  },
  {
    "objectID": "documentation/modules/velo.html#optional-arguments",
    "href": "documentation/modules/velo.html#optional-arguments",
    "title": "velo",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or arrow or arrows : – arrow=parameters\nModify vector parameters. For vector heads, append vector head size [Default is 9p]. See Vector Attributes for specifying additional attributes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nC or color or cmap : – cmap=cpt\nGive a CPT and let symbol color normally set by G be determined from the magnitude. See Z for other selections.\nD or sigma_scale : – *sigma_scale=scale* Can be used to rescale the uncertainties of velocities (Se and Sr) and rotations (Sw).\nE or uncertaintyfill or fill_wedges : – uncertaintyfill=fill\nSets the color or shade used for filling uncertainty wedges (Sw) or velocity error ellipses (Se or Sr). If E is not specified, the uncertainty regions will be transparent.\nNote: Using C and Z=“+e” will update the uncertainty fill color based on the selected measure in Z [magnitude error].\nG or fill : – fill=color\nSelect color or pattern for filling of symbols [Default is no fill].\nNote: Using C (and optionally Z) will update the symbol fill color based on the selected measure in Z [magnitude].\nH or scale : – scale=true | scale=scale\nScale symbol sizes and pen widths on a per-record basis using the scale read from the data file. The symbol size is either provided by convention or via the input size column. Alternatively, append a constant scale that should be used instead of reading a scale column.\nI or intens or intensity : – intens=val | intens=:a\nUse the supplied intens value (nominally in the ±1 range) to modulate the compressional fill color by simulating illumination [none]. If no intensity is provided we will instead read intens from an extra data column after the required input columns determined by convention.\n\n\nL or outline : [pen[+c[f|l]]]\nDraw lines. Ellipses and rotational wedges will have their outlines drawn using current pen (see **W**). Alternatively, append a separate pen to use for the error outlines. If the modifier **+cl** is appended then the color of the pen are updated from the CPT (see **C**). If instead modifier **+cf** is appended then the color from the cpt file is applied to error fill only [Default]. Use just **+c** to set both pen and fill color.\n\nN or no_clip or noclip : – no_clip=true\nDo not skip symbols that fall outside the frame boundary specified by region. [Default plots symbols inside frame only].\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\n\n\n\nW or pen : [pen][+c[f|l]]\nSet pen attributes for velocity arrows, ellipse circumference and fault plane edges. [Defaults: width = 0.25p, color = black, style = solid]. If the modifier **+cl** is appended then the color of the pen are updated from the CPT (see **C**). If instead modifier **+cf** is appended then the color from the cpt file is applied to symbol fill only [Default]. Use just **+c** to set both pen and fill color.\n\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\n\n\n\nZ or colorbar_quantity : [m|e|n|u][+e]\nSelect the quantity that will be used with the CPT given via **C** to set the fill color. Choose from:\n- **m**: magnitude (vector magnitude or rotation magnitude)\n- **e**: east-west velocity\n- **n**: north-south velocity\n- **u**: user-supplied data column (supplied after the required columns)\n\nTo instead use the corresponding error estimates (i.e., vector or rotation uncertainty) to lookup the color and paint the error ellipse or wedge instead, append **+e**.\n\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/velo.html#vector-attributes",
    "href": "documentation/modules/velo.html#vector-attributes",
    "title": "velo",
    "section": "Vector Attributes",
    "text": "Vector Attributes\nVector attributes are controlled by options and modifiers. All vectors require you to specify the begin point (x_b, y_b) and the end point (x_e, y_e), or alternatively the direction d and length L, while for map projections we usually specify the azimuth α instead.\nSeveral modifiers may be appended to vector-producing options for specifying the placement of vector heads, their shapes, and the justification of the vector. Below, left and right refers to the side of the vector line when viewed from the beginning point (b) to the end point (e) of a line segment:\n\n+a : Append argument to set the angle θ of the vector head apex [30].\n+b : Place a vector head at the beginning of the vector path [none]. Optionally, append t for a terminal line, c for a circle, s for a square, a for arrow [Default], i for tail, A for plain open arrow, and I for plain open tail. Note: For geovectors only a and A are available. Further append l|r to only draw the left or right half-sides of this head [both sides].\n+c : Select the vector data quantity magnitude for use with CPT color look-up [Default requires a separate data column following the 2 or 3 coordinates]. Requires that data quantity scaling (with unit q via +v or +z) and a CPT have been selected.\n+e : Place a vector head at the end of the vector path [none]. Optionally, append t for a terminal line, c for a circle, s for a square, a for arrow [Default], i for tail, A for plain open arrow, and I for plain open tail. Note: For geovectors only a and A are available. Further append l|r to only draw the left or right half-sides of this head [both sides].\n+g : Append [fill] sets the vector head fill [Default fill is used, which may be no fill]. Turn off vector head fill by not appending a fill. Some modules have a separate -G option and if used will select the fill as well.\n+h : Append shape of the vector head (range -2/2). Default is controlled by MAP_VECTOR_SHAPE [default is theme dependent]. A zero value produces no notch. Positive values moves the notch toward the head apex while a negative value moves it away.\n+m : Places a vector head at the mid-point the vector path [none]. Append f or r for forward or reverse direction of the vector [forward]. Optionally, append t for a terminal line, c for a circle, a for arrow [Default], i for tail, A for plain open arrow, and I for plain open tail. Further append l|r to only draw the left or right half-sides of this head [both sides]. Cannot be combined with +b or +e.\n+n : Give [norm[/min]] to scale down vector attributes (pen thickness, head size) with decreasing length, where vector plot lengths shorter than norm will have their attributes scaled by length/norm [other arrow attributes remain invariant to length]. Optionally, append /min for the minimum shrink factor (in the 0-1 range) that we will shrink to [0.25]. For Cartesian vectors, please specify a norm in plot units, while for geovectors specify a norm in map units (see Distance units) [k]. Alternatively, append unit q to indicate we should use user quantity units in making the decision; this means the user also must select user quantity input via +v or +z. If no argument is given then +n ensures vector heads are not shrunk and always plotted regardless of vector length [Vector heads are not plotted if exceeding vector length].\n+o : Specify the oblique pole [plon/plat] for the great or small circles. Only needed for great circles if +q is given. If no pole is appended then we default to the north pole. Input arguments are then lon lat arclength with the latter in map distance units; see +q of angular limits instead.\n+p : Sets the vector pen attributes [pen]. If no pen is appended then the head outline is not drawn. [Default pen is half the width of stem pen, and head outline is drawn]. The vector stem attributes are controlled by -W.\n+q : Means the input direction, length data instead represent the start and stop opening angles of the arc segment relative to the given point. See +o to specify a specific pole for the arc [north pole].\n+t : [b|e]trim - Shift the beginning or end point (or both) along the vector segment by the given trim; append suitable unit (c, i, or p). If the modifiers b|e are not used then trim may be two values separated by a slash, which is used to specify different trims for the beginning and end. Positive trims will shorted the vector while negative trims will lengthen it [no trim].\n\nIn addition, all but circular vectors may take these modifiers:\n\n+j : The just determines how the input x,y point relates to the vector. Choose from beginning [default], end, or center.\n+s : The input angle, length are instead the (x_e, y_e) coordinates of the vector end point.\n\nFinally, Cartesian vectors and geovectors may take these modifiers (except in grdvector) which can be used to convert vector components to polar form or magnify user quantity magnitudes into plot lengths:\n\n+v : [i|l]scale - Expects a scale to magnify the polar length in the given unit. If i is prepended we use the inverse scale while if l is prepended then it is taken as a fixed length to override input lengths. Append unit q if input magnitudes are given in user quantity units and we will scale them to current plot unit for Cartesian vectors (see PROJ_LENGTH_UNIT for how to change the plot unit) or to km for geovectors. In addition, if +c is selected then the vector magnitudes may be used for CPT color-lookup (and no extra data column is required by -C).\n+z : [scale] - Expects input Δx, Δy vector components and uses the scale [1] to convert to polar coordinates with length in given unit. Append unit q if input components are given in user quantity units and we will scale to current plot unit for Cartesian vectors (see PROJ_LENGTH_UNIT for how to change the plot unit) or to km for geovectors. In addition, if +c is selected then the vector magnitudes may be used for CPT color-lookup (and no extra data column is required by -C).\n\nNote: Vectors were completely redesigned for GMT5 which separated the vector head (a polygon) from the vector stem (a line). In GMT4, the entire vector was a polygon and it could only be a straight Cartesian vector. Yes, the old GMT4 vector shape remains accessible if you specify a vector (-Sv|V) using the GMT4 syntax, explained here: size, if present, will be interpreted as tailwidth/headlength/halfheadwidth [Default is 0.075c/0.3c/0.25c (or 0.03i/0.12i/0.1i)]. By default, arrow attributes remain invariant to the length of the arrow. To have the size of the vector scale down with decreasing size, append +nnorm, where vectors shorter than norm will have their attributes scaled by length/norm. To center the vector on the balance point, use -Svb; to align point with the vector head, use -Svh; to align point with the vector tail, use -Svt [Default]. To give the head point’s coordinates instead of direction and length, use -Svs. Upper case B, H, T, S will draw a double-headed vector [Default is single head]. Note: If headlength/halfheadwidth are given as 0/0 then only the head-less vector stick will be plotted.\nA GMT 4 vector has no separate pen for the stem – it is all part of a Cartesian polygon. You may optionally fill and draw its outline. The modifiers listed above generally do not apply. Note: While the tailwidth and headlength parameters are given as indicated, the halfheadwidth is oddly given as the half-width in GMT 4 so we retain that convention here (but have updated the documentation)."
  },
  {
    "objectID": "documentation/modules/velo.html#data-column-order",
    "href": "documentation/modules/velo.html#data-column-order",
    "title": "velo",
    "section": "Data Column Order",
    "text": "Data Column Order\nThe S option determines how many data columns are required to generate the selected symbol. In addition, your use of options H, I and t will require extra columns, as will a S option without the size or a user-column selected via -Zu for color lookup purposes. The order of the data record is fixed regardless of option order, even if not all items may be activated.\nWe expect data columns to come in the following order:\nlon lat symbol-columns [usercol] [size] [scale] [intens] [transp [transp2]] [trailing-text]\nwhere symbol-columns represent the normally required data columns, and items given in brackets are optional and under the control of the stated options (the trailing text is always optional). Note: You can use -i to rearrange your data record to match the expected format."
  },
  {
    "objectID": "documentation/modules/velo.html#examples",
    "href": "documentation/modules/velo.html#examples",
    "title": "velo",
    "section": "Examples",
    "text": "Examples\nThe following should make big red arrows with green ellipses, outlined in red. Note that the 39% confidence scaling will give an ellipse which fits inside a rectangle of dimension Esig by Nsig:\nvelo(\"\"\"\n0. -8. 0.0 0.0 4.0 6.0 0.500 4x6\n-8. 5. 3.0 3.0 0.0 0.0 0.500 3x3\n0. 0. 4.0 6.0 4.0 6.0 0.500\n-5. -5. 6.0 4.0 6.0 4.0 0.500 6x4\n5. 0. -6.0 4.0 6.0 4.0 -0.500 -6x4\n0. -5. 6.0 -4.0 6.0 4.0 -0.500 6x-4\n\"\"\", region=(-10,10,-10,10), pen=(0.6,:red), error_fill=:green, outline=true,\n    symbol=\"e0.2/0.39/18\", frame=(axes=:auto, grid=1), proj=:linear, figscale=(0.4,0.4),\n    arrow=\"0.3c+p1p+e+gred\", show=true)\nThis example should plot some residual rates of rotation in the Western Transverse Ranges, California. The wedges will be dark gray, with light gray wedges to represent the 2-sigma uncertainties:\nvelo(\"\"\"\n241.4806 34.2073 5.65E-08 1.17E-08\n241.6024 34.4468 -4.85E-08 1.85E-08\n241.0952 34.4079 4.46E-09 3.07E-08\n241.2542 34.2581 1.28E-07 1.59E-08\n242.0593 34.0773 -6.62E-08 1.74E-08\n241.0553 34.5369 -2.38E-07 4.27E-08\n241.1993 33.1894 -2.99E-10 7.64E-09\n241.1084 34.2565 2.17E-08 3.53E-08\n\"\"\", symbol=\"w0.4i/1.e7\", pen=0.75, fill=:darkgray, error_fill=:lightgray,\n    scale_down=2, proj=:merc, figscale=\"2.2i\",\n    region=(240,243,32.5,34.75), frame=(axes=:auto, annot=:auto),\n    show=true)"
  },
  {
    "objectID": "documentation/modules/velo.html#notes",
    "href": "documentation/modules/velo.html#notes",
    "title": "velo",
    "section": "Notes",
    "text": "Notes\nThis module provides specialized plotting capabilities for geodetic data including GPS velocity vectors, rotational deformation, anisotropy measurements, and strain tensor visualizations. The error representation (ellipses or wedges) can be customized independently from the main symbol to properly represent measurement uncertainties.\nFor velocity ellipses, the confidence parameter controls the size of the uncertainty ellipse according to the desired confidence level (e.g., 0.39 for 1-sigma, 0.95 for 95% confidence). The correlation coefficient between eastward and northward components is critical for proper ellipse orientation."
  },
  {
    "objectID": "documentation/modules/velo.html#references",
    "href": "documentation/modules/velo.html#references",
    "title": "velo",
    "section": "References",
    "text": "References\nKurt L. Feigl, Department of Geology and Geophysics at University of Wisconsin-Madison, Madison, Wisconsin, USA"
  },
  {
    "objectID": "documentation/modules/velo.html#source-code",
    "href": "documentation/modules/velo.html#source-code",
    "title": "velo",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nvelo(cmd0::String; ...) - psvelo.jl:12\nvelo(; ...) - psvelo.jl:12\nvelo(arg1; kw...) - psvelo.jl:49\nvelo(cmd0::String, arg1; first, kwargs...) - psvelo.jl:12"
  },
  {
    "objectID": "documentation/modules/velo.html#see-also",
    "href": "documentation/modules/velo.html#see-also",
    "title": "velo",
    "section": "See Also",
    "text": "See Also\nplot, arrows, meca, coupe"
  },
  {
    "objectID": "documentation/modules/trisurf.html",
    "href": "documentation/modules/trisurf.html",
    "title": "trisurf",
    "section": "",
    "text": "trisurf(in, kw...)\nPlots the 3-D triangular surface defined by the points in a Mx3 matrix or a GMTdataset with data x, y, z in the 3 first columns. The triangles are computed with a Delaunay triangulation done internaly. Since this is a plot3 avatar all options in this function are those of the plot3d program.\nCreate a set of 3-D points and plot the surface defined by the triangulation.\nusing GMT\nx,y,z = GMT.peaks(N=45, grid=false);\ntrisurf([x[:] y[:] z[:]], pen=0.5, show=true)"
  },
  {
    "objectID": "documentation/modules/trisurf.html#source-code",
    "href": "documentation/modules/trisurf.html#source-code",
    "title": "trisurf",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntrisurf(G::Union{String, GMTgrid}, G2; first, thickness, isbase, downsample, ratio, bottom, wall_only, top_only, geog, kw...) - triangulate.jl:187\ntrisurf(G::Union{String, GMTgrid}; ...) - triangulate.jl:187\ntrisurf(in::Union{GDtype, Matrix}; first, gdal, kw...) - triangulate.jl:166"
  },
  {
    "objectID": "documentation/modules/triangulate.html",
    "href": "documentation/modules/triangulate.html",
    "title": "triangulate",
    "section": "",
    "text": "triangulate(cmd0::String=\"\", arg1=nothing; kwargs...)\nDelaunay triangulation or Voronoi partitioning and gridding of Cartesian data"
  },
  {
    "objectID": "documentation/modules/triangulate.html#description",
    "href": "documentation/modules/triangulate.html#description",
    "title": "triangulate",
    "section": "Description",
    "text": "Description\nReads x,y[,z] from file or table and performs Delaunay triangulation, i.e., it finds how the points should be connected to give the most equilateral triangulation possible. If a map projection (give region and proj) is chosen then it is applied before the triangulation is calculated. By default, the output is triplets of point id numbers that make up each triangle and is written to standard output. The id numbers refer to the points position (line number, starting at 0 for the first line) in the input file. As an option, you may choose to create a multiple segment file that can be send to plot to draw the triangulation network.\nUsing x,y[,z] or only x,y in input depends on the intended usage of this module. If only the triangulation is desired, then only x,y is used and even if the input table has a z column, that is ignored. If, however, we wish to compute a grid (see below) than z is mandatory and is interpreted as a functional value, z = f(x,y).\nIf region and inc are set a grid will be calculated based on the surface defined by the planar triangles. The algorithm used in the triangulations is that of Shewchuk [1996] and you can also perform the calculation of Voronoi polygons and optionally grid your data via the natural nearest neighbor algorithm. Note: For geographic data with global or very large extent you should consider sphtriangulate instead since triangulate is a Cartesian or small-geographic area operator and is unaware of periodic or polar boundary conditions."
  },
  {
    "objectID": "documentation/modules/triangulate.html#required-arguments",
    "href": "documentation/modules/triangulate.html#required-arguments",
    "title": "triangulate",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns."
  },
  {
    "objectID": "documentation/modules/triangulate.html#optional-arguments",
    "href": "documentation/modules/triangulate.html#optional-arguments",
    "title": "triangulate",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or area : – area=true\nCompute the area of the Cartesian triangles and append the areas in the output segment headers [no areas calculated]. Requires triangles and is not compatible with voronoi (GMT &gt;= 6.4).\nC or slope_grid : – slope_grid=slpfile\nRead a slope grid (in degrees), either a file or a GMTgrid, and compute the propagated uncertainty in the bathymetry using the CURVE algorithm [Zambo et al, 2016]. Requires the outgrid option to specify the output grid. Note that the slope_grid sets the domain for the output grid so region, inc, registration are not required. Cannot be used in conjunction with derivatives, network, ids, voronoi, triangles and edges.\nD or derivatives : derivatives=:x|y\nTake either the x- or y-derivatives of surface represented by the planar facets (only used when outgrid is set).\nE or empty : – empty=??\nSet the value assigned to empty nodes when outgrid is set [NaN].\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nUse triangulation to grid the data onto an even grid. NOTE: by specifying the region and inc options this one is automatically selected. Now, if you want to save the result in a grid file explicitly use this option and append the name of the output grid file. The interpolation is performed in the original coordinates, so if your triangles are close to the poles you are better off projecting all data to a local coordinate system before using triangulate (this is true of all gridding routines) or instead use sphtriangulate. For natural nearest neighbor gridding you must add voronoi=:pol. See other modules that also write files, such as surface, to see further options to this.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or index : – index=indexfile[+b]\nGive name of file or a GMTdataset with previously computed Delaunay information. Each record must contain triplets of node numbers for a triangle in the input table [Default computes these using Delaunay triangulation]. If the indexfile is binary and can be read the same way as the binary input table then you can append +b to spead up the reading (GMT6.4).\nM or network : – network=true\nOutput triangulation network as multiple line segments separated by a segment header record.\nN or ids : – ids=true\nUsed in conjunction with outgrid to also write the triplets of the ids of all the Delaunay vertices [Default only writes the grid].\nQ or voronoi : – voronoi=true | voronoi=:polygon\nOutput the edges of the Voronoi cells instead [Default is Delaunay triangle edges]. Requires region and is only available if linked with the Shewchuk [1996] library. Note that xyz is ignored on output. Optionally, use voronoi=:polygon (or just =:pol) for combining the edges into closed Voronoi polygons.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or triangles : – triangles=true\nOutput triangles as polygon segments separated by a segment header record. Requires Delaunay triangulation.\nT or edges : – edges=true\nOutput edges or polygons even if gridding has been selected with the outgrid option [Default will not output the triangulation or Voronoi polygons is gridding is selected].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or xyz or triplets : – xyz=true\nControls whether we read (x,y) or (x,y,z) data and if z should be output when network or triangles are used [Read (x,y) only].\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\n\n{{&lt; include ../common_opts/opt__r.md &gt;}} (Only valid with outgrid).\n\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/triangulate.html#grid-values-precision",
    "href": "documentation/modules/triangulate.html#grid-values-precision",
    "title": "triangulate",
    "section": "Grid Values Precision",
    "text": "Grid Values Precision\nRegardless of the precision of the input data, GMT programs that create grid files will internally hold the grids in 4-byte floating point arrays. This is done to conserve memory and furthermore most if not all real data can be stored using 4-byte floating point values. Data with higher precision (i.e., double precision values) will lose that precision once GMT operates on the grid or writes out new grids. To limit loss of precision when processing data you should always consider normalizing the data prior to processing."
  },
  {
    "objectID": "documentation/modules/triangulate.html#insideoutside-status",
    "href": "documentation/modules/triangulate.html#insideoutside-status",
    "title": "triangulate",
    "section": "Inside/outside Status",
    "text": "Inside/outside Status\nTo determine if a point is inside, outside, or exactly on the boundary of a polygon we need to balance the complexity (and execution time) of the algorithm with the type of data and shape of the polygons. For any Cartesian data we use a non-zero winding algorithm, which is quite fast. For geographic data we will also use this algorithm as long as (1) the polygons do not include a geographic pole, and (2) the longitude extent of the polygons is less than 360. If this is the situation we also carefully adjust the test point longitude for any 360 degree offsets, if appropriate. Otherwise, we employ a full spherical ray-shooting method to determine a points status."
  },
  {
    "objectID": "documentation/modules/triangulate.html#examples",
    "href": "documentation/modules/triangulate.html#examples",
    "title": "triangulate",
    "section": "Examples",
    "text": "Examples\nTo triangulate the points in the file samples.xyz, return the triangle information, and make a grid for the given area and spacing, use\n    D = triangulate(\"samples.xyz\", region=(0,30,0,30), inc=2, save=\"surf.nc\")\nTo draw the optimal Delaunay triangulation network based on the same file using a 15-cm-wide Mercator map, use\n    D = triangulate(\"samples.xyz\", region=(100,-90,30,34), network=true, proj=:Mercator)\n    plot(D, pen=0.5, frame=(annot=1,), show=true)\nTo instead plot the Voronoi cell outlines, try\n    D = triangulate(\"samples.xyz\", region=(100,-90,30,34), network=true, voronoi=true, proj=:Mercator)\n    plot(D, pen=0.5, frame=(annot=1,), show=true)\nTo combine the Voronoi outlines into polygons and paint them according to their ID, try\n    D = triangulate(\"samples.xyz\", region=(100,-90,30,34), network=true, voronoi=:polyg, proj=:Mercator)\n    plot(D, pen=\"0.5p+cf\", frame=(annot=1,), cmap=\"colors.cpt\", show=true)\nTo grid the data using the natural nearest neighbor algorithm, try\n    G = triangulate(\"samples.xyz\", region=(100,-90,30,34), inc=0.5, voronoi=:polygon)"
  },
  {
    "objectID": "documentation/modules/triangulate.html#notes",
    "href": "documentation/modules/triangulate.html#notes",
    "title": "triangulate",
    "section": "Notes",
    "text": "Notes\nThe uncertainty propagation for bathymetric grids requires both horizontal and vertical uncertainties and these are weighted given the local slope. See the Zambo et al. [2014] and Zhou and Liu [2004] references for more details."
  },
  {
    "objectID": "documentation/modules/triangulate.html#source-code",
    "href": "documentation/modules/triangulate.html#source-code",
    "title": "triangulate",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntriangulate(cmd0::String; kwargs...) - triangulate.jl:68\ntriangulate(arg1; kwargs...) - triangulate.jl:69"
  },
  {
    "objectID": "documentation/modules/triangulate.html#see-also",
    "href": "documentation/modules/triangulate.html#see-also",
    "title": "triangulate",
    "section": "See Also",
    "text": "See Also\ngreenspline, nearneighbor, contour, sphdistance, sphinterpolate, sphtriangulate, surface"
  },
  {
    "objectID": "documentation/modules/triangulate.html#references",
    "href": "documentation/modules/triangulate.html#references",
    "title": "triangulate",
    "section": "References",
    "text": "References\nShewchuk, J. R., 1996, Triangle: Engineering a 2D Quality Mesh Generator and Delaunay Triangulator, First Workshop on Applied Computational Geometry (Philadelphia, PA), 124-133, ACM, May 1996.\nZambo, S., Elmore, P. A., Bourgeois, B. S., and Perkins, A. L., 2016, Uncertainty estimation for sparse data gridding algorithms, Proceedings of the U.S. Hydro Conference,National Harbor, MD, 16-19 March 2015.\nZhou, Q., and Liu, X., 2004, Error analysis on grid-based slope and aspect algorithms, Photogrammetric Eng. & Remote Sensing, 70 (8), 957-962.\nShewchuk’s Homepage"
  },
  {
    "objectID": "documentation/modules/trend1d.html",
    "href": "documentation/modules/trend1d.html",
    "title": "trend1d",
    "section": "",
    "text": "trend1d(cmd0::String=\"\", arg1=nothing, kwargs...)\nFit [weighted] [robust] polynomial/Fourier model for y = f(x) to xy[w] data."
  },
  {
    "objectID": "documentation/modules/trend1d.html#description",
    "href": "documentation/modules/trend1d.html#description",
    "title": "trend1d",
    "section": "Description",
    "text": "Description\ntrend1d reads x,y [and w] values from the first two [three] columns and fits a regression model y = f(x) + e by [weighted] least squares. The functional form of f(x) may be chosen as polynomial or Fourier or a mix of the two, and the fit may be made robust by iterative reweighting of the data. The user may also search for the number of terms in f(x) which significantly reduce the variance in y."
  },
  {
    "objectID": "documentation/modules/trend1d.html#required-arguments",
    "href": "documentation/modules/trend1d.html#required-arguments",
    "title": "trend1d",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nData table(s) containing x,y [w] values in the first 2 [3] columns.\nF or out or output : – out=:xymrw | out=:p|:P|:c\nSpecify up to six letters from the set {x y m r w} in any order to create columns of output. x = x, y = y, m = model f(x), r = residual y - m, w = weight used in fitting. Alternatively, choose just the single selection out=:p to output a record with the polynomial model coefficients, P for the normalized polynomial model coefficients, or c for the normalized Chebyshev model coefficients.\nN or model : – model=n | model=“[p|P|f|F|c|C|s|S|x]n[,…][+llength][+oorigin][+r]”\nSpecify the components of the (possibly mixed) model. Add one or more comma-separated model components. Each component is of the form ?n, where ? indicates the basis function and n indicates the polynomial degree or how many terms in the Fourier series we want to include. Choose ? from p (polynomial with intercept and powers of x up to degree n), P (just the single term x^n), f (Fourier series with n terms), c (Cosine series with n terms), s (sine series with n terms), F (single Fourier component of order n), C (single cosine component of order n), and S (single sine component of order n). By default the x-origin and fundamental period is set to the mid-point and data range, respectively. Change this using the +oorigin and +llength modifiers. We normalize x before evaluating the basis functions. Basically, the trigonometric bases all use the normalized x’ = (2pi(x-origin)/length) while the polynomials use x’ = 2*(x-x_mid)/(xmax - xmin) for stability. Finally, add +r for a robust solution [Default gives a least squares fit]. Use verbose to see a plain-text representation of the y(x) model specified in model.\nAn alternative syntax is via long options: – model=(polynome=deg, fourier=deg, cosine=deg, sine=deg, single=true, length=xx, origin=xx, robust=true)\nWhere deg is the polynomiala degree or how many terms in the Fourier series. The single option forces the use that single deg term (equivalent to the upper case letter in the terse syntax). length, origin, robust have the meaning of the +l, +o, +r options explanied above. To choose mixed models, we must enclose each model in a named tuple and only the last one may contain the length, origin, robust options. For example model=((polynome=2,),(fourier=1, single=true, origin=0, length=25))."
  },
  {
    "objectID": "documentation/modules/trend1d.html#optional-arguments",
    "href": "documentation/modules/trend1d.html#optional-arguments",
    "title": "trend1d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or condition_number : – condition_number=number\nSet the maximum allowed condition number for the matrix solution. trend2d fits a damped least squares model, retaining only that part of the eigenvalue spectrum such that the ratio of the largest eigenvalue to the smallest eigenvalue is condition_#. [Default: condition_# = 1.0e06].\nI or conf_level : – conf_level=true | conf_level=level\nIteratively increase the number of model parameters, starting at one, until n_model is reached or the reduction in variance of the model is not significant at the confidence_level level. You may set conf_level=true only, without an attached number; in this case the fit will be iterative with a default confidence level of 0.51. Or choose your own level between 0 and 1. See remarks section. Note that the model terms are added in the order they were given in model so you should place the most important terms first.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weights : – weights=true | weights=“+s|+w”\nWeights are supplied in input column 4. Do a weighted least squares fit [or start with these weights when doing the iterative robust fit]. Append +s to instead read data uncertainties (one sigma) and create weights as 1/sigma^2, or use the weights as read (+w) [Default reads only the first 2 columns].\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/trend1d.html#remarks",
    "href": "documentation/modules/trend1d.html#remarks",
    "title": "trend1d",
    "section": "Remarks",
    "text": "Remarks\nThe domain of x and y will be shifted and scaled to [-1, 1] and the basis functions are built from Chebyshev polynomials. These have a numerical advantage in the form of the matrix which must be inverted and allow more accurate solutions. In many applications of trend2d the user has data located approximately along a line in the x,y plane which makes an angle with the x axis (such as data collected along a road or ship track). In this case the accuracy could be improved by a rotation of the x,y axes. trend2d does not search for such a rotation; instead, it may find that the matrix problem has deficient rank. However, the solution is computed using the generalized inverse and should still work out OK. The user should check the results graphically if trend2d shows deficient rank. NOTE: The model parameters listed with verbose are Chebyshev coefficients; they are not numerically equivalent to the m#s in the equation described above. The description above is to allow the user to match model with the order of the polynomial surface. For evaluating Chebyshev polynomials, see grdmath.\nThe model=“n_model+r” (robust) and conf_level (iterative) options evaluate the significance of the improvement in model misfit Chi-Squared by an F test. The default confidence limit is set at 0.51; it can be changed with the conf_level option. The user may be surprised to find that in most cases the reduction in variance achieved by increasing the number of terms in a model is not significant at a very high degree of confidence. For example, with 120 degrees of freedom, Chi-Squared must decrease by 26% or more to be significant at the 95% confidence level. If you want to keep iterating as long as Chi-Squared is decreasing, set conf_level to zero.\nA low confidence limit (such as the default value of 0.51) is needed to make the robust method work. This method iteratively reweights the data to reduce the influence of outliers. The weight is based on the Median Absolute Deviation and a formula from Huber [1964], and is 95% efficient when the model residuals have an outlier-free normal distribution. This means that the influence of outliers is reduced only slightly at each iteration; consequently the reduction in Chi-Squared is not very significant. If the procedure needs a few iterations to successfully attenuate their effect, the significance level of the F test must be kept low."
  },
  {
    "objectID": "documentation/modules/trend1d.html#examples",
    "href": "documentation/modules/trend1d.html#examples",
    "title": "trend1d",
    "section": "Examples",
    "text": "Examples\nTo remove a linear trend from data.xy by ordinary least squares, use:\n    D = trend2d(\"data.xyz\", out=:xr, model=\"p1\")\nTo make the above linear trend robust with respect to outliers, use:\n    D = trend2d(\"data.xyz\", out=:xr, model=\"p1+r\")\nTo fit the model y(x) = a + bx^2 + c * cos(2pi3(x/l) + d  sin(2pi3*(x/l), with l the fundamental period (here l = 15), try:\n    D = trend2d(\"data.xyz\", out=:xm, model=\"P0,P2,F3+l15\")\nTo find out how many terms (up to 20), say in a robust Fourier interpolant are significant in fitting data.xy, use:\n    trend2d(\"data.xyz\", model=\"f20+r\", conf_level=true, verbose=true)\n\nusing GMT\n\nx = -50.0:50;\ny = x / 50 .+ 3 .+ 0.25 * rand(length(x));\nD = trend1d([x y], model=(polynome=1), out=:xm);\nplot(x,y, region=(-50,50,0,6), marker=:point)\nplot!(D, lc=:blue, show=true)\n\n\n\n\n\n\n\n\nFit with a constant and the cubic term only.\n\nusing GMT\n\nx = -50.0:50;\ny = 4 * (x / 50) .^3 .+ 3 .+ 0.25 * rand(length(x));\nD = trend1d([x y], model=((polynome=0,single=1),(polynome=3,single=true)), out=:xm);\n# Or, if the condensed form is prefered\n#D = trend1d(xy, model=\"P0,P3\", out=:xm);\nplot(x,y, region=(-50,50,0,6), marker=:point)\nplot!(D, lc=:blue, show=true)\n\n\n\n\n\n\n\n\nFit a linear trend and a sinusoid\n\nusing GMT\n\nx = 10.0:110;\ny = (x / 50) .^2 .+ x/60 .+ 4 .+ cos.(2pi * x/25) .+ 0.25 * rand(length(x));\nD = trend1d([x y], model=((polynome=2,),(fourier=1,single=true, origin=0, length=25)), out=:xm);\nplot(x,y, region=(0,120,0,15), marker=:point)\nplot!(D, lc=:blue, show=true)"
  },
  {
    "objectID": "documentation/modules/trend1d.html#source-code",
    "href": "documentation/modules/trend1d.html#source-code",
    "title": "trend1d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntrend1d(cmd0::String; ...) - trend1d.jl:40\ntrend1d(; ...) - trend1d.jl:40\ntrend1d(arg1; kw...) - trend1d.jl:98\ntrend1d(cmd0::String, arg1; kwargs...) - trend1d.jl:40"
  },
  {
    "objectID": "documentation/modules/trend1d.html#see-also",
    "href": "documentation/modules/trend1d.html#see-also",
    "title": "trend1d",
    "section": "See Also",
    "text": "See Also\ngmtregress, grdtrend, trend2d"
  },
  {
    "objectID": "documentation/modules/trend1d.html#references",
    "href": "documentation/modules/trend1d.html#references",
    "title": "trend1d",
    "section": "References",
    "text": "References\nHuber, P. J., 1964, Robust estimation of a location parameter, Ann. Math. Stat., 35, 73-101.\nMenke, W., 1989, Geophysical Data Analysis: Discrete Inverse Theory, Revised Edition, Academic Press, San Diego."
  },
  {
    "objectID": "documentation/modules/ternary.html",
    "href": "documentation/modules/ternary.html",
    "title": "ternary",
    "section": "",
    "text": "ternary(cmd0::String=\"\", arg1=[]; kwargs...)\nPlot data on ternary diagrams"
  },
  {
    "objectID": "documentation/modules/ternary.html#description",
    "href": "documentation/modules/ternary.html#description",
    "title": "ternary",
    "section": "Description",
    "text": "Description\nReads (a, b, c [, z]) records from table and plots symbols at those locations on a ternary diagram. If a symbol is selected and no symbol size given, then we will interpret the fourth column of the input data as symbol size. Symbols whose size is &lt;= 0 are skipped. If no symbols are specified then the symbol code (see marker below) must be present as last column in the input. If marker is not specified then we instead plot lines or polygons."
  },
  {
    "objectID": "documentation/modules/ternary.html#parameters",
    "href": "documentation/modules/ternary.html#parameters",
    "title": "ternary",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame : – frame=??\nFor ternary diagrams the three sides are referred to as a, b, and c. Thus, to give specific settings for one of these axis you must include the axis letter before the arguments. If all axes have the same arguments then only give one option without the axis letter. For more details, see the example at the bottom of this page and the general [frame] docs.\nC or color or cmap : – color=cpt\nGive a CPT or specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically, where z starts at 0 and is incremented by one for each color. In this case color_n can be a [r g b] triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc). If symbol is set, let symbol fill color be determined by the z-value in the fourth column. Additional fields are shifted over by one column (optional size would be 5th rather than 4th field, etc.).\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nJ or proj or projection : – proj=width\nThe only valid projection is linear plot with specified ternary width. Use a negative width to indicate that positive axes directions be clock-wise [Default lets the a, b, c axes be positive in a counter-clockwise direction].\nL or vertex_labels : – vertex_labels=“Lab1/lab2/Lab3” | vertex_labels=(“Lab1”, “lab2”, “Lab3”)\nSet the labels for the three diagram vertices where the component is 100% [none]. These are placed a distance of three times the MAP_LABEL_OFFSET setting from their respective corners. To skip any one of then, specify that label as “-”.\nM or dump : – dump=true\nDo no plot. Instead, convert the input (a, b, c [, z]) records to Cartesian (x, y, [, z]) records, where x, y are normalized coordinates on the triangle (i.e., 0–1 in x and 0–sqrt(3)/2 in y).\nN or noclip or no_clip : noclip=true\nDo NOT clip symbols that fall outside map border [Default plots points whose coordinates are strictly inside the map border only].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or marker or symbol : – symbol=(symb=name, size=val, unit=unity) or marker|Marker|shape=name, markersize|MarkerSize|ms|size=val\nPlot individual symbols in a ternary diagram. If marker is not given then we will instead plot lines (requires markerline) or polygons (requires cmap or fill). For details on symbols see the symbol option in plot\n\nOther than the above options, the kwargs input accepts still the following options:\n\nimage : – image=true\nFills the ternary plot with an image computed automatically with grdimage from a grid interpolated with surface\ncontour : – contour=??\nThis option works in two different ways. If used together with image it overlays a contour by doing a call to grdcontour. However, if used alone it will call contour to do the contours. The difference is important because this option can be used in default mode with contour=true where the number and annotated contours is picked automatically, or the use can exert full control by passing as argument a NamedTuple with all options appropriated to that module. e.g. contour=(cont=10, annot=20, pen=0.5)\ncontourf : – contourf=??\nWorks a bit like the standalone contour. If used with contourf=true call make a filled contour using automatic parameters. The form contourf=(...) let us selects options of the contourf module.\nclockwise : – clockwise=true` Set it to true to indicate that positive axes directions be clock-wise [Default lets the a, b, c axes be positive in a counter-clockwise direction].\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats."
  },
  {
    "objectID": "documentation/modules/ternary.html#examples",
    "href": "documentation/modules/ternary.html#examples",
    "title": "ternary",
    "section": "Examples",
    "text": "Examples\nTo plot circles (diameter = 0.1 cm) on a 6-inch-wide ternary diagram at the positions listed in the file ternary.txt, with default annotations and gridline spacings, using the specified labeling, try\n\nusing GMT\n\nmakecpt(cmap=:turbo, range=(0,80,10))\nternary(\"@ternary.txt\", region=(0,100,0,100,0,100), marker=:circ, ms=0.1, vertex_labels=\"Water/Air/Limestone\",\n    frame=(annot=:auto, grid=:a, ticks=:a, alabel=\"Water component\", blabel=\"Air component\", clabel=\"Limestone component\", suffix=\" %\", fill=:ivory, title=\"Example data from MATLAB Central\"), show=true)\n\n\n\n\n\n\n\n\nSee other examples at Ternary plots"
  },
  {
    "objectID": "documentation/modules/ternary.html#source-code",
    "href": "documentation/modules/ternary.html#source-code",
    "title": "ternary",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nternary(cmd0::String; ...) - plot.jl:1662\nternary(; ...) - plot.jl:1662\nternary(arg1; kw...) - plot.jl:1763\nternary(cmd0::String, arg1; first, image, kwargs...) - plot.jl:1662\nternary(kw...) - plot.jl:1765"
  },
  {
    "objectID": "documentation/modules/ternary.html#see-also",
    "href": "documentation/modules/ternary.html#see-also",
    "title": "ternary",
    "section": "See Also",
    "text": "See Also\nplot"
  },
  {
    "objectID": "documentation/modules/talwani2d.html",
    "href": "documentation/modules/talwani2d.html",
    "title": "talwani2d",
    "section": "",
    "text": "Compute geopotential anomalies over 2-D bodies by the method of Talwani.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/subplot.html",
    "href": "documentation/modules/subplot.html",
    "title": "subplot",
    "section": "",
    "text": "subplot(fim=nothing; stop=false, kwargs...)\nsubplot module is used to split the current figure into a rectangular layout of subplots that each may contain a single self-contained figure. A subplot setup is started with the subplot directive that defines the layout of the subplots, while positioning to a particular subplot for plotting is done via the subplot(:set, …) directive. The subplot process is completed via the subplot(:end) or subplot(:show) directives.\nsubplot : – subplot=(:set, :end, show; grid=…, dims=…, panels_size=…, autolabel=…, clearance=…, axes=…, proj=…, margins=…, region=…, layout, title=…, figname=…, name=…, savefig=…, fmt=…)"
  },
  {
    "objectID": "documentation/modules/subplot.html#required-arguments",
    "href": "documentation/modules/subplot.html#required-arguments",
    "title": "subplot",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ngrid : grid=“nrows x ncols” | grid=(nrows, ncols)\nSpecifies the number of rows and columns of subplots. Each row will have the same number of subplots. Note1: Use NO spaces with the first form. i.e. grid=“2x2” and NOT grid=” 2 x 2”\nNote2: You are not required to place a plot in each subplot.\nF or dims or dimensions or size or sizes : – dims=(panels=(w,h), figsize=(w,h), frac=(), clearance=(dx,dy), outline=pen, fill=color, divlines=pen)\nSpecify the dimensions of the figure. There are two different ways to do this:\n\nWith the keyword figsize Specify overall figure dimensions\n\nWith the keyword panels specify the dimensions of a single subplot.\n\nFor grids up to 3x3 and 2x1 and 3x1, if neither figsize or panels are specified, an estimation of the panels size plus margins will be provided. This may suite many use cases but with a probable need to specify better margins.\nfigsize\nSpecify the final figure dimensions. The subplot dimensions are then calculated from the figure dimensions after accounting for the space that optional tick marks, annotations, labels, and margins occupy between subplots. As for other figures, annotations, ticks, and labels along the outside perimeter are not counted as part of the figure dimensions. To specify different subplot dimensions for each row (or column), append frac with value given as a tuple of width and height fractions. For example dims=(size=(10,10), frac=((3,1),(1,2))) will make a 10x10 cm fig with the first column three times as wide as the second, while the second row will be twice as tall as the first row. A single number means constant widths (or heights) [Default]. If prefered, instead of size and/or frac as tuples, the width=x, height=y, fwidth=(…), fheight=(…) form is also allowed.\npanels\nSpecify the dimensions of each subplot directly. Then, the figure dimensions are computed from the subplot dimensions after adding the space that optional tick marks, annotations, labels, and margins occupy between subplots. As for other figures, annotations, ticks, and labels along the outside perimeter are not counted as part of the figure dimensions. To specify different subplot dimensions for each row (or column), append a comma-separated list of widths, a slash, and then the comma-separated list of heights. A single number means constant widths (or heights) [Default]. For example dims=(panels=((5,8),8),) will make the first column 5 cm wide and the second column 8 cm wide, with all having a constant height of 8 cm. The number of values must either be one (constant across the rows or columns) or exactly match the number of rows (or columns). For geographic maps, the height of each subplot depends on your map region and projection. There are two options:\n\nSpecify both limits and projection and we use these to compute the height of each subplot. All subplots must share the same region and projection and you specify a zero height, or\nyou can select height based on trial and error to suit your plot layout.\n\nOptionally, you may draw the outline (outline=pen) or paint (fill=color) the figure rectangle behind the subplots, add dividing lines between panels (divlines=pen), and even expand it via clearance=(dx,dy). These are most useful if you supply axes=:none, meaning no ticks or annotations will take place in the subplots. See [Setting color] and [Pen attributes] for extend color and pen selections.\nBut when we only want to set panels with a constant size one can use the simpler form subplot(grid=…, panels_size=8, …), i.e. without using the dims=(panels=()) form. panels_size, panel_size and panel_sizes are all aliases."
  },
  {
    "objectID": "documentation/modules/subplot.html#optional-arguments",
    "href": "documentation/modules/subplot.html#optional-arguments",
    "title": "subplot",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or autolabel : – autolabel=(Anchor=tag, anchor=tag, label=““, clearance=(dx,dy), fill=color, pen=pen, offset=, roman=Bool, Roman=Bool, vertical=Bool)\nSpecify automatic tagging of each subplot. Use label= either a number or letter (as a string) [Default “a”]. This sets the tag of the first, top-left subplot and others follow sequentially. Surround the number or letter by parentheses on any side if these should be typeset as part of the tag. Use anchor or Anchor =refpoint to specify where the tag should be placed in the subplot [TL, meaning TopLeft]. Note: anchor sets the justification of the tag to refpoint (suitable for interior tags) while Anchor instead selects the mirror opposite (suitable for exterior tags).\n\nAppend clearance=dx or clearance=(dx,dy) to set the clearance between the tag and a surrounding text box requested via fill or pen [3p/3p, i.e., 15% of the FONT_TAG size dimension].\nAppend fill=color to paint the tag’s text box with color [no painting].\nAppend offset=dx or offset=(dx,dy) to offset the tag’s reference point in the direction implied by the justification [4p/4p, i.e., 20% of the FONT_TAG size].\nAppend pen=pen to draw the outline of the tag’s text box using selected pen [no outline].\nAppend roman=true to typeset your tag numbers using lowercase Roman numerals.\nAppend Roman=true for uppercase Roman numerals [Arabic numerals].\nAppend vertical=true to increase tag numbers vertically down columns [horizontally across rows].\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or clearance : – clearance=val | clearance=(left=val, right=val, bott=val, bottom=val, top=val))\nReserve a space of dimension val between the margin and the subplot on the specified side, using side values from left=val, right=val, bottom=val, or top=val. No side means all sides. Can specify more than one side. Such space will be left untouched by the main map plotting but can be accessed by modules that plot scales, bars, text, etc. Settings specified under begin directive apply to all subplots, while settings under set only apply to the selected (active) subplot. Note: Common options xshift and yshift are not available during subplots; use clearance instead.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nM or margins : – margins=val\nThis is margin space that is added between neighboring subplots (i.e., the interior margins) in addition to the automatic space added for tick marks, annotations, and labels. The margins can be specified as a single value (for same margin on all sides), a pair of values separated by slashes (for setting separate horizontal and vertical margins), or the full set of four slash-separated margins (for setting separate left, right, bottom, and top margins). The actual gap created is always a sum of the margins for the two opposing sides (e.g., east plus west or south plus north margins) [Default is half the primary annotation font size, giving the full annotation font size as the default gap].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nSC or col_axes or colaxes or sharex : – col_axes=(top=““, bott=”“, bottom=”“, label=”“, grid=pen))\n\nSR or row_axes or rowaxes or sharey : – row_axes=(left=““, right=”“, label=”“, parallel=”“, row_title=”t”, top_row_title=““, grid=pen))\nSet subplot layout for shared axes. May be set separately for rows (row_axes) and columns (col_axes).\nConsiderations for col_axes:\nUse when all subplots in a column share a common x-range. The first (i.e., top) and the last (i.e., bottom) rows will have x annotations; append top=““ or bott=““ to select only one of those two rows [both].\n\nAdd label=““ if annotated x-axes should have a label [none]; optionally append the label if it is the same for the entire subplot. Labels and titles that depends on which row or column are specified as usual via a subplot’s own axes setting.\nConsiderations for row_axes:\nUse when all subplots in a row share a common y-range. The first (i.e., left) and the last (i.e., right) columns will have y-annotations; append left=““ or right=““ to select only one of those two columns [both].\nAdd left=““ if annotated y-axes will have a label [none]; optionally, append the label if it is the same for the entire subplot.\nAdd row_title to make space for subplot titles for each row; use top_row_title for top row titles only [no subplot titles].\nAdd parallel=““ to make all annotations axis-parallel [horizontal]; if not used you may have to set clearance to secure extra space for long horizontal annotations.\nAdd grid=pen to draw horizontal and vertical lines between interior panels using selected pen [no lines].\n\nT or title : – title=“Heading”\nWhile individual subplots can have titles (see S or axes), the entire figure may also have a overarching heading [no heading]. Font is determined by setting FONT_HEADING."
  },
  {
    "objectID": "documentation/modules/subplot.html#synopsis-set-mode",
    "href": "documentation/modules/subplot.html#synopsis-set-mode",
    "title": "subplot",
    "section": "Synopsis (set mode)",
    "text": "Synopsis (set mode)\n\nsubplot(:set, panel=…, fixedlabel=“Label”, clearance=…)\n\n\nBefore you start plotting you must first select the active subplot. Note: If any figsize or figscale option is passed with auto as width or scale when plotting subplots, then the dimensions of the map are automatically determined by the subplot size and your region. For Cartesian plots: If you want the scale to apply equally to both dimensions then you must specify proj=:linear, figscale=“auto” [The default figsize=“auto” will fill the subplot by using unequal scales]."
  },
  {
    "objectID": "documentation/modules/subplot.html#optional-arguments-1",
    "href": "documentation/modules/subplot.html#optional-arguments-1",
    "title": "subplot",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\npanel=(row,col)\nSets the current subplot until further notice. Note: First row or col is 1 not 0 like in plain GMT. If not given we go to the next subplot by order specified via autolabel=(vertical=true,). As an alternative, you may bypass the set mode and instead supply the common option panel=(row,col) to the first plot command you issue in that subplot. GMT maintains information about the current figure and subplot. Also, you may give the one-dimensional index instead which starts at 1 and follows the row or column order set via autolabel=(vertical=true,). panel=“next” or panel=““ are alternative index syntaxes\nA or fixedlabel : – fixedlabel=“Label”\nOverrides the automatic labeling with the given string. No modifiers are allowed. Placement, justification, etc. are all inherited from how autolablel was specified.\nC or clearance : – clearance=(left=val, right=val, bott=val, bottom=val, top=val))\nReserve a space of dimension clearance between the margin and the subplot on the specified side. This setting has the same syntax and overrides the common clearances set by clearance outside the subplot(:set, …) command.\n\nAny number of plotting command can now take place and all output will be directed to the selected subplot. There are a few other rules that need to be followed:\n1. The subplot machinery expects the first plotting command in a new subplot window to take care of plotting the base frame. The particulars of this frame may have been specified by the row|col_axes option. In either case, should you need to set or override frame and axes parameters then you must specify these axes options with this first plot command. 2. The subplot machinery automatically uses the xshift and yshift options under the hood so these options are not available while a subplot is active."
  },
  {
    "objectID": "documentation/modules/subplot.html#synopsis-end-mode",
    "href": "documentation/modules/subplot.html#synopsis-end-mode",
    "title": "subplot",
    "section": "Synopsis (end mode)",
    "text": "Synopsis (end mode)\n\nsubplot(:end) or subplot(:show)\n\n\nThis command finalizes the current subplot, including any placement of tags, and updates the gmt.history to reflect the dimensions and linear projection required to draw the entire figure outline. This allows subsequent commands, such as colorbar, to use pos=… to place bars with reference to the complete figure dimensions. We also reset the current plot location to where it was prior to the subplot. The keyword :end just finishes the plot silently whislst with :show the plot is displayed automatically.\n\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)"
  },
  {
    "objectID": "documentation/modules/subplot.html#examples",
    "href": "documentation/modules/subplot.html#examples",
    "title": "subplot",
    "section": "Examples",
    "text": "Examples\nTo make a minimalistic 3x3 basemap layout, try::\n\nusing GMT\nsubplot(grid=\"3x3\", panels_size=(5,7), region=(0, 100, 0, 80), frame=:WSen, autolabel=1, margins=\"6p\")\n    basemap(panel=1)\n    basemap(panel=2, proj=:linear)      # Same as above\n    basemap(panel=\"next\", proj=:linear, figsize=\"auto,auto\")\n\n    basemap(panel=\"\", proj=:linear, figsize=\"auto,auto\", flipaxes=:x)\n    basemap(panel=\"\", proj=:linear, figsize=\"auto,auto\", flipaxes=:y)\n    basemap(panel=\"\", proj=:linear, figsize=\"auto,auto\", flipaxes=:xy)\n\n    basemap(panel=(3,1), proj=:linear, figscale=\"auto,auto\", flipaxes=:x)\n    basemap(panel=\"next\", proj=:geog, figsize=\"auto,auto\")\n    basemap(panel=\"next\", proj=:geog, figsize=\"auto\")\nsubplot(:show)\n\n\n\n\n\n\n\n\nand a 2x2 with some symbols and showing more ways of setting the panel sizes and selection\nsubplot(grid=(2,2), panels_size=8, region=(0, 100, 0, 80), margins=\"5p\", autolabel=true, col_axes=(bott=true,), row_axes=(left=true,), axes=\"wstr\", name=\"panels.pdf\")\n    basemap(region=(0,80,0,50))\n    subplot(:set)\n    plot([50 40], marker=:circle, mc=:red)\n    subplot(:set)\n    plot([50 40], marker=:square, mc=:green)\n    subplot(:set, panel=(2,2))\n    plot([50 40], marker=:star, mc=:blue)\nsubplot(:show)\nUse variable panels with variable sizes:\n\nusing GMT\nsubplot(grid=(3,2), dims=(panels=true, sizes=((\"2i\",\"4i\"),(\"2.5i\",\"5i\",\"1.25i\"))), row_axes=(left=true, parallel=true),\n        col_axes=(bott=true,), margins=0, autolabel=(label=:A, vertical=true), title=\"Variable dimensions\")\n    basemap(region=(0,5,0,5),     frame=(fill=:pink,))\n    basemap(region=(0,5,10,15),   frame=(fill=:cyan,),   panel=:next)\n    basemap(region=(0,5,10,15),   frame=(fill=:lightgray,),   panel=:next)\n    basemap(region=(10,15,0,5),   frame=(fill=:yellow,), panel=:next)\n    basemap(region=(10,15,10,15), frame=(fill=:purple,), panel=:next)\n    basemap(region=(10,15,10,15), frame=(fill=:orange,), panel=:next)\nsubplot(:show)\n\n\n\n\n\n\n\n\nA very similar to the above figure can be created with:\nsubplot(grid=(3,2), dims=(size=(\"6.5i\",\"9i\"), frac=((1,2), (1,2,0.5)) ), row_axes=(left=true, parallel=true),\n        col_axes=(bott=true,), frame=:WSne, margins=0, autolabel=true, title=\"Variable fractions\")\n    basemap(region=(0,5,0,5),     frame=(fill=:pink,))\n    basemap(region=(10,15,0,5),   frame=(fill=:yellow,), panel=:next)\n    basemap(region=(0,5,10,15),   frame=(fill=:cyan,),   panel=:next)\n    basemap(region=(10,15,10,15), frame=(fill=:purple,), panel=:next)\n    basemap(region=(0,5,10,15), frame=(fill=:lightgray,),panel=:next)\n    basemap(region=(10,15,10,15), frame=(fill=:orange,), panel=:next)\nsubplot(:show)"
  },
  {
    "objectID": "documentation/modules/subplot.html#restriction",
    "href": "documentation/modules/subplot.html#restriction",
    "title": "subplot",
    "section": "Restriction",
    "text": "Restriction\nCurrently, nesting of subplots is not implemented. With the geog projection one cannot set the fist axes to geog and the other to whatever because only last dimension is assigned that label. The solution to fine control here is to use the GMT syntax given as a string"
  },
  {
    "objectID": "documentation/modules/subplot.html#source-code",
    "href": "documentation/modules/subplot.html#source-code",
    "title": "subplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsubplot(; ...) - subplot.jl:39\nsubplot(fim; stop, kwargs...) - subplot.jl:39"
  },
  {
    "objectID": "documentation/modules/stairs.html",
    "href": "documentation/modules/stairs.html",
    "title": "stairs",
    "section": "",
    "text": "stairs(cmd0::String=\"\", arg1=nothing; step=:post, kwargs...)\nReads (x,y) pairs and plot stairstep graph. The input can either be a file name of a file with at least two columns (x,y), but optionally more, a GMTdatset object with also two or more columns, or direct x,y inputs\nstairs(D::GMTdatset,xvar,yvar) plots the variables xvar and yvar from the table D. You can specify one or multiple variables for yvar and one only for xvar."
  },
  {
    "objectID": "documentation/modules/stairs.html#examples",
    "href": "documentation/modules/stairs.html#examples",
    "title": "stairs",
    "section": "Examples",
    "text": "Examples\nCreate a stairs plot of sine evaluated at 50 equally spaced values between 0 and 4π.\n\nusing GMT\nx = linspace(0, 4*pi, 50);\nstairs(x, sin.(x), show=true)\n\n\n\n\n\n\n\n\nCreate a stairs plot of sine and a cosine evaluated at same points as above and add a circle marker at the points location. Note that now we are selectiong the columns from teir names in the D GMTdataset.\n\nusing GMT\n# Create a GMTdataset with named columns.\nx = linspace(0, 4*pi, 50);\nD = mat2ds([x sin.(x) cos.(x)], colnames=[\"x\", \"sin(x)\", \"cos(x)\"]);\nstairs(D, xvar=:x, yvar=[\"sin(x)\", \"cos(x)\"], lw=0.5, marker=:circ, show=true)"
  },
  {
    "objectID": "documentation/modules/stairs.html#source-code",
    "href": "documentation/modules/stairs.html#source-code",
    "title": "stairs",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nstairs(cmd0::String; ...) - plot.jl:875\nstairs(; ...) - plot.jl:875\nstairs(cmd0::String, arg1; first, step, kwargs...) - plot.jl:875\nstairs(arg1, arg2; step, kw...) - plot.jl:883\nstairs(arg; step, kw...) - plot.jl:881"
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html",
    "href": "documentation/modules/sphinterpolate.html",
    "title": "sphinterpolate",
    "section": "",
    "text": "sphinterpolate(cmd0::String=\"\", arg1=nothing, kwargs...)\nSpherical gridding in tension of data on a sphere."
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#description",
    "href": "documentation/modules/sphinterpolate.html#description",
    "title": "sphinterpolate",
    "section": "Description",
    "text": "Description\nReads lon, lat, z from file or table and performs a Delaunay triangulation to set up a spherical interpolation in tension. The final grid is saved to the specified file. Several options may be used to affect the outcome, such as choosing local versus global gradient estimation or optimize the tension selection to satisfy one of four criteria."
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#required-arguments",
    "href": "documentation/modules/sphinterpolate.html#required-arguments",
    "title": "sphinterpolate",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#optional-arguments",
    "href": "documentation/modules/sphinterpolate.html#optional-arguments",
    "title": "sphinterpolate",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nD or skipdup : skipdup=true | skipdup=:east\nSkip duplicate points since the spherical gridding algorithm cannot handle them. [Default assumes there are no duplicates, except possibly at the poles]. Append a repeating longitude (east) to skip records with that longitude instead of the full (slow) search for duplicates.\nQ or tension : – tension=mode\nSpecify one of four ways to calculate tension factors to preserve local shape properties or satisfy arc constraints [Default is no tension]. Use:\n\ntension=:p for piecewise linear interpolation; no tension is applied.\ntension=:l for local Smooth interpolation with local gradient estimates.\ntension=:g for global Smooth interpolation with global gradient estimates. You may optionally append N/M/U (e.g. (invented) tension=“g1/2/3), where N is the number of iterations used to converge at solutions for gradients when variable tensions are selected (e.g., var_tension only) [3], M is the number of Gauss-Seidel iterations used when determining the global gradients [10], and U is the maximum change in a gradient at the last iteration [0.01].\ntension=:s for smoothing. Optionally append E/U/N [/0/0/3], where E is Expected squared error in a typical (scaled) data value, and U is Upper bound on weighted sum of squares of deviations from data. Here, N is the number of iterations used to converge at solutions for gradients when variable tensions are selected (e.g., var_tension only) [3]\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nT or var_tension : var_tension=true\nUse variable tension.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or scale : – scale=true\nBefore interpolation, scale data by the maximum data range [no scaling].\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#examples",
    "href": "documentation/modules/sphinterpolate.html#examples",
    "title": "sphinterpolate",
    "section": "Examples",
    "text": "Examples\nTo interpolate data from the remote file mars370d.txt using the piecewise method for a 1x1 global grid, then plot it, try:\n\nusing GMT\nG = sphinterpolate(\"@mars370d.txt\", region=:global, inc=1, tension=:p)\nimshow(G, proj=:guess, shade=true)\n\n\n\n\n\n\n\n\nTo interpolate the points in the file testdata.txt on a global 1x1 degree grid with no tension, use:\n    G = sphinterpolate(\"testdata.txt\", region=:global, inc=1)"
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#notes",
    "href": "documentation/modules/sphinterpolate.html#notes",
    "title": "sphinterpolate",
    "section": "Notes",
    "text": "Notes\nThe STRIPACK algorithm and implementation expect that there are no duplicate points in the input. It is best that the user ensures that this is the case. GMT has tools, such as blockmean and others, to combine close points into single entries. Also, sphinterpolate has a skipdup option to determine and exclude duplicates, but it is a very brute-force yet exact comparison that is very slow for large data sets. A much quicker check involves appending a specific repeating longitude value. Detection of duplicates in the STRIPACK library will exit the module."
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#source-code",
    "href": "documentation/modules/sphinterpolate.html#source-code",
    "title": "sphinterpolate",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsphinterpolate(cmd0::String; ...) - sphinterpolate.jl:40\nsphinterpolate(; ...) - sphinterpolate.jl:40\nsphinterpolate(arg1; kw...) - sphinterpolate.jl:50\nsphinterpolate(cmd0::String, arg1; kwargs...) - sphinterpolate.jl:40"
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#see-also",
    "href": "documentation/modules/sphinterpolate.html#see-also",
    "title": "sphinterpolate",
    "section": "See Also",
    "text": "See Also\ngreenspline, nearneighbor, sphdistance, sphtriangulate, surface, triangulate"
  },
  {
    "objectID": "documentation/modules/sphinterpolate.html#references",
    "href": "documentation/modules/sphinterpolate.html#references",
    "title": "sphinterpolate",
    "section": "References",
    "text": "References\nRenka, R, J., 1997, Algorithm 772: STRIPACK: Delaunay Triangulation and Voronoi Diagram on the Surface of a Sphere, AMC Trans. Math. Software, 23 (3), 416-434.\nRenka, R, J,, 1997, Algorithm 773: SSRFPACK: Interpolation of scattered data on the Surface of a Sphere with a surface under tension, AMC Trans. Math. Software, 23 (3), 435-442."
  },
  {
    "objectID": "documentation/modules/spectrum1d.html",
    "href": "documentation/modules/spectrum1d.html",
    "title": "spectrum1d",
    "section": "",
    "text": "spectrum1d(cmd0::String=\"\", arg1=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#description",
    "href": "documentation/modules/spectrum1d.html#description",
    "title": "spectrum1d",
    "section": "Description",
    "text": "Description\nReads X [and Y] values from the first [and second] columns [or x[y]file]. These values are treated as timeseries X (t) [Y (t)] sampled at equal intervals spaced dt units apart. There may be any number of lines of input. spectrum1d will create file[s] containing auto- [and cross- ] spectral density estimates by Welch’s [1967] method of ensemble averaging of multiple overlapped windows, using standard error estimates from Bendat and Piersol [1986].\nThe output has 3 columns: f or w, p, and e. f or w is the frequency or wavelength, p is the spectral density estimate, and e is the one standard deviation error bar size. If the output option is used, up to eight files are created; otherwise only one (xpower) is written.\n\nname_stem.xpower\nPower spectral density of X (t). Units of X * X * dt.\nname_stem.ypower\nPower spectral density of Y (t). Units of Y * Y * dt.\nname_stem.cpower\nPower spectral density of the coherent output. Units same as ypower.\nname_stem.npower\nPower spectral density of the noise output. Units same as ypower.\nname_stem.gain\nGain spectrum, or modulus of the transfer function. Units of (Y / X).\nname_stem.phase\nPhase spectrum, or phase of the transfer function. Units are radians.\nname_stem.admit\nAdmittance spectrum, or real part of the transfer function. Units of (Y / X).\nname_stem.coh\n(Squared) coherency spectrum, or linear correlation coefficient as a function of frequency. Dimensionless number in [0, 1]. The Signal-to-Noise-Ratio (SNR) is coh / (1 - coh). SNR = 1 when coh = 0.5.\n\nIn addition, a single file with all of the above as individual columns will be written to standard output (unless disabled via multifiles).\nWARNING The above, as well as some other parts of this manual were written for the CLI (Command Line Interface) version of this module and are guaranteed to work exactly as described. More testing is needed."
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#required-arguments",
    "href": "documentation/modules/spectrum1d.html#required-arguments",
    "title": "spectrum1d",
    "section": "Required Arguments",
    "text": "Required Arguments\ntable A file name, a GMTdataset or a Mx2 matrix holding \\(X(t)\\) [\\(Y(t)\\)] samples in the first 1 [or 2] columns.\n\nS or size : – size=segment_size\nsegment_size is a radix-2 number of samples per window for ensemble averaging. The smallest frequency estimated is 1.0/(segment_size * dt), while the largest is 1.0/(2 * dt). One standard error in power spectral density is approximately 1.0 / sqrt(n_data / segment_size), so if segment_size = 256, you need 25,600 data to get a one standard error bar of 10%. Cross-spectral error bars are larger and more complicated, being a function also of the coherency."
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#optional-arguments",
    "href": "documentation/modules/spectrum1d.html#optional-arguments",
    "title": "spectrum1d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or components or output : – output=(xpower=true, ypower=true, cpower=true, npower=true”, phase=true, admitt=true, gain=true, coh=true)\nRead the first two columns of input as samples of two time-series, X (t) and Y (t). Consider Y (t) to be the output and X (t) the input in a linear system with noise. Estimate the optimum frequency response function by least squares, such that the noise output is minimized and the coherent output and the noise output are uncorrelated. Optionally specify up to 8 directives from the set refered above in any order to create only those output files instead of the default [all]. Use in alternatively a string made of the acgnopxy characters, or the expanded version that uses the keywords.\n\na or admitt=true: Admittance spectrum, or real part of the transfer function.\nc or cpower=true: Power spectral density of the coherent output.\ng or gain=true: Gain spectrum, or modulus of the transfer function.\nn or npower=true: Power spectral density of the noise output.\no or coh=true: Squared coherency spectrum, or linear correlation coefficient as a function of frequency.\np or phase=true: Phase spectrum, or phase of the transfer function.\nx or xpower=true: Power spectral density of X (t).\ny or ypower=true: Power spectral density of Y (t).\n\nD or sample_dist : – sample_dist=dt\ndt Set the spacing between samples in the time-series [Default = 1].\nL or leave_trend : – leave_trend=“h|m”\nLeave trend alone. By default, a linear trend will be removed prior to the transform. Alternatively, use leave_trend=m to just remove the mean value or h to remove the mid-value.\nN or name : – name=name_stem\nSupply an alternate name stem to be used for each individual output file [Default = “spectrum”]. If this option is given with no argument then we disable the writing of individual output files and instead write a single composite results table.\nT or multifiles : – multifiles=true\nDisable the creation of a single composite results table. Only individual output files for each selected component (see output) will be created.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or wavelength : – wavelength=true\nWrite Wavelength rather than frequency in column 1 of the output file[s] [Default = frequency, (cycles / dt)].\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at"
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#examples",
    "href": "documentation/modules/spectrum1d.html#examples",
    "title": "spectrum1d",
    "section": "Examples",
    "text": "Examples\nSuppose data.g is gravity data in mGal, sampled every 1.5 km. To write its power spectrum, in mGal^2-km, to the file data.xpower, use:\nD = spectrum1d(\"data.g\", size=256, sample_dist=1.5);\nSuppose in addition to gravity data you have also the topography data.t in meters sampled at the same points as gravity. To estimate various features of the transfer function, considering topography as input and gravity as output, stored in the first and second columns of the data.tg use:\nD = spectrum1d(\"data.tg\", size=256, sample_dist=1.5, output=true);  # 'true' here means 'all'"
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#tutorial",
    "href": "documentation/modules/spectrum1d.html#tutorial",
    "title": "spectrum1d",
    "section": "Tutorial",
    "text": "Tutorial\nThe output of spectrum1d is in units of power spectral density, and so to get units of data-squared you must divide by delta_t, where delta_t is the sample spacing. (There may be a factor of 2 pi somewhere, also. If you want to be sure of the normalization, you can determine a scale factor from Parseval’s theorem: the sum of the squares of your input data should equal the sum of the squares of the outputs from spectrum1d, if you are simply trying to get a periodogram. [See below.])\nSuppose we simply take a data set, x(t), and compute the discrete Fourier transform (DFT) of the entire data set in one go. Call this X(f). Then suppose we form X(f) times the complex conjugate of X(f).\nP_raw(f) = X(f) * X’(f), where the ’ indicates complex conjugation.\nP_raw is called the periodogram. The sum of the samples of the periodogram equals the sum of the samples of the squares of x(t), by Parseval’s theorem. (If you use a DFT subroutine on a computer, usually the sum of P_raw equals the sum of x-squared, times M, where M is the number of samples in x(t).)\nEach estimate of X(f) is now formed by a weighted linear combination of all of the x(t) values. (The weights are sometimes called “twiddle factors” in the DFT literature.) So, no matter what the probability distribution for the x(t) values is, the probability distribution for the X(f) values approaches [complex] Gaussian, by the Central Limit Theorem. This means that the probability distribution for P_raw(f) approaches chi-squared with two degrees of freedom. That reduces to an exponential distribution, and the variance of the estimate of P_raw is proportional to the square of the mean, that is, the expected value of P_raw.\nIn practice if we form P_raw, the estimates are hopelessly noisy. Thus P_raw is not useful, and we need to do some kind of smoothing or averaging to get a useful estimate, P_useful(f).\nThere are several different ways to do this in the literature. One is to form P_raw and then smooth it. Another is to form the auto-covariance function of x(t), smooth, taper and shape it, and then take the Fourier transform of the smoothed, tapered and shaped auto-covariance. Another is to form a parametric model for the auto-correlation structure in x(t), then compute the spectrum of that model. This last approach is what is done in what is called the “maximum entropy” or “Berg” or “Box-Jenkins” or “ARMA” or “ARIMA” methods.\nWelch’s method is a tried-and-true method. In his method, you choose a segment length, size=N, so that estimates will be made from segments of length N. The frequency samples (in cycles per delta_t unit) of your P_useful will then be at k /(N * delta_t), where k is an integer, and you will get N samples (since the spectrum is an even function of f, only N/2 of them are really useful). If the length of your entire data set, x(t), is M samples long, then the variance in your P_useful will decrease in proportion to N/M. Thus you need to choose N &lt;&lt; M to get very low noise and high confidence in P_useful. There is a trade-off here; see below.\nThere is an additional reduction in variance in that Welch’s method uses a Von Hann spectral window on each sample of length N. This reduces side lobe leakage and has the effect of smoothing the (N segment) periodogram as if the X(f) had been convolved with [1/4, 1/2, 1/4] prior to forming P_useful. But this slightly widens the spectral bandwidth of each estimate, because the estimate at frequency sample k is now a little correlated with the estimate at frequency sample k+1. (Of course this would also happen if you simply formed P_raw and then smoothed it.)\nFinally, Welch ’s method also uses overlapped processing. Since the Von Hann window is large in the middle and tapers to near zero at the ends, only the middle of the segment of length N contributes much to its estimate. Therefore in taking the next segment of data, we move ahead in the x(t) sequence only N/2 points. In this way, the next segment gets large weight where the segments on either side of it will get little weight, and vice versa. This doubles the smoothing effect and ensures that (if N &lt;&lt; M) nearly every point in x(t) contributes with nearly equal weight in the final answer.\nWelch’s method of spectral estimation has been widely used and widely studied. It is very reliable and its statistical properties are well understood. It is highly recommended in such textbooks as “Random Data: Analysis and Measurement Procedures” [Bendat and Piersol, 1986].\nIn all problems of estimating parameters from data, there is a classic trade-off between resolution and variance. If you want to try to squeeze more resolution out of your data set, then you have to be willing to accept more noise in the estimates. The same trade-off is evident here in Welch’s method. If you want to have very low noise in the spectral estimates, then you have to choose N &lt;&lt; M, and this means that you get only N samples of the spectrum, and the longest period that you can resolve is only N * delta_t. So you see that reducing the noise lowers the number of spectral samples and lowers the longest period. Conversely, if you choose N approaching M, then you approach the periodogram with its very bad statistical properties, but you get lots of samples and a large fundamental period.\nThe other spectral estimation methods also can do a good job. Welch’s method was selected because the way it works, how one can code it, and its effects on statistical distributions, resolution, side-lobe leakage, bias, variance, etc. are all easily understood. Some of the other methods (e.g. Maximum Entropy) tend to hide where some of these trade-offs are happening inside a “black box”."
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#source-code",
    "href": "documentation/modules/spectrum1d.html#source-code",
    "title": "spectrum1d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nspectrum1d(cmd0::String; kw...) - spectrum1d.jl:47\nspectrum1d(arg1; kw...) - spectrum1d.jl:48"
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#see-also",
    "href": "documentation/modules/spectrum1d.html#see-also",
    "title": "spectrum1d",
    "section": "See Also",
    "text": "See Also\ngrdfft"
  },
  {
    "objectID": "documentation/modules/spectrum1d.html#references",
    "href": "documentation/modules/spectrum1d.html#references",
    "title": "spectrum1d",
    "section": "References",
    "text": "References\nBendat, J. S., and A. G. Piersol, 1986, Random Data, 2nd revised ed., John Wiley & Sons.\nWelch, P. D., 1967, The use of Fast Fourier Transform for the estimation of power spectra: a method based on time averaging over short, modified periodograms, IEEE Transactions on Audio and Electroacoustics, Vol AU-15, No 2."
  },
  {
    "objectID": "documentation/modules/segyz.html",
    "href": "documentation/modules/segyz.html",
    "title": "segyz",
    "section": "",
    "text": "Plot a SEGY file in 3-D.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/seismicity.html",
    "href": "documentation/modules/seismicity.html",
    "title": "seismicity",
    "section": "",
    "text": "seismicity(starttime=\"\", endtime=\"\", minmagnitude=3, mindepth=0, maxdepth=0, last=0, printurl=false, show=true, kw...)\nMake automatic maps of the world-wide seismicity obtained from USGS Earthquake Hazards Program in Julia using GMT.\nThis module is a mix of plot, coast and legend functionalities. So not all (fine) controlling plotting parameters are listed here. For the finest control, user should consult the manuals of those modules."
  },
  {
    "objectID": "documentation/modules/seismicity.html#parameters",
    "href": "documentation/modules/seismicity.html#parameters",
    "title": "seismicity",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nstarttime: Limit to events on or after the specified start time. NOTE: All times use ISO8601 Date/Time format OR a DateTime type. Default is NOW - 30 days.\nendtime: Limit to events on or before the specified end time. Same remarks as for starttime. Default is present time.\nminmagnitude: Limit to events with a magnitude larger than the specified minimum.\nmindepth: Limit to events with depth more than the specified minimum (km positive down).\nmaxdepth: Limit to events with depth less than the specified maximum (km positive down).\nlast: If value is an integer (e.g. last=90), select the events in the last n days. If it is a string than we expect that it ends with a ‘w’(eek), ‘m’(onth) or ‘y’(ear). Example: last=\"2Y\" (period code is caseless)\nprinturl: Print the url of the requested data.\ncircle: A 3 elements Tuple or Array with lon,lat,radius, where radius is in km, to perform a circle search.\ndata: The default is to make a seismicity map but if the data option is used (containing whatever) we return the data in a GMTdataset\nfigname: Save the figure with the figname=name.ext where ext chooses the figure format (e.g. figname=\"name.png\")\nland: By default we paint the continents with the “burlywood” color. Like in the coast module, use land=“othercolor” to replace it.\nlayers: By default we divide depth into three layers; 1-100, 100-300 and &gt; 300 km, Use layers=4 to subdivide top layer into 0-50 and 50-100 km.\nlegend: By default we plot a legend. Particular options for the legend command (e.g. pos, box, etc) are passed via the kw... options. Use legend=false to have no legend.\nocean: By default we paint the oceans with the “lightblue” color. Use ocean=“othercolor” to replace it.\nregion: The region of interest. By default it is [-180 180 -90 90] but one may pass a sub-region like all other modules that accept this option (e.g. coast)\nproj: By default we select an appropriate projection based on the region extents, but that may be overridden by specifying a proj=xxx like, for example, in coast.\nsize: Can be a scalar to plot all events with same size. This size is expected to be in cm but &gt; 1 it is interpreted to be in points.\n\nsize=[min_sz max_sz] will scale linearly min/max magnitude to have sizes min_sz/max_sz\nsize=([min_sz max_sz], [min_mag max_mag]) will scale linearly min_mag/max_mag magnitude to have sizes min_sz/max_sz\nsize=(fun, [min_sz max_sz] [, [min_mag max_mag]]) does the same as above but the transformation is determined by the function fun. Possibles functions are exp10, exp, pow and sqrt. In the pow case we must pass in also the exponent and the syntax is: size=((pow,2), [min_sz max_sz]) to have a square scaling.\n\nshow: By default this function shows the plot (when no data option). Use show=false to prevent that (and leave the figure open to accept more plots from posterior commands.)\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/seismicity.html#examples",
    "href": "documentation/modules/seismicity.html#examples",
    "title": "seismicity",
    "section": "Examples",
    "text": "Examples\nMake a map of the global seismicity of last 30 days..\n\nusing GMT\nseismicity()"
  },
  {
    "objectID": "documentation/modules/seismicity.html#source-code",
    "href": "documentation/modules/seismicity.html#source-code",
    "title": "seismicity",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/seismicity.html#see-also",
    "href": "documentation/modules/seismicity.html#see-also",
    "title": "seismicity",
    "section": "See Also",
    "text": "See Also\nplot, coast, legend"
  },
  {
    "objectID": "documentation/modules/scatter3.html",
    "href": "documentation/modules/scatter3.html",
    "title": "scatter3",
    "section": "",
    "text": "scatter3(cmd0::String=\"\", arg1=[]; kwargs...)\nReads (x,y,z) triplets and plot symbols at those locations on a map. This module is a subset of plot to make it simpler to draw scatter plots. So many (fine) controlling parameters are not listed here. For a finer control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/scatter3.html#parameters",
    "href": "documentation/modules/scatter3.html#parameters",
    "title": "scatter3",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax, zmin, zmax) | limits=(BB=(xmin, xmax, ymin, ymax, zmin, zmax),) | …more\nSpecify the region of interest. Default limits are computed from data extents. More at [limits](../common_opts/opt_R.html)\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nS or symbol or marker or Marker or shape : – Default is cube with size of 7 points\n\nsymbol=symbol string\nA full GMT compact string.\nsymbol=(symb=…, size=…, unit=…)\nWhere symb is one Symbols like :circle, size is symbol size in cm, unless unit is specified i.e. :points\n\nIn alternative to the symbol keyword, user can select the symbol name with either marker or shape and symbol size with markersize, ms or just size. The value of these keywords can be either numeric (symb meaning size in cm) or string if an unit is appended, e.g. markersize=5p. This form of symbol selection allows also to specify a variable symbol size. All it’s need for this is that the keywrd’s value be an array with the same number of elements as the number of data points.\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/scatter3.html#examples",
    "href": "documentation/modules/scatter3.html#examples",
    "title": "scatter3",
    "section": "Examples",
    "text": "Examples\nA scatter of ten points plotted as black cubes of 7 points size using the default perspective of 200,30\n\nusing GMT\nscatter3(rand(10,10,3), zsize=4, marker=:cube, mc=:darkgreen, show=true)"
  },
  {
    "objectID": "documentation/modules/scatter3.html#source-code",
    "href": "documentation/modules/scatter3.html#source-code",
    "title": "scatter3",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nscatter3(cmd0::String; ...) - plot.jl:413\nscatter3(cmd0::String, arg1; kw...) - plot.jl:413\nscatter3(f1::Function, f2::Function, f3::Function, range_t; first, kw...) - plot.jl:431\nscatter3(f1::Function, f2::Function, f3::Function; ...) - plot.jl:431\nscatter3(f1::Function, f2::Function; ...) - plot.jl:426\nscatter3(f1::Function, f2::Function, range_t; first, kw...) - plot.jl:426\nscatter3(arg1::AbstractArray, arg2::AbstractArray, arg3::AbstractArray; kw...) - plot.jl:419\nscatter3(; ...) - plot.jl:413\nscatter3(arg; kw...) - plot.jl:416"
  },
  {
    "objectID": "documentation/modules/scatter3.html#see-also",
    "href": "documentation/modules/scatter3.html#see-also",
    "title": "scatter3",
    "section": "See also",
    "text": "See also"
  },
  {
    "objectID": "documentation/modules/sample1d.html",
    "href": "documentation/modules/sample1d.html",
    "title": "sample1d",
    "section": "",
    "text": "sample1d(cmd0::String=\"\", arg1=nothing, kwargs...)\nResample 1-D table data using splines"
  },
  {
    "objectID": "documentation/modules/sample1d.html#description",
    "href": "documentation/modules/sample1d.html#description",
    "title": "sample1d",
    "section": "Description",
    "text": "Description\nReads a multi-column data set and interpolates the time-series or spatial profile at locations where the user needs the values. The user must provide the column number of the independent (monotonically increasing or decreasing) variable, here called time (it may of course be any type of quantity) when that is not the first column in data set. Equidistant or arbitrary sampling can be selected. All columns are resampled based on the new sampling interval. Several interpolation schemes are available, in addition to a smoothing spline which trades off misfit for curvature. Extrapolation outside the range of the input data is not supported."
  },
  {
    "objectID": "documentation/modules/sample1d.html#required-arguments",
    "href": "documentation/modules/sample1d.html#required-arguments",
    "title": "sample1d",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables containing the independent time variable (which must be monotonically in/de-creasing) and any number of optional columns holding other data values."
  },
  {
    "objectID": "documentation/modules/sample1d.html#optional-arguments",
    "href": "documentation/modules/sample1d.html#optional-arguments",
    "title": "sample1d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or resample : – resample=“f|p|m|r|R” | resample=“f|p|m|r|R[+d][+l]”\nFor track resampling (if inc…unit is set) we can select how this is to be performed. Use resample=:f to keep original points, but add intermediate points if needed; note this selection does not necessarily yield equidistant points [Default]. resample=:m as f but first follow meridian (along y) then parallel (along x). p as f but first follow parallel (along y) then meridian (along x). r to resample at equidistant locations; input points are not necessarily included in the output. R as r but adjust given spacing to fit the track length exactly. Finally, append +d to delete duplicate input records (identified by having no change in the time column, and +l if distances should be measured along rhumb lines (loxodromes)). Note: Calculation made for loxodromes is spherical, hence spherical=:ellipsoidal cannot be used in combination with +l.\nE or keeptext : – keeptext=true\nIf the input dataset contains records with trailing text then we will attempt to add these to output records that exactly match the input times. Output records that have no matching input record times will have no trailing text appended [Default ignores trailing text]. Needs GMT6.4 or higher.\nF or interp : – interp=type | interp=(type, [,par], “derivative”)\nThe default is Akima. You may change the default interpolant; see GMT_INTERPOLANT in your gmt.conf file.\nChoose type from (the interp_type=type form):\n\nlinear\nakima spline\ncubic (natural cubic spline)\nnointerp (no interpolation: nearest point)\nsmoothing cubic spline; append fit parameter p. Note, in this case one must pass only the first char, the s and the fitting parameter. Example: interp=“s0.01”\n\nYou may optionally evaluate the first or second derivative of the spline by appending +d1 or +d2, respectively.\nWhen using the second form (the interp_type=(…)), the first member is the same as above, except the smooth and the derivatives. To select first or second derivative use the :first or :second keywords. Examples of this syntax: interp=(:akima, :first), or interp=(:smoothing, 0.1), or interp=(:smoothing, 0.1, :second).\n\n\nusing GMT\nmat = [0 0; 1 1; 2 1.5; 3 1.25; 4 1.5; 4.5 3; 5 2; 6 2.5];\ngmtbegin()\n    D = sample1d(mat, inc=0.01, interp=:cubic);\n    plot(D, region=(-0.1,6.1,-0.1,3.1), figsize=(14,6), xlabel=:u, ylabel=\"u(x)\", lw=1, legend=\"Cubic spline (F=:c)\")\n    D = sample1d(mat, inc=0.01, interp=(:smooth, 1));\n    plot!(D, lw=1, lc=:orange, legend=\"Smooth cubic spline (F=:s1)\")\n    D = sample1d(mat, inc=0.01, interp=:linear);\n    plot!(D, lw=1, lc=:blue, legend=\"Linear spline (F=:l)\")\n    D = sample1d(mat, inc=0.01, interp=:akima);\n    plot!(D, lw=1, lc=:red, legend=\"Akima spline (F=:a)\")\n    D = sample1d(mat, inc=0.01, interp=:nointerp);\n    plot!(D, lw=1, lc=:darkgreen, legend=\"Nearest neighbor (F=:n)\")\n    plot!(mat, marker=:circ, ms=0.25, mc=:red, ml=:thin, legend=\"Data\")\n    legend(position=(inside=:TL, width=4.9, offset=0.2), box=(pen=1, fill=:white, shaded=true))\ngmtend(:show)\n\n\n\n\n\n\n\n\nThe interp option lets you choose among several interpolators, including one that is approximate (the smoothing spline). You can also specify that you actually need a derivative of the solution instead of the value.\n\nN or time_col or timecol : – timecol=t_col\nSets the column number of the independent time variable [Default is 0 (first)].\nT or range or inc : – range=(min,max,inc[,:number,:log2,:log10]) | range=[list] | range=file\nMake evenly spaced time-steps from min to max by inc [Default uses input times]. The form range=_list_ means a online list of time coordinates like for example: range=[13,15,16,22.5] whilst range=file means: read the time coordinates from file, one coordinate per row in file. Note: For resampling of spatial (x,y or lon,lat) series you must give an increment with a valid distance unit; see [Units] for map units or use c if plain Cartesian coordinates. The first two columns must contain the spatial coordinates. From these we calculate distances in the chosen units and interpolate using this parametric series.\ncumdist or cumsum : – cumdist=true\nCompute the cumulative distance along the input line. Note that for this the first two columns must contain the spatial coordinates and the accumulated distance is appended after last column of the table.\nkeep_nans : – keep_nans=true\nBy default we will ignore all NaN values in the input. This option will keep the NaN values in interpolation, meaning that all to-interpolate points in a vicinity of a NaN will be NaN. Use this option if you want NaNs to be used as gap separators.\nfill_nans or interp_nans : – interp_nans=true\nReplace all NaNs in input by their interpolated values. All other values will be kept as is.\nnonans : – nonans=true\niWhen using the gaps option, make sure that the output does not contain any NaN values. That means all rows that contain at least one record with a NaN will be removed. The default behavior is to keep the NaN values.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weights : – weights=col\nSets the column number of the weights to be used with a smoothing cubic spline. Requires interp=:s.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/sample1d.html#notes",
    "href": "documentation/modules/sample1d.html#notes",
    "title": "sample1d",
    "section": "Notes",
    "text": "Notes\nThe smoothing spline s(t) requires a fit parameter p that allows for the trade-off between an exact interpolation (fitting the data exactly; large p) to minimizing curvature (p approaching 0). Specifically, we seek to minimize\n\\[ F_p (s)= K (s) + p E (s), \\quad p &gt; 0 \\]\nwhere the misfit is evaluated as\n$$ E (s)= \\sum^n_{i=1} \\left [ \\frac{s(t_i) - y_i}{\\sigma_i} \\right ]^2 $$\nand the curvature is given by the integral over the domain of the second derivative of the spline\n$$ K (s) = \\int ^b _a [s''(t) ]^2 dt. $$\nTrial and error may be needed to select a suitable p."
  },
  {
    "objectID": "documentation/modules/sample1d.html#examples",
    "href": "documentation/modules/sample1d.html#examples",
    "title": "sample1d",
    "section": "Examples",
    "text": "Examples\nTo resample the file profiles.tdgmb, which contains (time,distance,gravity,magnetics,bathymetry) records, at 1 km equidistant intervals using Akima’s spline, use:\n    D = sample1d(\"profiles.tdgmb\", timecol=1, interp=:akima, inc=1)\nTo resample the file depths.dt at positions listed in the file grav_pos.dg, using a cubic spline for the interpolation, use:\n    D = sample1d(\"depths.txt\", range=\"grav_pos.dg\", interp=:cubic)\nTo resample the file points.txt every 0.01 from 0-6, using a cubic spline for the interpolation, but output the first derivative instead (the slope), try:\n    Ds = sample1d(\"points.txt\", range=(0,6,0.01), interp=(cubic, :first))\nTo resample the file track.txt which contains lon, lat, depth every 2 nautical miles, use:\n    D = sample1d(\"track.txt\", inc=\"2n\", resample=:R)\nTo do approximately the same, but make sure the original points are included, use:\n    D = sample1d(\"track.txt\", inc=\"2n\", resample=:f)\nTo obtain a rhumb line (loxodrome) sampled every 5 km instead, use:\n    D = sample1d(\"track.txt\", inc=\"5k\", resample=\"R+l\")\nTo sample temperatures.txt every month from 2000 to 2018, use\n    Dmo = sample1d(\"temperatures.txt\", range=(\"2000T\", \"2018T\", \"1o\"))\nTo use a smoothing spline on a topographic profile for a given fit parameter, try:\n    sample1d(\"@topo_crossection.txt\", range(300,500,0.1), interp=(:smooth, 0.001))"
  },
  {
    "objectID": "documentation/modules/sample1d.html#source-code",
    "href": "documentation/modules/sample1d.html#source-code",
    "title": "sample1d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsample1d(cmd0::String; kw...) - sample1d.jl:56\nsample1d(arg1; kw...) - sample1d.jl:57"
  },
  {
    "objectID": "documentation/modules/sample1d.html#see-also",
    "href": "documentation/modules/sample1d.html#see-also",
    "title": "sample1d",
    "section": "See Also",
    "text": "See Also\ngmt.conf, greenspline, filter1d"
  },
  {
    "objectID": "documentation/modules/rotsmoother.html",
    "href": "documentation/modules/rotsmoother.html",
    "title": "rotsmoother",
    "section": "",
    "text": "Get mean rotations and covariance matrices from set of finite rotations.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/radar.html",
    "href": "documentation/modules/radar.html",
    "title": "radar",
    "section": "",
    "text": "radar(cmd0=\"\", arg1=nothing; axeslimts=Float64[], annotall=false, axeslabels=String[], kwargs...)\nRadar plots are a useful way for seeing which variables have similar values or if there are outliers amongst each variable. By default we expect a matrix, or a GMTdatset (or a vector of them) with normalized values. This is so because a radar plot has multiple axis that each have different limits. So the options are to pass normalized variables or set each axis limits via the axeslimts option.\nBy default the polygons are not filled but that is often not so nice. To fill with the default cyclic color use just fill=true. Other options are to use:"
  },
  {
    "objectID": "documentation/modules/radar.html#examples",
    "href": "documentation/modules/radar.html#examples",
    "title": "radar",
    "section": "Examples",
    "text": "Examples\nCreate a\n\nusing GMT\n\nradar([0.5 0.5 0.6 0.9 0.77; 0.6 0.5 0.8 0.2 0.9], show=true, marker=:circ, fill=true)\n\n\n\n\n\n\n\n\nPlot\n\nradar([10.5 20.5 30.6 40.9 46], axeslimts=[15, 25, 50, 90, 50], annotall=true, marker=:circ, fill=true, \n      labels=[\"Spoons\",\"Forks\",\"Knifes\",\"Dishes\",\"Oranges\"], show=1)"
  },
  {
    "objectID": "documentation/modules/radar.html#source-code",
    "href": "documentation/modules/radar.html#source-code",
    "title": "radar",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nradar(cmd0::String; kwargs...) - plot.jl:1316\nradar(arg1; kwargs...) - plot.jl:1317"
  },
  {
    "objectID": "documentation/modules/radar.html#see-also",
    "href": "documentation/modules/radar.html#see-also",
    "title": "radar",
    "section": "See also",
    "text": "See also\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/qqplot.html",
    "href": "documentation/modules/qqplot.html",
    "title": "qqplot",
    "section": "",
    "text": "qqplot(x::AbstractVector{AbstractFloat}, y::AbstractVector{AbstractFloat}; kwargs...)\nThe qqplot function compares the quantiles of two distributions. The qqnorm is a shorthand for comparing a distribution to the normal distribution. If the distributions are similar the points will be on a straight line.\nThis module is a subset of plot to make it simpler to draw stair plots. So not all (fine) controlling parameters are not listed here. For the finest control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/qqplot.html#parameters",
    "href": "documentation/modules/qqplot.html#parameters",
    "title": "qqplot",
    "section": "Parameters",
    "text": "Parameters\n\nqqline : – Determines how to compute a fit line for the Q-Q plot. The options are\n\n\nidentity: draw the line y = x (the deafult).\nfit: draw a least squares line fit of the quantile pairs.\nfitrobust or quantile: draw the line that passes through the first and third quartiles of the distributions.\nnone: do not draw any line.\n\nBroadly speaking, qqline=:identity is useful to see if x and y follow the same distribution, whereas qqline=:fit and qqline=:fitrobust are useful to see if the distribution of y can be obtained from the distribution of x via an affine transformation.\nFor fine the lines settings use the same options as in the plot module. Nemely lw or lt for controling the line thickness, lc for line color, ls for line styles, etc…\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/qqplot.html#examples",
    "href": "documentation/modules/qqplot.html#examples",
    "title": "qqplot",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nqqplot(randn(100), randn(100), show=true)\n\n\n\n\n\n\n\n\n\nqqplot(randn(100), show=true)"
  },
  {
    "objectID": "documentation/modules/qqplot.html#source-code",
    "href": "documentation/modules/qqplot.html#source-code",
    "title": "qqplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nqqplot(x; qqline, first, kwargs...) - statplots.jl:953\nqqplot(x, y; qqline, first, kwargs...) - statplots.jl:905"
  },
  {
    "objectID": "documentation/modules/qqplot.html#see-also",
    "href": "documentation/modules/qqplot.html#see-also",
    "title": "qqplot",
    "section": "See also",
    "text": "See also\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/polespotter.html",
    "href": "documentation/modules/polespotter.html",
    "title": "polespotter",
    "section": "",
    "text": "Find stage poles given fracture zones and abyssal hills.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/pmodeler.html",
    "href": "documentation/modules/pmodeler.html",
    "title": "pmodeler",
    "section": "",
    "text": "Evaluate a plate motion model at given locations.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/piechart.html",
    "href": "documentation/modules/piechart.html",
    "title": "piechart",
    "section": "",
    "text": "piechart(x::VecOrMat; kw...)\nCreate a pie chart of the values in the vector data x.\nEach slice has a label indicating its size as a percentage of the whole pie or a label provided by the user."
  },
  {
    "objectID": "documentation/modules/piechart.html#source-code",
    "href": "documentation/modules/piechart.html#source-code",
    "title": "piechart",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/piechart.html#see-also",
    "href": "documentation/modules/piechart.html#see-also",
    "title": "piechart",
    "section": "See also",
    "text": "See also\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/originater.html",
    "href": "documentation/modules/originater.html",
    "title": "originater",
    "section": "",
    "text": "Associate seamounts with nearest hotspot point sources.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/movie.html",
    "href": "documentation/modules/movie.html",
    "title": "movie",
    "section": "",
    "text": "movie(main; pre=nothing, post=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/movie.html#description",
    "href": "documentation/modules/movie.html#description",
    "title": "movie",
    "section": "Description",
    "text": "Description\nmovie module can generate GMT animation sequences using a single-plot script that is repeated for all frames, with some variation using specific frame variables. The module simplifies (and hides) most of the steps normally needed to set up a full-blown animation job. Instead, the user can focus on composing the main frame plot and let the parallel execution of frames and assembly of images into a movie take place in the background. Individual frames are converted from PostScript plots to lossless, transparent PNG images and optionally assembled into an animation (this last step requires external tools that must be present in your path; see Technical Details below). For opaque PNG images, simply specify a background color via -G."
  },
  {
    "objectID": "documentation/modules/movie.html#required-arguments",
    "href": "documentation/modules/movie.html#required-arguments",
    "title": "movie",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nmainscript This argument can be one of: (1) The name of a Julia function containg GMT.jl commands that makes the frame-dependent plot. (2) Name of a stand-alone GMT.jl script that makes the frame-dependent plot. The function or script may access frame variables, such as frame number and others. Parameters that can be accessed are discussed below.\nC or canvas : – canvas=…\nSpecify the canvas size used when composing the movie frames. You can choose from a set of preset formats or specify a custom layout. The named 16:9 ratio formats have a canvas dimension of 24 x 13.5 cm or 9.6 x 5.4 inch and are (with pixel dimensions given in parenthesis):\n\n4320p (7680 x 4320), 2160p (3840 x 2160), 1080p (1920 x 1080), 720p (1280 x 720),\n540p (960 x 540), 480p (854 x 480), 360p (640 x 360), and 240p (426 x 240). We also accept 8k or uhd-2 to mean 4320p, 4k or uhd to mean 2160p, and hd to mean 1080p. The recognized 4:3 ratio formats have a canvas dimension of 24 x 18 cm or 9.6 x 7.2 inch and are (with pixel dimensions given in parenthesis):\nuxga (1600 x 1200), sxga+ (1400 x 1050), xga (1024 x 768),\nsvga (800 x 600), and dvd (640 x 480). Note: Your PROJ_LENGTH_UNIT setting determines if movie sets you up to work with the SI or US canvas dimensions. Instead of a named format you can request a custom format directly by giving width x height x dpu (no spaces arround the x), where dpu is the dots-per-unit pixel density (pixel density is set automatically for the named formats).\n\nN or name : – name=…\nDetermines the name of the final movie file and a sub-directory with frame images (but see work_dir). Note: If the subdirectory exist then we exit immediately. You are therefore required to remove any old directory by that name first. This is done to prevent the accidental loss of valuable data.\nT or frames : – frames=(range=…, n_frames=…, first=…, tag_width=…, split_words=…)\nEither specify how many image frames to make (ex frames=30), create a one-column data set width values from min to max every inc (ex frames=range(min,max,inc), append n_frames=““ if inc is number of frames instead), or supply a file with a set of parameters, one record (i.e., row) per frame (ex frame= timefile). The values in the columns will be available to the mainscript as named variables MOVIE_COL0, MOVIE_COL1, etc., while any trailing text can be accessed via the variable MOVIE_TEXT. Append split_words=““ to split the trailing string into individual words that can be accessed via variables MOVIE_WORD0, MOVIE_WORD1, etc. By default we use any white-space to separate words. Use split_words=str to select another character(s) as the valid separator(s). The number of records equals the number of frames. Note that the background script is allowed to create timefile, hence we check for its existence both before and after the background script has completed. Normally, the frame numbering starts at 0; you can change this by appending a different starting frame number via first=…. Note: All frames are still included; this modifier only affects the numbering of the given frames. Finally, tag_width=… can be used to set the tag width of the format used in naming frames. For instance, name_000010.png has a tag width of 6. By default, this is automatically set but if you are splitting large jobs across several computers then you must use the same tag width for all names."
  },
  {
    "objectID": "documentation/modules/movie.html#optional-arguments",
    "href": "documentation/modules/movie.html#optional-arguments",
    "title": "movie",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or gif : – gif=(loop=…, stride=…)\nBuild an animated GIF file. You may specify if the movie should play more than once (i.e., loop=N) and if so append how many times to repeat [default is infinite]. If a video product is also selected (format) then you can limit the frames being used to make the GIF file. Append stride=stride to only use every stride frame, with stride being one of a fixed set of strides: 2, 5, 10, 20, 50, 100, 200, and 500.\nD or frame_rate : – frame_rate=…\nSet the display frame rate in frames per seconds for the final animation [24].\n-E or titlepage : – titlepage=(script=…, duration=N, fade=…, fill=…)\nGive a titlepage script that creates a static title page for the movie (i.e. titlepage=(script=Fun|sc.jl,)) [no title]. Alternatively, titlepage can be a PostScript plot (titlepage=(script=“psfile.ps”, )) of dimensions exactly matching the canvas size set in canvas. You control the duration of the title sequence with duration and specify the number of frames (or append s for a duration in seconds instead, e.g. duration=“10s”) [4s]. Optionally, supply the fade length via fade=N (in frames or seconds [1s]) as well [no fading]; Use fade=“iN” and/or fade=“oN” to specify one-sided fading or to give unequal fade intervals [Default is same duration for both]. The fading affects the beginning and end of the title page duration. We fade from and to black by default; append fill=color to use another terminal fade color.\nF or format : – format=(format=…, transparent=““, options=…)\nSet the format of the final video product. Choose either mp4 (MPEG-4 movie) or webm (WebM movie). You may optionally add additional FFmpeg encoding settings for this format via the options=… modifier (in quotes if more than one word). If “none” is chosen then no PNGs will be created at all; this requires cover_page. Choose transparent=true to generate transparent PNG images [opaque].\nG or fill : – fill=color | fill=(fill=color, pen=pen)\nSet the canvas color or fill before plotting commences [none]. Optionally, append pen=pen to draw the canvas outline with pen [no outline]. See [Setting color] and [Pen attributes] for extend color and pen selections.\nH or scale : – scale=factor\nGiven the finite dots-per-unit used to rasterize PostScript frames to PNGs, the quantizing of features to discrete pixel will lead to rounding. Some of this is mitigated by the anti-aliasing settings. However, changes from frame to frame is outside the control of the individual frame rasterization and we find that, in particular, moving text may appear jittery when seen in the final animation. You can mitigate this effect by selecting a scale factor that, in effect, temporarily increases the effective dots-per-unit by factor, rasterizes the frame, then downsamples the image by the same factor at the end. The larger the factor, the smoother the transitions. Because processing time increases with factor we suggest you try values in the 2-5 range. Note that images can also suffer from quantizing when the original data have much higher resolution than your final frame pixel dimensions. The scale option may then be used to smooth the result to avoid aliasing [no downsampling]. This effect is called subpixel rendering.\nI or includefile : – includefile=file\nInsert the contents of includefile into the movie_init.sh|bat script that is accessed by all movie scripts. This mechanism is used to add information (typically constant variable assignments) that the mainscript and any optional S scripts rely on. Warning, the contents of this file are pure GMT commands.\nK or fading : – fading=(fade=N, fill=color, preserve=true))\nAdd fading in and out for the main animation sequence [no fading]. Append the length of the fading in number of frames (e.g. fading=10 or fading=5s for fading in seconds) [1s]. Use fading=“iN(s) and/or fading=“oN” to specify one-sided fading or to give unequal fade intervals [Default is same duration for both]. Normally, fading will be overlaid on the first and last fade frames of the main animation. Append preserve=true to preserve these frames by fading over only the first and last (repeated) animation frames instead. We fade from and to black by default; append fill=color to use another terminal fade color.\nL or label : – label=str (not yet translated to keywords)\nAutomatic labeling of individual frames. Places the chosen label at the frame perimeter: e selects the elapsed time in seconds as the label; append +sscale to set the length in seconds of each frame [Default is 1/framerate], sstring uses the fixed text string as the label, f selects the running frame number as the label, p selects the percentage of progress so far, ccol uses the value in column number col of timefile as label (first column is 0), while tcol uses word number col from the trailing text in timefile (first word is 0). Note: If you use -Lc with an absolute time column, then the format of the timestamp will depend on the two default settings FORMAT_DATE_MAP and FORMAT_CLOCK_MAP. By default, both date and time are displayed (with a space between); set one of the settings to “-” to skip that component. Append +cdx [/dy] for the clearance between label and bounding box; only used if +g or +p are set. Append units c | i | p or % of the font size [15%]. Append +f to use a specific font [FONT_TAG]. Append +g to fill the label bounding box with fill color [no fill]. Use +jrefpoint to specify where the label should be plotted [TL]. Append +odx [/dy] to offset label in direction implied by justify. Append units c | i | p or % of the font size [20% of font size]. Append +p to draw the outline of the bounding box using selected pen [no outline]. Append +t to provide a format statement to be used with the label item selected [no special formatting]. If -Lt is used then the format statement must contain a %s-like format, else it may have an integer (%d) or floating point (%e, %f, %g) format specification.\nM or cover_page : – cover_page=frame | cover_page=“frame,format”\nIn addition to making the animation sequence, select a single master frame [0] for a cover page. The master frame will be written to the current directory with name prefix.format, where format can one of the graphics extensions from the allowable graphics formats [pdf].\nP or progress : – progress=(indicator=char, annot=“…”, font=font, justify=tag, offset=(dx,dy), width=…, fill=color, Fill=color, pen=pen, Pen=pen)\n\nAutomatic placement of progress indicator(s). Places the chosen indicator at the frame perimeter. Select from six indicators called a-f [a]. Indicators a-c are different types of circular indicators while d-f are linear (axis-like) indicators. Specify dimension of the indicator with wdth=… [5% of max canvas dimension for circular indicators and 60% of relevant canvas dimension for the linear indicators] and placement via justify=tag [TR for circular and BC for axes]. Indicators b-f can optionally add annotations if modifier annot is used, append one of e or f or p or s or c col or t col to indicate what should be annotated (see label for more information on what these are); append font=font to use a specific font [FONT_ANNOT_SECONDARY scaled as needed]. Append offset=dx or offset=(dx,dy) to offset indicator in direction implied by justify. Append fill=color to set moving item fill color [see below for defaults]. Use pen=pen to set moving item pen. For corresponding static fill and pen, use Fill and Pen instead.\nQ or debug : – debug=true | debug=“s”\nDebugging: Leave all files and directories we create behind for inspection. Alternatively, append s to only build the movie scripts but not perform any execution. One exception involves the optional background script derived from -Sb which is always executed since it may produce data needed when building the movie scripts.\nSb or background : – background=“script.jl” or background=Fun\nThe optional background Julia script or function can be used for one or two purposes: (1) It may create files (such as timefile) that will be needed by mainscript to make the movie, and (2) It may make a static background plot that should form the background for all frames. If a plot is generated the script must make sure it uses the same positioning (i.e., X Y) as the main script so that the layered plot will stack correctly (unless you actually want a different offset). Alternatively, background can be a PostScript plot layer of dimensions exactly matching the canvas size.\nSf or foreground : – foreground=“script.jl” or foreground=Fun  The optional foreground can be used to make a static foreground plot that should be overlain on all frames. Make sure the script uses the same positioning (i.e., X Y) as the main script so that the layers will stack correctly. Alternatively, foreground can be a PostScript plot layer of dimensions exactly matching the canvas size.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or workdir : – name=“prefix”\nBy default, all temporary files and frame PNG file are created in the subdirectory prefix set via name. You can override that selection by giving another workdir as a relative or full directory path. If no path is given then we create a working directory in the system temp folder named prefix. The main benefit of a working directory is to avoid endless syncing by agents like DropBox or TimeMachine, or to avoid problems related to low space in the main directory.\nZ or clean : – clean=true or clean=“s”\nErase the entire prefix directory after assembling the final movie [Default leaves directory with all images; the temporary script files, parameter files, and layer PostScript files are all removed (but see debug)]. If your mainscript and all input scripts via titlepage, includefile, and fore|background should be deleted as well then append s.\nx or cores : – cores=N\nLimit the number of cores used when making the individual frames. By default we try to use all available cores. Append N to only use n cores (if too large it will be truncated to the maximum cores available). Finally, give a negative N to select (all - N) cores (or at least 1 if N equals or exceeds all). The parallel processing does not depend on OpenMP."
  },
  {
    "objectID": "documentation/modules/movie.html#parameters",
    "href": "documentation/modules/movie.html#parameters",
    "title": "movie",
    "section": "Parameters",
    "text": "Parameters\nSeveral parameters are automatically assigned and can be used when composing mainscript and the optional background and foreground scripts. There are two sets of parameters: Those that are constants and those that change with the frame number. The constants are accessible by all the scripts: MOVIE_WIDTH: The width of the canvas (the full movie frame), MOVIE_HEIGHT: The height of the canvas (the full movie frame), MOVIE_DPU: The current dots-per-unit, MOVIE_RATE: The current number of frames per second, MOVIE_NFRAMES: The total number of frames. Also, if includefile was used then any static parameters listed there will be available to all the scripts as well. In addition, the mainscript also has access to parameters that vary with the frame counter: MOVIE_FRAME: The current frame number (an integer, e.g., 136), MOVIE_TAG: The formatted frame number (a string, e.g., 000136), and MOVIE_NAME: The name prefix for the current frame (i.e., prefix _ MOVIE_TAG), Furthermore, if a timefile was given then variables MOVIE_COL0, MOVIE_COL1, etc. are also set, yielding one variable per column in timefile. If timefile has trailing text then that text can be accessed via the variable MOVIE_TEXT, and if word-splitting was explicitly requested by -T+w or implicitly by selecting word labels in format or progress) then the trailing text is also split into individual word parameters MOVIE_WORD0, MOVIE_WORD1, etc."
  },
  {
    "objectID": "documentation/modules/movie.html#data-files",
    "href": "documentation/modules/movie.html#data-files",
    "title": "movie",
    "section": "Data Files",
    "text": "Data Files\nThe movie scripts will be able to find any files present in the starting directory when movie was initiated, as well as any new files produced by mainscript or the optional scripts set via fore|background. No path specification is needed to access these files. Other files may require full paths unless their directories were already included in the DIR_DATA setting."
  },
  {
    "objectID": "documentation/modules/movie.html#plotting-temporal-changes",
    "href": "documentation/modules/movie.html#plotting-temporal-changes",
    "title": "movie",
    "section": "Plotting Temporal Changes",
    "text": "Plotting Temporal Changes\nA movie is not very interesting if nothing changes. For the animation to change you need to have your mainscript either access a different data set as the frame counter changes, or you need to plot only a varying subset of a data set, showing only the part that should be displayed in each frame. There are several strategies you can use to accomplish these effects:\n\nYour timefile passed to frames may have names of specific data files and you simply have your mainscript use the relevant MOVIE_TEXT or MOVIE_WORD? to access the frame-specific file name.\nYou have a single data table which includes absolute time for each record, and you wish to plot these events as time moves forward, yet not displaying events still in the future. This effect is achieved via the module events.\nYou have a 3-D grid (or a stack of 2-D grids) and you want to interpolate along the axis perpendicular to the 2-D slices (e.g., time, or it could be depth). In this situation you will use the module grdinterpolate to have the mainscript obtain a slice for the correct time (this may be an interpolation between two different times or depths) and make the frame plot with this temporary grid file.\nYou may be creating data on the fly using gmtmath or grdmath, or perhaps processing data slightly differently per frame (using parameters in the timefile) and displaying these or the changes between frames."
  },
  {
    "objectID": "documentation/modules/movie.html#your-canvas",
    "href": "documentation/modules/movie.html#your-canvas",
    "title": "movie",
    "section": "Your Canvas",
    "text": "Your Canvas\nAs you can see from canvas, unless you specified a custom format you are given a canvas size that is either 24 x 13.5 cm (16:9) or 24 x 18 cm (4:3). If your PROJ_LENGTH_UNIT setting is inch then the custom canvas sizes are just slightly (1.6%) larger than the corresponding SI sizes (9.6 x 5.4” or 9.6 x 7.2”); this has no effect on the size of the movie frames but allow us to use good sizes that work well with the dpu chosen. You should compose your plots using the given canvas size, and movie will make proper conversions of the canvas to image pixel dimensions. It is your responsibility to use X Y to allow for suitable margins and any positioning of items on the canvas. To minimize processing time it is recommended that any static part of the movie be considered either a static background (to be made once by background) and/or a static foreground (to be made once by foreground); movie will then assemble these layers per frame. Also, any computation of static data files to be used in the loop over frames can be produced by background. Any data or variables that depend on the frame number must be computed or set by mainscript or provided via the parameters as discussed above. Note: Using the variables MOVIE_WIDTH or MOVIE_HIGHT to set plot dimensions may lead to clipping against the canvas since these are also the exact canvas dimensions."
  },
  {
    "objectID": "documentation/modules/movie.html#external-postscript-layers",
    "href": "documentation/modules/movie.html#external-postscript-layers",
    "title": "movie",
    "section": "External PostScript Layers",
    "text": "External PostScript Layers\nInstead of passing scripts/functions to fore|background you can alternatively provide the name of PostScript plot layer files. Note that these must exactly match the canvas size. As a simple example, if you are making a HD movie using the US unit dimensions then a background pink layer would be created by\nbasemap(region=(0,9.6,0,5.4), proj=:linear, figscale=\"1i\", axes=(fill=:pink,), X=0, Y=0, par=(PS_MEDIA=\"9.6ix5.4i\", figname=\"background.ps\")\nNote the canvas selection via PS_MEDIA, the matching region and projection, and the zero location of the origin."
  },
  {
    "objectID": "documentation/modules/movie.html#basemap-frames",
    "href": "documentation/modules/movie.html#basemap-frames",
    "title": "movie",
    "section": "Basemap Frames",
    "text": "Basemap Frames\nSome map projections will by default draw a fancy map frame; this feature is under the control of MAP_FRAME_TYPE. However, whether a fancy or plain frame is actually drawn also depends on the projection center latitude. Thus, if your movie varies the projection center latitude by changing the view, you should set the frame setting to plain as part of your setup."
  },
  {
    "objectID": "documentation/modules/movie.html#transparent-images",
    "href": "documentation/modules/movie.html#transparent-images",
    "title": "movie",
    "section": "Transparent Images",
    "text": "Transparent Images\nBy default, movie will build opaque PNG images which can then be assembled into an animation. The vast majority of movies is likely to be made that way. Use the format option’s experimental modifier transparent to make transparent PNG images. Currently, very few video codecs support transparency. It is claimed both H.265 (HECV) and VP9 (Webm) offer this capability; we have only been able to verify the latter by viewing a transparent webm movie in Chrome. Animated GIFs can be built from transparent PNGs as well and here each additional frame accumulate in the final movie. Experts may create transparent PNGs and create movies in professional tools that support a movie alpha channel."
  },
  {
    "objectID": "documentation/modules/movie.html#technical-details",
    "href": "documentation/modules/movie.html#technical-details",
    "title": "movie",
    "section": "Technical Details",
    "text": "Technical Details\nThe movie module creates several hidden script files that are used in the generation of the images (here we have left the file extension off since it depends on the scripting language used): movie_init (initializes variables related to canvas size and dots-per-unit, and includes the contents of the optional includefile), movie_preflight (optional since it derives from background and computes needed data files and possibly a background layer), movie_postflight (optional since it derives from foreground and builds a foreground layer), movie_frame (accepts a frame counter argument and builds the frame image), and movie_cleanup (removes temporary files at the end of the run). For each frame there is a separate movie_params_###### script that provides frame-specific variables (e.g., frame number and anything given via frames). The pre- and post-flight scripts have access to the information in movie_init while the frame script in addition has access to the frame-specific parameter file. Using the debug option will just produce these scripts which you can then examine. Note: The mainscript is duplicated per frame and each copy is run simultaneously on all available cores. Multi-treaded GMT modules will therefore be limited to a single core as well.\nThe conversion of PNG frames to an animated GIF (format=“gif”) relies on GraphicsMagick. Thus, gm must be accessible via your standard search path. Likewise, the conversion of PNG frames to an MP4 (format=“mp4”) or WebM (format=“webm”) movie relies on FFmpeg."
  },
  {
    "objectID": "documentation/modules/movie.html#hints-for-movie-makers",
    "href": "documentation/modules/movie.html#hints-for-movie-makers",
    "title": "movie",
    "section": "Hints for Movie Makers",
    "text": "Hints for Movie Makers\nComposing movies is relatively simple but you have to think in terms of variables. Examine the examples we have described. Then, start by making a single plot script (your mainscript) and identify which things should change with time (i.e., with the frame number). Create variables for these values. If they are among the listed parameters that movie creates then use those names. Unless you only require the frame number you will need to make a file that you can pass to frames. This file should then have all the values you need, per frame (i.e., row), with values across all the columns you need. If you need to assign various fixed variables that do not change with time then your mainscript will look shorter and cleaner if you offload those assignments to a separate includefile (includefile). To test your movie, start by using options format=:none debug cover_page to ensure your master frame page looks correct. This page shows you one frame of your movie (you can select which frame via the cover_page arguments). Fix any issues with your use of variables and options until this works. You can then try to remove debug. We recommend you make a very short (i.e., frames) and small (i.e., canvas) movie so you don’t have to wait very long to see the result. Once things are working you can beef up number of frames and movie quality."
  },
  {
    "objectID": "documentation/modules/movie.html#color-table-usage",
    "href": "documentation/modules/movie.html#color-table-usage",
    "title": "movie",
    "section": "Color Table Usage",
    "text": "Color Table Usage\nBecause movie launches individual frame plots as separate sessions running in parallel, we cannot utilize the current CPT (i.e., the last CPT created directly by makecpt or grd2cpt, or indirectly by grdimage or grdview). Instead, you must create CPTs using explicit files and pass those names to the modules that require CPT information. In modern mode, this means you need to use the H option in makecpt or grd2cpt in order to redirect their output to named files."
  },
  {
    "objectID": "documentation/modules/movie.html#progress-indicators",
    "href": "documentation/modules/movie.html#progress-indicators",
    "title": "movie",
    "section": "Progress Indicators",
    "text": "Progress Indicators\n\nThe six types of movie progress indicators. All have default sizes, placements, colors and pens (shown) but these can be overridden by the corresponding modifiers (see below).\nThe letters a-f select one of the six progress indicators shown above. - Indicator a) needs a static [lightgreen] and moving [lightred] fill (set via Fill and fill); there is no label option.\n\nIndicator b) takes a static [lightblue] and moving [blue] pen (set via Pen and pen), and if annot is set we place a centered label with a font size scaled to 30% of indicator size (unless font was set which is used as given).\nIndicator c) takes a static [dashed darkred, pen width is 1% of indicator size] and moving [red] pen (default pen width is 5% of indicator size) for a circular arrow (head size is 20% of indicator size), with a central label (if given annot) with a font size 30% of indicator size (unless font was set which we will honor).\nIndicator d) takes a static [black] and moving [yellow, width 0.5% of length] pen for a rounded line with a cross-mark. If label is requested (annot) we use a font size that is twice the static pen thickness (unless font was set).\nIndicator e) takes a static [red] and moving [lightgreen] pen. If labels are requested (annot) we use a font size that is twice the static pen thickness (unless font was set).\nFinally, indicator f) takes a pen for the static axis [black] and a fill for the moving triangle [red]; the triangle size is scaled to twice the axis width (see below), and a font size scaled to thrice the axis width.\nNote for indicators d-f: If percentage labels are selected (annot=“p”), then the axes display a unit label, otherwise no unit label is supplied. The indicators d-f are horizontal for all justify codes except for ML and MR. The default pen thickness for the linear static lines is the smallest of 2.5% of their lengths and 8p (1.5% and 3p for f). If no size is specified (width) then we default to 5% of canvas width for the three circular indicators and 60% of the relevant canvas dimension for the linear indicators."
  },
  {
    "objectID": "documentation/modules/movie.html#title-sequence-and-fading",
    "href": "documentation/modules/movie.html#title-sequence-and-fading",
    "title": "movie",
    "section": "Title Sequence and Fading",
    "text": "Title Sequence and Fading\n&lt;img src=\"/assets/docs/GMT_title_fade.png\" alt=\"Simple color contour\" width=\"500\" class=\"center\"/&gt;\nThe fade-level (0 means black, 100 means normal visibility) for the complete movie, including an optional title sequence.\nThe complete movie may have an optional leading title sequence (titlepage) of a given duration. A short section at the beginning and/or end of this duration may be designated to fade in/out via the designated fade color [black]. The main animation sequence may also have an optional fade in and/or out section (fading). Here, you can choose to fade on top of the animation or you can “freeze” the first and/or last animation frame and only fade over those static images (via modifier preserve) in order to preserve the whole animation sequence."
  },
  {
    "objectID": "documentation/modules/movie.html#examples",
    "href": "documentation/modules/movie.html#examples",
    "title": "movie",
    "section": "Examples",
    "text": "Examples\nTo make an animated GIF movie based on the script globe.sh, which simply spins a globe using the frame number to serve as the view longitude, using a custom square 600 by 600 pixel canvas and 360 frames, place a frame counter in the top left corner, and place a progress indicator in the top right corner, try\nfunction globe_sc()\n    coast(region=:global, proj=(name=:Ortho, center=(\"MOVIE_FRAME\",20)), figsize=\"MOVIE_WIDTH\", land=:maroon, water=:turquoise, frame=:g, X=0, Y=0)\nend\n\nmovie(globe_sc, name=:globe, frames=360, gif=true, canvas=\"15x15x100\", label=:f, progress=true, Vd=1)\nHere, the globe_sc function simply plots a map with coast but uses the frame number variable as the center longitude. As the automatic frame loop is executed the different frames will be produced with different longitudes.\nAt the end of the execution we find the animated GIF globe.gif and a directory (called globe) that contains all 360 PNG images. Note that there is no information in the globe scripts that reflects the name of the plot, the canvas size, the dimensions of the rasterized PostScript, and so on. That information is hidden from the user; the actual movie scripts that execute are derived from the user-provided scripts and supply the extra machinery. The movie module automatically manages the parallel execution loop over all frames using all available cores.\nYou will note also that it was printed a line with\nmovie main_script.bat -C6ix6ix100 -Nglobe -Lf -A -P -T360\nthis is the result of having used the option Vd=1 in the movie command. It means print the GMT command that creates the movie. Another option is to use Vd=2. In this case, the same command is printed but it’s not executed. This can be very handy if one wants to run that command from a system shell instead of from the Julia REPL because movie commands can take a long time to run.\nAs another simple example, this will create mp4 movie with 25 scroling numbers like in very old movies of 20th century.\nfunction main_sc()\n    text(limits=(0,1,0,1), proj=:linear, figsize=10, font=\"200p\", region_justify=:CM, text=\"MOVIE_FRAME\", axes=:noannot, X=0, Y=0)\nend\nmovie(main_sc, canvas=\"10cx10cx30\", name=:count, frames=25, fill=:pink, format=:mp4, frame_rate=4, clean=true)"
  },
  {
    "objectID": "documentation/modules/movie.html#longer-examples",
    "href": "documentation/modules/movie.html#longer-examples",
    "title": "movie",
    "section": "Longer Examples",
    "text": "Longer Examples\nTo explore more elaborate movies, see the Animations examples under our GMT Animations or view high-resolution movies on the GMT Youtube channel."
  },
  {
    "objectID": "documentation/modules/movie.html#other-movie-formats",
    "href": "documentation/modules/movie.html#other-movie-formats",
    "title": "movie",
    "section": "Other Movie Formats",
    "text": "Other Movie Formats\nAs configured, movie only offers the MP4 and WebM formats for movies. The conversion is performed by the tool FFmpeg, which has more codecs and processing options than there are children in China. If you wish to run FFmpeg with other options, run movie with one of the two video formats. At the end it will print the FFmpeg command used. You can copy, paste, and modify this command to select other codecs, bit-rates, and arguments. You can also use the PNG sequence as input to tools such as QuickTime Player, iMovie, MovieMaker, and other commercial programs to make a movie that way."
  },
  {
    "objectID": "documentation/modules/movie.html#remaking-movie-with-existing-png-frames",
    "href": "documentation/modules/movie.html#remaking-movie-with-existing-png-frames",
    "title": "movie",
    "section": "Remaking Movie with Existing PNG Frames",
    "text": "Remaking Movie with Existing PNG Frames\nPerhaps you made your movie and then decided you want to change the frame rate or adjust something else in how the movie is put together from all the still images. If you kept all the frame images then you do not have to rerun the whole render process. Assuming you want a MP4 movie and that you want to rerun just the ffmpeg command, here is an example\nffmpeg -loglevel warning -f image2 -framerate 24 -y -i \"mydir/myimages_%04d.png\" -vcodec libx264 -pix_fmt yuv420p mymovie.mp4\nThis command is also written out when movie performs this step. For other movie formats you will need to consult the FFmpeg documentation. Note: On Windows, the percentage character is special (like the dollar sign under shells) so you will need to enter two (%%)."
  },
  {
    "objectID": "documentation/modules/movie.html#manipulating-multiple-movies",
    "href": "documentation/modules/movie.html#manipulating-multiple-movies",
    "title": "movie",
    "section": "Manipulating Multiple Movies",
    "text": "Manipulating Multiple Movies\nIf you are making a series of similar movies, you can use FFmpeg to paste and stitch them into a single movie. Assume we have four movies called movie_1.mp4, movie_2.mp4, movie_3.mp4, and movie_4.mp4, and you wish to combine them into a 2x2 panel showing the four movies simultaneously. You would first combine movies (1,2) and (3,4) horizontally, then combine the two resulting strips vertically\nffmpeg -i movie_1.mp4 -i movie_2.mp4 -filter_complex hstack=inputs=2 top.mp4\nffmpeg -i movie_3.mp4 -i movie_4.mp4 -filter_complex hstack=inputs=2 bottom.mp4\nffmpeg -i top.mp4 -i bottom.mp4 -filter_complex vstack=inputs=2 four_movies.mp4\nFor more information on such manipulations, see the FFmpeg documentation."
  },
  {
    "objectID": "documentation/modules/movie.html#source-code",
    "href": "documentation/modules/movie.html#source-code",
    "title": "movie",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/mgd77convert.html",
    "href": "documentation/modules/mgd77convert.html",
    "title": "mgd77convert",
    "section": "",
    "text": "Interpolate GPS velocities using Green’s functions for elastic deformation.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/mask.html",
    "href": "documentation/modules/mask.html",
    "title": "mask",
    "section": "",
    "text": "mask(cmd0::String=\"\", arg1=[]; kwargs...)\n\nor\n\nmask(GI:GItype, shapes::GMTdataset, touches=false, inverse::Bool=false, maskvalues=??)\nClip or mask map areas with no data table coverage"
  },
  {
    "objectID": "documentation/modules/mask.html#description",
    "href": "documentation/modules/mask.html#description",
    "title": "mask",
    "section": "Description",
    "text": "Description\nReads (x, y, z) tables (or a file) and uses this information to find out which grid cells are reliable. Only grid cells which have one or more data points are considered reliable. As an option, you may specify a radius of influence. Then, all grid cells that are within radius of a data point are considered reliable. Furthermore, an option is provided to reverse the sense of the test. Having found the reliable/not reliable points, the module will either paint tiles to mask these nodes (with the tiles switch), or use contouring to create polygons that will clip out regions of no interest. When clipping is initiated, it will stay in effect until turned off by a second call to the module using the endclip option.\nA second method expects a GMTgrid or an GMTimage as first argument and a GMTdataset in second and will clip the grid/image to the selected region(s) defined in polygons of the second argument. Grids are clipped to the global BoundingBox of the polygons and images are copped to that limit and set to transparent in the regions outside of the polygons. This method uses GDAL to compute the clipping mask. Used together with the DCW option of coast this is very handy to clip rasters to country or earthregions boundaries. Note that this method is in a way similar to one of the grdlandmask methods. The difference is that here use a external polygon description that may be read from any OGR vector file whilst grdlandmask uses the GSHHG dataset."
  },
  {
    "objectID": "documentation/modules/mask.html#required-arguments-1st-method",
    "href": "documentation/modules/mask.html#required-arguments-1st-method",
    "title": "mask",
    "section": "Required Arguments (1st method)",
    "text": "Required Arguments (1st method)\n\ntable\nOne or more data tables holding a number of data columns.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax, zmin, zmax) | limits=(BB=(xmin, xmax, ymin, ymax, zmin, zmax),) | …more\nSpecify the region of interest. Default limits are computed from data extents. More at [limits](../common_opts/opt_R.html)"
  },
  {
    "objectID": "documentation/modules/mask.html#required-arguments-2nd-method",
    "href": "documentation/modules/mask.html#required-arguments-2nd-method",
    "title": "mask",
    "section": "Required Arguments (2nd method)",
    "text": "Required Arguments (2nd method)\n\nGI: A grid (GMTgrid) or image (GMTimage) to be clipped.\nshapes: A GMTdataset or a vector of them containing the polygons outside which the elements of GI will be clipped"
  },
  {
    "objectID": "documentation/modules/mask.html#optional-arguments",
    "href": "documentation/modules/mask.html#optional-arguments",
    "title": "mask",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or endclip or end_clip_path : – endclip=true\nMark end of existing clip path. No input file is needed. Also supply xshift and yshift settings if you have moved since the clip started.\nD or dump : – dump=fname\nDump the (x,y) coordinates of each clipping polygon to one or more output files (or in-memory array). No plotting will take place. If template contains the C-format specifier %d (including modifications like %05d) then polygons will be written to different files; otherwise all polygons are written to the specified file (template). The files are ASCII unless binary_out is used. See cut_number to exclude small polygons from consideration.\nF or oriented : – oriented=:left | oriented=true | oriented=:right\nForce clip contours (polygons) to be oriented so that data points are to the left ([Default]) or right (oriented=:right) as we move along the perimeter [Default is arbitrary orientation]. Requires dump.\nG or fill : – fill=color\nPaint the clip polygons (or tiles) with a selected fill [Default is no fill].\nJz or JZ or zscale or zsize : zscale=scale | zsize=size\nSet z-axis scaling or or z-axis size. zsize=size sets the size to the fixed value size (for example zsize=10 or zsize=4i). zscale=scale sets the vertical scale to UNIT/z-unit.\nL or nodegrid : – nodegrid=“gridname” | nodegrid=“gridname+i” | nodegrid=“gridname+o”\nSave the internal grid with ones (data constraint) and zeros (no data) to the named gridname. Append +o to convert the outside (no data) nodes to NaNs before writing the grid, while appending +i will instead convert the inside (data) flags to NaNs. Omitting the gridname*, as in nodegrid=true or nodegrid=“+i” returns a grid as a GMTgrid object.\nN or inverse : – inverse=true\nInvert the sense of the test, i.e., clip regions where there is data coverage.\nQ or cut or cut_number : – cut=n Do not dump polygons with less than cut number of points [Dumps all polygons]. Only applicable if dump has been specified.\nS or search_radius : – search_radius=rad\nSets radius of influence. Grid nodes within radius of a data point are considered reliable. [Default is 0, which means that only grid cells with data in them are reliable]. Append the distance unit (see [Units]).\nT or tiles : – tiles=true\nPlot tiles instead of clip polygons. Use fill to set tile color or pattern. Cannot be used with dump.\ntouches: For the grid/image method, include all cells/pixels that are touched by the polygons. The default is to include only the cells whose centers that are inside the polygons.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used).\n\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/mask.html#examples",
    "href": "documentation/modules/mask.html#examples",
    "title": "mask",
    "section": "Examples",
    "text": "Examples\nTo make a mask that has a 5 degree radius around points spaced every 10 degree along the prime meridian, and just paint those areas yellow we try::\n\nusing GMT\nt = [repeat([0],19) -90:10:90]      # Some fake data\nmask(t, fill=:yellow, inc=\"30m\", region=(-75,75,-90,90), proj=:eqc, search_radius=\"5d\", tiles=true,\n     title=\"Mask for points with r = 5 degrees\", xaxis=(annot=:auto, ticks=:auto, grid=180),\n     yaxis=(annot=:auto, ticks=:auto, grid=10), show=true)\n\n\n\n\n\n\n\n\nTo make an overlay that will mask out the regions of a contour map where there is no control data using clip polygons, use:\n    gmt mask africa_grav.xyg -R20/40/20/40 -I5m -JM10i -pdf mask\nWe do it again, but this time we wish to save the clipping polygons to file all_pols.txt:\n    gmt mask africa_grav.xyg -R20/40/20/40 -I5m -Dall_pols.txt\nA repeat of the first example but this time we use white tiling:\n    gmt mask africa_grav.xyg -R20/40/20/40 -I5m -JM10i -T -Gwhite -pdf mask\n\nusing GMT\n\nD = coast(DCW=:HR, dump=true);      # Extract the Croatia border from the DCW\nI = gmtread(\"@earth_day_30s\", region=D, V=:q);  # Load Earth image containing Croatia\nIc = mask(I, D);                    # Mask outside (make image transparent there)\n\ngmtwrite(\"Ic.tiff\", Ic)             # For now we need to save and reload to see\nIc = gmtread(\"Ic.tiff\");            # the tranparency in action.\n\nviz(Ic, title=\"Croatia\")\n\nWarning 1: Non closed ring detected. To avoid accepting it, set the OGR_GEOMETRY_ACCEPT_UNCLOSED_RING configuration option to NO"
  },
  {
    "objectID": "documentation/modules/mask.html#source-code",
    "href": "documentation/modules/mask.html#source-code",
    "title": "mask",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmask(cmd0::String; ...) - psmask.jl:63\nmask(; ...) - psmask.jl:63\nmask(arg1; kw...) - psmask.jl:97\nmask(cmd0::String, arg1; first, kwargs...) - psmask.jl:63\nmask(GI::GItype, D::GDtype; touches, inverse) - psmask.jl:102"
  },
  {
    "objectID": "documentation/modules/mask.html#see-also",
    "href": "documentation/modules/mask.html#see-also",
    "title": "mask",
    "section": "See Also",
    "text": "See Also\ngrdmask, surface, basemap, clip"
  },
  {
    "objectID": "documentation/modules/mapproject.html",
    "href": "documentation/modules/mapproject.html",
    "title": "mapproject",
    "section": "",
    "text": "Forward and inverse map transformations, datum conversions and geodesy"
  },
  {
    "objectID": "documentation/modules/mapproject.html#synopsis",
    "href": "documentation/modules/mapproject.html#synopsis",
    "title": "mapproject",
    "section": "Synopsis",
    "text": "Synopsis\nD = mapproject(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/mapproject.html#description",
    "href": "documentation/modules/mapproject.html#description",
    "title": "mapproject",
    "section": "Description",
    "text": "Description\nmapproject reads (lon, lat) positions from tables and computes (x, y) coordinates using the specified map projection and scales. Optionally, it can read (x, y) positions and compute (lon, lat) values doing the inverse transformation.\nThis can be used to transform linear (x, y) points obtained by digitizing a map of known projection to geographical coordinates. May also calculate distances along track, to a fixed point, or closest approach to a line.\nAlternatively, can be used to perform various datum conversions. Additional data fields are permitted after the first 2 columns which must have (longitude,latitude) or (x, y). See option colinfo on how to read (latitude,longitude) files.\nFinally, mapproject can compute a variety of auxiliary output data from input coordinates that make up a track. Items like azimuth, distances, distances to other lines, and travel-times along lines can all be computed by using one or more of the options azim, dist, dist2line, and travel_time.\nNote: Depending on the Optional Arguments listed below, most times proj or region are not actually required."
  },
  {
    "objectID": "documentation/modules/mapproject.html#required-arguments",
    "href": "documentation/modules/mapproject.html#required-arguments",
    "title": "mapproject",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable (or provide data via first positional argument)\nOne table file name or a GMTdataset or a Matrix object holding (lon, lat) or (x, y) data."
  },
  {
    "objectID": "documentation/modules/mapproject.html#optional-arguments",
    "href": "documentation/modules/mapproject.html#optional-arguments",
    "title": "mapproject",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or azim or azimuth : – azim=:b | azim=:f | azim=:o | azim=(fixed_pt=(lon, lat),) | azim=(var_pt=true,)\nCalculate azimuth along track or to the optional fixed point. Choose among several directives:\n\n:b - Calculate the back-azimuth from data points to the fixed point\n:f - Calculate the forward azimuth from the fixed point to each data point\n\n:o - Get orientations (-90/90) rather than azimuths (0/360)\nazim=(back=true | forward=true | orientation=true, fixed_pt=(lon, lat)) - Specify fixed point\nazim=(back=true | forward=true | orientation=true, var_pt=true) - Obtain variable 2nd point via columns 3-4 in input\n\n\n\nUse distcalc=:e to compute azimuths on the ellipsoid. If no fixed point is given, computes azimuth from the previous point. Note: If region and proj are given, coordinates are projected first and then Cartesian angles are computed.\n\n\nC or center : – center=true | center=(dx, dy) | center=((dx, dy), merc=true)\nSet center of projected coordinates to be at map projection center [Default is lower left corner]. Optionally, add offsets in the projected units to be added (or subtracted when inverse is set):\n\ncenter=true - Center at map projection center\ncenter=(dx, dy) - Add false easting/northing offsets\ncenter=((dx, dy), merc=true) - For Mercator only, set origin at standard parallel\n\nThe offset unit is the plot distance unit unless unit is used (in which case offsets are in meters).\nD or lengthunit : – lengthunit=:c | lengthunit=:i | lengthunit=:p\nTemporarily override PROJ_LENGTH_UNIT:\n\n:c - Use centimeters\n:i - Use inches\n\n:p - Use points\n\nCannot be used with one2one.\nE or ecef or geod2ecef : – ecef=true | ecef=datum\nConvert from geodetic (lon, lat, height) to Earth Centered Earth Fixed (ECEF) (x, y, z) coordinates. Add inverse=true for the reverse. Append datum ID or ellipsoid parameters.\nF or one2one : – one2one=true | one2one=:e | one2one=:f | one2one=:k | one2one=:M | one2one=:n | one2one=:u | one2one=:c | one2one=:i | one2one=:p\nForce 1:1 scaling (output data in actual projected meters). Specify desired unit:\n\n:e - meters [Default]\n:f - feet\n:k - kilometers\n:M - statute miles\n:n - nautical miles\n:u - US survey feet\n:c, :i, :p - centimeters, inches, points\n\nG or track_distances : – track_distances=true | track_distances=(fixed_pt=(lon,lat), accumulated=true, incremental=true, unit=“??”, var_pt=true)\nCalculate distances along track or to optional fixed point:\n\ntrack_distances=true - Accumulated distances along track\ntrack_distances=(lon, lat) - Incremental distances to fixed point\nModifiers:\n\nfixed_pt=(lon, lat) - Incremental distances to fixed point\naccumulated=true - Accumulated distances\nincr=true - Incremental distances\n\nunit=:k - Distance unit (see Units)\nunit=:c - Cartesian distance using input coordinates\nunit=:C - Cartesian distance using projected coordinates (requires region and proj)\nvar=true - Variable 2nd point via columns 3-4\n\n\nI or inverse : – inverse=true\nDo inverse transformation: get (longitude, latitude) from (x, y) data.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or dist2line : – dist2line=table” | dist2line=(“table.txt”, unit=“??”, cartesian=true, project=true, fractional_pt=true)\nDetermine shortest distance from input data points to line(s) in the multisegment file. Appends distance and nearest point coordinates:\n\ndist2line=Matrix|Datset|\"table.txt\" - Basic usage\nModifiers:\n\nfractional_pt=true - Report segment id and fractional point number instead of lon/lat\nunit=:k - Distance unit (see Units)\ncartesian=true - Cartesian distances\nproject=true - Cartesian distances using projected coordinates (requires region and proj)\n\n\n\n\nNote: Calculation mode for geographic data is spherical; distcalc=:e cannot be used with dist2line.\n\n\nN or geod2aux : – geod2aux=:a | geod2aux=:c | geod2aux=:g | geod2aux=:m\nConvert from geodetic latitudes to auxiliary latitudes (longitudes unaffected):\n\n:a - Authalic latitudes\n:c - Conformal latitudes\n:g - Geocentric latitudes [Default]\n:m - Meridional latitudes\n\nUse inverse=true to convert from auxiliary to geodetic latitudes.\nQ or list : – list=true | list=:d | list=:e\nList all projection parameters:\n\nlist=:d - List only datums\nlist=:e - List only ellipsoids\n\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or suppress : – suppress=true\nSuppress points that fall outside the region.\nT or datum : – datum=“from/to” | datum=(“from”, “to”, height=true)\nCoordinate conversions between datums using standard Molodensky transformation:\n\ndatum=\"from/to\" - Convert between datums\ndatum=(\"from\", \"to\", height=true) - Use when 3rd input column has height above ellipsoid\n\nSpecify datums using datum ID or ellipsoid parameters. May be used with region and proj to change datum before projection (add inverse=true for datum conversion after inverse projection).\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or mapsize or map_size : – mapsize=true | mapsize=:b | mapsize=:e | mapsize=:g | mapsize=:h | mapsize=:w | mapsize=:r | mapsize=“r+n200*\nReport plot dimensions or map regions. No input files are read:\n\nmapsize=true - Report map width and height\nmapsize=:b - Bounding box in lon/lat\nmapsize=:B - Same, in region string format\n\nmapsize=:e - Rectangular area encompassing non-rectangular domain\nmapsize=:E - Same, in region string format\nmapsize=(:g, lon, lat) - Plot coordinates of map point\nmapsize=:h - Only height\nmapsize=:w - Only width\nmapsize=(:j, code) - Map coords of reference point (e.g., :TL)\nmapsize=(:n, (rx, ry)) - Normalized reference point (0-1 range)\nmapsize=:o - Diagonal corner coords for oblique domain\nmapsize=:O - Same, in region string format\nmapsize=:m - Rectangular region in projected plot coords\nmapsize=:M - Same, in region string format\nmapsize=:r - Rectangular domain covering oblique area\nmapsize=:R - Same, in region string format\nmapsize=(:x, (px, py)) - Map coords of specific plot reference point\n\nZ or travel_time : – travel_time=speed | travel_time=(speed=speed, accum=true, incr=true, iso=true, epoch=t0)\nCalculate travel times along track as specified with dist:\n\ntravel_time=12 - Constant speed (in distance units per TIME_UNIT)\nModifiers:\n\nincr=true - Incremental travel times\naccum=true - Accumulated travel times\niso=true - Format accumulated time per ISO 8601 convention\nepoch=t0 - Report absolute times (ETA) for successive points\n\n\nIf speed is omitted, expects to read variable speed from column 3. Requires dist option with incr=true modifier when using epoch.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/mapproject.html#units",
    "href": "documentation/modules/mapproject.html#units",
    "title": "mapproject",
    "section": "Units",
    "text": "Units\nFor map distance unit, append unit: - d - arc degree - m - arc minute - s - arc second - e - meter [Default unless stated otherwise] - f - foot - k - kilometer - M - statute mile - n - nautical mile - u - US survey foot\nBy default, distances use spherical approximation with great circles (distcalc=:g) using the authalic radius. Use distcalc=:f for “Flat Earth” calculations (quicker but less accurate) or distcalc=:e for exact geodesic calculations (slower but more accurate)."
  },
  {
    "objectID": "documentation/modules/mapproject.html#examples",
    "href": "documentation/modules/mapproject.html#examples",
    "title": "mapproject",
    "section": "Examples",
    "text": "Examples\nTransform remote file with (latitude, longitude) to (x, y) in cm on Mercator grid:\nD = mapproject(\"@waypoints.txt\", region=(-180,180,-72,72), proj=\"M0.5c\", yx=:i)\nConvert UTM coordinates to geographic locations:\nD = mapproject(\"utm.txt\", proj=(utm=11,), center=true, inverse=true, unit=true)\nTransform binary files with (latitude, longitude) to (x, y) on Transverse Mercator:\nD = mapproject(\"tracks.bin\", region=(-80,-70,20,40), proj=(tmerc=-75, scale=\"1:500000\"),\n               swap_xy=:i, suppress=true, lengthunit=:i, binary_in=2, binary_out=2)\nConvert NAD27 to WGS84 datum:\nD = mapproject(\"old.txt\", datum=\"131\")  # From NAD27 CONUS (datum 131) to WGS84\nCompute closest distance between points and line segments:\nD = mapproject(\"quakes.txt\", line_dist=(\"coastline.txt\", unit=:k))\nCompute accumulated distance along Cartesian track:\nD = mapproject(\"pos.txt\", dist=(unit=:c,))\nCompute distances and travel times with fixed speed:\nD = mapproject(\"track.txt\", dist=(unit=:n, accum=true, incr=true),\n               travel_time=(12, accum=true), par=(TIME_UNIT=:h,))\n# Speed is 12 nm/hour, times reported in hours\nGet geographic coordinates of map mid-point:\nD = mapproject(region=(-80,-70,20,40), proj=(tmerc=-75, scale=\"1:500000\"), W=(:j, :CM))\nDetermine rectangular region encompassing oblique region:\nD = mapproject(region=\"270/20/305/25+r\", proj=(obl_merc=(280,25.5,22,69), width=2), W=:R)\nGet oblique region string from rectangular projected region:\nD = mapproject(region=\"-2800/2400/-570/630+uk\", proj=(obl_merc=(190,25,266,68), scale=\"1:1\"), W=:O)\nGet closed polygon of oblique area in geographic coords:\nD = mapproject(region=\"-2800/2400/-570/630+uk\", proj=(obl_merc=(190,25,266,68), scale=\"1:1\"),\n               W=(:r, npts=100))\nGet bounding box for stereographic projection:\nD = mapproject(proj=(stereo=(36,90), width=30), region=(-15,60,68,90), W=:E)\nObtain azimuth of railroad using entry/exit points:\n# Input: lon1 lat1 lon2 lat2\nresult = mapproject([(-87.7447873 42.1192976; -87.7725841 42.1523955)],\n                    azim=(:f, var=true), colinfo=:g, outcols=\"4\")"
  },
  {
    "objectID": "documentation/modules/mapproject.html#important-notes",
    "href": "documentation/modules/mapproject.html#important-notes",
    "title": "mapproject",
    "section": "Important Notes",
    "text": "Important Notes\n\nCentering Output Region\nThe rectangular input region set with region will generally be mapped into a non-rectangular grid. Unless center is set, the leftmost point has x=0.0 and lowermost point has y=0.0. Before digitizing a map, run extreme coordinates through mapproject to see their (x, y) values for proper setup.\n\n\nEllipsoidal vs Spherical Solution\nGMT uses ellipsoidal formulae when implemented and an ellipsoid is selected. Be aware:\n\nSome projections (Transverse Mercator, Albers, Lambert’s conformal conic) use ellipsoidal expressions for small areas and switch to spherical for larger maps:\n\nTransverse Mercator: All points within 10° of central meridian\nConic projections: Longitudinal range &lt; 90°\nCassini: All points within 4° of central meridian\n\nHistorical data discrepancies may arise from:\n\nDifferent precision in calculations\nDifferent reference datums\nDifferent PROJ_SCALE_FACTOR values\n\nSome projections may use spherical solution despite ellipsoid selection when the region exceeds valid domain for ellipsoidal series expansions.\n\n\n\nOutput Order\nThe production order for geodetic and temporal columns from azim, dist, line_dist, and travel_time is fixed (alphabetical by option). Command-line order is irrelevant. Use outcols to modulate the final output order."
  },
  {
    "objectID": "documentation/modules/mapproject.html#source-code",
    "href": "documentation/modules/mapproject.html#source-code",
    "title": "mapproject",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmapproject(cmd0::String; ...) - mapproject.jl:73\nmapproject(; ...) - mapproject.jl:73\nmapproject(cmd0::String, arg1; ...) - mapproject.jl:73\nmapproject(arg1, arg2; kw...) - mapproject.jl:118\nmapproject(arg1; ...) - mapproject.jl:118\nmapproject(cmd0::String, arg1, arg2; kwargs...) - mapproject.jl:73"
  },
  {
    "objectID": "documentation/modules/mapproject.html#see-also",
    "href": "documentation/modules/mapproject.html#see-also",
    "title": "mapproject",
    "section": "See Also",
    "text": "See Also\nproject"
  },
  {
    "objectID": "documentation/modules/mapproject.html#references",
    "href": "documentation/modules/mapproject.html#references",
    "title": "mapproject",
    "section": "References",
    "text": "References\n\nBomford, G., 1952, Geodesy, Oxford U. Press.\nSnyder, J. P., 1987, Map Projections - A Working Manual, U.S. Geological Survey Prof. Paper 1395.\nVanicek, P. and Krakiwsky, E, 1982, Geodesy - The Concepts, North-Holland Publ., ISBN: 0 444 86149 1."
  },
  {
    "objectID": "documentation/modules/magref.html",
    "href": "documentation/modules/magref.html",
    "title": "magref",
    "section": "",
    "text": "magref(cmd0::String=\"\"; kwargs...)"
  },
  {
    "objectID": "documentation/modules/magref.html#description",
    "href": "documentation/modules/magref.html#description",
    "title": "magref",
    "section": "Description",
    "text": "Description\nEvaluates the IGRF or the CM4 geomagnetic models at the specified locations and times.\nA note about the CM4 validity domain. The core field of CM4 is valid from 1960-2002.5 but the ionospheric and magnetospheric fields are computed after the Dst and F10.7 coefficient files. We extended here those coefficient files up to 2006, which means that one can compute external contributions up until 2006 but the Secular Variation will be biased (non reliable). New indices files may be retrieved from ftp://ftp.ngdc.noaa.gov/STP/GEOMAGNETIC_DATA/INDICES/DST/ (the Dst coefficients) and http://umbra.nascom.nasa.gov/sdb/yohkoh/ys_dbase/indices_flux_raw/Penticton_Absolute/monthly/MONTHPLT.ABS (The F10.7 index file is a MONTHPLT.ABS). Note: since the Dst files in the …/DST/ directory are still only up to 2006, for GMT4.5.3 and after we extended the Dst until August 2009 by reformatting the data in the preliminary file Est_Ist_index_0_mean.pli, which is at ftp://ftp.ngdc.noaa.gov/STP/GEOMAGNETIC_DATA/INDICES/EST_IST. But since this site is now also outdated, we get the DST indices from http://wdc.kugi.kyoto-u.ac.jp/dstae/index.html However, for the most recent dates those indices are “Quick Look” (the best are the “Definitive” type). Because the F10.7 from the MONTHPLT.ABS file mentioned above are apparently no being updated, we found another place where they are, which is: ftp://ftp.ngdc.noaa.gov/STP/space-weather/solar-data/solar-features/solar-radio/noontime-flux/penticton/penticton_absolute/listings/listing_drao_noontime-flux-absolute_monthly.txt\nAnother update in January 2025. The NASA site above no longer updated its data and now we use F10.7 data downloaded from https://celestrak.org/spacedata/SW-All.csv (Matlab refences this site as well). But it contains only daily data. Hence we computed the montly averages. However, comparing previous and computed averages from this site show some differences. For example the first 4 months of 2018 (replaced to in this update) compare like this: [609 632 608 634] (nasa) vs [699 725 683 700] (celestrak)."
  },
  {
    "objectID": "documentation/modules/magref.html#required-arguments",
    "href": "documentation/modules/magref.html#required-arguments",
    "title": "magref",
    "section": "Required Arguments",
    "text": "Required Arguments\nNone."
  },
  {
    "objectID": "documentation/modules/magref.html#optional-arguments",
    "href": "documentation/modules/magref.html#optional-arguments",
    "title": "magref",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\ninput\nContains the moments in space-time where we want to evaluate the magnetic reference field. The first two columns must contain longitude and latitude (however, see yx for latitude and longitude instead). Normally, the third and fourth columns must contain altitude (in km) and time, respectively, but if one or both of these are constant for all records they can be supplied via the adjust option instead and are thus not expected in the input file. The alternative to provide the x,y locations is to use the region and (when grids are not global) the inc options. With them we get the results in a grid form. It requires setting time and altitude via the adjust option.\nA or adjust : – input_params=(alt|altitude=true, onetime=true, yeardec=true)\nAdjusts how the input record is interpreted. Use alt=true to set a fixed altitude (in km) that should apply to all data records [Default expects altitude to be in the 3rd column of all records]. Use onetime=true to set a fixed time that should apply to all data records [Default expects time to be in the 4th column of all records]. Finally, use yeardec=true to indicate that all times are specified as decimal years [Default is ISO date_T_colck format, see TIME_EPOCH].\nNOTE: This basically only applies when passing data via a file, where we have no chance to know if time was passed as decimar years or as a DateTime string. When passing data directly in numeric form, we try to guess all this for you. So, for example, you can do magref([-28 38 0 \"2001-05-01T12:00:00\"], internal=...) or magref([-28 38 0 2001.330137], ...) and we do the guessings. If input has only two columns, we assume an altitude of zero and current time.\nC or cm4file : – cm4file=file\nSpecify an alternate CM4 coefficient file [umdl.CM4].\nD or dstfile : – dstfile=file Specify an alternate file with hourly means of the Dst index for CM4 [Dst_all.wdc]. Alternatively, simply specify a single index to apply for all records.\nE or f107file : – f107file=file Specify an alternate file with monthly means of absolute F10.7 solar radio flux for CM4 [F107_mon.plt]. Alternatively, specify a single flux to apply for all records.\nF or internal : – internal=flags | internal=(all_input=true, total|T=true, horizontal|H=true, X=true, Y=true, Z=true, dec|declination=true, inc|inclination=true, IGRF=true, CM4core=true, CM4litho=true, CM4mag_p=true, CM4mag_i=true, CM4iono_p=true, CM4iono_i=true, CM4toroid=true, IGRG_CM4=true)\nSelects output items; Use, in alternative, the expanded form or the flags string made up of one or more of these characters:\n\nr or all_input=true means output all input columns before adding the items below\nt or total|T=true means list total field (nT).\nh or horizontal|H=true means list horizontal field (nT).\nx or X=true means list X component (nT, positive north).\ny or Y=true means list Y component (nT, positive east).\nz or Z=true means list Z component (nT, positive down).\nd or dec|declination=true means list declination (deg, clockwise from north).\ni or inc|inclination=true means list inclination (deg, positive down). Select requested field contribution(s) using either the keyword or append one or more numbers after a slash (/):\n0 or IGRF=true means IGRF field (no combinations allowed)\n1 or CM4core=true means CM4 Core field\n2 or CM4litho=true means CM4 Lithospheric field\n3 or CM4mag_p=true means CM4 Primary Magnetospheric field\n4 or CM4mag_i=true means CM4 Induced Magnetospheric field\n5 or CM4iono_p=true means CM4 Primary ionospheric field\n6 or CM4iono_i=true means CM4 Induced ionospheric field\n7 or CM4toroid=true means CM4 Toroidal field\n9 or IGRF_CM4=true means Core field from IGRF and other contributions from CM4. Do not use both IGRF and IGRF_CM4 (or 0 and 9).\n\nUsing several of the fiels contribution options (or appending several numbers (1-7)) will add up the different contributions. For example internal=(total=true, CM4core=true, CM4litho=true) (or internal=t/12) computes the total field due to Core and Lithospheric sources. The special case, that mixes Core field from IGRF and other sources from CM4, internal=t/934 computes Core field due to IGRF plus terms 3 and 4 from CM4 (but you can add others). This case is very important to be able to continue to use the CM4 model outside of its original time validity limits. The data is written out in the order they appear in flags [Default is F=rthxyzdi/1].\nG or geocentric : – geocentric=true\nSpecifies that coordinates are geocentric [geodetic].\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nL or external : – external=(all_input=true, total|T=true, X=true, Y=true, Z=true, mag_i=true, iono_p=true, iono_i=true, poloidal=true)\nComputes J field vectors from certain external sources.\n\nr or all_input=true means output all input columns before adding the items below (all in Ampers/m).\nt or total|T=true means list magnitude field.\nx or X=true means list X component.\ny or Y=true means list Y component.\nz or Z=true means list Z or current function Psi. Append a number to indicate the requested J contribution:\n1 or mag_i=true means Induced Magnetospheric field.\n2 or iono_p=true means Primary ionospheric field.\n3 or iono_i=true means Induced ionospheric field.\n4 or poloidal=true means Poloidal field.\n\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nSc or core_coef : – core_coef=(low,high)\nLimits the wavelengths of the core field contribution to the band indicated by the low and high spherical harmonic order [1/13].\nSl or litho_coef : – litho_coef=(low,high)\nLimits the wavelengths of the lithosphere field contribution to the band indicated by the low and high spherical harmonic order [14/65].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/magref.html#time-settings",
    "href": "documentation/modules/magref.html#time-settings",
    "title": "magref",
    "section": "Time Settings",
    "text": "Time Settings\nIf binary input files are used then absolute time are stored as time relative to the selected epoch. However, since the epoch used is not stored in the data files there can be problems decoding the correct time. The mgd77 supplement uses the Unix time system as its default; thus you should make sure that binary data files with time uses the same system (see the GMT default TIME_SYSTEM)."
  },
  {
    "objectID": "documentation/modules/magref.html#examples",
    "href": "documentation/modules/magref.html#examples",
    "title": "magref",
    "section": "Examples",
    "text": "Examples\nTo get the CM4 Total field, Declination and Inclination due to all but lithospheric and toroidal field at a one point location and decimal time 2000.0, do\nmagref([-28 38 0 2000.0], internal=(T=true, dec=true, inc=true, CM4core=true, CM4litho=true, CM4mag_p=true))\n1×3 GMTdataset{Float64, 2}\n Row │   col.1     col.2   col.3\n─────┼───────────────────────────\n   1 │ 43795.6  -12.1047  54.178\n```──────────\n   1 │ 43795.6  -12.1047  54.178\nTo do the same as above but at noon (Universal Time) of first May 2001, try (note, we now use the condensed form of specifying the field components):\nD = magref([-28 38 0 \"2001-05-01T12:00:00\"], internal=\"tdi/123\")\n1×3 GMTdataset{Float64, 2}\n Row │   col.1    col.2    col.3\n─────┼───────────────────────────\n   1 │ 43758.0  -11.866  54.0388\n```──────────\n   1 │ 43758.0  -11.866  54.0388\nAnd to see the IGRF field at 2025.0. Since we are not specifying the grid increments (inc) it will assume a inc=0.25 degrees.\n\nusing GMT\n\nG = magref(R=:d, onetime=2025);\nviz(G, coast=true, colorbar=true)"
  },
  {
    "objectID": "documentation/modules/magref.html#source-code",
    "href": "documentation/modules/magref.html#source-code",
    "title": "magref",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmagref(; kwargs...) - magref.jl:16\nmagref(cmd0::String; kwargs...) - magref.jl:14\nmagref(arg1; kwargs...) - magref.jl:15"
  },
  {
    "objectID": "documentation/modules/magref.html#see-also",
    "href": "documentation/modules/magref.html#see-also",
    "title": "magref",
    "section": "See Also",
    "text": "See Also\n[mgd77track]"
  },
  {
    "objectID": "documentation/modules/magref.html#references",
    "href": "documentation/modules/magref.html#references",
    "title": "magref",
    "section": "References",
    "text": "References\nComprehensive Modeling of the Geomagnetic Field, see https://doi.org/10.1111/j.1365-246X.2004.02421.x\nThe International Geomagnetic Reference Field (IGRF), see https://www.ngdc.noaa.gov/IAGA/vmod/igrf.html"
  },
  {
    "objectID": "documentation/modules/legend.html",
    "href": "documentation/modules/legend.html",
    "title": "legend",
    "section": "",
    "text": "legend(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/legend.html#description",
    "href": "documentation/modules/legend.html#description",
    "title": "legend",
    "section": "Description",
    "text": "Description\nMakes legends that can be overlaid on maps. It reads specific legend-related information from an input file or from a GMTdatset type. Unless otherwise noted, annotations will be made using the primary annotation font and size in effect (i.e., FONT_ANNOT_PRIMARY)\n\nExample of a map legend, here for seismicity in the Pacific region."
  },
  {
    "objectID": "documentation/modules/legend.html#required-arguments",
    "href": "documentation/modules/legend.html#required-arguments",
    "title": "legend",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nD or pos or position : – pos=(map=(lon,lat), inside=true, outside=true, norm=(x,y), paper=(x,y), justify=code, offset=XX)\nDefines the reference point on the map for the legend using one of four coordinate systems:\n\n\nUse map=(lon,lat) for map coordinates. Requires both region and proj to be set.\nUse inside=code or outside=code for setting the refpoint via a 2-char justification code that refers to the (invisible) projected map bounding box. Requires both region and proj to be set.\nUse norm=(x,y) for normalized bounding box coordinates (0-1). Requires both region and proj to be set.\nUse paper=(x,y) for plot coordinates (append cm, inch, or point).\n\nUse width=(width,height) to set the width (and height) of the legend box in plot coordinates (inches, cm, etc.). If height is zero or not given then we estimate height based the expected vertical extent of the items to be placed. By default, the anchor point on the legend is assumed to be the bottom left corner (:BL), but this can be changed by appending justify followed by a 2-char justification code justify (see text). Note: If inside is used then justify defaults to the same as anchor, if outside is used then justify defaults to the mirror opposite of anchor. Use spacing=val to change the line-spacing factor in units of the current font size [1.1]."
  },
  {
    "objectID": "documentation/modules/legend.html#optional-arguments",
    "href": "documentation/modules/legend.html#optional-arguments",
    "title": "legend",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or clearance : – clearance=(dx,dy)\nSets the clearance between the legend frame and the internal items [4p/4p].\nF or box : – box=(clearance=val, fill=color, inner=true, pen=pen, rounded=true, shaded=XX)\nWithout further options, draws a rectangular border around the scale using MAP_FRAME_PEN; specify a different pen with pen=pen (see [Pen attributes]).\n\nfill=color where color is any valid color setting (see [Setting color]), to fill the scale panel [no fill].\nclearance=val where val is either gap or (xgap,ygap), or (lgap,rgap,bgap,tgap) where these items are uniform, separate in x- and y-direction, or individual side spacings between scale and border.\ninner=true to draw a secondary, inner border as well. We use a uniform gap between borders of 2p and the MAP_DEFAULTS_PEN unless other values are specified (like inner=\"gap/pen\")\nrounded=true to draw rounded rectangular borders instead, with a 6p corner radius. You can override this radius by using another value instead of true (default is 6p).\nshadded=true or shadded=(dx,dy) or shadded=shade to draw an offset background shaded region. Here, dx/dy indicates the shift relative to the foreground frame [4p/-4p]and shade sets the fill style to use for shading (“gray50”).\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nM or source\nModern mode only: Read both (1) the hidden auto-generated legend information file created by plotting-modules’ legend option (warning: not this legend module) and (2) additional information from input file(s) given on the command line [hidden file only].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or scale : scale=val\nScale all symbol sizes by a common scale.\nT or leg_file : leg_file=fname\nModern mode only: Write hidden legend specification file to fname.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats."
  },
  {
    "objectID": "documentation/modules/legend.html#legend-codes",
    "href": "documentation/modules/legend.html#legend-codes",
    "title": "legend",
    "section": "Legend Codes",
    "text": "Legend Codes\nEach legend item is described by a unique record. All records begin with a unique keyword name template that is common to all records of the same kind. We may have to use a template because keyword names cannot be repeated but several records of the same type can. Hence, when needing to repeat a record type we use, for example, symbol1, symbol2, etc… The order of the legend items is implied by the order of the records. Fourteen different record types are recognized, and the syntax for each of these records are presented below:\n\nA or cmap or cpt : cmap=cptname\nSymbol or cell color fills may be given indirectly via a z-value which can be used for the color look-up via the given CPT cptname. You may switch to other cptname by repeating this command.\nB or colorbar : colorbar=(name=cptname, offset=val, height=val [, extra=“…”])\nThis record will plot a horizontal color bar, colorbar -style in the middle, starting at offset from the left edge, and of the given height. You may add any additional colorbar options as well as string in extra=opts. Any of the modifiers (here in hardcore GMT syntax) [+e[b|f][length]][+h][+m[a|c|l|u]][+n[txt]] may be appended ts a string o the height argument, while other module options frame, shade, equal, monochrome, dpi, nolines zfile and view may be appended as optional arguments at the end of the record. See colorbar for details on all modifiers and options.\nC or textcolor : textcolor=color\nSpecifies the color with which the remaining text is to be printed via z=value (requires a prior cmap code as well). When textcolor is used in a legend then your font specifications cannot also contain a color specification since we will append ,textcolor to the font. Use - to reset to default color.\nD or hline : hline=(pen=pen, offset=val)\nThe hline record results in a horizontal line with specified pen across the legend with one quarter of the line-spacing left blank above and below the line. Two gaps of offset units are left blank between the horizontal line and the left and right frame sides [0]. If no pen is given we use MAP_GRID_PEN_PRIMARY, and if pen is set to - then no visible line is drawn (we just remember the location as a possible start/stop point for a vertical line; see vline). To not add the quarter line-spacing before the line, add -. To not add the spacing after the line, add +. For no spacing at all, add = [Default places a quarter line-spacing both before and after the line].\nF or fill : fill=fill1 | fill=(fill1, fill2, …)\nSpecify fill (color of pattern) for cells. Alternatively, you can specify an indirect color via z=value (requires a prior cmap code). If only fill1 is given then it is used to fill the entire row, otherwise give one fill value for each active column (see ncol). If any fill is - then no fill takes place [Default].\nG or gap or vspace : vspace=space\nThis record specifies a vertical gap of the given length. In addition to the standard units (i, c, p) you may use l for lines. A negative gap will move the current line upwards (thus closing a gap).\nH or header : header=(text=txt, [font=font])\nThis record plots a centered text string using the specified font parameters. If font is not used we default to size and fonttype of FONT_TITLE.\nI or image : image=(image=fname, width=val, justify=code)\nPlace an EPS or raster image in the legend justified relative to the current point. The image width determines the size of the image on the page and code is 2-chars positioning code.\nL or label : label=(label=text, justify=code [,font=font])\nPlots a (L)eft, (C)entered, or (R)ight-justified text string within a column using the specified font parameters. code is one of :L, :C or :R. If font is not used we default to size and fonttype of FONT_TITLE\nM or map_scale : map_scale=([lon=val,] lat|y=val, length=val [,region=?, proj=?, box=?])\nPlace a map scale in the legend. Specify lon lat, the point on the map where the scale applies (lon is only meaningful for certain oblique projections). Give length=val, the length of the scale in km (for other units append e (meter), f (foot), M (mile), n (nautical mile), or u (survey foot)). Append +f for a fancy map scale [Default is plain]. All these cases using a unit imply that val must be a string. Append +l to the length to select the default label which equals the distance unit (meter, feet, km, miles, nautical miles, survey feet) and is justified on top of the scale [t]. Change this by giving your own label (append +l_label_). Change label alignment with +a_align_ (choose among l(eft), r(ight), t(op) , and b(ottom)). Apply +u to append the unit to all distance annotations along the scale. If you want to place a map panel behind the scale, add a suitable box panel option (see basemap for details on panels as well as map scale modifiers). All +_modifiers_ must be appended to length to make a single string argument. If the region proj supplied to the module is different than the projection needed for the scale (or not given at all, e.g., with pos=(x=(…),), supply the two optional region and proj settings as well.\nN or ncols : ncols=val\nChange the number of columns in the legend [1]. This only affects the printing of symbols (symbol) and labels (label). The number of columns stay in effect until ncols is used again. To get columns of unequal width, instead provide the relative width of each column separated by whitespace in the form of a string as in relwidth1 relwidth2 … relwidthn. The sum of these widths are equated to the legend width set via position. If no argument is given the we set ncols to 1.\nP or paragraph : paragraph=true | paragraph=options\nStart a new text paragraph by specifying all the parameters needed (see text paragraph record description). Note that the module knows what all those values should be, so normally you can just use paragraph=true. If you need to set at least one of the parameters directly, you must specify all and set the ones you want to leave at their default value to -.\nS or symbol : symbol=(marker=name, [dx_left=val,] size=val [fill=fill, pen=pen] [, dx_right, label=text])\nPlots the selected symbol with specified diameter, fill, and outline (see plot). The symbol is centered at dx_left from the left margin of the column, with the optional explanatory label starting dx_right from the margin, printed with FONT_ANNOT_PRIMARY. If dx_left is not given then it is automatically computed from half the largest symbol size. If dx_right is not given then it is automatically computed as 1.5 times the largest symbol size. The fill can be a pen of pattern or may be specified indirectly via z=value and the color is assigned via the CPT look-up (requires a prior cmap code). When plotting just a symbol, without text, dx_right and label can be omitted. The dx_left value can also be given as a justification code L, C, or R which justifies the symbol with respect to the current column. If no arguments are given to symbol then we simply skip to the next column. Three plot symbols may take special modifiers: front (f), quoted line (q) and vector (v). You can append modifiers to the symbol and affect how the fronts, quoted lines and vectors are presented (see plot man page for modifiers). The module will determine default settings for all modifiers and secondary arguments if not provided. A few other symbols (the rectangles, ellipse, wedge, mathangle) may take more than a single argument size. Note that for a line segment you should use the horizontal dash symbol (-). If just a single size if given then we will provide reasonable arguments to plot the symbol (See Defaults). Alternatively, combine the required arguments into a single, comma-separated string and use that as the symbol size (again, see plot for details on the arguments needed).\nT or text[xx] : text[xx]=text\nOne or more of these text records with paragraph-text printed with FONT_ANNOT_PRIMARY. To specify special positioning and typesetting arrangements, or to enter a paragraph break, use the optional paragraph record. NOTE: since we cannot repeat keyword names, if we want to provide several text strings we must use different keyword names. Hence the text[xx] that means we can repeat this option with text1, text2, etc…\nV or vline : vline=(pen=pen[, offset=val])\nDraws a vertical line between columns (if more than one) using the selected pen. Here, offset is analogous to the offset for the hline records but in the vertical direction [0]. The first time vline is used we remember the vertical position of the last hline line, and the second time vline is set we draw from that past location to the most recent location of the hline line. Thus, hline must be used to mark the start and stop of a vertical line (so vline must follow hline). If no horizontal line is desired simply give - as pen to hline.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format.\n\nThe function GMT.mk_legend(kwargs...) can be used to generate the hard core GMT Legend Codes, which in turn can be written to a file and feed to this module as input. It can also be used in debug to check that the appropriate ASCII codes were generated."
  },
  {
    "objectID": "documentation/modules/legend.html#defaults",
    "href": "documentation/modules/legend.html#defaults",
    "title": "legend",
    "section": "Defaults",
    "text": "Defaults\nWhen attributes are not provided, or extended symbol information (for symbols taking more than just an overall size) are not given as comma-separated quantities, we will provide the following defaults:\nFront: The size argument is length[/gap[ticklength]]. Front symbol is left-side (here, that means upper side) box, with ticklength set 30% of the given symbol length (if not specified separately), and gap* defaulting to -1 (one entered front symbol) if not specified. Modifiers to the symbol argument can be provided.\nVector: Head size is 30% of given symbol size.\nEllipse: Minor axis is 65% of major axis (the symbol size), with an azimuth of 0 degrees.\nRectangle: Height is 65% of width (the symbol size).\nRotated rectangle: Same, with a rotation of 30 degrees.\nRounded rectangle: Same as rectangle, but with corner radius of 10% of width.\nMathangle: Angles are -10 and 45 degrees, with arrow head size 30% of symbol size.\nWedge: Angles are -30 and 30 degrees."
  },
  {
    "objectID": "documentation/modules/legend.html#note-on-legend-height",
    "href": "documentation/modules/legend.html#note-on-legend-height",
    "title": "legend",
    "section": "Note On Legend Height",
    "text": "Note On Legend Height\nAs position suggests, leaving the height off forces a calculation of the expected height. This is an exact calculation except in the case of legends that place paragraph text. Here we simply do a first-order estimate of how many typeset lines might appear. Without access to font metrics this estimate will occasionally be off by 1 line. If so, note the reported height (with verbose) and specify a slightly larger or smaller height in position."
  },
  {
    "objectID": "documentation/modules/legend.html#examples",
    "href": "documentation/modules/legend.html#examples",
    "title": "legend",
    "section": "Examples",
    "text": "Examples\nTo add an example of a legend to a Mercator plot with the given specifications:\n\nusing GMT\nmakecpt(\"-Cpanoply -T-8/8 &gt; tt.cpt\")\n\nlegend((\n       vspace=-0.25,\n       header=(text=\"My Map Legend\", font=(24,\"Times-Roman\")),\n       hline=(pen=1, offset=0.5),\n       ncolumns=2,\n       vline=(pen=1, offset=0),\n       symbol1=(marker=:circ,    size=0.4, dx_left=0.25, fill=\"p300/12\", dx_right=0.75, text=\"This circle is hachured\"),\n       symbol2=(marker=:ellipse, size=0.4, dx_left=0.25, fill=:yellow,   dx_right=0.75, text=\"This ellipse is yellow\"),\n       symbol3=(marker=:wedge,   size=0.4, dx_left=0.25, fill=:green, pen=0.25, dx_right=0.75, text=\"This wedge is green\"),\n       symbol4=(marker=:fault,   size=0.65, dx_left=0.25, fill=:blue, dx_right=0.75, text=\"This is a fault\"),\n       symbol5=(marker=\"-\", size=0.4,  dx_left=0.25, pen=(0.25,:dash), dx_right=0.75, text=\"A contour\"),\n       symbol6=(marker=:vector, size=0.65, dx_left=0.25, fill=:magenta, pen=0.5, dx_right=0.75, text=\"This is a vector\"),\n       symbol7=(marker=\"i\", size=0.4,  dx_left=0.25, fill=:cyan,    pen=0.25, dx_right=0.75, text=\"This triangle is boring\"),\n       hline2=(pen=1, offset=0.5),\n       vline2=(pen=1, offset=0),\n       ncolumns2=1,\n       map_scale=(lon=5, lat=5, length=\"600+u+f\"),\n       vspace2=0.13,\n       image=(width=7.5, fname=\"@SOEST_block4.png\", justify=:CT),\n       vspacep3=0.13,\n       colorbar=(name=\"tt.cpt\", offset=0.5, height=0.5, extra=\"-B0\"),\n       label=(txt=\"Smith et al., @%5%J. Geophys. Res., 99@%%, 2000\", justify=:R, font=(9, \"Times-Roman\")),\n       vspace4=0.25,\n       text1=\"Let us just try some simple text that can go on a few lines. There is no easy way to predetermine\",\n       text2=\"how many lines may be required so we may have to adjust the height to get the right size box.\"\n       ),\n       region=(0,10,0,8), pos=(paper=(1.25,1.25), width=14, justify=:BL, spacing=1.2),\n       clearance=(0.25,0.25), box=(pen=0.5, fill=:azure1),\n       figsize=16, proj=:Mercator, show=true\n       )"
  },
  {
    "objectID": "documentation/modules/legend.html#source-code",
    "href": "documentation/modules/legend.html#source-code",
    "title": "legend",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlegend(cmd0::String; ...) - pslegend.jl:45\nlegend(; ...) - pslegend.jl:45\nlegend(arg1; kw...) - pslegend.jl:249\nlegend(cmd0::String, arg1; first, kwargs...) - pslegend.jl:45"
  },
  {
    "objectID": "documentation/modules/img2grd.html",
    "href": "documentation/modules/img2grd.html",
    "title": "img2grd",
    "section": "",
    "text": "Extract a subset from an img file in Mercator or Geographic format.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/hotspotter.html",
    "href": "documentation/modules/hotspotter.html",
    "title": "hotspotter",
    "section": "",
    "text": "Create CVA grid from seamount locations.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/hband.html",
    "href": "documentation/modules/hband.html",
    "title": "hband",
    "section": "",
    "text": "hband(mat::Matrix; region=(...), height=false, percent=false, fill=nothing, fillalpha=nothing)\nPlease see this function documentation in vband"
  },
  {
    "objectID": "documentation/modules/hband.html#source-code",
    "href": "documentation/modules/hband.html#source-code",
    "title": "hband",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/grdvolume.html",
    "href": "documentation/modules/grdvolume.html",
    "title": "grdvolume",
    "section": "",
    "text": "grdvolume(cmd0::String=\"\", arg1=nothing; kwargs...)\ngrdvolume - Calculate grid volume and area constrained by a contour\n(Warning: Manual translate by Claude. Needs revision)"
  },
  {
    "objectID": "documentation/modules/grdvolume.html#description",
    "href": "documentation/modules/grdvolume.html#description",
    "title": "grdvolume",
    "section": "Description",
    "text": "Description\nReads a 2-D grid file and calculates the volume contained below the surface and above the plane specified by the given contour (or zero if not given) and reports the contour, area, volume, and maximum mean height (volume/area). Alternatively, a range of contours can be specified to determine the volume and area inside the contour for all contour values. Using find_max, the contour that produced the maximum mean height (or maximum curvature of heights vs contour value) is reported as well. This feature may be used with grdfilter in designing an Optimal Robust Separator [Wessel, 1998; 2016]."
  },
  {
    "objectID": "documentation/modules/grdvolume.html#required-arguments",
    "href": "documentation/modules/grdvolume.html#required-arguments",
    "title": "grdvolume",
    "section": "Required Arguments",
    "text": "Required Arguments\nA GMTgrid or a grid file name of a 2-D gridded data set."
  },
  {
    "objectID": "documentation/modules/grdvolume.html#optional-arguments",
    "href": "documentation/modules/grdvolume.html#optional-arguments",
    "title": "grdvolume",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or cont or contour : – cont=cval | cont=(low,high,delta) | cont=“r(low,high)” | cont=“rcval”\nFind area, volume and mean height (volume/area) inside and above the cval contour. Alternatively, search using all contours from low to high in steps of delta. [Default returns area, volume and mean height of the entire grid]. The area is measured in the plane of the contour. Adding the r prefix computes the volume below the grid surface and above the planes defined by low and high, or below cval and grid’s minimum. Note that this is an outside volume whilst the other forms compute an inside (below the surface) area volume. Use this form to compute for example the volume of water between two contours.\nD or diff or difference : – diff=true\nAppend the difference between the volume calculated and the volume of the grid domain bounding box (i.e., the missing or remainder volume).\nL or base_level or baselevel : – base_level=val\nAlso compute the area, volume and mean height from base up to the contour. If no cont is given then we compute the area and volume below the surface and above base [Default base is contour].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or unit : – unit=:letter\nFor geographical grids, append a unit from e|f|k|M|n|u. Default calculates areas and volumes based upon a spherical Earth using great circle distances.\nT or find_max or findmax: – find_max=:c | find_max=:h\nDetermine the single contour that maximized the average height (volume/area). Select find_max=:c to use the maximum curvature of heights versus contour value rather than the contour with the maximum height to pick the best contour value [Default is :h].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or scale : – scale=fact | scale=(fact,shift)\nOptionally subtract shift before scaling data by fact. [Default is no scaling]. (Numbers with units are not supported).\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/grdvolume.html#notes",
    "href": "documentation/modules/grdvolume.html#notes",
    "title": "grdvolume",
    "section": "Notes",
    "text": "Notes\nThe surface will be approximated using a bilinear expression for the z-value inside each grid box defined by four grid nodes:\nz(x,y) = z_0 + z'_x x + z'_y y + z''_{xy} xy\nwhere the first term is the grid value at the lower left corner of the cell (where our relative coordinates x = y = 0). The primed z-values are derivatives in x, y, and both directions, respectively. We analytically integrate this expression within each box, allowing for straight line contour intersections to go through a box and affect the integration domain and limits. We then sum up all contributions from all the grid cells.\nFor geographical grids we convert degrees to “Flat Earth” distances in meter. You can use unit to select another distance unit. The area is then reported in this unit squared while the volume is reported in unit^2 * z_{unit} quantities.\ngrdvolume distinguishes between gridline and pixel-registered grids. In both cases the area and volume are computed up to the grid boundaries. That means that in the first case the grid cells on the boundary only contribute half their area (and volume), whereas in the second case all grid cells are fully used. The exception is when the cont option is used: since contours do not extend beyond the outermost grid point, both grid types are treated the same."
  },
  {
    "objectID": "documentation/modules/grdvolume.html#examples",
    "href": "documentation/modules/grdvolume.html#examples",
    "title": "grdvolume",
    "section": "Examples",
    "text": "Examples\nTo determine area, volume, and mean height in km for all land areas (above zero contour) in the Hawaiian Islands from the remote grid (height in m):\n\nusing GMT\nG = gmtread(\"@earth_relief_05m\", region=(190,210,15,25))\nD = grdvolume(G, cont=0, unit=:k, scale=0.001)\n\n\n\n\n\n\n\n1×4 GMTdataset{Float64, 2}\n Row │ col.1    col.2    col.3    col.4\n─────┼──────────────────────────────────\n   1 │   0.0  15771.3  13707.5  0.86914\n\n\nTo find the volume below the surface peaks.nc and above the contour z = 250 m:\nG = gmtread(\"peaks.nc\")\nD = grdvolume(G, cont=250)\nTo search for the contour, ranging from 100 to 300 in steps of 10, that maximizes the ratio of volume to surface area for the file peaks.nc:\nG = gmtread(\"peaks.nc\")\nD = grdvolume(G, cont=(100,300,10), find_max=:h)\nTo see the areas and volumes for all the contours in the previous example:\nG = gmtread(\"peaks.nc\")\nD = grdvolume(G, cont=(100,300,10))"
  },
  {
    "objectID": "documentation/modules/grdvolume.html#references",
    "href": "documentation/modules/grdvolume.html#references",
    "title": "grdvolume",
    "section": "References",
    "text": "References\nWessel, P., 1998, An empirical method for optimal robust regional-residual separation of geophysical data, Math. Geol., 30(4), 391-408, https://doi.org/10.1023/A:1021744224861.\nWessel, P., 2016, Regional–residual separation of bathymetry and revised estimates of Hawaii plume flux, Geophys. J. Int., 204(2), 932-947, https://doi.org/10.1093/gji/ggv472."
  },
  {
    "objectID": "documentation/modules/grdvolume.html#source-code",
    "href": "documentation/modules/grdvolume.html#source-code",
    "title": "grdvolume",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdvolume(cmd0::String; ...) - grdvolume.jl:31\ngrdvolume(; ...) - grdvolume.jl:31\ngrdvolume(arg1; kw...) - grdvolume.jl:40\ngrdvolume(cmd0::String, arg1; kwargs...) - grdvolume.jl:31"
  },
  {
    "objectID": "documentation/modules/grdvolume.html#see-also",
    "href": "documentation/modules/grdvolume.html#see-also",
    "title": "grdvolume",
    "section": "See Also",
    "text": "See Also\ngrdfilter, grdmask"
  },
  {
    "objectID": "documentation/modules/grdvector.html",
    "href": "documentation/modules/grdvector.html",
    "title": "grdvector",
    "section": "",
    "text": "grdvector(compx, compy; kwargs...)\nor\n    grdvector(X, Y, U, V; kwargs...)\nPlot vector field from two component grids"
  },
  {
    "objectID": "documentation/modules/grdvector.html#description",
    "href": "documentation/modules/grdvector.html#description",
    "title": "grdvector",
    "section": "Description",
    "text": "Description\nReads two 2-D grid files which represents the x and y components of a vector field and produces a vector field plot by drawing vectors with orientation and length according to the information in the files. Alternatively, polar coordinate r, theta grids may be given instead. To replicate the Matlab functioning one can also pass four arrays in input: X, Y -&gt; arrays of coordinates as produced by meshgrid; U, V horizontal and vertical components."
  },
  {
    "objectID": "documentation/modules/grdvector.html#required-arguments",
    "href": "documentation/modules/grdvector.html#required-arguments",
    "title": "grdvector",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ncompx Contains the x-components of the vector field.\ncompy Contains the y-components of the vector field."
  },
  {
    "objectID": "documentation/modules/grdvector.html#optional-arguments",
    "href": "documentation/modules/grdvector.html#optional-arguments",
    "title": "grdvector",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or polar : – polar=true\nThe grid files contain polar (r, theta) components instead of Cartesian (x, y) [Default is Cartesian components].\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap or colorap or colorscale : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name (for grd_z only). Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. In this case color1 etc can be a (r,g,b) triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ) (see [Setting color](../common_features/color.html)). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map.\nG or fill : – fill=fill\nSets color or shade for vector interiors (see [Fill color/pattern]) [Default is no fill]. Alternatively, the fill may be set via |-Q|.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“x”“multx”[“/multy”]\nOnly plot vectors at nodes every x_inc, y_inc apart (must be multiples of original grid spacing). Append m for arc minutes or s for arc seconds. Alternatively, use inc=“x” to specify the multiples multx[/multy] directly [Default plots every node]. Example inc=“x10/5” to select every other 10 nodes in x and 5 nodes in y. NOTE: by default we estimate good values so that the arrows do no overlap so you may start by jumping this option unless some fine control is desired.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nN or noclip or no_clip : noclip=true\nDo NOT clip vectors at map boundaries [Default will clip].\nQ or vec or vector or arrow : – vector=parameters\nModify vector parameters. For vector heads, append vector head size [Default is 0, i.e., stick-plot]. See [Vector Attributes] for specifying additional attributes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or vscale or vec_scale : – vscale=(inverse=len, length=len, scale=xx, scale_at_lat=??, refsize=size)\nSets scale for vector plot lengths in data units per plot distance measurement unit. Append c, i, or p to indicate the desired plot distance measurement (then xx must be a string) unit (cm, inch, or point); if no unit is given we use the default value that is controlled by PROJ_LENGTH_UNI. Vector lengths converted via plot unit scaling will plot as straight Cartesian vectors and their lengths are not affected by map projections and coordinate locations. For geographic data you may alternatively give scale in data units per map distance unit (see Units). Then, your vector magnitudes (in data units) are scaled to map distances in the given distance unit, and finally projected onto the Earth to give plot dimensions. These are geo-vectors that follow great circle paths and their lengths may be affected by the map projection and their coordinates. Finally, use vscale=(inverse=len,…) if it is simpler to give the reciprocal scale in plot length or distance units per data unit. Alternatively, use vscale=(length=len,…) to set a fixed plot len for all vectors. To report the minimum, maximum, and mean data and plot vector lengths of all vectors plotted, use verbose option. If an automatic legend entry is desired via label, or or two modifiers will be required:\n\nscale_at_lat=slon or scale_at_lat=(slon,slat) or scale_at_lat=true controls where on a geographic map a geovector’s refsize length applies. The modifier is neither needed nor available when plotting Cartesian vectors. The length is calculated for latitude slat (optionally supply longitude slon for oblique projections [default is central meridian]). If scale_at_lat=true then we select the reference length origin to be the middle of the map.\nrefsize=size sets the desired reference vector magnitude in data units. E.g., for a reference length of 25 mm/yr for plate motions, use modifier refsize=25 with a corresponding option label=“Velocity (25 mm/yr)”. If refsize is not specified we default to the scale given above.\n\nT or sign_scale : – sign_scale=true\nMeans the azimuths of Cartesian data sets should be adjusted according to the signs of the scales in the x- and y-directions [Leave alone]. This option can be used to convert vector azimuths in cases when a negative scale is used in one of both directions (e.g., positive down).\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format.\nZ or azimuth : – azimuth=true\nThe theta grid provided contains azimuths rather than directions (implies polar=true).\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nl or legend : – legend=params\nAdd a map legend entry to the session legend information file for the current plot (modern mode only). While this option is not expanded, see params at The -l option\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used).\n.. include:: explain_vectors.rst_"
  },
  {
    "objectID": "documentation/modules/grdvector.html#examples",
    "href": "documentation/modules/grdvector.html#examples",
    "title": "grdvector",
    "section": "Examples",
    "text": "Examples\nTo draw the vector field given by the files r.nc and theta.nc on a linear plot with scale 5 cm per data unit, using vector rather than stick plot, scale vector magnitudes so that 10 units equal 1 inch, and center vectors on the node locations, run\n    grdvector(\"r.nc\", \"theta.nc\", figscale=5, polar=true, vscale=\"10i\",\n              vector=(len=0.25, stop=true, justify=:center))\nTo plot a geographic data sets given the files comp_x.nc and comp_y.nc, using a length scale of 200 km per data unit and only plot every 3rd node in either direction, try\n    grdvector(\"comp_x.nc\", \"comp_y.nc\", inc=\"x3\", proj=:guess, vscale=\"200k\",\n              vector=(len=0.25, stop=true, justify=:center))\nA nice arrow field\n\nusing GMT\nX,Y = meshgrid(-pi:pi/8:pi,-pi:pi/8:pi);\nU = sin.(Y);\nV = cos.(X);\ngrdvector(X, Y, U, V, region=(-3.6,3.6,-3.6,3.6), fill=:black, lc=:red, show=true)\n\n\n\n\n\n\n\n\nFor simplicity let’s create a grid using grdmath and compute its horizontal derivatives. Then we plot them as an arrow field.\n\nusing GMT\nG = gmt(\"grdmath -R-2/2/-2/2 -I0.1 X Y R2 NEG EXP X MUL\");\ndzdy = gmt(\"grdmath ? DDY\", G);\ndzdx = gmt(\"grdmath ? DDX\", G);\ngrdcontour(G, annot=:none, pen=:gray80)\ngrdvector!(dzdx, dzdy, cmap=:turbo, lw=1, show=true)"
  },
  {
    "objectID": "documentation/modules/grdvector.html#vector-scaling-and-unit-effects",
    "href": "documentation/modules/grdvector.html#vector-scaling-and-unit-effects",
    "title": "grdvector",
    "section": "Vector scaling and unit effects",
    "text": "Vector scaling and unit effects\nThe scale given via vscale may require some consideration. As explained in vscale, it is specified in data-units per plot or distance unit. The plot or distance unit chosen will affect the type of vector you select. In all cases, we first compute the magnitude r of the user’s data vectors at each selected node from the x and y components (unless you are passing r, theta grids directly with polar). These magnitudes are given in whatever data units they come with. Let us pretend our data grids record secular changes in the Earth’s magnetic horizontal vector field in units of nTesla/year, and that at a particular node the magnitude is 28 nTesla/year (in some direction). If you specify the scale using plot distance units (c | i | p) then you are selecting Cartesian vectors. Let us further pretend that you selected vscale=“10c” as your scale option. That means you want 10 nTesla/year to equate to a 1 cm plot length. Internally, we convert this scale to a plot scale of 1/10 = 0.1 cm per nTesla/year. Given our vector magnitude of 28 nTesla/year, we multiply it by our plot scale and finally obtain a vector length of 2.8 cm, which is then plotted. The user’s data units do not enter of course, i.e., they always cancel [Likewise, if we had used vscale=“25i” (25 nTesla/year per inch) the plot scale would be (1/25) = 0.04 inch per nTesla/year and the vector plot lengths would be 28 * 0.04 inch = 1.12 inch]. If we now wished to plot a 10 nTesla/year reference vector in the map legend we would plot one that is 10 times 0.1 cm = 1 cm long since the scale length is constant regardless of map projection and location. A 10 nTesla/year vector will be 1 cm anywhere.\nLet us contrast this behavior with what happens if we use a geographic distance unit instead, say vscale=“0.5k” (0.5 nTesla/year per km). Internally, this becomes a map scale of 2 km per nTesta/year. Given our node magnitude of 28 nTesla/year, the vector length will be 28 x 2 km = 56 km. Again, the user’s data unit do not enter. Now, that vector length of 56 km must be projected onto the Earth, and because of map distortions, a 56 km vector will be mapped to a length on the plot that is a function of the user’s map projection, the map scale, and possibly the location on the map. E.g., a 56 km vector due east at Equator on a Mercator map would seem to equal ~0.5 degree longitude but at 60 north it would be more like ~1 degree longitude. A consequence of this effect is that a user who wants to add a 10 nTesla/year reference vector to a legend faces the same problem we do when we wish to draw a 100 km map scale on a map: the plotted length usually will depend on latitude and hence that reference scale is only useful around that latitude.\nThis brings us to the inverse scale option, vscale=(inverse=len,…). This variant is useful when providing the inverse of the scale is simpler. In the Cartesian case above, we could instead give vscale=(inverse=“0.1c”) which would directly imply a plot scale of 0.1 cm per nTesla/year. Likewise, for geographic distances we could give vscale=(inverse=“2k”) for 2 km per nTesla/year scale as well. As the inverse argument increases, the plotted vector length increases as well, while for plain vscale the plot length decreases with increasing scale."
  },
  {
    "objectID": "documentation/modules/grdvector.html#notes",
    "href": "documentation/modules/grdvector.html#notes",
    "title": "grdvector",
    "section": "Notes",
    "text": "Notes\nBe aware that using inc may lead to aliasing unless your grid is smoothly varying over the new length increments. It is generally better to filter your grids and resample at a larger grid increment and use these grids instead of the originals."
  },
  {
    "objectID": "documentation/modules/grdvector.html#source-code",
    "href": "documentation/modules/grdvector.html#source-code",
    "title": "grdvector",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdvector(arg1::Matrix{&lt;:Real}, arg2::Matrix{&lt;:Real}; kw...) - grdvector.jl:186\ngrdvector(arg1, arg2; first, kwargs...) - grdvector.jl:58\ngrdvector(arg1::Matrix{&lt;:Real}, arg2::Matrix{&lt;:Real}, arg3::Matrix{&lt;:Real}, arg4::Matrix{&lt;:Real}; kw...) - grdvector.jl:188"
  },
  {
    "objectID": "documentation/modules/grdvector.html#see-also",
    "href": "documentation/modules/grdvector.html#see-also",
    "title": "grdvector",
    "section": "See Also",
    "text": "See Also\ngrdcontour, plot"
  },
  {
    "objectID": "documentation/modules/grdtrack.html",
    "href": "documentation/modules/grdtrack.html",
    "title": "grdtrack",
    "section": "",
    "text": "grdtrack(cmd0::String=\"\", arg1=nothing, arg2=nothing; kwargs...)\nSample grids at specified (x,y) locations"
  },
  {
    "objectID": "documentation/modules/grdtrack.html#warning-only-half-ported-to-gmt.jl-need-help-for-finishing",
    "href": "documentation/modules/grdtrack.html#warning-only-half-ported-to-gmt.jl-need-help-for-finishing",
    "title": "grdtrack",
    "section": "WARNING: ONLY HALF PORTED TO GMT.JL NEED HELP FOR FINISHING",
    "text": "WARNING: ONLY HALF PORTED TO GMT.JL NEED HELP FOR FINISHING"
  },
  {
    "objectID": "documentation/modules/grdtrack.html#description",
    "href": "documentation/modules/grdtrack.html#description",
    "title": "grdtrack",
    "section": "Description",
    "text": "Description\nReads one or more grid files (or a Sandwell/Smith IMG files) and a table (from file or standard input; but see profile for exception) with (x,y) [or (lon,lat)] positions in the first two columns (more columns may be present). It interpolates the grid(s) at the positions in the table and writes out the table with the interpolated values added as (one or more) new columns. Alternatively (crossprofile), the input is considered to be line-segments and we create orthogonal cross-profiles at each data point or with an equidistant separation and sample the grid(s) along these profiles. A bicubic [Default], bilinear, B-spline or nearest-neighbor (see interp) interpolation is used, requiring boundary conditions at the limits of the region (see interp; Default uses “natural” conditions (second partial derivative normal to edge is zero) unless the grid is automatically recognized as periodic.)"
  },
  {
    "objectID": "documentation/modules/grdtrack.html#required-arguments",
    "href": "documentation/modules/grdtrack.html#required-arguments",
    "title": "grdtrack",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding the (x,y) positions where the user wants to sample the 2-D data set. Mandatory except if profile option is used.\nG or grid : – grid=GMTgrid | grid=gridfile\nGMTgrid (a grid type) or gridfile is a 2-D binary grid file with the function f(x,y). If the specified grid is in Sandwell/Smith Mercator format you must append a comma-separated list of arguments that includes a scale to multiply the data (usually 1 or 0.1), the mode which stand for the following: (0) Img files with no constraint code, returns data at all points, (1) Img file with constraints coded, return data at all points, (2) Img file with constraints coded, return data only at constrained points and NaN elsewhere, and (3) Img file with constraints coded, return 1 at constraints and 0 elsewhere, and optionally the max latitude in the IMG file [80.738]. You may repeat grid as many times as you have grids you wish to sample. Alternatively, use -G+l list to pass a file whose first word in the trailing text record will be extracted as the file names. The grids are sampled and results are output in the order given. Note: If gridfile is a remote global grid and no registration is specified then grdtrack will default to gridline registration (instead of the default pixel registration) to ensure all input points are inside the grid."
  },
  {
    "objectID": "documentation/modules/grdtrack.html#optional-arguments",
    "href": "documentation/modules/grdtrack.html#optional-arguments",
    "title": "grdtrack",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or interp_path or resample : – interp_path=[f|p|m|r|R][+l]\nFor track resampling (if crossprofile or profile are set) we can select how this is to be performed. Append f to keep original points, but add intermediate points if needed [Default], m as f, but first follow meridian (along y) then parallel (along x), p as f, but first follow parallel (along y) then meridian (along x), r to resample at equidistant locations; input points are not necessarily included in the output, and R as r, but adjust given spacing to fit the track length exactly. Finally, append +l if geographic distances should be measured along rhumb lines (loxodromes) instead of great circles. Ignored unless crossprofile is used.\nC or crossprofile : – crossprofile=length/ds[/spacing][+a|v][d|f value][l|r]\nUse input line segments to create an equidistant and (optionally) equally-spaced set of crossing profiles along which we sample the grid(s) [Default simply samples the grid(s) at the input locations]. Specify two length scales that control how the sampling is done: length* sets the full length of each cross-profile, while ds is the sampling spacing along each cross-profile. Optionally, append / spacing for an equidistant spacing between cross-profiles [Default erects cross-profiles at the input coordinates]; see interp_path for how resampling the input track is controlled. By default, all cross-profiles have the same direction (left to right as we look in the direction of the input line segment). Append +a to alternate the direction of cross-profiles, or v to enforce either a “west-to-east” or “south-to-north” view. By default the entire profiles are output. Choose to only output the left or right halves of the profiles by appending +l or +r, respectively. Append suitable units to length; it sets the unit used for ds (and spacing) (See Units below). The default unit for geographic grids is meter while Cartesian grids implies the user unit. The output columns will be lon, lat, dist, azimuth, z1, z2, …, zn (The zi are the sampled values for each of the n grids). Use +d to change the profiles from being orthogonal to the line by the given deviation [0]. Looking in the direction of the line, a positive deviation will rotate the crosslines clockwise and a negative one will rotate them counter-clockwise. Finally, you can use +f to set a fixed azimuth for all profiles.\nD or dfile : – dfile=fname\nIn concert with crossprofile we can save the (possibly resampled) original lines to the file fname [Default only saves/returns the cross-profiles]. The columns will be lon, lat, dist, azimuth, z1, z2, … (sampled value for each grid)\nE or profile : – profile=line [, line,…][+a az][+c][+d][+g][+i inc][+l length][+n np][+o az][+r radius]\nInstead of reading input track coordinates, specify profiles via coordinates and modifiers. The format of each line is start/stop, where start or stop are either lon/lat (x/y for Cartesian data) or a 2-character XY key that uses the text-style justification format to specify a point on the map as [LCR][BMT]. Each line will be a separate segment unless +c is used which will connect segments with shared joints into a single segment. In addition to line coordinates, you can use Z-, Z+ to mean the global minimum and maximum locations in the grid (only available if a single grid is given via grid). You may append +i inc to set the sampling interval; if not given then we default to half the minimum grid interval. For a line along parallels or meridians you can add +g to report degrees of longitude or latitude instead of great circle distances starting at zero. Instead of two coordinates you can specify an origin and one of +a, +o, or +r. The +a sets the azimuth of a profile of given length starting at the given origin, while +o centers the profile on the origin; both require +l. For circular sampling specify +r to define a circle of given radius centered on the origin; this option requires either +n or +i. The +n np modifier sets the desired number of points, while +l length gives the total length of the profile. Append +d to output the along-track distances after the coordinates. Note: No track file will be read. Also note that only one distance unit can be chosen. Giving different units will result in an error. If no units are specified we default to great circle distances in km (if geographic). If working with geographic data you can use -j to control distance calculation mode [Great Circle]. Note: If crossprofile is set and spacing is given the that sampling scheme overrules any modifier set in profile.\nF or critical : – critical=[+b][+n][+r][+z z0]\nFind critical points along each cross-profile as a function of along-track distance. Requires crossprofile and a single input grid (z). We examine each cross-profile generated and report (dist, lonc, latc, distc, azimuthc, zc) at the center peak of maximum z value, (lonl, latl, distl) and (lonr, latr, distr) at the first and last non-NaN point whose z-value exceeds z0, respectively, and the width based on the two extreme points found. Here, dist is the distance along the original input trackfile and the other 12 output columns are a function of that distance. When searching for the center peak and the extreme first and last values that exceed the threshold we assume the profile is positive up. If we instead are looking for a trough then you must use +n to temporarily flip the profile to positive. The threshold z0 value is always given as &gt;= 0; use +z to change it [0]. Alternatively, use +b to determine the balance point and standard deviation of the profile; this is the weighted mean and weighted standard deviation of the distances, with z acting as the weight. Finally, use +r to obtain the weighted rms about the cross-track center (distc == 0). Note: We round the exact results to the nearest distance nodes along the cross-profiles. We write 13 output columns per track: dist, lonc, latc, distc, azimuthc, zc, lonl, latl, distl, lonr, latr, distr, width.\nN or no_skip or noskip : – no_skip=true\nDo not skip points that fall outside the domain of the grid(s) [Default only output points within grid domain].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or stack : – stack=method/modifiers\nIn conjunction with crossprofile, compute a single stacked profile from all profiles across each segment. Append how stacking should be computed: a = mean (average), m = median, p = mode (maximum likelihood), l = lower, L = lower but only consider positive values, u = upper, U = upper but only consider negative values [a]. The modifiers control the output; choose one or more among these choices: +a : Append stacked values to all cross-profiles. +d : Append stack deviations to all cross-profiles. +r : Append data residuals (data - stack) to all cross-profiles. +s [file] : Save stacked profile to file [grdtrack_stacked_profile.txt]. +c fact : Compute envelope on stacked profile as ± fact * deviation [2]. Notes: (1) Deviations depend on method and are st.dev (a), L1 scale, i.e., 1.4826 * median absolute deviation (MAD) (for m and p), or half-range (upper-lower)/2. (2) The stacked profile file contains a leading column plus groups of 4-6 columns, with one group for each sampled grid. The leading column holds cross distance, while the first four columns in a group hold stacked value, deviation, min value, and max value, respectively. If method is one of a| m| p then we also write the lower and upper confidence bounds (see +c). When one or more of +a, +d, and +r are used then we also append the stacking results to the end of each row, for all cross-profiles. The order is always stacked value (+a), followed by deviations (+d) and finally residuals (+r). When more than one grid is sampled this sequence of 1-3 columns is repeated for each grid.\nT or radius : – radius= [radius][+e|p]\nTo be used with normal grid sampling, and limited to a single, non-IMG grid. If the nearest node to the input point is NaN, search outwards until we find the nearest non-NaN node and report that value instead. Optionally specify a search radius which limits the consideration to points within this distance from the input point. To report the location of the nearest node and its distance from the input point, append +e. The default unit for geographic grid distances is spherical degrees. Use radius to change the unit and give radius = 0 if you do not want to limit the radius search. To instead replace the input point with the coordinates of the nearest node, append +p.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or z_only : – z_only=true\nOnly write out the sampled z-values [Default writes all columns]. Note: If used in conjunction with -s then the default column becomes 0 instead of 2. If specifying specific columns in -s then start numbering the z-columns from 0 instead of 2.\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used).\n.. include:: explain_grdresample2.rst_"
  },
  {
    "objectID": "documentation/modules/grdtrack.html#hints",
    "href": "documentation/modules/grdtrack.html#hints",
    "title": "grdtrack",
    "section": "Hints",
    "text": "Hints\nIf an interpolation point is not on a node of the input grid, then a NaN at any node in the neighborhood surrounding the point will yield an interpolated NaN. Bicubic interpolation [default] yields continuous first derivatives but requires a neighborhood of 4 nodes by 4 nodes. Bilinear interpolation [interp] uses only a 2 by 2 neighborhood, but yields only zeroth-order continuity. Use bicubic when smoothness is important. Use bilinear to minimize the propagation of NaNs, or lower threshold."
  },
  {
    "objectID": "documentation/modules/grdtrack.html#examples",
    "href": "documentation/modules/grdtrack.html#examples",
    "title": "grdtrack",
    "section": "Examples",
    "text": "Examples\nTo extract a profile along a great circle between (0,0) to (20,20) from the remote grid earth_relief_05m, and only write out (dist, topo) records, try\n\nusing GMT\nresetGMT()  # hide\nD = grdtrack(\"@earth_relief_05m\", region=(0,20,0,20), profile=\"BL/TR+d\", o=\"3,2\")\nimshow(D)\n\n\n\n\n\n\n\n\nTo sample the file hawaii_topo.nc along the SEASAT track track_4.xyg (An ASCII table containing longitude, latitude, and SEASAT-derived gravity, preceded by one header record)\n    D = grdtrack(\"track_4.xyg\", grid=\"hawaii_topo.nc\", header=1)\nTo sample the Sandwell/Smith IMG format file grav.18.1.img (1 minute free-air anomalies on a Mercator grid) along 100-km-long cross-profiles that are orthogonal to the line segment given in the file track.xy, erecting cross-profiles every 25 km and sampling the grid every 3 km, try\n    grdtrack(\"track.xy\", grid=\"grav.18.1.img,0.1,1\", crossprofile=(\"100k\",3,25), interp_path=:r)\nThe same thing, but now determining the central anomaly location along track, with a threshold of 25 mGal, try\n    grdtrack(\"track.xy\", grid=\"grav.18.1.img,0.1,1\", crossprofile=(\"100k\",3,25), critical=\"+z25\")\nTo sample the grid data.nc along a line from the lower left to the upper right corner, using a grid spacing of 1 km on the geodesic, and output distances as well, try\n    grdtrack(profile=\"LB/RT+i1k+d\", grid=\"data.nc\", spherical=:ellipsoidal)"
  },
  {
    "objectID": "documentation/modules/grdtrack.html#source-code",
    "href": "documentation/modules/grdtrack.html#source-code",
    "title": "grdtrack",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdtrack(cmd0::String; ...) - grdtrack.jl:12\ngrdtrack(; ...) - grdtrack.jl:12\ngrdtrack(cmd0::String, arg1; ...) - grdtrack.jl:12\ngrdtrack(arg1, arg2; kw...) - grdtrack.jl:106\ngrdtrack(arg1; ...) - grdtrack.jl:106\ngrdtrack(cmd0::String, arg1, arg2; kwargs...) - grdtrack.jl:12"
  },
  {
    "objectID": "documentation/modules/grdtrack.html#see-also",
    "href": "documentation/modules/grdtrack.html#see-also",
    "title": "grdtrack",
    "section": "See Also",
    "text": "See Also\ngmtconvert, text, sample1d, surface"
  },
  {
    "objectID": "documentation/modules/grdsample.html",
    "href": "documentation/modules/grdsample.html",
    "title": "grdsample",
    "section": "",
    "text": "grdsample(cmd0::String=\"\", arg1=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/grdsample.html#description",
    "href": "documentation/modules/grdsample.html#description",
    "title": "grdsample",
    "section": "Description",
    "text": "Description\nRead a grid file and interpolates it to create a new grid file with either: a different registration (reg or toggle); or, a new grid-spacing or number of nodes (inc), and perhaps also a new sub-region (region). A bicubic [Default], bilinear, B-spline or nearest-neighbor interpolation is used; see interp for settings. Note that using region only is equivalent to grdcut or grdedit -S. grdsample safely creates a fine mesh from a coarse one; the converse may suffer aliasing unless the data are filtered using grdfft or grdfilter.\nWhen the region is omitted, the output grid will cover the same region as the input grid. When inc is omitted, the grid spacing of the output grid will be the same as the input grid. Either reg or toggle can be used to change the grid registration. When omitted, the output grid will have the same registration as the input grid."
  },
  {
    "objectID": "documentation/modules/grdsample.html#required-arguments",
    "href": "documentation/modules/grdsample.html#required-arguments",
    "title": "grdsample",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe 2-D gridded data set to be contoured."
  },
  {
    "objectID": "documentation/modules/grdsample.html#optional-arguments",
    "href": "documentation/modules/grdsample.html#optional-arguments",
    "title": "grdsample",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or toggle : toggle=true\nTranslate between grid and pixel registration; if the input is grid-registered, the output will be pixel-registered and vice-versa. This is a destructive grid change; see Switching registrations.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nx or cores : – cores=N\nLimit the number of cores used when making the individual frames. By default we try to use all available cores. Append N to only use n cores (if too large it will be truncated to the maximum cores available). Finally, give a negative N to select (all - N) cores (or at least 1 if N equals or exceeds all). The parallel processing does not depend on OpenMP."
  },
  {
    "objectID": "documentation/modules/grdsample.html#grid-values-precision",
    "href": "documentation/modules/grdsample.html#grid-values-precision",
    "title": "grdsample",
    "section": "Grid Values Precision",
    "text": "Grid Values Precision\nRegardless of the precision of the input data, GMT programs that create grid files will internally hold the grids in 4-byte floating point arrays. This is done to conserve memory and furthermore most if not all real data can be stored using 4-byte floating point values. Data with higher precision (i.e., double precision values) will lose that precision once GMT operates on the grid or writes out new grids. To limit loss of precision when processing data you should always consider normalizing the data prior to processing."
  },
  {
    "objectID": "documentation/modules/grdsample.html#consequences-of-grid-resampling",
    "href": "documentation/modules/grdsample.html#consequences-of-grid-resampling",
    "title": "grdsample",
    "section": "Consequences of grid resampling",
    "text": "Consequences of grid resampling\nResample or sampling of grids will use various algorithms (see interp) that may lead to possible distortions or unexpected results in the resampled values. One expected effect of resampling with splines is the tendency for the new resampled values to slightly exceed the global min/max limits of the original grid. If this is unacceptable, you can impose clipping of the resampled values values so they do not exceed the input min/max values by adding +c to your interp option."
  },
  {
    "objectID": "documentation/modules/grdsample.html#hints",
    "href": "documentation/modules/grdsample.html#hints",
    "title": "grdsample",
    "section": "Hints",
    "text": "Hints\nIf an interpolation point is not on a node of the input grid, then a NaN at any node in the neighborhood surrounding the point will yield an interpolated NaN. Bicubic interpolation [default] yields continuous first derivatives but requires a neighborhood of 4 nodes by 4 nodes. Bilinear interpolation [interp] uses only a 2 by 2 neighborhood, but yields only zero-order continuity. Use bicubic when smoothness is important. Use bilinear to minimize the propagation of NaNs."
  },
  {
    "objectID": "documentation/modules/grdsample.html#notes",
    "href": "documentation/modules/grdsample.html#notes",
    "title": "grdsample",
    "section": "Notes",
    "text": "Notes\nAs an alternative to bicubic spline, linear spline or nearest neighbor interpolation one can instead send the entire dataset through surface for re-gridding. This approach allows more control on aspects such as tension but it also leads to a solution that is not likely to have fully converged. The general approach would be something like\ngrd2xyz old.grd | gmt surface -Rold.grd -Inewinc -Gnew.grd [other options]\nFor moderate data set one could also achieve an exact solution with greenspline, such as\ngrd2xyz old.grd | gmt greenspline -Rold.grd -Inewinc -Gnew.grd [other options]"
  },
  {
    "objectID": "documentation/modules/grdsample.html#examples",
    "href": "documentation/modules/grdsample.html#examples",
    "title": "grdsample",
    "section": "Examples",
    "text": "Examples\nTo resample a sub-region of the 5 x 5 minute remote grid earth_relief_05m onto a 1 minute grid::\nG = grdsample(\"@earth_relief_05m\", region=\"0/20/0/20\", inc=\"1m\");\nTo translate the gridline-registered remote grid earth_relief_05m to pixel registration while keeping the same region and grid interval::\nG = grdsample(\"@earth_relief_05m\", toggle=true);"
  },
  {
    "objectID": "documentation/modules/grdsample.html#source-code",
    "href": "documentation/modules/grdsample.html#source-code",
    "title": "grdsample",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdsample(cmd0::String; kwargs...) - grdsample.jl:30\ngrdsample(arg1; kwargs...) - grdsample.jl:31"
  },
  {
    "objectID": "documentation/modules/grdsample.html#see-also",
    "href": "documentation/modules/grdsample.html#see-also",
    "title": "grdsample",
    "section": "See Also",
    "text": "See Also"
  },
  {
    "objectID": "documentation/modules/grdredpol.html",
    "href": "documentation/modules/grdredpol.html",
    "title": "grdredpol",
    "section": "",
    "text": "Compute the Continuous Reduction To the Pole, AKA differential RTP.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/grdpmodeler.html",
    "href": "documentation/modules/grdpmodeler.html",
    "title": "grdpmodeler",
    "section": "",
    "text": "Evaluate a plate motion model on a geographic grid.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/grdmath.html",
    "href": "documentation/modules/grdmath.html",
    "title": "grdmath",
    "section": "",
    "text": "Reverse Polish Notation (RPN) calculator for grids (element by element)"
  },
  {
    "objectID": "documentation/modules/grdmath.html#description",
    "href": "documentation/modules/grdmath.html#description",
    "title": "grdmath",
    "section": "Description",
    "text": "Description\ngrdmath will perform operations like add, subtract, multiply, and hundreds of other operands on one or more grid files or constants using Reverse Polish Notation (RPN) syntax. Arbitrarily complicated expressions may therefore be evaluated; the final result is written to an output grid file. Grid operations are element-by-element, not matrix manipulations. Some operators only require one operand (see below). If no grid files are used in the expression then options |-R|, |-I| must be set. The expression = outgrid can occur as many times as the depth of the stack allows in order to save intermediate results. Complicated or frequently occurring expressions may be coded as a macro for future use or stored and recalled via named memory locations.\nOK, but RPN is quite painfull to master for other than simple expressions and for it the normal Julia operators are much easier to use. However, there are many operators that are handy and already programmed or even kind of unique like for example LDISTG that computes distances to coastlines. So, there is still interest in grdmath but due to its nature it was nor wrapped into a vebose version and for using it one must use the [Monolithic] mode.\nFor the full manual, consult the main GMT grdmath manual"
  },
  {
    "objectID": "documentation/modules/grdmath.html#examples",
    "href": "documentation/modules/grdmath.html#examples",
    "title": "grdmath",
    "section": "Examples",
    "text": "Examples\nTo compute all distances to north pole, try::\n    G = grdmath(\"-Rg -I1 0 90 SDIST =\")\nTo create a grid with resolution 0.5x0.5 degrees with distances in km from the coast line, use::\n    G = grdmath(\"-RNO,IS -Dc -I.5 LDISTG =\")"
  },
  {
    "objectID": "documentation/modules/grdmath.html#source-code",
    "href": "documentation/modules/grdmath.html#source-code",
    "title": "grdmath",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html",
    "href": "documentation/modules/grdlandmask.html",
    "title": "grdlandmask",
    "section": "",
    "text": "grdlandmask(area=??, resolution=??, border=??, save=??, maskvalues=??, registration=??, cores=??)\n\nor\n\n    grdlandmask(GI:GItype, ...)\nCreate a “wet-dry” mask grid from shoreline data base"
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#description",
    "href": "documentation/modules/grdlandmask.html#description",
    "title": "grdlandmask",
    "section": "Description",
    "text": "Description\nReads the selected shoreline database and uses that information to decide which nodes in the specified grid are over land or over water. The nodes defined by the selected region and lattice spacing will be set according to one of two criteria: (1) land vs water, or (2) the more detailed (hierarchical) ocean vs land vs lake vs island vs pond. The resulting mask may be used in subsequent operations involving grdmath to mask out data from land [or water] areas.\nThe second method expects a GMTgrid or an GMTimage as first argument and will clip this grid/image outside (the default) or inside the land areas. Grids are clipped according to the maskvalues set by that option and images are set to transparent in the regions outside (or inside) of the land areas. See also the mask module that has also a method with a similar behavior but uses polygons set via an input argument."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#required-arguments-1st-method",
    "href": "documentation/modules/grdlandmask.html#required-arguments-1st-method",
    "title": "grdlandmask",
    "section": "Required Arguments (1st method)",
    "text": "Required Arguments (1st method)\n\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#required-arguments-2nd-method",
    "href": "documentation/modules/grdlandmask.html#required-arguments-2nd-method",
    "title": "grdlandmask",
    "section": "Required Arguments (2nd method)",
    "text": "Required Arguments (2nd method)\n\nGI: A grid (GMTgrid) or image (GMTimage) to be clipped."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#optional-arguments",
    "href": "documentation/modules/grdlandmask.html#optional-arguments",
    "title": "grdlandmask",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\n-A or area : – area=(min_area[,min_level,max_level]), river_lake=true, lake=true, antarctica_ground=true, skip60S=true, skipN60S=true, percent=pct)\nFeatures with an area smaller than min_area in km^2 or of hierarchical level that is lower than min_level or higher than max_level will not be plotted [Default is 0/0/4 (all features)]. Level 2 (lakes) contains regular lakes and wide river bodies which we normally include as lakes; use river_lake=true to just get river-lakes or lake=true to just get regular lakes. By default we select the ice shelf boundary as the coastline for Antarctica; use antarctica_ground=true to instead select the ice grounding line as coastline. For expert users who wish to print their own Antarctica coastline and islands via plot you can use skip60S=true to skip all GSHHG features below 60S or skipN60S=true to instead skip all features north of 60S. Finally, append percent=pct to exclude polygons whose percentage area of the corresponding full-resolution feature is less than pct.\nD or res or resolution : – res=:full | res=:high | res=:auto\nSelects the resolution of the data set to use full, high, intermediate, low, and crude. The resolution drops off by 80% between data sets. Alternatively, chooses res=auto, to automatically select the best resolution given the chosen region. Note that because the coastlines differ in details a node in a mask file using one resolution is not guaranteed to remain inside [or outside] when a different resolution is selected.\nE or border or bordervalues : – border=true | border=bordervalues\nNodes that fall exactly on a polygon boundary should be considered to be outside the polygon [Default considers them to be inside]. Alternatively, append either the four values cborder/lborder/iborder/pborder or just the single value bordervalue (for the case when they should all be the same value). This turns on the line-tracking mode. Now, after setting the mask values specified via maskvalues we trace the lines and change the node values for all cells traversed by a line to the corresponding border value. Here, cborder is used for cells traversed by the coastline, lborder for cells traversed by a lake outline, iborder for islands-in-lakes outlines, and pborder for ponds-in-islands-in-lakes outlines [Default is no line tracing].\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nN or maskvalues : – maskvalues=(wet,dry) | maskvalues=(ocean,land,lake,island,pond)\nSets the values that will be assigned to nodes. Values can be any number, including NaN. Also select border to let nodes exactly on feature boundaries be considered outside [Default is inside]. Specify this information using 1 of 2 formats:\n\nmaskvalues=(wet,dry)\nmaskvalues=(ocean,land,lake,island,pond)\n\n[Default is (0,1,0,1,0) (i.e., 0,1)].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nx or cores : – cores=N\nLimit the number of cores used when making the individual frames. By default we try to use all available cores. Append N to only use n cores (if too large it will be truncated to the maximum cores available). Finally, give a negative N to select (all - N) cores (or at least 1 if N equals or exceeds all). The parallel processing does not depend on OpenMP."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#notes",
    "href": "documentation/modules/grdlandmask.html#notes",
    "title": "grdlandmask",
    "section": "Notes",
    "text": "Notes\nA grid produced by grdlandmask is a categorical dataset. As such, one has to be careful not to interpolate it with standard methods, such as splines. However, if you make a map of this grid using a map projection the grid will be reprojected to yield a rectangular matrix in the projected coordinates. This interpolation is done using splines by default and thus may yield artifacts in your map. We recommend you use grdimage interp=:n to instead use a nearest neighbor interpolation for such cases."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#global-landmask-grids",
    "href": "documentation/modules/grdlandmask.html#global-landmask-grids",
    "title": "grdlandmask",
    "section": "Global Landmask Grids",
    "text": "Global Landmask Grids\nBefore you make your own masks, be aware that the GMT data server offers global landmask files in multiple grid resolutions. These can be accessed using the remote file names @earth_mask_rru[_reg], where rru and the optional reg indicate the resolution and registration that you desire. See Global Earth Mask Grids for more information on the availability of resolutions."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#examples",
    "href": "documentation/modules/grdlandmask.html#examples",
    "title": "grdlandmask",
    "section": "Examples",
    "text": "Examples\nTo set all nodes on land to NaN, and nodes over water to 1, using the high resolution data set, do\n    G = grdlandmask(region=(-60,-40,-40,-30), res=:high, inc=\"5m\", maskvalues(1,NaN))\nTo make a 1x1 degree global grid with the hierarchical levels of the nodes based on the low resolution data:\nG = grdlandmask(region=:global360, res=:low, inc=1, maskvalues=(0,1,2,3,4))\nMask ocean areas to NaN from a relief grid.\n\nusing GMT\nG = grdcut(\"@earth_relief_04m\", region=(-10.5, -5, 35, 44));\nG = grdlandmask(G, maskvalues=(NaN,1))\nviz(G)"
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#gshhg-information",
    "href": "documentation/modules/grdlandmask.html#gshhg-information",
    "title": "grdlandmask",
    "section": "GSHHG Information",
    "text": "GSHHG Information\nThe coastline database is GSHHG (formerly GSHHS) which is compiled from three sources: World Vector Shorelines (WVS, not including Antarctica), CIA World Data Bank II (WDBII), and Atlas of the Cryosphere (AC, for Antarctica only). Apart from Antarctica, all level-1 polygons (ocean-land boundary) are derived from the more accurate WVS while all higher level polygons (level 2-4, representing land/lake, lake/island-in-lake, and island-in-lake/lake-in-island-in-lake boundaries) are taken from WDBII. The Antarctica coastlines come in two flavors: ice-front or grounding line, selectable via the area option. Much processing has taken place to convert WVS, WDBII, and AC data into usable form for GMT: assembling closed polygons from line segments, checking for duplicates, and correcting for crossings between polygons. The area of each polygon has been determined so that the user may choose not to draw features smaller than a minimum area (see area); one may also limit the highest hierarchical level of polygons to be included (4 is the maximum). The 4 lower-resolution databases were derived from the full resolution database using the Douglas-Peucker line-simplification algorithm. The classification of rivers and borders follow that of the WDBII. See The Global Self-consistent, Hierarchical, High-resolution Geography Database (GSHHG) for further details."
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#source-code",
    "href": "documentation/modules/grdlandmask.html#source-code",
    "title": "grdlandmask",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdlandmask(; kwargs...) - grdlandmask.jl:44\ngrdlandmask(cmd0::String; kwargs...) - grdlandmask.jl:42\ngrdlandmask(arg1::GItype; kwargs...) - grdlandmask.jl:43"
  },
  {
    "objectID": "documentation/modules/grdlandmask.html#see-also",
    "href": "documentation/modules/grdlandmask.html#see-also",
    "title": "grdlandmask",
    "section": "See Also",
    "text": "See Also\ngrdclip, mask, clip, coast"
  },
  {
    "objectID": "documentation/modules/grdimage.html",
    "href": "documentation/modules/grdimage.html",
    "title": "grdimage",
    "section": "",
    "text": "grdimage(cmd0::String=\"\"; kwargs...)\nProject grids or images and plot them on maps"
  },
  {
    "objectID": "documentation/modules/grdimage.html#description",
    "href": "documentation/modules/grdimage.html#description",
    "title": "grdimage",
    "section": "Description",
    "text": "Description\nReads one 2-D grid and produces a gray-shaded (or colored) map by plotting rectangles centered on each grid node and assigning them a gray-shade (or color) based on the z-value. Alternatively, grdimage reads three 2-D grid files with the red, green, and blue components directly (all must be in the 0-255 range). Optionally, illumination may be added by providing a file with intensities in the (-1,+1) range or instructions to derive intensities from the input data grid. Values outside this range will be clipped. Such intensity files can be created from the grid using grdgradient and, optionally, modified by grdhisteq. A third alternative is available when GMT is build with GDAL support. Pass img which can be an image file (geo-referenced or not). In this case the images can optionally be illuminated with the file provided via the shade option. Here, if image has no coordinates then those of the intensity file will be used.\nWhen using map projections, the grid is first resampled on a new rectangular grid with the same dimensions. Higher resolution images can be obtained by using the dpi option. To obtain the resampled value (and hence shade or color) of each map pixel, its location is inversely projected back onto the input grid after which a value is interpolated between the surrounding input grid values. By default bi-cubic interpolation is used. Aliasing is avoided by also forward projecting the input grid nodes. If two or more nodes are projected onto the same pixel, their average will dominate in the calculation of the pixel value. Interpolation and aliasing is controlled with the interp option.\nThe region option can be used to select a map region larger or smaller than that implied by the extent of the grid."
  },
  {
    "objectID": "documentation/modules/grdimage.html#required-arguments",
    "href": "documentation/modules/grdimage.html#required-arguments",
    "title": "grdimage",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)"
  },
  {
    "objectID": "documentation/modules/grdimage.html#optional-arguments",
    "href": "documentation/modules/grdimage.html#optional-arguments",
    "title": "grdimage",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or img_out or image_out : – img_out=fname\nSave an image in a raster format instead of PostScript. Use extension .ppm for a Portable Pixel Map format. For GDAL-aware versions there are more choices: Use fname to select the image file name and extension. If the extension is one of .bmp, .gif, .jpg, .png, or .tif then no driver information is required. For other output formats you must append the required GDAL driver. The driver is the driver code name used by GDAL; see your GDAL installation’s documentation for available drivers. Append a +c string where options is a list of one or more concatenated number of GDAL -co options. For example, to write a GeoPDF with the TerraGo format use “=PDF+cGEO_ENCODING=OGC_BP”. Notes: (1) If a tiff file (.tif) is selected then we will write a GeoTiff image if the GMT projection syntax translates into a PROJ4 syntax, otherwise a plain tiff file is produced. (2) Any vector elements will be lost.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap or colorap or colorscale : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name (for grd_z only). Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. In this case color1 etc can be a (r,g,b) triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ) (see [Setting color](../common_features/color.html)). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map.\nclim : – clim=(z_min,z_max) | clim=:zscale\nWhen doing an automatic colorization (i.e., when a colormap is not provided explicitly), limit the automatic color map to be computed between z_min,z_max. Grid values below z_min and above z_max will be painted with the same color as those. Alternatively, use clim=:zscale to use the Interval based on IRAF’s zscale that is an algorithm used in astronomy for finding colorbar limits of for the grid, which showcase data near the median.\nclip : – clip=“land” | clip=:ocean | clip=“country_code(s)” | clip=(country=“code(s)”, [outside=true]) | clip=xy | clip=(xy, inverse=true)\nClip the image according to the selected option. First set of options do the clipping using the coast module. e.,g.: clip=“land” (or =:land) clip outside land areas. clip=“ocean” does the inverse. clip=“country_code(s)” uses one or more country codes (separated by commas) to do the clipping. If want to reverse the sense of the clipping, use the form clip=(country=“code(s)”, outside=true). Use clip=(continent=code, [outside=true]) to pass the name of continent. Pay attention that this option must be a named tuple. The second set of options make use of the clip module and expect a first argument with a Mx2 matrix with the coordinates of the clipping polygon.\ncoast : – coast=true | coast=(…)\nCall the coast module to overlay coastlines and/or countries. The short form coast=true just plots the coastlines with a black, 0.5p thickness line. To access all options available in the coast module passe them in the named tuple (…).\ncolorbar : – colorbar=true | colorbar=(…)\nCall the colorbar module to add a colorbar. The short form colorbar=true automatically adds a color bar on the right side of the image using the current color map stored in the global scope. To access all options available in the colorbar module passe them in the named tuple (…).\nequalize : – equalize=true | equalize=ncolors\nWith automatic colorization, map data values to colors through the data’s cumulative distribution function (CDF), so that the colors are histogram equalized. Default (with equalize=true) chooses arbitrary values by a crazy scheme based on equidistant values for a Gaussian CDF. Use equalize=ncolors to specify the desire number of colors.\npercent : – percent=pct\nExclude the two tails of the distribution (in percentage). Grid values are sorted and we exclude data in 0.5pct and 100 - 0.5pct from the automatic colormap determination. This option is specially useful when the grid has outliers.\nD or img_in or image_in : – img_in=true | img_in=:r\nGMT will automatically detect standard image files (Geotiff, TIFF, JPG, PNG, GIF, etc.) and will read those via GDAL. For very obscure image formats you may need to explicitly set img_in, which specifies that the grid is in fact an image file to be read via GDAL. Use img_in=:r to assign the region specified by region to the image. For example, if you have used region=global then the image will be assigned a global domain. This mode allows you to project a raw image (an image without referencing coordinates).\nE or dpi : – dpi=xx | dpi=:i\nSets the resolution of the projected grid that will be created if a map projection other than Linear or Mercator was selected [100]. By default, the projected grid will be of the same size (rows and columns) as the input file. Specify dpi=:i to use the PostScript image operator to interpolate the image at the device resolution.\nG : – G=“+b” | G=“+f”\nThis option only applies when a resulting 1-bit image otherwise would consist of only two colors: black (0) and white (255). If so, this option will instead use the image as a transparent mask and paint the mask with the given color. Use G=“+b” to paint the background pixels (1) or G=“+f” for the foreground pixels [Default].\nI or shade or shading or intensity : – shade=grid | shade=azim | shade=(azimuth=az, norm=params, auto=true)\nGives the name of a grid with intensities in the (-1,+1) range, or a constant intensity to apply everywhere (affects the ambient light). Alternatively, derive an intensity grid from the input data grid grd_z via a call to grdgradient; use shade=az or shade=(azimuth=az, norm=params) to specify azimuth and intensity arguments for that module or just give shade=true to select the default arguments (azim=-45,norm=:t1). If you want a more specific intensity scenario then run grdgradient separately first.\nM or monochrome : – monochrome=true\nForce conversion to monochrome image using the (television) YIQ transformation. Cannot be used with nan_alpha.\nN or noclip : – noclip=true\nDo not clip the image at the map boundary (only relevant for non-rectangular maps).\nQ or nan_alpha or alpha_color : – nan_alpha=true or alpha_color=true|(r,g,b)\nMake grid nodes with z = NaN transparent. If input is an image alpha_color picks one color (default is black) and makes it transparent (requires GMT6.2 and above).\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/grdimage.html#examples",
    "href": "documentation/modules/grdimage.html#examples",
    "title": "grdimage",
    "section": "Examples",
    "text": "Examples\nTo make a map of a shaded global bathymetry (automatically download it if needed) using the Winkel projection, add coast lines, a colorbar and do an histogram equalization with 64 colors, do:\n\nusing GMT\ngrdimage(\"@earth_relief_20m_g\", proj=:Winkel, equalize=64, coast=true,\n         colorbar=true, shade=true, show=true)\n\n\n\n\n\n\n\n\nFor a quick-and-dirty illuminated color map of the data in the remote file @AK_gulf_grav.nc, try:\n\nusing GMT\ngrdimage(\"@AK_gulf_grav.nc\", shade=true, coast=true, show=true)\n\n\n\n\n\n\n\n\nClip the outside of Africa from Bing mosaic. (You can try also viz(I, clip=:land) and viz(I, clip=(continent=:AF, outside=true)))\n\nusing GMT\nI = mosaic(region=(continent=\"AF\",));   # Get a mosaic of the ~Africa region\nviz(I, clip=(continent=:AF,))           # Clip outside of the African continent."
  },
  {
    "objectID": "documentation/modules/grdimage.html#source-code",
    "href": "documentation/modules/grdimage.html#source-code",
    "title": "grdimage",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdimage(cmd0::String; ...) - grdimage.jl:43\ngrdimage(cmd0::String, arg1; ...) - grdimage.jl:43\ngrdimage(cmd0::String, arg1, arg2; ...) - grdimage.jl:43\ngrdimage(cmd0::String, arg1, arg2, arg3; first, kwargs...) - grdimage.jl:43\ngrdimage(; ...) - grdimage.jl:43\ngrdimage(arg1, arg2, arg3; kw...) - grdimage.jl:252\ngrdimage(arg1; ...) - grdimage.jl:252\ngrdimage(arg1, arg2; ...) - grdimage.jl:252"
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html",
    "href": "documentation/modules/grdgravmag3d.html",
    "title": "grdgravmag3d",
    "section": "",
    "text": "grdgravmag3d(cmd0::String=\"\", arg1=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#description",
    "href": "documentation/modules/grdgravmag3d.html#description",
    "title": "grdgravmag3d",
    "section": "Description",
    "text": "Description\nCompute the gravity or magnetic anomaly of a body described by one or (optionally) two grids. The output can either be along a given set of xy locations or on a grid. This method is not particularly fast but allows computing the anomaly of arbitrarily complex shapes."
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#required-arguments",
    "href": "documentation/modules/grdgravmag3d.html#required-arguments",
    "title": "grdgravmag3d",
    "section": "Required Arguments",
    "text": "Required Arguments\ngrd_top (and optionally grd_bot). Grid(s) whose gravity/mag effect is going to be computed. If two grids are provided then the gravity/magnetic effect of the volume between them is computed.\n\nC or density : – density=??\nSets body density in SI. Append either a constant, the name of a grid file or a GMTgrid grid with variable densities. This option is mutually exclusive with mag_params\nF or track : – track=xy_loc\nProvide xy_loc (file name or GMTdataset) locations where the anomaly will be computed. Note, this option is mutually exclusive with the save option.\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names."
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#optional-arguments",
    "href": "documentation/modules/grdgravmag3d.html#optional-arguments",
    "title": "grdgravmag3d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nE or thickness : – thickness=??\nTo provide the layer thickness in m [Default = 500 m].\nH or mag_params : – mag_params=f_dec/f_dip/m_int/m_dec/m_dip | mag_params=“magfile”|maggrid | mag_params=“x|X|y|Y|z|Z|h|H|t|T|f|F” | mag_params=“+i|+n”*\nSets parameters for computation of magnetic anomaly (Can be used multiple times).\n- *f_dec/f_dip* -&gt; geomagnetic declination/inclination\n\n- *m_int/m_dec/m_dip* -&gt; body magnetic intensity/declination/inclination\nOR for a grid mode\n- *maggrid*, a GMTgrid  grid, or *magfile*, where *magfile* is the name of the magnetic intensity file.\nTo compute a component, specify any of:\n- **x**|**X**|**e**|**E**  to compute the E-W component.\n\n- **y**|**Y**|**n**|**N**  to compute the N-S component.\n\n- **z**|**Z**      to compute the Vertical component.\n\n- **h**|**H**      to compute the Horizontal component.\n\n- **t**|**T**|**f**|**F**  to compute the total field.\nIf we want to compute the magnetic anomalies over a large region where the ambient magnetic field can no longer be assumed to be constant we can set variable inclinations and declinations via IGRF. Set any of mag_params=“+i|+n” to do that.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nL or level or reference_level : – z_obs=0\nSets level of observation [Default = 0]. That is the height (z) at which anomalies are computed.\nQ or pad : – pad=“nn_pad” | pad=“pad_dist”* | pad=“region”\nExtend the domain of computation with respect to output region region. - pad=“nn_pad” artificially extends the width of the outer rim of cells to have a fake width of n_pad * dx[/dy].\n- *pad=\"pad_dist\"* extend the region by west-pad, east+pad, etc.\n\n- *pad=\"west/east/south/north\"* Same syntax as **region**.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or radius : – radius=30\nSet search radius in km (valid only in the two grids mode OR when thickness) [Default = 30 km]. This option serves to speed up the computation by not computing the effect of prisms that are further away than radius from the current node.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or level or reference_level : – level=“b|t” | level=(bottom=true | top=true)\nlevel of reference plane [Default = 0]. Use this option when the triangles describe a non-closed surface and the volume is defined from each triangle and this reference level. An example will be the water depth to compute a Bouguer anomaly. Use level=:b or level=:t to close the body at its bottom (for example, to compute the effect of a dome) or at its top (to compute the effect of a spoon).\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nx or cores : – cores=N\nLimit the number of cores used when making the individual frames. By default we try to use all available cores. Append N to only use n cores (if too large it will be truncated to the maximum cores available). Finally, give a negative N to select (all - N) cores (or at least 1 if N equals or exceeds all). The parallel processing does not depend on OpenMP."
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#grid-distance-units",
    "href": "documentation/modules/grdgravmag3d.html#grid-distance-units",
    "title": "grdgravmag3d",
    "section": "Grid Distance Units",
    "text": "Grid Distance Units\nIf the grid does not have meter as the horizontal unit, append +u_unit_ to the input file name to convert from the specified unit to meter. If your grid is geographic, convert distances to meters by supplying f=:g instead."
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#examples",
    "href": "documentation/modules/grdgravmag3d.html#examples",
    "title": "grdgravmag3d",
    "section": "Examples",
    "text": "Examples\nTo compute the vertical component due to a magnetization stored in mag.grd over a zone defined by the surface bat.grd, using variable declination and inclination provided the IGRF and using 4 processors, do:\nG = grdgravmag3d(\"bat.grd\", thickness=10000, H=\"z -H+n -H+mmag.grd\", x=4, radius=50);\nSuppose you want to compute the gravity effect of the Gorringe bank.\n\nusing GMT\n\nG = grdgravmag3d(\"@earth_relief_10m\", region=(-12.5,-10,35.5,37.5),\n                 density=2700, inc=0.05, pad=0.5, level=:bottom, f=:g);\nviz(G, title=\"Gorringe FAA\", colorbar=true)\n\nThread 1     Row = 1     of = 018Thread 1    Row = 6     of = 018Thread 1    Row = 11    of = 018Thread 1    Row = 16    of = 018"
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#source-code",
    "href": "documentation/modules/grdgravmag3d.html#source-code",
    "title": "grdgravmag3d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdgravmag3d(cmd0::String; ...) - grdgravmag3d.jl:53\ngrdgravmag3d(; ...) - grdgravmag3d.jl:53\ngrdgravmag3d(cmd0::String, arg1, arg2; kwargs...) - grdgravmag3d.jl:53\ngrdgravmag3d(cmd0::String, arg1; ...) - grdgravmag3d.jl:53\ngrdgravmag3d(arg1, arg2; kw...) - grdgravmag3d.jl:52\ngrdgravmag3d(arg1; ...) - grdgravmag3d.jl:52"
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#see-also",
    "href": "documentation/modules/grdgravmag3d.html#see-also",
    "title": "grdgravmag3d",
    "section": "See Also",
    "text": "See Also\ngravmag3d, gravprism, talwani2d, talwani3d"
  },
  {
    "objectID": "documentation/modules/grdgravmag3d.html#reference",
    "href": "documentation/modules/grdgravmag3d.html#reference",
    "title": "grdgravmag3d",
    "section": "Reference",
    "text": "Reference\nOkabe, M., 1979, Analytical expressions for gravity anomalies due to polyhedral bodies and translation into magnetic anomalies, Geophysics, 44, 730-741."
  },
  {
    "objectID": "documentation/modules/grdflexure.html",
    "href": "documentation/modules/grdflexure.html",
    "title": "grdflexure",
    "section": "",
    "text": "Compute flexural deformation of 3-D surfaces for various rheologies.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/grdfill.html",
    "href": "documentation/modules/grdfill.html",
    "title": "grdfill",
    "section": "",
    "text": "grdfill(cmd0::String=\"\", arg1=nothing, kwargs...)\nInterpolate across holes in a grid."
  },
  {
    "objectID": "documentation/modules/grdfill.html#description",
    "href": "documentation/modules/grdfill.html#description",
    "title": "grdfill",
    "section": "Description",
    "text": "Description\nReads a grid that presumably has unfilled holes that the user wants to fill in some fashion. Holes are identified by NaN values but this criteria can be changed via nodata. There are several different algorithms that can be used to replace the hole values. Note: One of mode or list is required, and if no holes are found we output the original unchanged grid."
  },
  {
    "objectID": "documentation/modules/grdfill.html#required-arguments",
    "href": "documentation/modules/grdfill.html#required-arguments",
    "title": "grdfill",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe 2-D gridded data set."
  },
  {
    "objectID": "documentation/modules/grdfill.html#optional-arguments",
    "href": "documentation/modules/grdfill.html#optional-arguments",
    "title": "grdfill",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or mode : – mode=:c|:g|:n|:s[arg]\nSpecify the hole-filling algorithm to use. Choose among c for constant fill (and append the constant fill value), g to sample the (possibly coarser) grid arg at the nodes making up the holes, n for nearest neighbor (and optionally append a search radius in pixels [default radius is \\(r = \\sqrt{n^2 + m^2}\\), where (n,m) are the node dimensions of the grid]), or s for bicubic spline (optionally append a tension parameter [no tension]).\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nN or nodata or hole : – nodata=true | nodata=value\nSets the node value used to identify a point as a member of a hole [Default is NaN].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nL or list : – list=true | list=:p\nJust list the rectangular subregions west east south north of each hole. No grid fill takes place. Optionally, use list=:p to instead write closed polygons for all subregions.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at"
  },
  {
    "objectID": "documentation/modules/grdfill.html#geographical-and-time-coordinates",
    "href": "documentation/modules/grdfill.html#geographical-and-time-coordinates",
    "title": "grdfill",
    "section": "Geographical And Time Coordinates",
    "text": "Geographical And Time Coordinates\nWhen the output grid type is netCDF, the coordinates will be labeled “longitude”, “latitude”, or “time” based on the attributes of the input data or grid (if any) or on the colinfo or region options. For example, both colinfo=“0x” colinfo=“1t” and region=“90w/90e/0t/3t” will result in a longitude/time grid. When the x, y, or z coordinate is time, it will be stored in the grid as relative time since epoch as specified by TIME_UNIT and TIME_EPOCH in the gmt.conf file or on the command line. In addition, the unit attribute of the time variable will indicate both this unit and epoch."
  },
  {
    "objectID": "documentation/modules/grdfill.html#examples",
    "href": "documentation/modules/grdfill.html#examples",
    "title": "grdfill",
    "section": "Examples",
    "text": "Examples\nTo identify all regions with NaNs in the grid data.grd and create a listing of the bounding coordinates of rectangular regions that would cover these NaN areas, try:\n    D = grdfill(\"data.grd\", list=true)\nTo identify the same areas but this time write a multisegment file with polygons corresponding to the rectangular subregions, use:\n    D = grdfill(\"data.grd\", list=:p)\nTo replace all NaN values in the file data.grd with the value 999.0, use:\n    G = grdfill(\"data.grd\", mode=\"c999\")\nTo replace all NaN values in the file data.grd with the values at the nearest non-NaN neighbor, try:\n    G = grdfill(\"data.grd\", mode=:n)\nTo replace all NaN values in the file data.grd with a spline interpolation using a tension of 0.2, try:\n    G = grdfill(\"data.grd\", mode=\"s0.2\")\nTo replace all NaN values in the file data.grd by sampling another grid named background.grd, try:\n    G = grdfill(\"data.grd\", mode=\"gbackground.grd\")"
  },
  {
    "objectID": "documentation/modules/grdfill.html#source-code",
    "href": "documentation/modules/grdfill.html#source-code",
    "title": "grdfill",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdfill(cmd0::String; kwargs...) - grdfill.jl:31\ngrdfill(arg1; kwargs...) - grdfill.jl:32"
  },
  {
    "objectID": "documentation/modules/grdfill.html#see-also",
    "href": "documentation/modules/grdfill.html#see-also",
    "title": "grdfill",
    "section": "See Also",
    "text": "See Also\ngrdcut, grdclip, grdedit, grdinfo"
  },
  {
    "objectID": "documentation/modules/grdedit.html",
    "href": "documentation/modules/grdedit.html",
    "title": "grdedit",
    "section": "",
    "text": "grdedit(cmd0::String=\"\", arg1=nothing, kwargs...)\nModify header or content of a grid"
  },
  {
    "objectID": "documentation/modules/grdedit.html#description",
    "href": "documentation/modules/grdedit.html#description",
    "title": "grdedit",
    "section": "Description",
    "text": "Description\ngrdedit reads the header information in a binary 2-D grid file and replaces the information with values provided on the command line [if any]. As an option, global, geographical grids (with 360 degrees longitude range) can be rotated in the east-west direction, and individual nodal values can be replaced from a table of x, y, z values. grdedit only operates on files containing a grid header. Note: If it is important to retain the original data you should use outgrid to save the modified grid to a new file."
  },
  {
    "objectID": "documentation/modules/grdedit.html#required-arguments",
    "href": "documentation/modules/grdedit.html#required-arguments",
    "title": "grdedit",
    "section": "Required Arguments",
    "text": "Required Arguments\ningrid : – A grid file name or a GMTgrid"
  },
  {
    "objectID": "documentation/modules/grdedit.html#optional-arguments",
    "href": "documentation/modules/grdedit.html#optional-arguments",
    "title": "grdedit",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or adjust_inc : – adjust_inc=true\nIf necessary, adjust the file’s x_inc, y_inc to be compatible with its domain(or a new domain set with region). Older grid files (i.e., created prior to GMT 3.1) often had excessive slop in x_inc, y_inc and an adjustment is necessary. Newer files are created correctly.\nE or flip : – flip=:a|:e|:h|:l|:r|:t|:v\nTransform the grid in one of six ways and (for l|r|t) interchange the x and y information:\n\nflip=:a will flip the grid both horizontally and vertically,\nflip=:e will exchange the x (longitude) and y (latitude) dimensions,\nflip=:h will flip the grid horizontally (left-to-right),\nflip=:l will rotate the grid 90 degrees counter-clockwise (left),\nflip=:r will rotate the grid 90 degrees clockwise (right),\nflip=:t will transpose the grid [Default],\nflip=:v will flip the grid vertically (top-to-bottom). Incompatible with the other options (except outgrid).\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\n\nNormally, grdedit will overwrite the existing grid with the modified grid. Use this option to write the modified grid to the file outgrid instead.\n\nL or adjust_lon : – adjust_lon=true | adjust_lon=“+n|+p”\nAdjust the longitude values in the grid (only applies to geographic grids). By default we will try to adjust west and east so that west &gt;= -180 or east &lt;= +180, but this depends on the range of the longitudes. Use adjust_lon=“+n” to force negative longitude values and +p to force positive longitude values.\nN or replace : – replace=table | replace=“tablename”\nUse a Mx3 matrix with x,y,z values (or read them from file “tablename”) and replace the corresponding nodal values in the grid with these values.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or wrap : – wrap=true\nFor global, geographical grids only. Grid values will be shifted longitudinally according to the new borders given in region (if given, othersise use grid limits).\nT or toggle_reg or toggle : – toggle=true\nMake necessary changes in the header to convert a gridline-registered grid to a pixel-registered grid, or vice-versa. Basically, gridline-registered grids will have their domain extended by half the x- and y-increments whereas pixel-registered grids will have their domain shrunk by the same amount. This is a non-destructive grid change; see Switching registrations.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol"
  },
  {
    "objectID": "documentation/modules/grdedit.html#geographical-and-time-coordinates",
    "href": "documentation/modules/grdedit.html#geographical-and-time-coordinates",
    "title": "grdedit",
    "section": "Geographical And Time Coordinates",
    "text": "Geographical And Time Coordinates\nWhen the output grid type is netCDF, the coordinates will be labeled “longitude”, “latitude”, or “time” based on the attributes of the input data or grid (if any) or on the colinfo or region options. For example, both colinfo=“0x” colinfo=“1t” and region=“90w/90e/0t/3t” will result in a longitude/time grid. When the x, y, or z coordinate is time, it will be stored in the grid as relative time since epoch as specified by TIME_UNIT and TIME_EPOCH in the gmt.conf file or on the command line. In addition, the unit attribute of the time variable will indicate both this unit and epoch."
  },
  {
    "objectID": "documentation/modules/grdedit.html#examples",
    "href": "documentation/modules/grdedit.html#examples",
    "title": "grdedit",
    "section": "Examples",
    "text": "Examples\nLet us assume the file data.nc covers the area 300/310/10/30. We want to change the boundaries from geodetic longitudes to geographic and put a new title in the header. We accomplish this by:\ngrdedit(\"data.nc\", region=(-60,-50,10,30), D=\"+t\\\"Gravity Anomalies\\\"\")\nThe grid world.nc has the limits 0/360/-72/72. To shift the data so that the limits would be -180/180/-72/72, use:\ngrdedit world.nc -R-180/180/-72/72 -S\nThe file junk.nc was created prior to GMT 3.1 with incompatible region and increment arguments. To reset the x- and y-increments we run:\ngrdedit(\"junk.nc\", adjust_inc=true)\nThe file junk.nc was created prior to GMT 4.1.3 and does not contain the required information to indicate that the grid is geographic. To add this information, run:\ngrdedit(\"junk.nc\", colinfo=:g)\nTo rotate the grid oblique.nc 90 degrees counter-clockwise and write out the rotated grid to a new file, run::\ngmt grdedit oblique.nc -El -Goblique_rot.nc\nTo ensure that the grid depths.nc only has positive longitude values, run::\ngmt grdedit depths.nc -L+p\nThe grid bad.nc has latitude as x-coordinates an longitude as y-coordinates. We can exchange the two dimension by running::\ngmt grdedit bad.nc -Ee -Gnew.nc"
  },
  {
    "objectID": "documentation/modules/grdedit.html#notes",
    "href": "documentation/modules/grdedit.html#notes",
    "title": "grdedit",
    "section": "Notes",
    "text": "Notes\nThis module is not a general editor for netCDF files. If your netCDF file contains more than one 2-D (or higher dimension) data layer, then only the selected layer will be written out if changes are requested. Likewise, if you have additional netCDF attributes then those will also be lost in any revised output."
  },
  {
    "objectID": "documentation/modules/grdedit.html#source-code",
    "href": "documentation/modules/grdedit.html#source-code",
    "title": "grdedit",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdedit(cmd0::String; kwargs...) - grdedit.jl:51\ngrdedit(arg1; kwargs...) - grdedit.jl:52"
  },
  {
    "objectID": "documentation/modules/grdedit.html#see-also",
    "href": "documentation/modules/grdedit.html#see-also",
    "title": "grdedit",
    "section": "See Also",
    "text": "See Also\n:doc:grd2xyz, :doc:grdfill, :doc:grdinfo, :doc:xyz2grd"
  },
  {
    "objectID": "documentation/modules/grdcontour.html",
    "href": "documentation/modules/grdcontour.html",
    "title": "grdcontour",
    "section": "",
    "text": "grdcontour(cmd0::String=\"\", arg1=nothing; kwargs...)\nMake contour plot or map (using a projection) from a grid.\nRead a 2-D grid and produces a contour plot by tracing each contour through the grid. Various options that affect the plotting are available. Alternatively, the x, y, z positions of the contour lines may be saved to one or more output files (or memory) and no plot is produced."
  },
  {
    "objectID": "documentation/modules/grdcontour.html#required-arguments",
    "href": "documentation/modules/grdcontour.html#required-arguments",
    "title": "grdcontour",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe 2-D gridded data set to be contoured."
  },
  {
    "objectID": "documentation/modules/grdcontour.html#optional-arguments",
    "href": "documentation/modules/grdcontour.html#optional-arguments",
    "title": "grdcontour",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or annot or annotation : – annot=annot_int | annot=(int=annot_int, disable=true, single=true, labels=labelinfo)\nannot_int is annotation interval in data units; it is ignored if contour levels are given in a file. [Default is no annotations]. Use annot=(disable=true,) to disable all annotations implied by cont. Alternatively do annot=(single=true, int=val) to plot val as a single contour. The optional labelinfo controls the specifics of the label formatting and consists of a named tuple with the following control arguments [Label formatting]\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or cont or contours or levels : – cont=cont_int\nThe contours to be drawn may be specified in one of four possible ways:\n\nIf cont_int has the suffix “.cpt” and can be opened as a file, it is assumed to be a CPT. The color boundaries are then used as contour levels. If the CPT has annotation flags in the last column then those contours will be annotated. By default all contours are labeled; use annot=(disable=true,)) (or annot=:none) to disable all annotations.\nIf cont_int is a file but not a CPT, it is expected to contain contour levels in column 1 and a C(ontour) OR A(nnotate) in col 2. The levels marked C (or c) are contoured, while the levels marked A (or a) are contoured and annotated. If the annotation angle is present we will plot the label at that fixed angle [aligned with the contour]. Finally, a contour- specific pen may be present and will override the pen set by pen for this contour level only. Note: Please specify pen in proper format so it can be distinguished from a plain number like angle. If only cont-level columns are present then we set type to C\nIf cont_int is a constant or an array it means plot those contour intervals. This works also to draw single contours. E.g. contour=[0] will draw only the zero contour. The annot option offers the same list choice so they may be used together to plot a single annotated contour and another single non-annotated contour, as in anot=[10], cont=[5] that plots an annotated 10 contour and an non-annotated 5 contour. If annot is set and cont is not, then the contour interval is set equal to the specified annotation interval.\nIf no argument is given in modern mode then we select the current CPT.\nOtherwise, cont_int is interpreted as a constant contour interval.\n\nIf a file is given and ticks is set, then only contours marked with upper case C or A will have tick-marks. In all cases the contour values have the same units as the grid. Finally, if neither cont nor annot are set then we auto-compute suitable contour and annotation intervals from the data range, yielding 10-20 contours.\nD or dump : – dump=fname\nDump contours as data line segments; no plotting takes place. Append filename template which may contain C-format specifiers. If no filename template is given we write all lines to stdout. If filename has no specifiers then we write all lines to a single file. If a float format (e.g., %6.2f) is found we substitute the contour z-value. If an integer format (e.g., %06d) is found we substitute a running segment count. If an char format (%c) is found we substitute C or O for closed and open contours. The 1-3 specifiers may be combined and appear in any order to produce the the desired number of output files (e.g., just %c gives two files, just %f would separate segments into one file per contour level, and %d would write all segments to individual files; see manual page for more examples.\n-F or force : – force=true | force=:left | force=:right\nForce dumped contours to be oriented so that higher z-values are to the left (force=:left) or right (force=:right) as we move along the contour [Default is arbitrary orientation]. Requires dump.\nG or labels : – labels=()\nThe required argument controls the placement of labels along the quoted lines. Choose among five controlling algorithms as explained in [Placement methods]\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or range : – range=(low,high) | range=:n|:p|:N|:P\nLimit range: Do not draw contours for data values below low or above high. Alternatively, limit contours to negative (range=:n) or positive (range=:p) contours. Use upper case N or P to include the zero contour.\nN or fill : – fill=color\nFill the area between contours using the discrete color table given by color, a [Setting color] element. Then, cont and annot can be used as well to control the contour lines and annotations. If no color is set (fill=[]) then a discrete color setting must be given via cont instead.\nQ or cut : – cut=np | cut=length&unit[+z]\nDo not draw contours with less than np number of points [Draw all contours]. Alternatively, give instead a minimum contour length in distance units, including c (Cartesian distances using user coordinates) or C for plot length units in current plot units after projecting the coordinates. Optionally, append +z to exclude the zero contour.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or smooth : – smooth=smoothfactor\nUsed to resample the contour lines at roughly every (gridbox_size/smoothfactor) interval.\nT or ticks : – ticks=(local_high=true, local_low=true, gap=gap, closed=true, labels=labels)\nWill draw tick marks pointing in the downward direction every gap along the innermost closed contours only; set closed=true to tick all closed contours. Use gap=(gap,length) and optionally tick mark length (append units as c, i, or p) or use defaults [“15p/3p”]. User may choose to tick only local highs or local lows by specifying local_high=true, local_low=true, respectively. Set labels to annotate the centers of closed innermost contours (i.e., the local lows and highs). If no labels (i.e, set labels=““) is set, we use - and + as the labels. Appending exactly two characters, e.g., labels=:LH, will plot the two characters (here, L and H) as labels. For more elaborate labels, separate the low and hight label strings with a comma (e.g., labels=“lo,hi”). If a file is given by cont, and ticks is set, then only contours marked with upper case C or A will have tick marks [and annotations]. Note: The labeling of local highs and lows may plot sometimes outside the innermost contour since only the mean value of the ontour coordinates is used to position the label.\nW or pen : – pen=(annot=true, contour=true, pen=pen, colored=true, cline=true, ctext=true)\nannot=true if present, means to annotate contours or contour=true for regular contours [Default]. The pen sets the attributes for the particular line. Default pen for annotated contours: pen=(0.75,:black). Regular contours use pen=(0.25,:black). Normally, all contours are drawn with a fixed color determined by the pen setting. This option may be repeated, for example to separate contour and annotated contours settings. For that the syntax changes to use a Tuple of NamedTuples, e.g. pen=((annot=true, contour=true, pen=pen), (annot=true, contour=true, pen=pen)). If the modifier pen=(cline=true,) is used then the color of the contour lines are taken from the CPT (see cont). If instead pen=(ctext=true,) is appended then the color from the cpt file is applied to the contour annotations. Select pen=(colored=true,) for both effects.\nZ or muladd or scale : – scale=factor | muladd=(factor=factor, shift=shift, periodic=true)\nUse to subtract shift from the data and multiply the results by factor before contouring starts. (Numbers in annot, cont, range refer to values after this scaling has occurred.) Use periodic=true to indicate that this grid file contains z-values that are periodic in 360 degrees (e.g., phase data, angular distributions) and that special precautions must be taken when determining 0-contours.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/grdcontour.html#examples",
    "href": "documentation/modules/grdcontour.html#examples",
    "title": "grdcontour",
    "section": "Examples",
    "text": "Examples\nContour the peaks function. cont=1 and annot=2 means draw contours at every 1 unit of the G grid and annotate at every other contour line:\n\nusing GMT\nG = GMT.peaks();\ngrdcontour(G, cont=1, annot=2, show=true)\n\n\n\n\n\n\n\n\nFor a more elaborated example see [Contours]"
  },
  {
    "objectID": "documentation/modules/grdcontour.html#see-also",
    "href": "documentation/modules/grdcontour.html#see-also",
    "title": "grdcontour",
    "section": "See also",
    "text": "See also\nThe GMT man page"
  },
  {
    "objectID": "documentation/modules/grdcontour.html#source-code",
    "href": "documentation/modules/grdcontour.html#source-code",
    "title": "grdcontour",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdcontour(cmd0::String; kw...) - grdcontour.jl:66\ngrdcontour(arg1; kw...) - grdcontour.jl:67"
  },
  {
    "objectID": "documentation/modules/grd2xyz.html",
    "href": "documentation/modules/grd2xyz.html",
    "title": "grd2xyz",
    "section": "",
    "text": "grd2xyz(cmd0::String=\"\", arg1=nothing, kwargs...)\nConvert grid to data table"
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#description",
    "href": "documentation/modules/grd2xyz.html#description",
    "title": "grd2xyz",
    "section": "Description",
    "text": "Description\nReads a grid (from file or a Grid type object) and writes out xyz-triplets in ASCII [or binary] format to file or return them as a Julia variable. Modify the precision of the ASCII output format by editing the FORMAT_FLOAT_OUT parameter in your gmt.conf file or use par=(FORMAT_FLOAT_OUT=format,) or choose binary output using single or double precision storage. As an option you may output z-values without the (x,y) coordinates (see onecol below) or you can save the grid in the STL format for 3-D printers."
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#required-arguments",
    "href": "documentation/modules/grd2xyz.html#required-arguments",
    "title": "grd2xyz",
    "section": "Required Arguments",
    "text": "Required Arguments\ningrid : – A grid file name or a GMTgrid"
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#optional-arguments",
    "href": "documentation/modules/grd2xyz.html#optional-arguments",
    "title": "grd2xyz",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or rowcol or row_col : – rowcol=true | rowcol=:f|:i\nReplace the x- and y-coordinates on output with the corresponding column and row numbers. These start at 0 (C-style counting); use rowcol=:f to start at 1 (Fortran-style counting). Alternatively, use rowcol=:i to write just the two columns index and z, where index is the 1-D indexing that GMT uses when referring to grid nodes.\nL or hvline : – hvline=:c|:r|:x|:yvalue\nLimit the output of records to a single row or column. Identify the desired vector either by row or column number (via directives :c or :r), or by the constant x or y value (via directives :x or :y). If your selection is outside the valid range then no output will result and a warning is issued. Note: For directives :x and :y we find the nearest column or row, respectively.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or stl or STL : – STL=true | STL=[:b][base]\nWrite STL triangulation for 3-D printing to standard output. By default we write an STL ASCII file. Append b to instead write the STL binary (little-endian) format. For more information on STL, see the STL overview on Wikipedia. Note: All coordinates are adjusted so that xmin = ymin = zmin = 0. For other adjustments, see grdedit and grdproject Optionally, append a lower base other than the grid’s minimum value [Default]. Note: The grid must be free of NaN values. If your grid contains NaNs then we automatically replace these with the minimum value in the grid.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weight : – weight=true | weight=:a[+uunit] | weight=weight\nWrite out x,y,z,w, where w is the supplied weight (or 1 if not supplied) [Default writes x,y,z only]. Choose weight=:a to compute weights equal to the area each node represents. For Cartesian grids this is simply the product of the x and y increments (except for gridline-registered grids at all sides [half] and corners [quarter]). For geographic grids we default to a length unit of k (hence area is in km^2). Change this by appending +uunit (see [Units]). For such grids, the area varies with latitude and also sees special cases for gridline-registered layouts at sides, corners, and poles.\nZ or onecol or one_col : – onecol=“flags”\nWrite (or return) a 1-column table. Output will be organized according to the specified ordering convention contained in flags. If data should be written by rows, make flags start with T (op) if first row is y = ymax or B (ottom) if first row is y = ymin. Then, append L or R to indicate that first element should start at left or right end of row. Likewise for column formats: start with L or R to position first column, and then append T or B to position first element in a row. For gridline registered grids: If grid is periodic in x but the written data should not contain the (redundant) column at x = xmax, append x. For grid periodic in y, skip writing the redundant row at y = ymax by appending y. If the byte-order needs to be swapped, append w. Select one of several data types (all binary except a):\n\na ASCII representation of a single item per record\nc int8_t, signed 1-byte character\nu uint8_t, unsigned 1-byte character\nh int16_t, short 2-byte integer\nH uint16_t, unsigned short 2-byte integer\ni int32_t, 4-byte integer\nI uint32_t, unsigned 4-byte integer\nl int64_t, long (8-byte) integer\nL uint64_t, unsigned long (8-byte) integer\nf 4-byte floating point single precision\nd 8-byte floating point double precision\n\nDefault format is scanline orientation of ASCII numbers: onecol=:TLa.\nNOTE, to write on a disk file one must use the save=“file” option, otherwise data is return to Julia and the type options above are ignored. In that case, data is always Float64.\nname or save : – save=“file”\nSave data to disk file with save=“file”.\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#non-equidistant-xy-coordinates",
    "href": "documentation/modules/grd2xyz.html#non-equidistant-xy-coordinates",
    "title": "grd2xyz",
    "section": "Non-equidistant x/y Coordinates",
    "text": "Non-equidistant x/y Coordinates\nIn general, GMT modules cannot accept grids with variable x and/or y coordinates as most algorithms and plotting options expect equidistant grids. However, you can use grd2xyz to dump the original x y z triplets and then reprocess the data onto an equidistant lattice via greenspline, nearneighbor or surface, for instance."
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#time-coordinates",
    "href": "documentation/modules/grd2xyz.html#time-coordinates",
    "title": "grd2xyz",
    "section": "Time Coordinates",
    "text": "Time Coordinates\nTime coordinates in netCDF grids, be it the x, y, or z coordinate, will be recognized as such. The variable’s unit attribute is parsed to determine the unit and epoch of the time coordinate in the grid. Values are then converted to the internal time system specified by TIME_UNIT and TIME_EPOCH in the gmt.conf file or on the command line. The default output is relative time in that time system, or absolute time when using the option colinfo=“0T”, colinfo=“1T”, or colinfo=“2T” for x, y, or z coordinate, respectively."
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#row-order",
    "href": "documentation/modules/grd2xyz.html#row-order",
    "title": "grd2xyz",
    "section": "Row Order",
    "text": "Row Order\nThe hvline=:r option allows you to output a specific row in the grid. Note that while a grid’s y-coordinates are positive up, internal row numbers are scanline numbers and hence positive down. Therefore, the first row (0) coincides with the largest y-value. This means that hvline=:r0 and hvline=:y (for the correct maximum y-value) will yield the same result. In contrast, both x and column numbers are positive to the right, with hvline=:c0 and hvline=:x (for the correct minimum x-value) yielding the same output."
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#examples",
    "href": "documentation/modules/grd2xyz.html#examples",
    "title": "grd2xyz",
    "section": "Examples",
    "text": "Examples\nTo edit individual values in the 2’ by 2’ remote AFR.nc file, dump the .nc to GMTdataset. That is, return data in a Julia variable, do\n    D = grd2xyz(\"@AFR.nc\")\nTo write a single precision binary file without the x,y positions from the remote file @AFR.nc file, using scanline orientation, run:\n    grd2xyz(\"@AFR.nc\", onecol=:TLf, save=\"AFR.b\")\nTo write out lon, lat, topo, area from the @AFR.nc file, selecting meter^2 as the area unit, and where area reflects the size of each grid box, run:\n    grd2xyz(\"@AFR.nc\", weight=\"a+ue\", save=\"AFR.txt\")"
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#source-code",
    "href": "documentation/modules/grd2xyz.html#source-code",
    "title": "grd2xyz",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrd2xyz(cmd0::String; kwargs...) - grd2xyz.jl:39\ngrd2xyz(arg1; kwargs...) - grd2xyz.jl:40"
  },
  {
    "objectID": "documentation/modules/grd2xyz.html#see-also",
    "href": "documentation/modules/grd2xyz.html#see-also",
    "title": "grd2xyz",
    "section": "See Also",
    "text": "See Also\ngrdedit, grdconvert, xyz2grd"
  },
  {
    "objectID": "documentation/modules/grd2cpt.html",
    "href": "documentation/modules/grd2cpt.html",
    "title": "grd2cpt",
    "section": "",
    "text": "grd2cpt(cmd0::String=\"\", arg1=nothing, kwargs...)\nMake linear or histogram-equalized color palette table from grid"
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#description",
    "href": "documentation/modules/grd2cpt.html#description",
    "title": "grd2cpt",
    "section": "Description",
    "text": "Description\ngrd2cpt reads one or more grid and computes a static color palette (CPT). Once computed the color palette stays as the current CPT until an image using it is finished, either with the show command or saved to file. The CPT is based on an existing dynamic master CPT of your choice, and the mapping from data value to colors is through the data’s cumulative distribution function (CDF), so that the colors are histogram equalized. Thus if the grid(s) and the resulting CPT are used in grdimage with a linear projection, the colors will be uniformly distributed in area on the plot. Let z be the data values in the grid. Define CDF(Z) = (# of z &lt; Z) / (# of z in grid). (NaNs are ignored). These z-values are then normalized to the master CPT and colors are sampled at the desired intervals.\nThe color palette includes three additional colors beyond the range of z-values. These are the background color (B) assigned to values lower than the lowest z-value, the foreground color (F) assigned to values higher than the highest z-value, and the NaN color (N) painted wherever values are undefined. For color tables beyond the current GMT offerings, visit cpt-city.\nIf the master CPT includes B, F, and N entries, these will be copied into the new master file. If not, the parameters COLOR_BACKGROUND, COLOR_FOREGROUND, and COLOR_NAN from the gmt.conf file or the command line will be used. This default behavior can be overruled using the options bg, overrule_bg or no_bg.\nThe color model (RGB, HSV or CMYK) of the palette created by makecpt will be the same as specified in the header of the master CPT. When there is no COLOR_MODEL entry in the master CPT, the COLOR_MODEL specified in the gmt.conf (see gmtset) file or on the command line will be used."
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#required-arguments",
    "href": "documentation/modules/grd2cpt.html#required-arguments",
    "title": "grd2cpt",
    "section": "Required Arguments",
    "text": "Required Arguments\ningrid : – A grid file name or a GMTgrid"
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#optional-arguments",
    "href": "documentation/modules/grd2cpt.html#optional-arguments",
    "title": "grd2cpt",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or alpha or transparency : – alpha=xx | alpha=“xx+a”\nSets a constant level of transparency (0-100) for all color slices. Append +a to also affect the fore-, back-, and nan-colors.\nC or color or cmap or colormap or colorscale : – cmap=[[section/]master_cpt[+h[hinge]][+u|+Uunit]|local_cpt|color1,color2[,color3,…]]\nName of an input CPT file. Generally, the input is one of the GMT master_cpt files (see Of Colors and Color Legends) and can be either addressed by master_cpt or section/master_cpt (without the .cpt extension). If given a master CPT with soft-hinges then you can enable the hinge at data value hinge via +h, whereas for hard-hinge CPTs you can adjust the location of the hinge. For any other master_cpt, you may convert their z-values from meter to another distance unit (append +Uunit) or from another unit to meter (append +uunit), with unit taken from e|f|k|M|n|u. One can also supply the file name of already custom made local_cpt file. Alternatively, give color1,color2[,color3,…] to build a linear continuous CPT from those colors automatically, where z starts at 0 and is incremented by one for each color. In this case colorn can be a r/g/b triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc). See also [Setting color](../common_features/color.html)\nD or bg or background : – bg=true | bg=:i\nSelect the back- and foreground colors to match the colors for lowest and highest z-values in the output CPT [Default uses the colors specified in the master file, or those defined by the parameters COLOR_BACKGROUND, COLOR_FOREGROUND, and COLOR_NAN]. Append i to match the colors for the lowest and highest values in the input (instead of the output) CPT.\nE or nlevels : – nlevels=true | nlevels=nlevels|“+c[+f]”\nCreate a linear color table by using the grid z-range as the new limits in the CPT, so the number of levels in the CPT remain unchanged. Alternatively, append nlevels and we will instead resample the color table into nlevels equidistant slices. As an option, append +c to estimate the cumulative density function of the data and assign color levels accordingly. If +c is used then you may optionally append +f to save the CDF to file, or just use +c+f to return also a table with the CDF.\nF or color_model : – color_model=true|:r|:h|:c[“+c”[label]]\nForce output CPT to be written with r/g/b codes, gray-scale values or color name (the default) or r/g/b codes only (r), or h-s-v codes (h), or c/m/y/k codes (c). Optionally or alternatively, append +c to write discrete palettes in categorical format. If label is appended then we create labels for each category to be used when the CPT is plotted. The label may be a comma-separated list of category names (you can skip a category by not giving a name), or give start[-], where we automatically build monotonically increasing labels from start (a single letter or an integer). Append - to build ranges start-start+1 instead. Note: If +cM is given and the number of categories is 12, then we automatically create a list of month names. Likewise, if +cD is given and the number of categories is 7 then we make a list of weekday names. The format of these labels will depend on the FORMAT_TIME_PRIMARY_MAP, GMT_LANGUAGE and possibly TIME_WEEK_START settings.\nG or truncate : – truncate=(zlo,zhi)\nTruncate the incoming CPT so that the lowest and highest z-levels are to zlo and zhi. If one of these equal NaN then we leave that end of the CPT alone. The truncation takes place before any resampling. See also Manipulating CPTs\nI or inverse or reverse : – inverse=true | inverse=:z\nReverse the sense of color progression in the master CPT. Also exchanges the foreground and background colors, including those specified by the parameters COLOR_BACKGROUND and COLOR_FOREGROUND. Use inverse=:z to reverse the sign of z-values in the color table. Note that this change of z-direction happens before truncate and range values are used so the latter much be compatible with the changed z-range. See also Manipulating CPTs\nL or datarange or clim : – datarange=(minlimit, maxlimit)\nLimit range of CPT to (minlimit, maxlimit), and don’t count data outside this range when estimating CDF(Z). To set only one limit, specify the other limit as “-” [Default uses min and max of data.]\nM or overrule_bg : – overrule_bg=true\nOverrule background, foreground, and NaN colors specified in the master CPT with the values of the parameters COLOR_BACKGROUND, COLOR_FOREGROUND, and COLOR_NAN specified in the gmt.conf file or on the command line. When combined with bg, only COLOR_NAN is considered.\nN or no_bg or nobg : – no_bg=true\nMake all the background, foreground, and NaN-color fields be white (since we can’t remove them like in plain GMT).\nQ or log : – log=true | log=:i|:o\nSelects a logarithmic interpolation scheme [Default is linear]. log=:i expects input z-values to be log10(z), assigns colors, and writes out z [Default]. log=:o takes log10(z) first, assigns colors, and writes out z.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or symmetric : – symmetric=:h|l|m|u\nForce the color table to be symmetric about zero (from -R to +R). Append flag to set the range R: l for R =|zmin|, u for R = |zmax|, m for R = min(|zmin|, |zmax|), or h for R = max(|zmin|, |zmax|).\nT or range : – range=(min,max,inc) | range=n\nSet steps in CPT. Calculate entries in CPT from start to stop in steps of (inc). Default chooses arbitrary values by a crazy scheme based on equidistant values for a Gaussian CDF. Use range=n to select n points from such a cumulative normal distribution [11].\nV Verbose operation. This will write CDF(Z) estimates to stderr. [Default is silent.]\nW or categorical : – categorical=true | categorical=:w\nDo not interpolate the input color table but pick the output colors starting at the beginning of the color table, until colors for all intervals are assigned. This is particularly useful in combination with a categorical color table, like “categorical”. Alternatively, use categorical=:w to produce a wrapped (cyclic) color table that endlessly repeats its range.\nZ or continuous : – continuous=true\nForce a continuous CPT [Default is discontinuous].\nname or save : – save=“name.cpt”\nSave the color map with the save=“name.cpt”. When in modern mode this also automatically sets a required GMT option (-H).\n\n{{&lt; include ../common_opts/opt_bo.md &gt;}} This option only applies if nlevels selects CDF output.\n\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at"
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#notes-on-transparency",
    "href": "documentation/modules/grd2cpt.html#notes-on-transparency",
    "title": "grd2cpt",
    "section": "Notes on Transparency",
    "text": "Notes on Transparency\nThe PostScript language originally had no accommodation for transparency. However, Adobe added an extension that allows developers to encode some forms of transparency using the PostScript language model but it is only realized when converting the PostScript to PDF (and via PDF to any raster image format). GMT uses this model but there are some limitations: Transparency can only be controlled on a per-object or per-layer basis. This means that a color specifications (such as those in CPTs of given via command-line options) only apply to vector graphic items (i.e., text, lines, polygon fills) or to an entire layer (which could include items such as PostScript images). This limitation rules out any mechanism of controlling transparency in such images on a pixel level."
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#color-hinges",
    "href": "documentation/modules/grd2cpt.html#color-hinges",
    "title": "grd2cpt",
    "section": "Color Hinges",
    "text": "Color Hinges\nSome of the GMT master dynamic CPTs are actually two separate CPTs meeting at a hinge. Usually, colors may change dramatically across the hinge, which is used to separate two different domains (e.g., land and ocean across the shoreline, for instance). CPTs with a hinge will have their two parts stretched to the required range separately, i.e., the bottom part up to the hinge will be stretched independently of the part from the hinge to the top, according to the prescribed new range. Hinges are either hard or soft. Soft hinges must be activated by appending +h[hinge] to the CPT name. If the selected range does not include an activated soft or hard hinge then we only resample colors from the half of the CPT that pertains to the range. See Of Colors and Color Legends for more information."
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#discrete-versus-continuous-cpt",
    "href": "documentation/modules/grd2cpt.html#discrete-versus-continuous-cpt",
    "title": "grd2cpt",
    "section": "Discrete versus Continuous CPT",
    "text": "Discrete versus Continuous CPT\nAll CPTs can be stretched, but only continuous CPTs can be sampled at new nodes (i.e., by given an increment in range). We impose this limitation to avoid aliasing the original CPT."
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#examples",
    "href": "documentation/modules/grd2cpt.html#examples",
    "title": "grd2cpt",
    "section": "Examples",
    "text": "Examples\nTo get a reasonable and symmetrical color table for the data in the region 0/60/0/60 from the remote 5m relief file, using the geo color table, try:\n\nusing GMT\ngrd2cpt(\"@earth_relief_06m_g\", region=(0,60,0,60), cmap=:geo, symetric=:u)\nimshow(\"@earth_relief_06m_g\", region=(0,60,0,60), coast=true)\n\n\n\n\n\n\n\n\nSometimes you don’t want to make a CPT (yet) but would find it helpful to know that 90% of your data lie between z1 and z2, something you cannot learn from grdinfo. So you can do this to see some points on the CDF(Z) curve (use verbose=true option to see more):\n    grd2cpt(\"mydata.nc\", verbose=true)\nTo make a CPT with entries from 0 to 200 in steps of 20, and ignore data below zero in computing CDF(Z), and use the built-in master cpt file relief, run\n    C = grd2cpt(\"mydata.nc\", cmap=:relief, datarange=(0,10000), range=(0,200,20))\nTo determine the empirical cumulative density function of a grid and create a CPT that would give equal area to each color in the image, and return the CDF table as well, try:\n\nusing GMT\nC, cdf = grd2cpt(\"@earth_relief_10m_g\", nlevels=\"11+c+f\");\nimshow(\"@earth_relief_10m_g\", cmap=C)\n\n\n\n\n\n\n\n\nHere, cdf would be the cumulative hypsometric curve for the Earth."
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#source-code",
    "href": "documentation/modules/grd2cpt.html#source-code",
    "title": "grd2cpt",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrd2cpt(cmd0::String; kwargs...) - grd2cpt.jl:66\ngrd2cpt(arg1; kwargs...) - grd2cpt.jl:67"
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#see-also",
    "href": "documentation/modules/grd2cpt.html#see-also",
    "title": "grd2cpt",
    "section": "See Also",
    "text": "See Also\ngrdhisteq, grdinfo, makecpt"
  },
  {
    "objectID": "documentation/modules/grd2cpt.html#references",
    "href": "documentation/modules/grd2cpt.html#references",
    "title": "grd2cpt",
    "section": "References",
    "text": "References\nCrameri, F., (2018). Scientific colour-maps. Zenodo. http://doi.org/10.5281/zenodo.1243862\nCrameri, F. (2018), Geodynamic diagnostics, scientific visualisation and StagLab 3.0, Geosci. Model Dev., 11, 2541-2562, doi:10.5194/gmd-11-2541-2018."
  },
  {
    "objectID": "documentation/modules/gravmag3d.html",
    "href": "documentation/modules/gravmag3d.html",
    "title": "gravmag3d",
    "section": "",
    "text": "gravmag3d(cmd0::String=\"\"; kwargs...)\nCompute the gravity/magnetic anomaly of a 3-D body by the method of Okabe.\nSee full GMT docs at gmtgravmag3d\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet recived the proper attention to port the original manual.\n\n\n\n\n\nC | density :: [Type =&gt; Str | GMTgrid]\nSets body density in SI. Provide either a constant density or a grid with a variable one.\nF | track :: [Type =&gt; Str | Matrix | GMTdataset]\nProvide locations where the anomaly will be computed. Note this option is mutually exclusive with outgrid.\nG | save | outgrid | outfile :: [Type =&gt; Str]\nOutput grid file name. Note that this is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = gmtgravmag3d(….) form.\nH | mag_params :: [Type =&gt; Number]\nSets parameters for computation of magnetic anomaly. Alternatively, provide a magnetic intensity grid.\nI | inc | increment | spacing :: [Type =&gt; Str] \\(Arg = xinc[unit][+e|n][/yinc[unit][+e|n]]]\\)\nx_inc [and optionally y_inc] is the grid spacing. Optionally, append an increment unit.\nL | z_obs | observation_level :: [Type =&gt; Number]\nSets level of observation [Default = 0]. That is the height (z) at which anomalies are computed.\nM | body :: [Type =&gt; Str | Tuple]\nCreate geometric bodies and compute their grav/mag effect.\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nS | radius :: [Type =&gt; Number]\nSet search radius in km (valid only in the two grids mode OR when thickness) [Default = 30 km].\nT+v | index :: [Type =&gt; Str]\nT+r | raw_triang :: [Type =&gt; Str]\nT+s | stl :: [Type =&gt; Str]\nGives names of a xyz and vertex (ndex=“vert_file”) files defining a close surface.\nZ | level | reference_level :: [Type =&gt; Number]\nLevel of reference plane [Default = 0].\n\n\n\n    G = gmtgravmag3d(M=(shape=:prism, params=(1,1,1,5)), inc=1.0, region=\"-15/15/-15/15\", mag_params=\"10/60/10/-10/40\");\n    imshow(G)\n\n\n\n\nThis function has multiple methods:\n\ngravmag3d(; kwargs...) - gmtgravmag3d.jl:52\ngravmag3d(cmd0::String; kwargs...) - gmtgravmag3d.jl:50\ngravmag3d(arg1; kwargs...) - gmtgravmag3d.jl:51\n\n\n\n\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/gravmag3d.html#parameters",
    "href": "documentation/modules/gravmag3d.html#parameters",
    "title": "gravmag3d",
    "section": "",
    "text": "C | density :: [Type =&gt; Str | GMTgrid]\nSets body density in SI. Provide either a constant density or a grid with a variable one.\nF | track :: [Type =&gt; Str | Matrix | GMTdataset]\nProvide locations where the anomaly will be computed. Note this option is mutually exclusive with outgrid.\nG | save | outgrid | outfile :: [Type =&gt; Str]\nOutput grid file name. Note that this is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = gmtgravmag3d(….) form.\nH | mag_params :: [Type =&gt; Number]\nSets parameters for computation of magnetic anomaly. Alternatively, provide a magnetic intensity grid.\nI | inc | increment | spacing :: [Type =&gt; Str] \\(Arg = xinc[unit][+e|n][/yinc[unit][+e|n]]]\\)\nx_inc [and optionally y_inc] is the grid spacing. Optionally, append an increment unit.\nL | z_obs | observation_level :: [Type =&gt; Number]\nSets level of observation [Default = 0]. That is the height (z) at which anomalies are computed.\nM | body :: [Type =&gt; Str | Tuple]\nCreate geometric bodies and compute their grav/mag effect.\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nS | radius :: [Type =&gt; Number]\nSet search radius in km (valid only in the two grids mode OR when thickness) [Default = 30 km].\nT+v | index :: [Type =&gt; Str]\nT+r | raw_triang :: [Type =&gt; Str]\nT+s | stl :: [Type =&gt; Str]\nGives names of a xyz and vertex (ndex=“vert_file”) files defining a close surface.\nZ | level | reference_level :: [Type =&gt; Number]\nLevel of reference plane [Default = 0].\n\n\n\n    G = gmtgravmag3d(M=(shape=:prism, params=(1,1,1,5)), inc=1.0, region=\"-15/15/-15/15\", mag_params=\"10/60/10/-10/40\");\n    imshow(G)"
  },
  {
    "objectID": "documentation/modules/gravmag3d.html#source-code",
    "href": "documentation/modules/gravmag3d.html#source-code",
    "title": "gravmag3d",
    "section": "",
    "text": "This function has multiple methods:\n\ngravmag3d(; kwargs...) - gmtgravmag3d.jl:52\ngravmag3d(cmd0::String; kwargs...) - gmtgravmag3d.jl:50\ngravmag3d(arg1; kwargs...) - gmtgravmag3d.jl:51"
  },
  {
    "objectID": "documentation/modules/gravmag3d.html#see-also",
    "href": "documentation/modules/gravmag3d.html#see-also",
    "title": "gravmag3d",
    "section": "",
    "text": "Alphabetical Function List"
  },
  {
    "objectID": "documentation/modules/gpsgridder.html",
    "href": "documentation/modules/gpsgridder.html",
    "title": "gpsgridder",
    "section": "",
    "text": "Interpolate GPS velocities using Green’s functions for elastic deformation.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/gmtspatial.html",
    "href": "documentation/modules/gmtspatial.html",
    "title": "gmtspatial",
    "section": "",
    "text": "Geospatial operations on points, lines and polygons\n(Warning: Manual translate by Claude. Needs revision)"
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#synopsis",
    "href": "documentation/modules/gmtspatial.html#synopsis",
    "title": "gmtspatial",
    "section": "Synopsis",
    "text": "Synopsis\ngmtspatial [ table ] [ A | nn | nearest_neighbor ] [ C | clip ] [ D | duplicates ] [ E | handedness ] [ F | force_polygons ] [ I | intersections ] [ L | tile_lines ] [ N | in_polyg | in_polygons ] [ Q | area | length ] [ R | region | limits ] [ S | polygons | polyg_process] [ T | truncate ] [ V | verbose ] [ W | extend ] [ a | aspatial ] [ bi | binary_in ] [ di | nodata_in ] [ e | pattern ] [ f | colinfo ] [ g | gap ] [ h | header ] [ i | incol | incols ] [ j | spherical_dist | spherical ] [ o | outcol | outcols ] [ q | inrows | query ] [ s | skipNaN | skip_NaN ] [ yx ]"
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#description",
    "href": "documentation/modules/gmtspatial.html#description",
    "title": "gmtspatial",
    "section": "Description",
    "text": "Description\ngmtspatial reads a table (which may be multisegment files) that contains closed polygons and operates on these polygons in the specified way. Operations include area calculation, handedness reversals, and polygon intersections."
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#required-arguments",
    "href": "documentation/modules/gmtspatial.html#required-arguments",
    "title": "gmtspatial",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\n\nOne data table or file. Can be a file name, a GMTdataset object, or a Matrix."
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#optional-arguments",
    "href": "documentation/modules/gmtspatial.html#optional-arguments",
    "title": "gmtspatial",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or nn or nearest_neighbor : – nn=[amin_dist][unit]\nPerform spatial nearest neighbor (NN) analysis: Determine the nearest neighbor of each point and report the NN distances and the point IDs involved in each pair (IDs are the input record numbers starting at 0). Use nn=amin_dist to decimate a data set so that no NN distance is lower than the threshold amin_dist. In this case we write out the (possibly averaged) coordinates and the updated NN distances and point IDs. A negative point number means the original point was replaced by a weighted average (the absolute ID value gives the ID of the first original point ID to be included in the average). Note: The input data are assumed to contain (lon, lat) or (x, y), optionally followed by a z and a weight [1] column. We compute a weighted average of the location and z (if weight is present).\nC or clip : – clip=true\nClips polygons to the map region, including map boundary to the polygon as needed. The result is a closed polygon (see truncate for truncation instead). Requires region.\nD or duplicates : – duplicates=(modifiers…)\nCheck for duplicates among the input lines (or polygons). We consider both exact (same number and coordinates) and approximate matches (average distance between nearest points of two features is less than a threshold). We also consider that some features may have been reversed. By default, we compute the mean line separation. Available modifiers:\n\ncloseness or c : c=cmax – Set threshold of a pair’s closeness (defined as the average distance between the features divided by their average length) [0.01].\nCloseness or C : C=cmin – Use this to compute the median line separation and therefore a robust closeness value.\ndist or d : d=dmax – Features are considered approximate matches if their minimum distance is less than dmax [0] and their closeness is less than cmax.\nfile or f : f=“file” – Check if the input features already exist among the features in file.\nperpendicular or p : p=true – Limit the comparison to points that project perpendicularly to points on the other line (and not its extension) [Default considers all distances between points on one line and another].\nscale or s : s=factor – Scale factor to apply.\n\nFor each duplicate found, the output record begins with Y (exact match) or ~ (approximate match). If the two matching segments differ in length by more than a factor of 2 then we consider the duplicate to be either a subset (-) or a superset (+). Finally, we also note if two lines are the result of splitting a continuous line across the Dateline (|).\nE or handedness : – handedness=:p | handedness=:n | handedness=(pol=“+p”) | handedness=(pol=“+n”)\nReset the handedness of all polygons to match the given modifier:\n\n+p or pol=“+p” : Counter-clockwise (positive).\n+n or pol=“+n” : Clockwise (negative).\n\nF or force_polygons : – force_polygons=true | force_polygons=:l\nForce input data to become polygons on output, i.e., close them explicitly if not already closed. Optionally, append :l to force line geometry.\nI or intersections : – intersections=true | intersections=:i | intersections=:e\nDetermine the intersection locations between all pairs of polygons. Modifiers:\n\ni or :i : Only compute internal (self-intersecting polygons) crossovers.\ne or :e : Only compute external (between pairs of polygons) crossovers.\nDefault is both.\n\nOutput records list the coordinates of the crossing, the relative times along the two segments (i.e., floating point record numbers at the crossing), and the names of the two segments (as trailing text).\nL or tilelines : – tilelines=(dist, noise, offset)\nRemove tile lines. These are superfluous lines that were digitized with a polygon but that all fall along the rectangular region border and should be removed. Append dist (in m) [0], coordinate noise [1e-10], and max offset from gridlines [1e-10].\nN or in_polyg or in_polygons : – in_polyg=pfile | in_polyg=(poly=“pfile”, modifiers…)\nDetermine if one (or all) points of each feature in the input data are inside any of the polygons given in pfile. If inside, then report which polygon it is. The polygon ID is taken from the aspatial value assigned to Z or the segment header. By default, the input segments that are found to be inside a polygon are written to standard output with the polygon ID encoded in the segment header as -ZID. Available modifiers:\n\nall or a : all=true – All points of a feature must be inside the polygon.\nindividual or i : individual=true – Point clouds: determine the polygon ID for every individual input point and add it as the last output column.\nrunning_id or start or p : start=n – Instead of segment headers, assign a running ID number that is initialized to begin from n [0].\nreport or r : report=true – Just report which polygon contains a feature.\nid_column or z : z=true – Add the IDs as an extra data column on output.\n\nSegments that fail to be inside a polygon are not written out. If more than one polygon contains the same segment, we skip the second (and further) scenarios.\nQ or area or length : – area=true | area=unit | area=(unit=“k”, modifiers…)\nMeasure the area of all polygons or length of all line segments. For polygons, we also compute the centroid location while for lines we compute the mid-point (half-length) position. For geographical data, optionally append a distance unit to select the unit used [k]. Note that the area will depend on the current setting of PROJ_ELLIPSOID; this should be a recent ellipsoid to get accurate results. The centroid is computed using the mean of the 3-D Cartesian vectors making up the polygon vertices, while the area is obtained via a sum of areas for spherical triangles. Normally, all input segments will be reflected on output. By default, we consider open polygons as lines and closed polygons as polygons. Available modifiers:\n\nlimits or c : limits=(min, max) | c=“min/max” – Restrict processing to those features whose length (or area for polygons) fall inside the specified range. If max is not set it defaults to infinity.\nheader or h : header=true – Append the area to each polygon’s segment header [Default simply writes the area to standard output].\nlines or l : lines=true – Consider all input features as lines, even if closed.\npolygons or p : polygons=true – Close open polygons and thus consider all input as polygons.\nsort or s : sort=:a | sort=:d – Sort the segments based on their lengths or area. Append :a for ascending [Default] and :d for descending order.\n\nR or region or limits : – region=(xmin, xmax, ymin, ymax) | region=“west/east/south/north” | region=“gridfile” | region=country_code\nSpecify the region of interest. Clips polygons to the map region, including map boundary to the polygon as needed. The result is a closed polygon. [More at region]\nS or polygons or polyg_process : – polygons=:bwidth | polygons=:h | polygons=:s | polygons=(buffer=width,)\nSpatial processing of polygons. Choose from several directives:\n\nbuffer or b : buffer=width – Computes a buffer polygon around lines with the specified width. Note: This is a purely Cartesian operation, so width must be in data units. For geographical coordinates, width must be in degrees or, preferably, project data into an equal-area projection with mapproject, compute the buffer, and then convert back to geographical.\nh : Identifies perimeter and hole polygons (and flags/reverses them).\ns : Split polygons that straddle the Dateline.\n\nT or truncate : – truncate=true | truncate=polygon_file\nTruncate polygons and lines against the specified polygon, possibly resulting in open polygons. If no argument is given, we create a clipping polygon from region which then is required. Note that when the region clipping is in effect we will also look for polygons of length 4 or 5 that exactly match the region clipping polygon.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or extend : – extend=dist | extend=(dist=val, unit=“k”, modifiers…)\nExtend all segments with a new first and last point such that these points are dist away from their neighbor point in the direction implied by the two points at each end of the segment. For geographic data you may append a unit. To give separate distances for the two ends, give distf/distl instead. Available modifiers:\n\nfirst or f : first=true – Only extend the first point.\nlast or l : last=true – Only extend the last point.\n\nThe mode of geographical calculations depends on spherical_dist.\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. [More at aspatial]\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#units",
    "href": "documentation/modules/gmtspatial.html#units",
    "title": "gmtspatial",
    "section": "Units",
    "text": "Units\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (spherical=:greatcirc) using the authalic radius (see PROJ_MEAN_RADIUS). You can use spherical=:flat to perform “Flat Earth” calculations (quicker but less accurate) or spherical=:ellipsoidal to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#insideoutside-status",
    "href": "documentation/modules/gmtspatial.html#insideoutside-status",
    "title": "gmtspatial",
    "section": "Inside/Outside Status",
    "text": "Inside/Outside Status\nTo determine if a point is inside, outside, or exactly on the boundary of a polygon we need to balance the complexity (and execution time) of the algorithm with the type of data and shape of the polygons. For any Cartesian data we use a non-zero winding algorithm, which is quite fast. For geographic data we will also use this algorithm as long as (1) the polygons do not include a geographic pole, and (2) the longitude extent of the polygons is less than 360. If this is the situation we also carefully adjust the test point longitude for any 360 degree offsets, if appropriate. Otherwise, we employ a full spherical ray-shooting method to determine a point’s status."
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#examples",
    "href": "documentation/modules/gmtspatial.html#examples",
    "title": "gmtspatial",
    "section": "Examples",
    "text": "Examples\nTo determine the centroid of the remote GSHHH high-resolution polygon for Australia, as well as the land area in km squared, try:\n\nusing GMT\nD = gmtspatial(\"@GSHHS_h_Australia.txt\", colinfo=:g, area=\"k\")\n\nBoundingBox: [134.2087857138511, 134.2087857138511, -25.66163647094111, -25.66163647094111, 7.585270245486038e6, 7.585270245486038e6]\nPROJ: +proj=longlat +datum=WGS84 +units=m +no_defs\n\n\n\n\n\n\n1×3 GMTdataset{Float64, 2}\n Row │ centroid_x  centroid_y       area\n─────┼───────────────────────────────────\n   1 │    134.209    -25.6616  7.58527e6\n\n\nTo turn all lines in the multisegment file lines.txt into closed polygons, run:\nD = gmtspatial(\"lines.txt\", force_polygons=true)\nTo append the polygon ID of every individual point in cloud.txt that is inside the polygons in the file poly.txt and write that ID as the last column per output row, run:\nD = gmtspatial(\"cloud.txt\", in_polyg=(poly=\"poly.txt\", individual=true))\nTo compute the area of all geographic polygons in the multisegment file polygons.txt, run:\nD = gmtspatial(\"polygons.txt\", area=true)\nSame data, but now orient all polygons to go counter-clockwise and write their areas to the segment headers, run:\nD = gmtspatial(\"polygons.txt\", area=(header=true,), handedness=:p)\nTo determine the areas of all the polygon segments in the file janmayen_land_full.txt, add this information to the segment headers, sort the segments from largest to smallest in area but only keep polygons with area larger than 1000 sq. meters, run:\nD = gmtspatial(\"janmayen_land_full.txt\", area=(unit=\"e\", header=true, polygons=true, \n                limits=(1000, Inf), sort=:d), verbose=true)\nTo determine the intersections between the polygons A.txt and B.txt, run:\nD = gmtspatial([\"A.txt\", \"B.txt\"], intersections=:e)\nTo truncate polygons A.txt against polygon B.txt, resulting in an open line segment, run:\nD = gmtspatial(\"A.txt\", truncate=\"B.txt\")\nIf you want to plot a polygon with holes (donut polygon) from a multiple segment file which contains both perimeters and holes, it could be necessary first to reorganize the file so it can be plotted with plot. To do this, run:\nD = gmtspatial(\"file.txt\", polygons=:h)"
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#source-code",
    "href": "documentation/modules/gmtspatial.html#source-code",
    "title": "gmtspatial",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtspatial(cmd0::String; ...) - gmtspatial.jl:51\ngmtspatial(cmd0::String, arg1; kw...) - gmtspatial.jl:51\ngmtspatial(arg1, arg2; kw...) - gmtspatial.jl:53\ngmtspatial(arg1; kw...) - gmtspatial.jl:52"
  },
  {
    "objectID": "documentation/modules/gmtspatial.html#see-also",
    "href": "documentation/modules/gmtspatial.html#see-also",
    "title": "gmtspatial",
    "section": "See Also",
    "text": "See Also\ngmtselect, gmtsimplify, mapproject"
  },
  {
    "objectID": "documentation/modules/gmtset.html",
    "href": "documentation/modules/gmtset.html",
    "title": "gmtset",
    "section": "",
    "text": "gmtset(; kwargs...)\nChange individual GMT default settings"
  },
  {
    "objectID": "documentation/modules/gmtset.html#description",
    "href": "documentation/modules/gmtset.html#description",
    "title": "gmtset",
    "section": "Description",
    "text": "Description\nAdjusts individual GMT defaults settings in the current directory’s gmt.conf file (under classic mode) or in the current session directory (modern mode). If no such file exists one will be created. The main purpose of set is temporarily to change certain parameters inside a shell script, e.g., set the map frame type to plain, run the script, and reset to fancy. Only parameters that differ from the GMT SI system defaults will be written. Optionally, you can specify one or more temporary changes directly on any GMT command line with the syntax conf=(PARAMETER = VALUE, ...); such changes are only in effect for that command and do not permanently change the default settings on disk."
  },
  {
    "objectID": "documentation/modules/gmtset.html#required-arguments",
    "href": "documentation/modules/gmtset.html#required-arguments",
    "title": "gmtset",
    "section": "Required Arguments",
    "text": "Required Arguments\nPARAMETER value Provide one or several pairs of parameter/value combinations that you want to modify. For a complete listing of available parameters and their meaning, see the gmt.conf man page."
  },
  {
    "objectID": "documentation/modules/gmtset.html#optional-arguments",
    "href": "documentation/modules/gmtset.html#optional-arguments",
    "title": "gmtset",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nD or units : – units=true | units=:s | units=:u\nModify the GMT defaults based on the system settings. Use units=:u for US defaults or units=:s for SI defaults. [units alone gives the version selected at compile time]\n\n-G or defaultsfile : – defaultsfile=file\nName of specific gmt.conf file to read and modify [Default looks first in current directory, then in your home directory, then in ~/.gmt and finally in the system defaults]."
  },
  {
    "objectID": "documentation/modules/gmtset.html#examples",
    "href": "documentation/modules/gmtset.html#examples",
    "title": "gmtset",
    "section": "Examples",
    "text": "Examples\nTo change annotation font to 12-point Helvetica, select grid-crosses of size 0.25 cm, and set annotation offset to 0.2 cm\n    gmtset(FONT_ANNOT_PRIMARY=(12,Helvetica), MAP_GRID_CROSS_SIZE_PRIMARY=0.2.5, MAP_ANNOT_OFFSET_PRIMARY=0.2)"
  },
  {
    "objectID": "documentation/modules/gmtset.html#source-code",
    "href": "documentation/modules/gmtset.html#source-code",
    "title": "gmtset",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/gmtset.html#see-also",
    "href": "documentation/modules/gmtset.html#see-also",
    "title": "gmtset",
    "section": "See Also",
    "text": "See Also\ngmt.conf, gmtdefaults, gmtget"
  },
  {
    "objectID": "documentation/modules/gmtmath.html",
    "href": "documentation/modules/gmtmath.html",
    "title": "gmtmath",
    "section": "",
    "text": "Reverse Polish Notation (RPN) calculator for data tables"
  },
  {
    "objectID": "documentation/modules/gmtmath.html#description",
    "href": "documentation/modules/gmtmath.html#description",
    "title": "gmtmath",
    "section": "Description",
    "text": "Description\ngmtmath will perform operations like add, subtract, multiply, and numerous other operands on one or more table data files or constants using Reverse Polish Notation (RPN) syntax. Arbitrarily complicated expressions may therefore be evaluated; the final result is written to an output file [or standard output]. Data operations are element-by-element, not matrix manipulations (except where noted). Some operators only require one operand (see below). If no data tables are used in the expression then options |-T|, |-N| can be set (and optionally -bo to indicate the data type for binary tables). If STDIN is given, the standard input will be read and placed on the stack as if a file with that content had been given on the command line. By default, all columns except the “time” column are operated on, but this can be changed (see |-C|). Complicated or frequently occurring expressions may be coded as a macro for future use or stored and recalled via named memory locations.\nOK, but RPN is quite painfull to master for other than simple expressions and for it the normal Julia operators are much easier to use. However, there are many operators that are handy and already programmed or even kind of unique like for example XYZ2LAB that converts x,y,z triplets to l,a,b triplets to coastlines. So, there is still interest in gmtmath but due to its nature it was nor wrapped into a vebose version and for using it one must use the [Monolithic] mode.\nFor the full manual, consult the main GMT gmtmath manual"
  },
  {
    "objectID": "documentation/modules/gmtmath.html#source-code",
    "href": "documentation/modules/gmtmath.html#source-code",
    "title": "gmtmath",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html",
    "href": "documentation/modules/gmtgravmag3d.html",
    "title": "gravmag3d",
    "section": "",
    "text": "gravmag3d(fname::String=\"\", arg1=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#description",
    "href": "documentation/modules/gmtgravmag3d.html#description",
    "title": "gravmag3d",
    "section": "Description",
    "text": "Description\nCompute the gravity or magnetic anomaly of a body described by a set of triangles. The output can either be along a given set of xy locations or on a grid. This method is not particularly fast but allows computing the anomaly of arbitrarily complex shapes."
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#required-arguments-not-all",
    "href": "documentation/modules/gmtgravmag3d.html#required-arguments-not-all",
    "title": "gravmag3d",
    "section": "Required Arguments (not all)",
    "text": "Required Arguments (not all)\n\nfname : Optional positional argument with the name of a xyz… file that can be read by gmtread. The xyz file can have 3, 4, 5, 6 or 8 columns. In first case (3 columns) the magnetization (or density) are assumed constant (controlled by density or mag_params). Following cases are: 4 columns -&gt; 4rth col magnetization intensity; 5 columns: mag, mag dip; 6 columns: mag, mag dec, mag dip; 8 columns: field dec, field dip, mag, mag dec, mag dip. When n columns &gt; 3 the third argument of the mag_params option is ignored.\narg1 : In alternative to fname pass in a Mx3 matrix or a GMTdataset with at least 3 columns. arg1 can also be a GMTfv type like those produced by the solids functions (sphere, etc) but it must be one made of triangles. That is, the output of cube wont work because the body is made out of quadrangles. Note, if the body option is used neither this option nor fname are used.\nC or density : – density=??\nSets body density in SI. Append either a constant, the name of a grid file or a GMTgrid grid with variable densities. This option is mutually exclusive with mag_params\nH or mag_params : – mag_params=f_dec/f_dip/m_int/m_dec/m_dip\nSets parameters for computing a magnetic anomaly. Use f_dec/f_dip to set the geomagnetic declination/inclination in degrees. m_int/m_dec/m_dip are the body magnetic intensity declination and inclination.\nF or track : – track=xy_loc\nProvide xy_loc (file name or GMTdataset) locations where the anomaly will be computed. Note, this option is mutually exclusive with the save option.\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nM or body : – body=shape,params | body=(shape=name, params=…)\n(An alternative to raw_triang and stl). Create geometric bodies and compute their grav/mag effect. Select among one or more of the following bodies, where x0 & y0 represent the horizontal coordinates of the body center [default to 0,0 positive up], npts is the number of points that a circle is discretized and n_slices apply when bodies are made by a pile of slices. For example Spheres and Ellipsoids are made of 2 x n_slices and Bells have n_slices [Default 5]. It is also possible to select more than one body. For example body=((shape=:prism, params=“1/1/1/-5/-10/1”), (shape=:sphere, params=“1/-5”)) computes the effect of a prism and a sphere. Unfortunately there is no current way of selecting distinct densities or magnetic parameters for each body.\n- *bell,height/sx/sy/z0[/x0/y0/n_sig/npts/n_slices]* Gaussian of height *height* with characteristic\n   STDs *sx* and *sy*. The base width (at depth *z0*) is controlled by the number of sigmas (*n_sig*) [Default = 2]\n\n- *cylinder,rad/height/z0[/x0/y0/npts/n_slices]* Cylinder of radius *rad* and height *height* and base at depth *z0*\n\n- *cone,semi_x/semi_y/height/z0[/x0/y0/npts]* Cone of semi axes *semi_x/semi_y* height *height* and base at depth *z0*\n\n- *ellipsoid,semi_x/semi_y/semi_z/z_center[/x0/y0/npts/n_slices]* Ellipsoid of semi axes *semi_x/semi_y/semi_z*\n   and center depth *z_center*\n\n- *prism,side_x/side_y/side_z/z0[/x0/y0]* Prism of sides *x/y/z* and base at depth *z0*\n\n- *pyramid,side_x/side_y/height/z0[/x0/y0]* Pyramid of sides *x/y* height *height* and base at depth *z0*\n\n- *sphere,rad/z_center[/x0/y0/npts/n_slices]* Sphere of radius *rad* and center at depth *z_center*\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nTv or index : – index=vert_file | index=D\nGives name of a vertex file defining a closed surface. The file formats correspond to the output of the triangulate module. The form raw_triang=D means that we can also pass the data as a GMTdataset\nTr or raw_triang : – raw_triang=raw_file | raw_triang=D\nA raw format is a file with N rows (one per triangle) and 9 columns corresponding to the x, y, z coordinates of each of the three vertex of each triangle. The form raw_triang=D means that we can also pass the data as a GMTdataset\nTs or stl or STL : – stl=raw_file\nAlternatively, the stl option indicates that the surface file is in the ASCII STL (Stereo Lithographic) format. These two type of files are used to provide a closed surface.\nnoswap or no_swap : – noswap=true\nThe closed surface formats (STL or raw) are assumed to be provided with the facets (triangles) following the counter-clockwise order. If that is not the case, i.e. they are clockwise oriented, use this option to bring them to the expected order. However, this order may not be easy to check. In case of doubt, compute the gravity anomaly caused by the body and see if it has the expected signal."
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#optional-arguments",
    "href": "documentation/modules/gmtgravmag3d.html#optional-arguments",
    "title": "gravmag3d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nE or thickness : – thickness=??\nGive layer thickness in m [Default = 0 m]. Use this option only when the triangles describe a non-closed surface and you want the anomaly of a constant thickness layer.\nL or z_obs or observation_level : – – z_obs=0\nsets level of observation [Default = 0]. That is the height (z) at which anomalies are computed.\nS or radius : – radius=30\nSet search radius in km (valid only in the two grids mode OR when thickness) [Default = 30 km]. This option serves to speed up the computation by not computing the effect of prisms that are further away than radius from the current node.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\n\nZ or level or reference_level : – level=0\nlevel of reference plane [Default = 0]. Use this option when the triangles describe a non-closed surface and the volume is defined from each triangle and this reference level. An example will be the water depth to compute a Bouguer anomaly.\nQ or onebased or one_based : – onebased=true\nUse this option if the indices in file (index) is 1-based instead of the default (C) 0-based. This option is needed when indices are 1-based, as likely is the case when bodies may have been created in Julia.\n\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nGeographic grids (dimensions of longitude, latitude) will be converted to meters via a “Flat Earth” approximation using the current ellipsoid parameters.\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at"
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#grid-distance-units",
    "href": "documentation/modules/gmtgravmag3d.html#grid-distance-units",
    "title": "gravmag3d",
    "section": "Grid Distance Units",
    "text": "Grid Distance Units\nIf the grid does not have meter as the horizontal unit, append +u unit to the input file name to convert from the specified unit to meter. If your grid is geographic, convert distances to meters by supplying f=:g instead."
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#example",
    "href": "documentation/modules/gmtgravmag3d.html#example",
    "title": "gravmag3d",
    "section": "Example",
    "text": "Example\nTo compute the magnetic anomaly of a cube of unit sides located at 5 meters depth and centered at -10,1 in a domain R=“-15/15/-15/15” with a magnetization of 10 Am with a declination of 10 degrees, inclination of 60 in a magnetic field with -10 deg of declination and 40 deg of inclination, do:\n\nusing GMT\n\nG = gravmag3d(region=\"-15/15/-15/15\", I=0.1, mag_params=\"10/60/10/-10/40\", body=(shape=:prism, params=\"1/1/1/-5/-10/1\"));\nviz(G, colorbar=true)"
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#source-code",
    "href": "documentation/modules/gmtgravmag3d.html#source-code",
    "title": "gravmag3d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngravmag3d(; kwargs...) - gmtgravmag3d.jl:52\ngravmag3d(cmd0::String; kwargs...) - gmtgravmag3d.jl:50\ngravmag3d(arg1; kwargs...) - gmtgravmag3d.jl:51"
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#see-also",
    "href": "documentation/modules/gmtgravmag3d.html#see-also",
    "title": "gravmag3d",
    "section": "See Also",
    "text": "See Also\ngrdgravmag3d, gravprisms, talwani2d, talwani3d, triangulate"
  },
  {
    "objectID": "documentation/modules/gmtgravmag3d.html#reference",
    "href": "documentation/modules/gmtgravmag3d.html#reference",
    "title": "gravmag3d",
    "section": "Reference",
    "text": "Reference\nOkabe, M., 1979, Analytical expressions for gravity anomalies due to polyhedral bodies and translation into magnetic anomalies, Geophysics, 44, 730-741."
  },
  {
    "objectID": "documentation/modules/gmtconnect.html",
    "href": "documentation/modules/gmtconnect.html",
    "title": "gmtconnect",
    "section": "",
    "text": "gmtconnect(cmd0::String=\"\", arg1=nothing, kwargs...)\nConnect individual lines whose end points match within tolerance"
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#description",
    "href": "documentation/modules/gmtconnect.html#description",
    "title": "gmtconnect",
    "section": "Description",
    "text": "Description\nReads a multi-column data set and examines the coordinates of the end points of all line segments. If a pair of end points are identical or closer to each other than the specified separation cutoff then the two line segments are joined into a single segment. The process repeats until all the remaining endpoints no longer pass the tolerance test; the resulting segments are then written out to standard output or specified output file. If it is not clear what the separation tolerance should be then use linkfile to get a list of all separation distances and analyze them to determine a suitable cutoff."
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#required-arguments",
    "href": "documentation/modules/gmtconnect.html#required-arguments",
    "title": "gmtconnect",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns."
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#optional-arguments",
    "href": "documentation/modules/gmtconnect.html#optional-arguments",
    "title": "gmtconnect",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or closed : – closed=true | closed=closed_file\nWrite all the already-closed polygons to file closed [gmtconnect_closed.txt] and all open segments to standard output. No connection will take place. Use tolerance=cutoff to set a minimum separation [0], and then any existing polygon whose first and last point are separated by less that cutoff will be considered to be closed. Note that if cutoff is &gt; 0 then we explicitly close all polygons on output.\nD or dump : – dump=true | dump=“template”\nFor multiple segment data, dump each segment to a separate output file [Default writes a single multiple segment file]. Append a format template for the individual file names; this template must contain a C format specifier that can format an integer argument (the segment number); this is usually %d but could be %08d for leading zeros, etc. Optionally, it may also contain the format %c before the integer; this will then be replaced by C (closed) or O (open) to indicate segment type. [Default is gmtconnect_segment_%d.txt]. Note that segment headers will be written in either case. For composite segments, a generic segment header will be written and the segment headers of individual pieces will be written out as comments to make it possible to identify where the connected pieces came from.\nL or links or linkfile : – links=true | linkfile=“file”\nWrites link information to the specified file [gmtconnect_link.txt] (or return its contents). For each segment we write the original segment id, and for the beginning and end point of the segment we report the id of the nearest segment, whether it is the beginning (B) or end (E) point that is closest, and the distance between those points in units determined by tolerance.\nQ or list or listfile : – list=true | listfile=“template”\nUsed with dump to write a list file with the names of the individual output files. Optionally, append a filename template for the individual file names; this template may contain a C format specifier that can format an character (C or O for closed or open, respectively). [Default is gmtconnect_list.txt].\nT or tolerance : – tolerance=true | tolerance=cutoff | tolerance=“cutoff+sdist”\nSpecifies the separation tolerance in the data coordinate units [0]; for geographic data append distance unit (see [Units]). If two lines have end-points that are closer than cutoff they will be joined. Optionally, append +s dist which adds the extra requirement that a link will only be made if the second closest connection exceeds the dist distance. The latter distance must be given in the same units as cutoff. However, if tolerance is used with no arguments then we close every line segment or polygon regardless of the gap distance between the first and last point in the segment.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#examples",
    "href": "documentation/modules/gmtconnect.html#examples",
    "title": "gmtconnect",
    "section": "Examples",
    "text": "Examples\nTo combine the digitized segment lines segment_*.txt (whose Cartesian coordinates are in cm) into as few complete lines as possible, assuming the end points’ digitization error could be up to 0.1 mm, run::\n    D = connect(\"segment_*.txt\", tolerance=0.1)\nTo combine the digitized segments in the multisegment file my_lines.txt (whose coordinates are in lon,lat) into as few complete lines as possible, assuming the end points digitization error could be up to 150 m, and write the complete segments to individual files called Map_segment_0001.txt, Map_segment_0002.txt, etc., run::\n    connect(\"my_lines.txt\", tolerance=\"150e\", dump=\"Map_segment_%04d.txt\")"
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#bugs",
    "href": "documentation/modules/gmtconnect.html#bugs",
    "title": "gmtconnect",
    "section": "Bugs",
    "text": "Bugs\nThe line connection does not work if a line only has a single point. However, connect will correctly add the point to the nearest segment. Running connect again on the new set of lines will eventually connect all lines that satisfy the criteria given in tolerance."
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#source-code",
    "href": "documentation/modules/gmtconnect.html#source-code",
    "title": "gmtconnect",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtconnect(cmd0::String; ...) - gmtconnect.jl:29\ngmtconnect(; ...) - gmtconnect.jl:29\ngmtconnect(cmd0::String, arg1; ...) - gmtconnect.jl:29\ngmtconnect(arg1, arg2; kw...) - gmtconnect.jl:39\ngmtconnect(arg1; ...) - gmtconnect.jl:39\ngmtconnect(cmd0::String, arg1, arg2; kwargs...) - gmtconnect.jl:29"
  },
  {
    "objectID": "documentation/modules/gmtconnect.html#see-also",
    "href": "documentation/modules/gmtconnect.html#see-also",
    "title": "gmtconnect",
    "section": "See Also",
    "text": "See Also\ngmtsimplify, gmtspatial, mapproject"
  },
  {
    "objectID": "documentation/modules/gmt2kml.html",
    "href": "documentation/modules/gmt2kml.html",
    "title": "gmt2kml",
    "section": "",
    "text": "Convert GMT data table to Google Earth KML file."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#description",
    "href": "documentation/modules/gmt2kml.html#description",
    "title": "gmt2kml",
    "section": "Description",
    "text": "Description\ngmt2kml reads one or more GMT table file and converts them to a single output file using Google Earth’s KML format. Data may represent points, lines, polygons, or wiggles, and you may specify additional attributes such as title, altitude mode, colors, pen widths, transparency, regions, and data descriptions. You may also extend the feature down to ground level (assuming it is above it) and use custom icons for point symbols. Finally, there are controls on visibility depending on level of detail settings, altitude, regions, including the status upon loading into Google Earth as well as fading depending on zoom.\nThe input files should contain the following columns:\nlon lat [ alt ] [ timestart [ timestop ] ]\nwhere lon and lat are required for all features, alt is optional for all features (see also mode and cmap), and timestart and timestop apply to events and timespan features. For wiggles, the alt column is required but is expected to represent an along-track data anomaly such as gravity, magnetics, etc. These values will be scaled to yield distances from the line in degrees.\nThe output of this function can be sent back to Julia as a GMTdataset but most of times there is no real interest in that. The more useful usage is to redirect the result into a disk file since that’s what GE reads. To do this, one should use the |&gt;=“fname” or write=“fname” options."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#required-arguments",
    "href": "documentation/modules/gmt2kml.html#required-arguments",
    "title": "gmt2kml",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#optional-arguments",
    "href": "documentation/modules/gmt2kml.html#optional-arguments",
    "title": "gmt2kml",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or mode : – mode=:a|:g|s | mode=“a|g|s”\nSelect one of three altitude modes recognized by Google Earth that determines the altitude (in m) of the tile layer: a absolute altitude, g altitude relative to sea surface or ground, s altitude relative to seafloor or ground. To plot the tiles at a fixed altitude, append an altitude altitude (in m). Use 0 to clamp the features to the chosen reference surface. [By default the tiles are clamped to the sea surface or ground].\nC or color or cmap or colorap or colorscale : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name (for grd_z only). Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. In this case color1 etc can be a (r,g,b) triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ) (see [Setting color](../common_features/color.html)). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map.\nD or descript : – descript=descriptfile\nFile with HTML snippets that will be included as part of the main description content for the KML file [no description]. See SEGMENT INFORMATION below for feature-specific descriptions.\nE or extrude : – extrude=true | extrude=“+e” extrude=“+s”\nControl how lines and polygons are rendered in Google Earth. Use +e to extrude the feature down to ground level [no extrusion]. Use +s to connect points with straight lines (which may intersect the Earth’s surface and be invisible) [tessellate onto surface].\nF or feature_type : – feature_type=:e|:s|:t|:l|:p|:w\nSets the feature type. Choose from points (event, symbol, or timespan), line, polygon, or wiggle [symbol]. The first two columns of the input file should contain (lon, lat). When altitude or value is required (i.e., no altitude value was given with mode, or cmap is set), the third column needs to contain the altitude (in m) or value. The event (feature_type=:e) is a symbol that should only be active at a particular time, given in the next column. Timespan (feature_type=:t) is a symbol that should only be active during a particular time period indicated by the next two columns (timestart, timestop). Use NaN to indicate unbounded time limits. If used, times should be in ISO format yyyy-mm-ddThh:mm:ss[.xxx] or in GMT relative time format (see colinfo). For wiggles, the data anomaly is required to be in the 3rd input column. If you also need to plot the track itself then do that separately with feature_type=:l.\nG or fill : – fill=color | fill=“+f|+n”\nSets color for fill (modifier +f [Default]) or label font (modifier +n). Fill sets infill color for symbols, extrusions, polygons and positive anomaly wiggles [Default is light orange at 75% transparency]. Alternatively, use fill=“+f” to turn off such infill. Text labels: Specify color for the font [Default is white]. Alternatively, use fill=“+n” to instead disable the labels.\nI or icon : – icon=URL\nSpecify the URL to an alternative icon that should be used for the symbol [Default is a Google Earth circle]. If the URL starts with + then we will prepend http://maps.google.com/mapfiles/kml/ to the name. To turn off icons entirely (e.g., when just wanting a text label), use icon=-. [Default is a local icon with no directory path].\nK or not_over : – not_over=true\nAllow more KML code to be appended to the output later [finalize the KML file].\nL or extra_data : – extra_data=“name1,name2,…”\nExtended data given. Append one or more column names separated by commas. We will expect the listed data columns to exist in the input immediately following the data coordinates required for the selected feature set by feature, and they will be encoded in the KML file as Extended Data sets, whose attributes will be available in a Google Earth balloon when the item is selected. The data file must have enough data columns and trailing text to accommodate the number of columns requested. If the number of extended data is one larger than the number of available numerical columns then the entire trailing text is set as the last extended data column. Otherwise, the trailing text is split into individual words and set as separate extended columns.\nN or feature_name : – feature_name=true | feature_name=“t|col|name_template|name”\nBy default, if segment headers contain a -L”label string” then we use that for the name of the KML feature (polygon, line segment or set of symbols). Default names for these segments are “Line %d” and “Point Set %d”, depending on the feature, where %d is a sequence number of line segments within a file. Each point within a line segment will be named after the line segment plus a sequence number. Default is simply “Point %d”. Alternatively, select one of these options:\n\nappend col to supply individual symbol labels as the string formatted from the col data column,\nappend t to let individual symbol labels be the trailing text of each record\nappend a string that may include %d or a similar integer format to assign unique name IDs for each feature, with the segment number (for lines and polygons) or point number (symbols) appearing where %d is placed,\ngive no arguments to turn symbol labeling off; line segments will still be named.\n\nAlso note that option (2) is not available unless input is an ASCII file.\nO or overlay : – overlay=true\nAppend KML code to an existing KML file [initialize a new KML file]. WARNING the use of this option requires saving the result to file (that is, not returning it as a dataset) and the use of append=\"kmlfile\" and not any of the |&gt;=\"kmlfile\" or write=\"kmlfile\" file saving options.\nQa or wiggles or wiggle_fixedazim or wiggle_scale= : – wiggles=az | wiggle_fixedazim=az | wiggle_scale=scale\nOption in support of wiggle plots (requires feature_type=:w). You may control which directions the positive wiggles will tend to point to with wiggles=azim. The appended azimuth defines a half-circle centered on the selected azimuth [0] where positive anomalies will plot. If outside then switch by 180 degrees. Alternatively, use wiggle_fixedazim to set a fixed azimuth with no further variation. Scaling is also required via wiggle_scale=scale. Set a wiggle scale in z-data units per the user’s units (given via the trailing unit taken from d|m|s|e|f|k|M|n|u [e]). This scale is then inverted to yield degrees per user z-unit and used to convert wiggle anomalies to map distances and positions.\nR or region : – region=:e | region=(w,e,s,n)\nIssue a single Region tag. Use region=(w,e,s,n) to set a particular region (will ignore points outside the region), or region=:e to determine and use the exact domain of the data (single file only) [no region tags issued].\nS or ilscale : – ilscale=“c” | ilscale=“n”\nScale icons or labels. Here, ilscale=“c” sets a scale for the symbol icon, whereas ilscale=“n” sets a scale for the name labels [1 for both].\nT or title : – title=title | title=(“title”,“FolderName”)\nSets the document title [default is unset]. Optionally, set also the FolderName; this allows you, with overlay, not_over, to group features into folders within the KML document. [The default folder name is “Name Features”, where Name is Point, Event, Timespan, Line, Polygon or Wiggle].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nZ or attrib : – attrib=“+aalt_min/alt_max][+fminfade/maxfade][+lminLOD/maxLOD][+o][+v]”\nSet one or more attributes of the Document and Region tags. Append +aalt_min/alt_max to specify limits on visibility based on altitude. Add +ffade_min/fade_max** to fade in and out over a ramp [abrupt]. Add +llod_min/lod_max to specify limits on visibility based on Level Of Detail, where a lod_max of -1 means it is visible to infinite size. Add +o to open a older or document in the sidebar when loaded [closed]. Add +v to make a feature not visible when loaded [visible].\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#examples",
    "href": "documentation/modules/gmt2kml.html#examples",
    "title": "gmt2kml",
    "section": "Examples",
    "text": "Examples\nTo plot colored symbols based on a CPT of the remote file @kml_pointsets.txt, first make the CPT and then create the KML file thus:\n    C = makecpt(cmap=:categorical)\n    gmt2kml(\"@kml_pointsets.txt\", cmap=C, |&gt;=\"points.kml\")\nTo convert a file with point locations (lon, lat) into a KML file with red circle symbols, try\n    gmt2kml(\"mypoints.txt\", fill=\"red+f\", feature_type=:s, |&gt;=\"mypoints.kml\")\nTo convert a multisegment file with lines (lon, lat) separated by segment headers that contain a -L labelstring with the feature name, selecting a thick white pen, and title the document, try\n    gmt2kml(\"mylines.txt\", pen=(:thick,:white), feature_type=:l,\n            title=\"Lines from here to there\", |&gt;=\"mylines.kml\")\nTo convert a multisegment file with polygons (lon, lat) separated by segment headers that contain a -L labelstring with the feature name, selecting a thick black pen and semi-transparent yellow fill, giving a title to the document, and prescribing a particular region limit, try\n    gmt2kml(\"mypolygons.txt\", fill=\"yellow@50+f\", feature_type=:p, title=\"My polygons\",\n            region=(30,90,-20,40), |&gt;=\"mypolygons.kml\")\nTo extract contours and labels every 10 units from the grid temp.nc and plot them in KML, using red lines at 75% transparency and red labels (no transparency), try\n    D = grdcontour(\"temp.nc\", scale=1, annot=\"10+tlabel.txt\", cont=10, dump=true)\n    gmt2kml(D, feature_type=:l, pen=(1,\"red@75\"), not_over=true, |&gt;\"contours.kml\")\n    gmt2kml(\"label.txt\", overlay=true, feature_name=:t, feature_type=:s ilscale=\"n2\",\n            fill=\"red@0+n\", icon=\"-\", append=\"contours.kml\")\nTo instead plot the contours as lines with colors taken from the cpt file contours.cpt, try\n    gmt2kml(\"contours.txt\", feature_type=:l, cmap=\"contours.cpt\", |&gt;=\"contours.kml\")\nTo plot magnetic anomalies as wiggles along track, with positive wiggles painted orange and the wiggle line drawn with a black pen of width 2p, scaling the magnetic anomalies (in nTesla) so that 50 nT equals 1 nm on the map, and place the wiggles 50m above the sea surface, use\n    gmt2kml(\"magnetics_lon_lat_mag.txt\", feature_type=:w, fill=\"orange+f\",\n            pen=2, mode=\"g50\", wiggle_scale=\"50n\", |&gt;=\"wiggles.kml\")"
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#limitations",
    "href": "documentation/modules/gmt2kml.html#limitations",
    "title": "gmt2kml",
    "section": "Limitations",
    "text": "Limitations\nGoogle Earth has trouble displaying filled polygons across the Dateline. For now you must manually break any polygon crossing the dateline into a west and east polygon and plot them separately. Google Earth also has other less obvious limitations on file size or line length. These do not seem to be documented. If features do not show and you are not getting an error, try to reduce the size of the file by splitting things up."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#making-kmz-files",
    "href": "documentation/modules/gmt2kml.html#making-kmz-files",
    "title": "gmt2kml",
    "section": "Making Kmz Files",
    "text": "Making Kmz Files\nUsing the KMZ format is preferred as it takes less space. KMZ is simply a KML file and any data files, icons, or images referenced by the KML, contained in a zip archive. One way to organize large data sets is to split them into groups called Folders. A Document can contain any number of folders. Using scripts you can create a composite KML file using the not_over, overlay options just like you do with GMT plots. See title for switching between folders and documents. The gmt_shell_scripts.sh contains function gmt_build_kmz that can assist in building a KMZ file from any number of KML files (and optionally images they may refer to).\nIf you have made a series of KML files (which may depend on other items like local PNG images), you can consolidate these into a single KMZ file for saving space and for grouping related files together. The bash function gmt_build_kmz in the gmt_shell_functions.sh can be used to do this. You need to source gmt_shell_functions.sh first before you can use it."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#kml-hierarchy",
    "href": "documentation/modules/gmt2kml.html#kml-hierarchy",
    "title": "gmt2kml",
    "section": "Kml Hierarchy",
    "text": "Kml Hierarchy\nGMT stores the different features in hierarchical folders by feature type (when using overlay, not_over or title=tit/foldername), by input file (if not standard input), and by line segment (using the name from the segment header, or feature_name). This makes it more easy in Google Earth to switch on or off parts of the contents of the Document."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#segment-information",
    "href": "documentation/modules/gmt2kml.html#segment-information",
    "title": "gmt2kml",
    "section": "Segment Information",
    "text": "Segment Information\ngmt2kml will scan the segment headers for substrings of the form -L”some label” [also see feature_name discussion] and -T”some text description”. If present, these are parsed to supply name and description tags, respectively, for the current feature."
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#source-code",
    "href": "documentation/modules/gmt2kml.html#source-code",
    "title": "gmt2kml",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmt2kml(cmd0::String; kwargs...) - gmt2kml.jl:70\ngmt2kml(arg1; kwargs...) - gmt2kml.jl:71"
  },
  {
    "objectID": "documentation/modules/gmt2kml.html#see-also",
    "href": "documentation/modules/gmt2kml.html#see-also",
    "title": "gmt2kml",
    "section": "See Also",
    "text": "See Also\ngrd2kml, [kml2gmt], [psconvert]"
  },
  {
    "objectID": "documentation/modules/filter1d.html",
    "href": "documentation/modules/filter1d.html",
    "title": "filter1d",
    "section": "",
    "text": "filter1d(cmd0::String=\"\", arg1=[]; kwargs...)\nTime domain filtering of 1-D data tables"
  },
  {
    "objectID": "documentation/modules/filter1d.html#description",
    "href": "documentation/modules/filter1d.html#description",
    "title": "filter1d",
    "section": "Description",
    "text": "Description\nGeneral time domain filter for multiple column time series data. The user specifies which column is the time (i.e., the independent variable). (See timecol option below). The fastest operation occurs when the input time series are equally spaced and have no gaps or outliers and the special options are not needed. filter1d has options gap_width, quality, and symetry for unevenly sampled data with gaps. For spatial series there is an option to compute along-track distances and use that as the independent variable for filtering."
  },
  {
    "objectID": "documentation/modules/filter1d.html#required-arguments",
    "href": "documentation/modules/filter1d.html#required-arguments",
    "title": "filter1d",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nF or filter : – filter=type | filter=(type,width[,“highpass”])\nSets the filter type. Choose among convolution and non-convolution filters. Append the filter code followed by the full filter width in same units as time column. By default we perform low-pass filtering; use the highpass to select high-pass filtering. Some filters allow for optional arguments and a modifier. Available convolution filter types are:\n\nboxcar: All weights are equal.\ncosine Arch: Weights follow a cosine arch curve.\ngaussian: Weights are given by the Gaussian function.\nf Custom: Instead of width give name of a one-column file with your own weight coefficients.\n\nNon-convolution filter types are:\n\nmedian: Returns median value.\nprobability Maximum likelihood (a mode estimator): Return modal value. If more than one mode is found we return their average value. Append +l or +u if you rather want to return the lowermost or uppermost of the modal values.\nlower: Return the minimum of all values.\nLower: Return minimum of all positive values only.\nupper: Return maximum of all values.\nUpper: Return maximum of all negative values only.\n\nUpper case type B, C, G, M, P, F will use robust filter versions: i.e., replace outliers (2.5 L1 scale off median, using 1.4826 * median absolute deviation [MAD]) with median during filtering.\nIn the case of L | U it is possible that no data passes the initial sign test; in that case the filter will return 0.0. Apart from custom coefficients (f), the other filters may accept variable filter widths by passing width as a two-column time-series file with filter widths in the second column. The filter-width file does not need to be co-registered with the data as we obtain the required filter width at each output location via interpolation. For multi-segment data files the filter file must either have the same number of segments or just a single segment to be used for all data segments."
  },
  {
    "objectID": "documentation/modules/filter1d.html#optional-arguments",
    "href": "documentation/modules/filter1d.html#optional-arguments",
    "title": "filter1d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nD or inc or increment : – inc=increment\nincrement is used when series is NOT equidistantly sampled. Then increment will be the abscissae resolution, i.e., all abscissae will be rounded off to a multiple of increment. Alternatively, resample data with sample1d.\nE or end or ends : – ends=true\nInclude Ends of time series in output. Default loses half the filter-width of data at each end.\nL or gap_width : – gap_width=width\nChecks for Lack of data condition. If input data has a gap exceeding width then no output will be given at that point [Default does not check Lack].\nN or time_col or timecol : – timecol=t_col\nIndicates which column contains the independent variable (time). The left-most column is 0, while the right-most is (n_cols - 1) [Default is 0].\nQ or quality : – quality=q_factor\nAssess Quality of output value by checking mean weight in convolution. Enter q_factor between 0 and 1. If mean weight &lt; q_factor, output is suppressed at this point [Default does not check Quality].\nS or symmetry : – symmetry=factor\nChecks symmetry of data about window center. Enter a factor between 0 and 1. If ( (abs(n_left - n_right)) / (n_left + n_right) ) &gt; factor, then no output will be given at this point [Default does not check Symmetry].\nT or range : – range=(min,max,inc[,:number,:log2,:log10]) | range=[list] | range=file\nDefines the range of the new CPT by giving the lowest and highest z-value (and optionally an interval). If range is not given, the existing range in the master CPT will be used intact. The values produces defines the color slice boundaries. If :number is added as a fourth element then inc is meant to indicate the number of equidistant coordinates instead. Use :log2 if we should take log2 of min and max, get their nearest integers, build an equidistant log2-array using inc integer increments in log2, then undo the log2 conversion. Same for :log10. For details on array creation, see Generate 1D Array.\ncumdist or cumsum : – cumdist=true\nCompute the cumulative distance along the input line. Note that for this the first two columns must contain the spatial coordinates and the accumulated distance is appended after last column of the table.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\n[units]"
  },
  {
    "objectID": "documentation/modules/filter1d.html#examples",
    "href": "documentation/modules/filter1d.html#examples",
    "title": "filter1d",
    "section": "Examples",
    "text": "Examples\nTo filter the remote CO2 data set in the file MaunaLoa_CO2.txt (year, CO2) with a 5 year Gaussian filter, try\n\nusing GMT\nD = filter1d(\"@MaunaLoa_CO2.txt\", filter=(type=:gauss, width=5));\nplot(\"@MaunaLoa_CO2.txt\", legend=\"Raw data\")\nplot!(D, lc=:blue, legend=\"Filtered\", show=1)\n\n\n\n\n\n\n\n\nData along track often have uneven sampling and gaps which we do not want to interpolate using sample1d. To find the median depth in a 50 km window every 25 km along the track of cruise v3312, stored in v3312.txt, checking for gaps of 10km and asymmetry of 0.3:\nD = filter1d(\"v3312.txt\", filter=(:Median,50), range=(0,100000,25), gap_width=10, symetry=0.3)\nTo smooth a noisy geospatial track using a Gaussian filter of full-width 100 km and not shorten the track, and add the distances to the file, use\nD = filter1d(\"track.txt\", range=\"k+a\", ends=true, filter=(:gaussian, 200))"
  },
  {
    "objectID": "documentation/modules/filter1d.html#source-code",
    "href": "documentation/modules/filter1d.html#source-code",
    "title": "filter1d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfilter1d(cmd0::String; kw...) - filter1d.jl:42\nfilter1d(arg1; kw...) - filter1d.jl:43"
  },
  {
    "objectID": "documentation/modules/filter1d.html#see-also",
    "href": "documentation/modules/filter1d.html#see-also",
    "title": "filter1d",
    "section": "See Also",
    "text": "See Also\nsample1d, gmtsplit"
  },
  {
    "objectID": "documentation/modules/flexure.html",
    "href": "documentation/modules/flexure.html",
    "title": "flexure",
    "section": "",
    "text": "Compute flexural deformation of 2-D loads, forces, and bending moments.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/events.html",
    "href": "documentation/modules/events.html",
    "title": "events",
    "section": "",
    "text": "Category: Modules\nDocumentation for the events function."
  },
  {
    "objectID": "documentation/modules/events.html#source-code",
    "href": "documentation/modules/events.html#source-code",
    "title": "events",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nevents(cmd0::String; ...) - plot.jl:1823\nevents(; ...) - plot.jl:1823\nevents(cmd0::String, arg1; kwargs...) - plot.jl:1823"
  },
  {
    "objectID": "documentation/modules/events.html#see-also",
    "href": "documentation/modules/events.html#see-also",
    "title": "events",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/earthtide.html",
    "href": "documentation/modules/earthtide.html",
    "title": "earthtide",
    "section": "",
    "text": "earthtide(; kwargs...)\nCompute grids or time-series of solid Earth tides."
  },
  {
    "objectID": "documentation/modules/earthtide.html#description",
    "href": "documentation/modules/earthtide.html#description",
    "title": "earthtide",
    "section": "Description",
    "text": "Description\nCompute the three components of solid Earth tides as time-series or grids. Optionally compute also Sun and Moon position in (lon, lat). The output can be either in the form of a grid or as a table printed to standard output. The format of the table data is: time north east vertical in units of meters."
  },
  {
    "objectID": "documentation/modules/earthtide.html#arguments",
    "href": "documentation/modules/earthtide.html#arguments",
    "title": "earthtide",
    "section": "Arguments",
    "text": "Arguments\n\nG or grid or outgrid : – outgrid=“name”\nWrite one or more tide component directly to grid files. If more than one component are specified via components then outgrid must contain the format flag %s so that we can embed the component code in the file names (n for north; e for east and v for vertical). If only one component is selected with components than no code is appended to grid name (and no need to set the format flag %s). The grid(s) are computed at the time set by range, if that option is used, or at the now time calculated in UTC from the computer clock. NOTE that when returning the grid(s) to the Julia workspace this option should not be used. It is enough to set variable names as left-hand-side arguments. The grid(s) will be returned as a GMTgrid object(s).\nS or sun_moon : – sun_moon=true\nOutput position of Sun and Moon in geographical coordinates plus distance in meters. Output is a Mx7 matrix where M is the number of times (set by range) and columns are time, sun_lon, sun_lat, sun_dist moon_lon, moon_lat, moon_dist\nL or location : – location=(lon,lat)\nGeographical coordinate of the location where to compute a time-series. Coordinates are geodetic (ellipsoidal) latitude and longitude. GRS80 ellipsoid is used. (Which can be considered equivalent to the WGS84 ellipsoid at the sub-millimeter level.)\nC or components : – components=“x|e,y|n,z|v”\nSelect which component(s) to compute in individual grid(s). When returning the grid to Julia workspace, only one component can be selected (e.g. component=“e” to compute the East component). To save grids on files outgrid must be set. Append comma-separated codes for available components: x or e for the east component; y or n for the north component; and z or v for the vertical component. For example, C=e,v, will write 2 grids. One with east and other with the vertical components. If outgrid is set but not components then the default is to compute the vertical component.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or range : – range=(min,max,inc[,“+n”]) | range=[list] | range=file\nMake evenly spaced time-steps from min to max by inc. Append +n to indicate inc is the number of t-values to produce over the range instead. Append a valid time unit (d | h | m | s) to the increment. If only min is given then we use that date and time for the calculations. If no range is provided get current time in UTC from the computer clock. If no grid(s) or sun_moon are provided then range is interpreted to mean compute a time-series at the location specified by location, thus then location becomes mandatory. When grid(s) and range, only first time T series is considered. Finally, dates may range from 1901 through 2099.\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)"
  },
  {
    "objectID": "documentation/modules/earthtide.html#examples",
    "href": "documentation/modules/earthtide.html#examples",
    "title": "earthtide",
    "section": "Examples",
    "text": "Examples\nTo compute a global grid of the vertical component with a grid step of 30m at noon of 18 Jun 2018, (note: we are using the defaults for region and inc) try\n\nusing GMT\n\nG = earthtide(range=\"2018-06-18T12:00:00\");\nviz(G, coast=true, colorbar=true, title=\"Earth tide at noon 7-July-2022\")\n\n\n\n\n\n\n\n\nTo obtain a one day long time-series, starting at same date, at the -7 W, 37 N and 1 minute interval, try\nD_st = earthtide(range=\"2018-06-18T/2018-06-19T/1m\", location=(-7,37));\n\nAttribute table\n┌─────────┐\n│ Timecol │\n├─────────┤\n│       1 │\n└─────────┘\nBoundingBox: [1.52928e9, 1.5293664e9, -0.055276516851621674, -0.0036339665716482207, -0.045788605358317365, 0.04073662523448053, -0.12387708915816655, 0.17011740397714592]\n\n1441×4 GMTdataset{Float64, 2}\n Row │                Time        East         North   Vertical\n─────┼──────────────────────────────────────────────────────────\n   1 │ 2018-06-18T00:00:00  -0.0220331   0.014779     -0.120817\n   2 │ 2018-06-18T00:01:00  -0.0222226   0.0149741    -0.120428\n   3 │ 2018-06-18T00:02:00  -0.0224126   0.0151673    -0.120035\n...\n1 │ 2018-06-18T00:00:00 -0.0220331 0.014779 -0.120817 2 │ 2018-06-18T00:01:00 -0.0222226 0.0149741 -0.120428 3 │ 2018-06-18T00:02:00 -0.0224126 0.0151673 -0.120035 …\n\nThe get the Sun and Moon position in geographical coordinates at the *now* time\n\n```julia\nD = earthtide(sun_moon=true);"
  },
  {
    "objectID": "documentation/modules/earthtide.html#notes",
    "href": "documentation/modules/earthtide.html#notes",
    "title": "earthtide",
    "section": "Notes",
    "text": "Notes\n\nAll times, both input and output, are in UTC."
  },
  {
    "objectID": "documentation/modules/earthtide.html#references",
    "href": "documentation/modules/earthtide.html#references",
    "title": "earthtide",
    "section": "References",
    "text": "References\nhttp://geodesyworld.github.io/SOFTS/solid.htm"
  },
  {
    "objectID": "documentation/modules/earthtide.html#source-code",
    "href": "documentation/modules/earthtide.html#source-code",
    "title": "earthtide",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/coupe.html",
    "href": "documentation/modules/coupe.html",
    "title": "coupe",
    "section": "",
    "text": "coupe(cmd0::String=\"\", arg1=nothing; kwargs...)\ncoupe - Plot cross-sections of focal mechanisms"
  },
  {
    "objectID": "documentation/modules/coupe.html#description",
    "href": "documentation/modules/coupe.html#description",
    "title": "coupe",
    "section": "Description",
    "text": "Description\nReads data values from tables and plots focal mechanisms in cross-section plane. The name “coupe” comes from the French verb “to cut”. The best translation is a (vertical) cross section. Unless no_project is used, a new dataset is created with transformed coordinates (x, y) and the mechanism projected from the lower focal half-sphere (for horizontal plane) to the half-sphere behind a vertical plane.\nMechanisms within the specified width of the cross-section are included. Events outside this distance are excluded."
  },
  {
    "objectID": "documentation/modules/coupe.html#focal-mechanism-conventions",
    "href": "documentation/modules/coupe.html#focal-mechanism-conventions",
    "title": "coupe",
    "section": "Focal Mechanism Conventions",
    "text": "Focal Mechanism Conventions\n\nAki & Richards (aki= or Sa)\nColumns: lon, lat, depth, strike, dip, rake, magnitude, newlon, newlat, text\n\n\nGlobal CMT (CMT= or Sc)\nColumns: lon, lat, depth, strike1, dip1, rake1, strike2, dip2, rake2, mantissa, exponent, newlon, newlat, text\n\n\nMoment Tensor (moment_tensor= or Sm/Sz/Sd)\nColumns: lon, lat, depth, mrr, mtt, mff, mrt, mrf, mtf, exponent, newlon, newlat, text\n\n\nPartial (partial= or Sp)\nColumns: lon, lat, depth, strike1, dip1, strike2, fault_type, magnitude, newlon, newlat, text\n\n\nPrincipal Axis (principal_axis= or Sx/Sy)\nColumns: lon, lat, depth, T_value, T_azim, T_plunge, N_value, N_azim, N_plunge, P_value, P_azim, P_plunge, exponent, newlon, newlat, text"
  },
  {
    "objectID": "documentation/modules/coupe.html#required-arguments",
    "href": "documentation/modules/coupe.html#required-arguments",
    "title": "coupe",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nA data table (or matrices/datasets) containing focal mechanism parameters. The format depends on the convention specified.\nDefines the cross-section. Choose from four profiles : – Aa=(lon1, lat1, lon2, lat2) | Ab=(lon1, lat1, strike, length) | Ac=(x1, y1, strike, length) | Ad=(x1, y1, strike, length)\n\nAa or cross_ll_pts =(lon1, lat1, lon2, lat2) lon and lat are the longitude and latitude of points 1 and 2 limiting the length of the cross-section.\nAb or cross_ll_azim =(lon1, lat1, strike, length)\n\nlon1 and lat1 are the longitude and latitude of the beginning of the cross-section, strike is the azimuth of the direction of the cross-section, and length is the length along which the cross-section is made (in km). The other parameters are the same as for Aaa option.\n\nAc or cross_xy_pts =(x1, y1, x2, y2)\n\nThe same as Aa option with x and y given as Cartesian coordinates.\n\nAd or cross_xy_azim =(x1, y1, strike, length)\n\nThe same as Ab option with x and y given as Cartesian coordinates.\n\nAvailable modifiers (as named tuple elements):\n\nreport : Simply report the determined region and exit (no plotting takes places). By default (report=:n) we report a single numerical record with xmin xmax ymin ymax. Use report=:t to instead report a text record in the format region=\"xmin/xmax/ymin/ymax\".\ndip : Dip of the plane on which the cross-section is made [Default: 90].\nregion : Get the plot domain from the cross-section parameters; append a for automatic rounding of the domain, e for the exact limits [Default], or dx to round the distances to integer multiples of dx.\nwidth : The width in km of the cross-section on each side of a vertical plane or above and under an oblique plane [infinity], and min and max are the limits on distances from horizontal plane in km, along steepest descent direction.\nzrange : control the depth range by appending a for automatic rounding, e to use the exact fit values [Default], dz to round depths to integer multiples of dz, or give desired min/max range. For a and dz you may prepend s to clamp the minimum depth at the surface (0). When automatic depth range selection is in effect we consider the size of the symbols so that no symbol close to the depth limits will be clipped.\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or convention : Convention-specific options\nSelects the input convention and symbol size. Choose from:\n\naki or Sa : Aki & Richards convention\nCMT or Sc : Global CMT convention\n\nmoment_tensor or mt or Sm : Seismic moment tensor (full)\ndev or Sz : Deviatoric moment tensor (zero trace)\ndc or Sd : Double couple from moment tensor (zero trace and determinant)\npartial or Sp : Partial focal mechanism\naxis or principal_axis or Sx : Principal axis\nprincipal or Sy : Best double couple from principal axis\n\nAppend scale to set the symbol size. Use tuple form to add modifiers:\n\naki=(scale=val, ...) or CMT=(scale=val, ...) etc.\n\nAvailable modifiers (as named tuple elements):\n\nangle : Rotate text angle\nfont : Set text font\n\njustify : Text justification\nradius_moment : Radius will be proportional to the seismic moment\nsame_size : Plot the same size for any magnitude\noffset : Offset text by dx/dy\nrefmag : Reference magnitude for scaling"
  },
  {
    "objectID": "documentation/modules/coupe.html#optional-arguments",
    "href": "documentation/modules/coupe.html#optional-arguments",
    "title": "coupe",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap : – cmap=cpt\nGive a CPT to determine compressive quadrant fill based on depth (3rd column).\nD or offset : – offset=true | offset=(dist_is_geog=true, fill=…, offset=.., pen=…, size=…)\nOffsets beachballs with connecting line and symbol. Modifiers:\n\ndist_is_geog : If alternate geographical coordinates are given in the two columns, convert them to distance, depth coordinates.\nfill : Symbol fill color\noffset : Interpret the contents of the two columns as plot offsets instead, or append fixed offset dx[/dy] for all events.\npen : Line pen attributes\nsize : Set the size of the symbol. Prepend any of a|c|d|g|h|i|n|p|s|t|x to change the symbol fron the default [c]\n\nE or extensionfill : – extensionfill=fill\nSelects filling of extensive quadrants [Default is white].\nF : – Fa=true | Fa=[size[/Psymbol[Tsymbol]]] , Fe|Fg|Fr=fill , Fp|Ft|Fz=pen , Fo=true\nAliases:\n\nFa or PT_axes : Computes and plots P and T axes with symbols. Optionally specify size and (separate) P and T axis symbols from the following: (c) circle, (d) diamond, (h) hexagon, (i) inverse triangle, (p) point, (s) square, (t) triangle, (x) cross. [Default: 6p/cc]\nFe or T_axis_color : Sets the color or fill pattern for the T axis symbol. [Default as set by extensionfill]\nFo or psvelo : Old psvelomeca format (no depth in 3rd column)\nFg or P_axis_color : Sets the color or fill pattern for the P axis symbol. [Default as set by extensionfill]\nFr or label_box : Draw a box behind the label (if any). [Default fill is white]\nFp or P_axis_pen : Draws the P axis outline using default pen (see W), or sets pen attributes.\nFt or T_axis_pen : Draws the T axis outline using default pen (see W), or sets pen attributes.\nFz or zero_trace : Overlay zero trace moment tensor using default pen (see W), or sets pen attributes.\n\nG or fill or extensionfill : – fill=color\nSelects filling of compressive quadrants [Default is black].\nH or scale : – scale=true | scale=scale\nScale symbol sizes and pen widths on a per-record basis using the scale read from the data file. The symbol size is either provided by convention or via the input size column. Alternatively, append a constant scale that should be used instead of reading a scale column.\nI or intens or intensity : – intens=val | intens=:a\nUse the supplied intens value (nominally in the ±1 range) to modulate the compressional fill color by simulating illumination [none]. If no intensity is provided we will instead read intens from an extra data column after the required input columns determined by convention.\nL or pen_outline : – pen_outline=pen\nDraws the “beach ball” outline using specified pen attributes.\nM or same_size or samesize : – same_size=true\nUse the same size for all beachballs. Size is set from the magnitude columns, but the same size is used regardless of magnitude.\nN or no_clip or noclip : – no_clip=true\nDo NOT skip symbols that fall outside the map border [Default clips symbols].\nT or nodal : – nodal=plane | nodal=(plane=val, pen=…)\nPlot nodal planes and circumference only. Specify which plane(s) to draw:\n\n0 : Both planes\n1 : Only first nodal plane\n\n2 : Only second nodal plane\n\nUse tuple form to set pen: nodal=(plane=0, pen=pen_spec)\nFor double couple mechanisms, the nodal option renders the beach ball transparent by drawing only the nodal planes and the circumference. For non-double couple mechanisms, nodal=0 option overlays best double couple transparently.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen : – pen=pen\nSet pen attributes for text string or default pen attributes for fault plane edges. [Default: 0.25p,black,solid].\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/coupe.html#data-column-order",
    "href": "documentation/modules/coupe.html#data-column-order",
    "title": "coupe",
    "section": "Data Column Order",
    "text": "Data Column Order\nThe convention option determines how many size columns are required to generate the selected symbol, but if size is not given then we expect to read size from file. In addition, your use of options scale, intens and transparency will require extra columns. The order of the data record is fixed regardless of option order, even if not all items may be activated. We expect data columns to come in the following order:\nlon lat depth symbol-columns [size] [scale] [intens] [transp [transp2]] [trailing-text]\nwhere items given in brackets are optional and under the control of the stated options: convention without a size selects the optional size-columns, scale selects the optional scale column, intens selects the optional intens column, and transparency selects the optional transp column(s). Trailing text is always optional. Notes: (1) depth is normally required but will not be expected if Fo is given to meca. (2) You can use incols to rearrange your data record to match the expected format."
  },
  {
    "objectID": "documentation/modules/coupe.html#references",
    "href": "documentation/modules/coupe.html#references",
    "title": "coupe",
    "section": "References",
    "text": "References\nAki, K., & Richards, P. G. (1980). Quantitative seismology: theory and methods. San Francisco: W. H. Freeman.\nDahlen, F. A., & Tromp, J. (1998). Theoretical global seismology. Princeton, N.J: Princeton University Press.\nFrohlich, C. (1996). Cliff’s Nodes Concerning Plotting Nodal Lines for P, SH and SV. Seismological Research Letters, 67(1), 16–24, https://doi.org/10.1785/gssrl.67.1.16."
  },
  {
    "objectID": "documentation/modules/coupe.html#source-code",
    "href": "documentation/modules/coupe.html#source-code",
    "title": "coupe",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncoupe(cmd0::String; kwargs...) - psmeca.jl:101\ncoupe(arg1; kwargs...) - psmeca.jl:102"
  },
  {
    "objectID": "documentation/modules/coupe.html#see-also",
    "href": "documentation/modules/coupe.html#see-also",
    "title": "coupe",
    "section": "See Also",
    "text": "See Also\nmeca, [polar], velo"
  },
  {
    "objectID": "documentation/modules/contourf.html",
    "href": "documentation/modules/contourf.html",
    "title": "contourf",
    "section": "",
    "text": "contourf(cmd0::String=\"\", arg1=nothing, arg2=nothing; kwargs...)\nCreate filled contour mapps."
  },
  {
    "objectID": "documentation/modules/contourf.html#description",
    "href": "documentation/modules/contourf.html#description",
    "title": "contourf",
    "section": "Description",
    "text": "Description\nThis module is a wrapper to grdview, contour and grdcontour and as such it works with two different kinds of input data. If input is a grid (either a grid file name or a GMTgrid object) it will make a filled contour with grdview and optionally overlay contours by calling grdcontour. If, on the other hand, the input data is table data file or a Mx3 array (or GMTdataset), it first compute a Delaunay triangulation and makes the plot from it. In this later case, the job is done by contour module alone.\nOptionaly one can plot the so called Tanaka contours. These are contour lines whose thickness and intensity vary based on illumination direction, creating an illusion of 3D relief. Illuminated slopes get lighter/thinner lines, shaded slopes get darker/thicker lines. This is a slow method (not to be used with large grids) but with a nice visual effect. See the tanaka option.\nThe region option can be used to select a map region larger or smaller than that implied by the extent of the grid."
  },
  {
    "objectID": "documentation/modules/contourf.html#required-arguments",
    "href": "documentation/modules/contourf.html#required-arguments",
    "title": "contourf",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe input data set to be filled/contoured. It can be 2-D gridded data GMTgrid) or a Mx3 table (or GNTdataset). In these cases the data type detection is automatic. Alterativelly, one can provide the file name. In that case, if the data has known extensions (.grd or .nc among others for grids or .dat, .bin (need to use iput_type) for tables) the type detection is also automatic. And, for grids, passing a file name is actually the most efficient way os using thsi module. Still, if data type is not automatically detected, we can help the module by passing the grid=true or data=true options.\nNot exactly required but convinient, the second input argument can be a GMTcpt object. The advantage of this is that it releases the contour option to pass only options that control what contours to plot."
  },
  {
    "objectID": "documentation/modules/contourf.html#optional-arguments",
    "href": "documentation/modules/contourf.html#optional-arguments",
    "title": "contourf",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or annot : – annot=annot_int | annot=(int=annot_int, disable=true, single=true, labels=labelinfo)\nannot_int is annotation interval in data units; it is ignored if contour levels are given in a file. [Default is no annotations]. Use annot=(disable=true,) to disable all annotations implied by cont. Alternatively do annot=(single=true, int=val) to plot val as a single contour. The optional labelinfo controls the specifics of the label formatting and consists of a named tuple with the following control arguments [Label formatting]\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or cont or contour or contours or levels : – cont=cont_int\nThe contours to be drawn may be specified in one of two possible ways:\n\nIf cont_int is a GMTcpt object (or a string and has the suffix “.cpt” and can be opened as a file). The color boundaries are then used as contour levels. If the CPT has annotation flags in the last column then those contours will be annotated. By default all contours are labeled; use annot=(disable=true,)) (or annot=:none) to disable all annotations.\nIf cont_int is a constant or an array it means plot those contour intervals. This works also to draw single contours. E.g. contour=[0] will draw only the zero contour. The annot option offers the same possibility so they may be used together to plot a single annotated contour and another single non-annotated contour, as in anot=[10], cont=[5] that plots an annotated 10 contour and an non-annotated 5 contour. If annot is set and cont is not, then the contour interval is set equal to the specified annotation interval.\n\nIf no contour option and no GMTcpt are passed then for grid a default color map is computed and all of those automatically contours are drwan. Also, no GMTcpt and contour=[array] computes a cmap with only the contour values specified in array. When passing a Mx3 array or a GMTdataset the default behavior is basically the same.\nE or index : – index=tri_network\nGive a Mx3 array or name of file with network information. Each record must contain triplets of node numbers for a triangle [Default computes these using Delaunay triangulation (see triangulate)].\nG or labels : – labels=()\nThe required argument controls the placement of labels along the quoted lines. Choose among five controlling algorithms as explained in [Label formatting]\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nQ or cut : – cut=np | cut=length&unit[+z]\nDo not draw contours with less than np number of points [Draw all contours]. Alternatively, give instead a minimum contour length in distance units, including c (Cartesian distances using user coordinates) or C for plot length units in current plot units after projecting the coordinates. Optionally, append +z to exclude the zero contour.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or smooth : – smooth=smoothfactor\nResample the contour lines at roughly every (gridbox_size/smoothfactor) interval. This option should be used only when input data is a table.\nS or skip : – skip=true|“t”\nSkip all input xyz points that fall outside the region [Default uses all the data in the triangulation]. Alternatively, use skip=“t” to skip triangles whose three vertices are all outside the region. This option should be used only when input data is a grid.\nT or ticks : – ticks=(local_high=true, local_low=true, gap=gap, closed=true, labels=labels)\nWill draw tick marks pointing in the downward direction every gap along the innermost closed contours only; set closed=true to tick all closed contours. Use gap=(gap,length) and optionally tick mark length (append units as c, i, or p) or use defaults [“15p/3p”]. User may choose to tick only local highs or local lows by specifying local_high=true, local_low=true, respectively. Set labels to annotate the centers of closed innermost contours (i.e., the local lows and highs). If no labels (i.e, set labels=““) is set, we use - and + as the labels. Appending exactly two characters, e.g., labels=:LH, will plot the two characters (here, L and H) as labels. For more elaborate labels, separate the low and hight label strings with a comma (e.g., labels=“lo,hi”). If a file is given by cont, and ticks is set, then only contours marked with upper case C or A will have tick marks [and annotations].\ntanaka : – tanaka=true | tanaka=azimuth\nDraw Tanaka-style contours with varying line thickness and intensity to simulate illumination from a given direction. The azimuth (in degrees) gives the illumination direction (default is 315 degrees, i.e., NW). Tanaka contours are a bit slow to compute so avoid using this option with large grids.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen : – pen=(annot=true, contour=true, pen=pen, colored=true, cline=true, ctext=true)\nannot=true if present, means to annotate contours or contour=true for regular contours [Default]. The pen sets the attributes for the particular line. Default pen for annotated contours: pen=(0.75,:black). Regular contours use pen=(0.25,:black). Normally, all contours are drawn with a fixed color determined by the pen setting. This option may be repeated, for example to separate contour and annotated contours settings. For that the syntax changes to use a Tuple of NamedTuples, e.g. pen=((annot=true, contour=true, pen=pen), (annot=true, contour=true, pen=pen)). If the modifier pen=(cline=true,) is used then the color of the contour lines are taken from the CPT (see cont). If instead pen=(ctext=true,) is appended then the color from the cpt file is applied to the contour annotations. Select pen=(colored=true,) for both effects.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/contourf.html#examples",
    "href": "documentation/modules/contourf.html#examples",
    "title": "contourf",
    "section": "Examples",
    "text": "Examples\nUsing a grid\n\nusing GMT   # Hide\n\n    G = peaks();\n    C = makecpt(T=(-7,9,2));\n\n    contourf(G, show=1)\n    contourf(G, C=[-2, 0, 2, 5], show=1)\n    contourf(G, C, contour=[-2, 0, 2, 5], show=1)\n    contourf(G, C, annot=[-2, 0, 2, 5], show=1)\n    contourf(G, C, annot=2, show=1)\n    contourf(G, C, contour=1, annot=[-2, 0, 2, 5], show=1)\n    contourf(G, C, annot=:none, show=1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing a table data.\n\nusing GMT\n\n    d = [0 2 5; 1 4 5; 2 0.5 5; 3 3 9; 4 4.5 5; 4.2 1.2 5; 6 3 1; 8 1 5; 9 4.5 5];\n    contourf(d, limits=(-0.5,9.5,0,5), pen=0.25, labels=(line=(:min,:max),), show=1)\n\n\n\n\n\n\n\n\nTanaka contours\n\nusing GMT   # Hide\nG = peaks();\ncontourf(G, tanaka=true, show=true)"
  },
  {
    "objectID": "documentation/modules/contourf.html#source-code",
    "href": "documentation/modules/contourf.html#source-code",
    "title": "contourf",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncontourf(cmd0::String; ...) - contourf.jl:78\ncontourf(; ...) - contourf.jl:78\ncontourf(cmd0::String, arg1; ...) - contourf.jl:78\ncontourf(arg1, arg2; kw...) - contourf.jl:244\ncontourf(arg1; ...) - contourf.jl:244\ncontourf(cmd0::String, arg1, arg2, first::Bool, d::Dict{Symbol, Any}) - contourf.jl:96\ncontourf(cmd0::String, arg1, arg2; first, kwargs...) - contourf.jl:78"
  },
  {
    "objectID": "documentation/modules/colorbar.html",
    "href": "documentation/modules/colorbar.html",
    "title": "colorbar",
    "section": "",
    "text": "colorbar(arg1=nothing; kwargs...)\nPlot a gray or color scale-bar on maps"
  },
  {
    "objectID": "documentation/modules/colorbar.html#description",
    "href": "documentation/modules/colorbar.html#description",
    "title": "colorbar",
    "section": "Description",
    "text": "Description\nPlots gray scales or color scales on maps. Both horizontal and vertical scales are supported. For CPTs with gradational colors (i.e., the lower and upper boundary of an interval have different colors) we will interpolate to give a continuous scale. Variations in intensity due to shading/illumination may be displayed by setting the option shade. Colors may be spaced according to a linear scale, all be equal size, or by providing a file with individual tile widths. The font used for the annotations along the scale and optional units is specified by FONT_ANNOT_PRIMARY. If a label is requested, it is plotted with FONT_LABEL."
  },
  {
    "objectID": "documentation/modules/colorbar.html#required-arguments",
    "href": "documentation/modules/colorbar.html#required-arguments",
    "title": "colorbar",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nD or pos or position : – pos=(map=true, inside=true, outside=true, norm=true, paper=true, anchor=XX, size=XX, triangles=true, justify=code, offset=XX, horizontal=true, move_annot=true[:a|:l|:u], neon=true, nan=true)\n\nDefines the reference point on the map for the color scale using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inside=true or outside=true (the default) for setting anchor via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). All but paper=true requires both region and proj to be specified.\nFor inside or outside with codes TC, BC, ML, MR (i.e., centered on one of the map sides) we pre-calculate all further settings. Specifically, the length is set to 80% of the map side, horizontal or vertical depends on the side, the offset is MAP_LABEL_OFFSET for outside with an extra offset MAP_FRAME_WIDTH for outside, and annotations are placed on the side of the scale facing away from the map frame. However, you can override any of these with these modifiers. Use size=(length,width) to set the color bar size. If width is not specified then it is set to 4% of the given length. Give a negative length to reverse the scale bar. Use horizontal=true to get a horizontal scale [Default is vertical]. By default, the anchor point on the scale is assumed to be the bottom left corner (BL), but this can be changed by justify=code where code is a 2-char justification code (see text). Note: with the default outside=true, the justify defaults to the same as anchor, if inside=true is used then justify defaults to the mirror opposite of anchor. Finally,add offset=(dx,dy) to offset the color scale by dx, dy away from the anchor point in the direction implied by justify (or the direction implied by inside or outside). Add sidebar triangles for back- and/or foreground colors with triangles=true. Use triangles=:f (foreground) or triangles=:b (background) for only one sidebar triangle [Default gives both]. Optionally,append triangle height [Default is half the barwidth]. Move text to opposite side with move_annot=true[:a|:l|:u]. Horizontal scale bars: Move annotations and labels above the scale bar [Default is below]; the unit remains on the left. Vertical scale bars: Move annotations and labels to the left of the scale bar [Default is to the right]; the unit remains below. Append one or more of a, l or u to control which of the annotations, label, and unit that will be moved to the opposite side. Use neon=true if you want to print a vertical label as a column of characters (does not work with special characters). Append nan=true to plot a rectangle with the NaN color at the start of the bar, use text instead of true to change label from NaN."
  },
  {
    "objectID": "documentation/modules/colorbar.html#optional-arguments",
    "href": "documentation/modules/colorbar.html#optional-arguments",
    "title": "colorbar",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet annotation, tick, and gridline interval for the colorbar. More at [frame] The x-axis label will plot beneath a horizontal bar (or vertically to the right of a vertical bar), except when using the move_annot modifier of the pos option. As an option, use the y-axis label to plot the data unit to the right of a horizontal bar (and above a vertical bar). When using frame=(annot=:auto,) or frame=(annot=:auto,ticks=:auto) annotation and/or minor tick intervals are chosen automatically. If frame is omitted, or no annotation intervals are provided, the default is to annotate every color level based on the numerical entries in the CPT (which may be overridden by ULB flags in the CPT). The exception to this rule is for CPT files that were scaled to fit the range of a grid exactly and thus have arbitrary color levels; these will trigger an automatic frame=(annot=:auto,ticks=:auto) setting. To specify custom text annotations for intervals, you must append ; annotation to each z-slice in the CPT.\nC or color or cmap : color=cpt\nNote: If not given, the module will check if we have a valid current_cpt stored in memory (makecpt does store it). If there is one, fine, otherwise GMT will error. Where cpt is the CPT to be used. By default all color changes are annotated. To use a subset, add an extra column to the CPT with a L, U, or B to annotate Lower, Upper, or Both color segment boundaries (but see frame). We can understand pattern specifications in the CPT. For CPTs where the z range is in meters, it may be useful to change to another unit when plotting. To do so, append +Uunit to the file name. Likewise, if the CPT uses another unit than meter and you wish to plot the CPT versus meters, append +uunit. If a GMT master dynamic CPT is given instead then its z-range will be set to its default range (if it has one) before plotting.\nF or box : – box=(clearance=val, fill=color, inner=true, pen=pen, rounded=true, shaded=XX)\nWithout further options, draws a rectangular border around the scale using MAP_FRAME_PEN; specify a different pen with pen=pen, (see [Pen attributes]). Add fill=color, where color is any valid color setting (see [Setting color]), to fill the scale panel [no fill]. Add clearance=val where val is either gap or (xgap,ygap), or (lgap,rgap,bgap,tgap) where these items are uniform, separate in x- and y-direction, or individual side spacings between scale and border. Use inner=true to draw a secondary, inner border as well. We use a uniform gap between borders of 2p and the MAP_DEFAULTS_PEN unless other values are specified (like inner=“gap/pen”). Add rounded=true to draw rounded rectangular borders instead, with a 6p corner radius. You can override this radius by using another value instead of true. Finally, use shadded=true or shadded=(dx,dy) or shadded=shade to draw an offset background shaded region. Here, dx/dy indicates the shift relative to the foreground frame [4p/-4p]and shade sets the fill style to use for shading (“gray50”).\nG or truncate : – truncate=(zlo,zhi)\nTruncate the incoming CPT so that the lowest and highest z-levels are to zlo and zhi. If one of these equal NaN then we leave that end of the CPT alone. The truncation takes place before the plotting.\nI or shade : – shade=true | shade=max_intens | shade=(low_i,high_i)\nAdd illumination effects. Optionally, set the range of intensities from - to shade=max_intens. If not specified, 1 is used. Alternatively, use shade=(low,high) intensities to specify an asymmetric range [Default is no illumination].\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or equal or equal_size : – equal=true | equal=(range=true, gap=val)\nGives equal-sized color rectangles. Default scales rectangles according to the z-range in the CPT (Also see zfile). If set, any equal interval annotation set with frame will be ignored. If equal=(gap=val,) is appended and the CPT is discrete we will center each annotation on each rectangle, using the lower boundary z-value for the annotation. If equal=(range=true,) is prepended we annotate the interval range instead. If shade is used then each rectangle will have its constant color modified by the specified intensity.\nM or monochrome : – monochrome=true\nForce a monochrome graybar using the (television) YIQ transformation.\nN or dpi : – dpi=true | *dpi=:p | dpi=number\nControls how the color scale should be encoded graphically. To preferentially draw color rectangles (e.g., for discrete colors), use dpi=:p. Otherwise we will preferentially draw images (e.g., for continuous colors). Optionally use dpi=number** effective dots-per-inch for rasterization of color scales [600].\nQ or log : – log=true\nSelect logarithmic scale and power of ten annotations. All z-values in the CPT will be converted to p = log10(z) and only integer p values will be annotated using the 10^p format [Default is linear scale].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or nolines or appearance : – nolines=true\nDo not separate different color intervals with black grid lines.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or scale : – scale=true\nMultiply all z-values in the CPT by the provided scale. By default the CPT is used as is.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nZ or zfile : zfile=“file”\nFile with colorbar-width per color entry. By default, width of entry is scaled to color range, i.e., z = 0-100 gives twice the width as z = 100-150 (Also see equal).\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/colorbar.html#examples",
    "href": "documentation/modules/colorbar.html#examples",
    "title": "colorbar",
    "section": "Examples",
    "text": "Examples\nTo plot a horizontal color scale (12 cm long; 0.5 cm wide) at the reference point (8,1) (paper coordinates) with justification at top center and automatic annotation interval, do\n\nusing GMT\n\nmakecpt(range=(-200,1000,100), cmap=:rainbow)\ncolorbar(pos=(paper=true, anchor=(8,1), size=(12,0.5), justify=:TC, horizontal=true),\n        frame=(annot=:auto, ticks=:auto, xlabel=\"topography\", ylabel=:km), show=true)\n\n\n\n\n\n\n\n\nTo append a vertical color scale (7.5 cm long; 1.25 cm wide) to the right of a plot that is 6 inch wide and 4 inch high, using illumination, and show back- and foreground colors, and annotating every 5 units, we provide the reference point and select the left-mid anchor point via\n\ncolorbar(pos=(paper=true, anchor=\"6.5i/2i\", justify=(:LM,\"2i\"), size=(7.5,1.2), triangles=true),\n        cmap=:geo, shade=true, xaxis=(annot=1000, label=:BATHYMETRY), ylabel=:m, show=1)\n\n\n\n\n\n\n\n\nTo overlay a horizontal color scale (10 centimeters long and default width) above a Mercator map produced by a previous call, ensuring a 2 cm offset from the map frame, use\n\ncolorbar!(region=(0,10,0,10), pos=(justify=:CT, width=10, offset=(0,2), horizontal=true), cmap=\"colors.cpt\", show=1)\n\npsscale [ERROR]: GMT_Read_Data: File not found: colors.cpt\n\n\n\nSomething went wrong when calling the module. GMT error number = 16\n\nStacktrace:\n  [1] error(s::String)\n    @ Base .\\error.jl:35\n  [2] gmt(cmd::String, args::Nothing)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmt_main.jl:166\n  [3] finish_PS_module(d::Dict{Symbol, Any}, cmd::Vector{String}, opt_extra::String, K::Bool, O::Bool, finish::Bool, args::Nothing)\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4505\n  [4] finish_PS_module\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4429 [inlined]\n  [5] prep_and_call_finish_PS_module\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4419 [inlined]\n  [6] prep_and_call_finish_PS_module\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:4418 [inlined]\n  [7] colorbar(arg1::Nothing; first::Bool, kwargs::@Kwargs{region::NTuple{4, Int64}, pos::@NamedTuple{justify::Symbol, width::Int64, offset::Tuple{Int64, Int64}, horizontal::Bool}, cmap::String, show::Int64})\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\psscale.jl:53\n  [8] colorbar\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\psscale.jl:50 [inlined]\n  [9] colorbar!\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\psscale.jl:94 [inlined]\n [10] top-level scope\n    @ In[4]:1\n\n\n\nShow automatic placement of color bars when selecting a side mid-point.\n\nC = makecpt(cmap=:jet, range=(0,100));\nbasemap(region=(0,30,0,45), frame=(axes=:wsne, annot=:auto, ticks=:auto))\ncolorbar!(position=(inside=true, anchor=:BC), xaxis=(annot=:auto, ticks=:auto),\n          box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(outside=true, anchor=:BC), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(inside=true, anchor=:TC), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(outside=true, anchor=:TC), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(inside=true, anchor=:ML), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(outside=true, anchor=:ML), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(inside=true, anchor=:MR), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C)\ncolorbar!(position=(anchor=:MR,), box=(pen=(0.25,:red),), ylabel=\"@.C\", cmap=C, show=true)"
  },
  {
    "objectID": "documentation/modules/colorbar.html#source-code",
    "href": "documentation/modules/colorbar.html#source-code",
    "title": "colorbar",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncolorbar(; ...) - psscale.jl:50\ncolorbar(arg1::Union{Nothing, GMTcpt}; first, kwargs...) - psscale.jl:50"
  },
  {
    "objectID": "documentation/modules/clip.html",
    "href": "documentation/modules/clip.html",
    "title": "clip",
    "section": "",
    "text": "clip(cmd0::String=\"\", arg1=[]; kwargs...)\nInitialize or terminate polygonal clip paths"
  },
  {
    "objectID": "documentation/modules/clip.html#description",
    "href": "documentation/modules/clip.html#description",
    "title": "clip",
    "section": "Description",
    "text": "Description\nReads (x,y) tables (or a file) and draws polygons that are activated as clipping paths. Several files may be read to create complex paths consisting of several non-connecting segments. Only marks that are subsequently drawn inside the clipping path will be shown. To determine what is inside or outside the clipping path, we use the even-odd rule. When a ray drawn from any point, regardless of direction, crosses the clipping path segments an odd number of times, the point is inside the clipping path. If the number is even, the point is outside. The invert option, reverses the sense of what is the inside and outside of the paths by plotting a clipping path along the map boundary. After subsequent plotting, which will be clipped against these paths, the clipping may be deactivated by running the module a second time with the endclip option only."
  },
  {
    "objectID": "documentation/modules/clip.html#required-arguments",
    "href": "documentation/modules/clip.html#required-arguments",
    "title": "clip",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nC or endclip : – endclip=true or endclip=n\nMark end of existing clip path(s). No input file will be processed. No projection information is needed unless [frame] has been selected as well. With no arguments we terminate all active clipping paths. Experts may restrict the termination to just n of the active clipping path by passing that as the argument.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax, zmin, zmax) | limits=(BB=(xmin, xmax, ymin, ymax, zmin, zmax),) | …more\nSpecify the region of interest. Default limits are computed from data extents. More at [limits](../common_opts/opt_R.html)\nA or steps : – steps=true | steps=:meridian|:parallel|:x|:y|:r|:theta\nBy default, geographic line segments (as indicated for example by the colinfo option) are drawn as great circle arcs. To draw them as straight lines, use the steps=true. Alternatively, use steps=:meridian to draw the line by first following a meridian, then a parallel. Or append steps=:parallel to start following a parallel, then a meridian. (This can be practical to draw a line along parallels, for example). For Cartesian data, points are simply connected, unless you use steps=:x or steps=:y to draw stair-case curves that whose first move is along x or y, respectively. If your Cartesian data are polar (theta, r), use steps=:t or steps=:r to construct stair-case paths whose first move is along theta or r, respectively.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nN or invert : – invert=true\nInvert the sense of what is inside and outside. For example, when using a single path, this means that only points outside that path will be shown. Cannot be used together with [frame].\nT or clipregion : – clipregion=\nRather than depending on input data, simply turn on clipping for the current map region. Cannot be used together with [frame].\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/clip.html#examples",
    "href": "documentation/modules/clip.html#examples",
    "title": "clip",
    "section": "Examples",
    "text": "Examples\nTo see the effect of a simple clip path which result in some symbols being partly visible or missing altogether, try:\n\nusing GMT\nclip([0 0; 5 1; 5 5], region=(0,6,0,6), figscale=2.5, pen=(1,:blue))\nplot!(\"@tut_data.txt\", fill=:red, marker=:circ, ms=2, region=:same)\nclip!(endclip=true, frame=:same, show=true)\n\n\n\n\n\n\n\n\nwhere we activate and deactivate the clip path. Note we also draw the outline of the clip path to make it clear what is being clipped.\nBut although the above example shows how we can fine tune what is plotted under the clip path, and we could have drawn more elements if whiched, it is also a bit cumbersome for simple plots. A much more straightforward command can be done using the nested clip program that is available to all plotting modules. This one-liner produces almost the same plot.\n\nusing GMT\nplot(\"@tut_data.txt\", fill=:red, marker=:circ, ms=2, region=(0,6,0,6), clip=[0 0; 5 1; 5 5], show=true)"
  },
  {
    "objectID": "documentation/modules/clip.html#source-code",
    "href": "documentation/modules/clip.html#source-code",
    "title": "clip",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nclip(; kwargs...) - psclip.jl:35\nclip(cmd0::String; kwargs...) - psclip.jl:30\nclip(arg1; kwargs...) - psclip.jl:31"
  },
  {
    "objectID": "documentation/modules/clip.html#see-also",
    "href": "documentation/modules/clip.html#see-also",
    "title": "clip",
    "section": "See Also",
    "text": "See Also\nbasemap"
  },
  {
    "objectID": "documentation/modules/boxplot.html",
    "href": "documentation/modules/boxplot.html",
    "title": "boxplot",
    "section": "",
    "text": "boxplot(data, grp=[]; pos=nothing, kwargs...)\nDraw a box-and-whisker style plot. The input data can take several different forms.\nboxplot(data::AbstractVector{&lt;:Real}; kwargs...)\nDraws a single boxplot. Options in kwargs provide fine settings for the boxplot\nboxplot(data::AbstractVector{&lt;:Real}, grp::AbstractVector, ...) Use the categorical vector (made of integers or text strings) grp break down a the data column vector in cathegories (groups).\nboxplot(data::AbstractMatrix{&lt;:Real}; pos=Vector{&lt;:Real}, ...) where pos is a coordinate vector (or a single location when data is a vector) where to plot the boxes. Default plots them at 1:n_boxes or 1:n_groups.\nboxplot(data::GMTdatset{&lt;:Real}; pos=Vector{Real}(), ...) Like the above case but the input data is stored in a GMTdataset\nboxplot(data::Vector{Vector{&lt;:Real}}; pos=Vector{Real}(), ...) Similar to the Matrix case but here each data vector used to compute the statistics can have a different number of points. There will be as many boxplots as length(data)\nboxplot(data::Array{T&lt;:Real,3}; pos=Vector{Real}(), groupwidth=0.75, ccolor=false, ...) Draws G groups of boxplots of N columns boxes. - groupWidth: Specify the proportion of the x-axis interval across which each x-group of boxes should be spread. The default is 0.75. - ccolor: Logical value indicating whether the groups have constant color (when fill=true is used) or have variable color (the default). - fill: If fill=true paint the boxes with a pre-defined color scheme. Otherwise, give a list of colors to paint the boxes. - fillalpha: When the fill option is used, we can set the transparency of filled violins with this option that takes in an array (vec or 1-row matrix) with numeric values between [0-1] or ]1-100], where 100 (or 1) means full transparency. - separator: If = true plot a black line separating the groups. Otherwise provide the pen settings of those lines. - ticks or xticks or yticks: A tuple with annotations interval and labels. E.g. xticks=(1:5, [“a”, “b”, “c”, “d”]) where first element is an AbstractArray and second an array or tuple of strings or symbols.\nboxplot(data::Vector{Vector{Vector{&lt;:Real}}}, ...) Like the above but here the groups (length(data)) can have a variable number of elements and each have its own size."
  },
  {
    "objectID": "documentation/modules/boxplot.html#examples",
    "href": "documentation/modules/boxplot.html#examples",
    "title": "boxplot",
    "section": "Examples",
    "text": "Examples\nCreate a boxplot with five boxes, name each, plot the outliers, colorize with the default color schema and add notches (this needs GMT &gt;= 6.5).\n\nusing GMT\nboxplot(randn(100,5), outliers=(size=\"5p\",), ticks=[\"A\",\"B\",\"C\",\"D\",\"E\"], fill=true, notch=true, show=true)\n\n\n\n\n\n\n\n\nAn horizontal boxplot with default colors, displaying outliers as 6p black stars. Noches are also shown but this requires GMT6.5.\n\nusing GMT\nboxplot(randn(50,6), notch=true, fill=true, outliers=(size=\"6p\",), hbar=true, show=1)"
  },
  {
    "objectID": "documentation/modules/boxplot.html#source-code",
    "href": "documentation/modules/boxplot.html#source-code",
    "title": "boxplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nboxplot(data::Array{Array{Vector{T}, 1}, 1}; pos, first, groupwidth, ccolor, kwargs...) where T - statplots.jl:308\nboxplot(data::Array{T, 3}; pos, first, groupwidth, ccolor, kwargs...) where T - statplots.jl:269\nboxplot(data::GMTdataset; pos, first, kwargs...) - statplots.jl:238\nboxplot(data::Union{AbstractMatrix{T}, Array{Vector{T}, 1}}; pos, first, kwargs...) where T - statplots.jl:251\nboxplot(data::AbstractVector{&lt;:Real}, grp::AbstractVector; pos, first, kwargs...) - statplots.jl:242\nboxplot(data::AbstractVector{&lt;:Real}; ...) - statplots.jl:242"
  },
  {
    "objectID": "documentation/modules/blockmedian.html",
    "href": "documentation/modules/blockmedian.html",
    "title": "blockmedian",
    "section": "",
    "text": "blockmedian(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/blockmedian.html#description",
    "href": "documentation/modules/blockmedian.html#description",
    "title": "blockmedian",
    "section": "Description",
    "text": "Description\nBlock average (x,y,z) data tables by median estimation.\nReads arbitrarily located (x,y,z) triples [or optionally weighted quadruples (x,y,z,w)] and computes a median position and value for every non-empty block in a grid region defined by the region and increment parameters.\nTakes a Mx3 matrix, a GMTdataset, or a file name as input and returns either a table (a GMTdataset) or one or more grids (GMTgrid). Aternatively, save the result directly in a disk file."
  },
  {
    "objectID": "documentation/modules/blockmedian.html#required-arguments",
    "href": "documentation/modules/blockmedian.html#required-arguments",
    "title": "blockmedian",
    "section": "Required Arguments",
    "text": "Required Arguments\ntable\n3 (or 4, see weights) column data table file (or binary, see binary_in) holding (x,y,z[,w]) data values, where [ w] is an optional weight for the data.\n\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/blockmedian.html#optional-arguments",
    "href": "documentation/modules/blockmedian.html#optional-arguments",
    "title": "blockmedian",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or field or fields: – field=median|scale|highest|lowest|weights\nOutput is a grid with one of the select fields. field=median writes the mean of z. Other options are: scale (the L1 scale of the median), lowest (lowest value), highest (highest value) and weights (the output weight; requires the weights option). The deafault is field=median. Alternatively, one can use a condensed form which uses the first character (except the mean) of the above options, separated by commas, to compute more than one grid. For example: fields=\"z,l\" computes two grids; one with the medians and the other with the lowest value in each block.\nC or center : – center=true\nUse the center of the block as the output location [Default uses the mean location]. Not used whith fields.\nE or extend : — extend=true | extend=:b | extend=“r|s[+l|+h]”\nProvide Extended report which includes s ((the L1 scale of the median, i.e., 1.4826 * median absolute deviation [MAD]), l, the lowest value, and h, the high value for each block. Output order becomes x,y,z,s,l,h[,w]. Default outputs x,y,z[ ,w]. For box-and-whisker calculation, use extend=:b which will output x,y,z,l,q25,q75,h[,w], where q25 and q75 are the 25% and 75% quantiles, respectively. See weights for enabling w output.\nIf extend=\"r|s[+l|+h]\" is used then provide source id s or record number r output, i.e., append the source id or record number associated with the median value. If tied then report the record number of the higher of the two values (i.e., +h is the default); append +l to instead report the record number of the lower value.\nNote that extend may be repeated so that both extend=true[:b] and extend=\"r[+l|+h]\" can be specified. But in this case (repeated extend option) one must encapsulate the intire option in a Tuple because option names can not be repeated (not yet imlemented). For extend=:s we expect input records of the form x,y,z[,w],sid, where sid is an unsigned integer source id.\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nQ or quick : – quick=true\n(Quicker) Finds median z and (x,y) at that the median z [Default finds median x, median y independent of z]. Also see center.\nT or quantile : – quantile=val\nSets the quantile of the distribution to be returned [Default is 0.5 which returns the median z]. Here, 0 &lt; val &lt; 1.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weights : – weights=:i | weights=:o | weights=“i+s” | weights=“i|o+s|+w”\nWeighted modifier[s]. Unweighted input and output have 3 columns x,y,z; Weighted i/o has 4 columns x,y,z,w. Weights can be used in input to construct weighted mean values for each block. Weight sums can be reported in output for later combining several runs, etc. Use weights for weighted i/o, weights=:i for weighted input only, and weights=:o for weighted output only. [Default uses unweighted i/o]. If your weights are actually uncertainties (one sigma) then append the string +s (as in weights=“i+s”) and we compute weight = 1/sigma. Otherwise (or via +w) we use the weights directly.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/blockmedian.html#examples",
    "href": "documentation/modules/blockmedian.html#examples",
    "title": "blockmedian",
    "section": "Examples",
    "text": "Examples\nTo find 5 by 5 minute block medians values from the ASCII data in ship_15.txt, run\n    D = blockmedian(\"@ship_15.txt\", region=(245,255,20,30), inc=\"5m\");\nTo compute the shape of a data distribution per bin via a box-and-whisker diagram we need the 0%, 25%, 50%, 75%, and 100% quantiles. To do so on a global 5 by 5 degree basis from the ASCII table mars370.txt do:\n    D = blockmedian(\"@ship_15.txt\", region=:global, inc=\"5m\", extend=:b);\nTo determine the median and L1 scale (MAD) on the median per 10 minute bin and save these to two separate grids called field_z.nc and field_s.nc, run\n    blockmedian(\"@ship_15.txt\", spacing=\"10m\", region=(-115,-105,20,30), extend=true, save=\"field_%s.nc\", fields=\"z,s\")\nThe same as above but this time returns the two grids to the Julia REPL\n    Z,S = blockmedian(\"@ship_15.txt\", spacing=\"10m\", region=(-115,-105,20,30), extend=true, fields=\"z,s\")"
  },
  {
    "objectID": "documentation/modules/blockmedian.html#source-code",
    "href": "documentation/modules/blockmedian.html#source-code",
    "title": "blockmedian",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nblockmedian(cmd0::String; kwargs...) - blocks.jl:87\nblockmedian(arg1; kwargs...) - blocks.jl:88"
  },
  {
    "objectID": "documentation/modules/blockmedian.html#see-also",
    "href": "documentation/modules/blockmedian.html#see-also",
    "title": "blockmedian",
    "section": "See Also",
    "text": "See Also\nblockmean blockmode"
  },
  {
    "objectID": "documentation/modules/biplot.html",
    "href": "documentation/modules/biplot.html",
    "title": "biplot",
    "section": "",
    "text": "biplot(name::String | D::GMTDataset; arrow::Tuple=(0.3, 0.5, 0.75, \"#0072BD\"), cmap=:categorical,\n       colorbar::Bool=true, marker=:point,ms=\"auto\", obsnumbers::Bool=false, PC=(1,2),\n       varlabels=:yes, xlabel=\"\", ylabel=\"\", kw...)\nCreate a 2D biplot of the Principal Component Analysis (PCA) of a two-dimensional chart that represents the relationship between the rows and columns of a table.\nThe biplot function:"
  },
  {
    "objectID": "documentation/modules/biplot.html#examples",
    "href": "documentation/modules/biplot.html#examples",
    "title": "biplot",
    "section": "Examples",
    "text": "Examples\nSee the classic analysis of the Iris dataset.\n\nusing GMT\nbiplot(TESTSDIR * \"iris.dat\", show=true)\n\n\n\n\n\n\n\n\nPlot a 6 cm fig with the observarion numbers.\n\nusing GMT\nbiplot(TESTSDIR * \"iris.dat\", figsize=6, obsnumbers=true, show=true)"
  },
  {
    "objectID": "documentation/modules/biplot.html#source-code",
    "href": "documentation/modules/biplot.html#source-code",
    "title": "biplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbiplot(cmd0::String; first, PC, xlabel, ylabel, varlabels, cmap, marker, ms, obsnumbers, colorbar, arrow, kw...) - plot.jl:2145\nbiplot(coefs::Matrix{Float64}, scores::Matrix{Float64}, explained::Vector{Float64}, varlabels::Vector{&lt;:String}, obslabels::Vector{&lt;:String}, obsnumb::Bool, xlabel::String, ylabel::String, cmap::String, marker::String, ms::String, colorbar::Bool, arrow_pars::Tuple{Float64, Float64, Float64, String}, first::Bool, d::Dict{Symbol, Any}) - plot.jl:2166\nbiplot(D::GMTdataset{T, 2}; first, PC, cmap, xlabel, ylabel, varlabels, marker, ms, obsnumbers, colorbar, arrow, kw...) where T&lt;:Real - plot.jl:2150"
  },
  {
    "objectID": "documentation/modules/bar3.html",
    "href": "documentation/modules/bar3.html",
    "title": "bar3",
    "section": "",
    "text": "bar3(cmd0::String=\"\", arg1=nothing; kwargs...)\nPlots a 3D bar graph. The input can either be a file name of a file with at least three columns (x,y,z), but optionally more, a GMTdatset object with also three or more columns. However, the simplest usage is to provide a grid object (a GMTgrid) or a MxN matrix (with M,N &gt; 3) and accept the defaults set for these data types. When not using grids or matrices the width keyword (see below) is mandatory, unless both xsize and ysize are given as two extra data columns. When using file names, however, it is necessary to tell the program if it is going to read a grid or a table. That is achieved by using grd=true or dataset=true, respectively.\nThis module is a subset of plot to make it simpler to draw 3D bar plots. So not all (fine) controlling parameters are listed here. For a finer control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/bar3.html#parameters",
    "href": "documentation/modules/bar3.html#parameters",
    "title": "bar3",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax, zmin, zmax) | limits=(BB=(xmin, xmax, ymin, ymax, zmin, zmax),) | …more\nSpecify the region of interest. Default limits are computed from data extents. More at [limits](../common_opts/opt_R.html)\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nbar\ncolumn (3-D) extending from base to z. By default, base is 0 and the bar widths are 0.85 of the width in x-units. You can change this by using (in alternative):\n\nwidth=xx\nwhere xx is the bar width in x-units (bar base remains = 0).\nbase=xx\nwhere xx is the base value (bar width remains = 0.85).\nbar=??\nwhere ?? is a string with a full GMT syntax for this option (-Sb)\nbar=(width=xx,unit=xx,base=xx,height=xx)\nFull featured option. Attention, the order of members matters. unit must always come after width, but otherwise they are all optional.\n\nwidth\nThe bar width in x-units. To specify it in plot units, use the unit member with cm, inch or point.\nunit\nIn case width is given in plot units. Valid units are cm, inch or point.\nbase=xx\nwhere xx is the base value.\nheight\nIf the bar height is measured relative to base xx [Default is relative to origin]. Cannot be used together with base. The facet colors will be modified to simulate shading. Use noshade=true to disable such 3-D illumination. Normally a single z value is considered. For multi-band columns, use nbands=n (and provide n z-values on input; these must be monotonically increasing up the column) or Nbands=n (and expect n of dz increments that must be summed to yield actual z values). The multi-band column symbol requires a fill=cmap (i.e. the use of a colormap) and will use the band number (0, 1, nbands-1) to assign the band color. The way to use these options is also as a separate keyword, or as an extra member of the bar tuple.\n\nnbands=n or Nbands=n or\nbar=(width=xx,unit=xx,base=xx,height=xx,nbands=xx) (or Nbands=xx for last element)\n\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/bar3.html#examples",
    "href": "documentation/modules/bar3.html#examples",
    "title": "bar3",
    "section": "Examples",
    "text": "Examples\nView a grid as a 3D bar plot\n\nusing GMT\nG = gmt(\"grdmath -R-15/15/-15/15 -I0.5 X Y HYPOT DUP 2 MUL PI MUL 8 DIV COS EXCH NEG 10 DIV EXP MUL =\");\ncmap = grd2cpt(G);      # Compute a colormap with the grid's data range\nbar3(G, lw=:thinnest, color=cmap, show=true)"
  },
  {
    "objectID": "documentation/modules/bar3.html#see-also",
    "href": "documentation/modules/bar3.html#see-also",
    "title": "bar3",
    "section": "See also",
    "text": "See also"
  },
  {
    "objectID": "documentation/modules/bar3.html#source-code",
    "href": "documentation/modules/bar3.html#source-code",
    "title": "bar3",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbar3(cmd0::String; ...) - plot.jl:524\nbar3(; ...) - plot.jl:524\nbar3(arg1; kw...) - plot.jl:605\nbar3(cmd0::String, arg; first, kwargs...) - plot.jl:524"
  },
  {
    "objectID": "documentation/modules/band.html",
    "href": "documentation/modules/band.html",
    "title": "band",
    "section": "",
    "text": "band(cmd0::String=\"\", arg1=nothing; width=0.0, envelope=false, kwargs...)\n\nor\n\nband(arg1, ag2, arg3; kwargs...)\n\nor\n\nband(Function, range; width=0.0, envelope=false, kwargs...)\nPlot a line with a symmetrical or asymmetrical band around it. If the band is not color filled then, by default, only the envelope outline is plotted.\nFirst form expects either a file name or a Matrix/GMTdatset with two to four columns. When number of columns is two, width must be set and can be a scalar (symmetrical band) or a two elements tuple/array with dx & dy offsets (asymmetrical band). A three columns input automatically selects a symmetrical band with offsets taken from third column. A four columns input needs to be disambiguated with the width or envelope options.\nSecond form expects arg1 to contain a Mx2 array (can be a GMTdataset) with x,y coordinates and upper and lower band limits provided in the arg1 and arg2 vectors (that need to have same number of elements as rows in arg1).\nThird form let user pass a function whose x limits are set by the range positional option. When range is a scalar it is interpreted to mean x = linspace(-range, range, 200). A two elements mean x = linspace(-range[1], range[2], 200)\nThis module is a subset of plot to make it simpler to draw band plots. So not all (fine) controlling parameters are not listed here. For the finest control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/band.html#parameters",
    "href": "documentation/modules/band.html#parameters",
    "title": "band",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or fill\nSelect color or pattern for filling the band [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color] for extend color selection (including color map generation).\nL or polygon : – polygon=(sym=true, asym=true, envelope=true, pen=pen)\nAdd modifiers to build a band polygon from a line segment. Note, this is an alternative way of setting the band that is provided only because it also allows a fine control for the pen band outline.\n\nsym=true to build symmetrical envelope around y(x) using deviations dy(x) given in extra column 3.\nasym=true to build asymmetrical envelope around y(x) using deviations dy1(x) and dy2(x) from extra columns 3-4.\nenvelope=true to build asymmetrical envelope around y(x) using bounds yl(x) and yh(x) from extra columns 3-4. Polygon may be painted (fill) and optionally outlined by adding pen=pen.\n\nenvelope : – envelope=true\nWhen input table has four columns, or the band([x y], upper, lower, ...) form is used builds an asymmetrical envelope around y(x) using bounds yl(x) and yh(x) from extra columns 3-4 or the upper & lower vectors are provided as input arguments.\nwidth : – width=val | width=(dx,dy)\nCreate a symmetrical envelope around y(x) using deviations +/- val or dx & dy. Note: this assumes that the input table has only two columns, otherwise the band type is determined by the number of columns (symmetrical if ncols = 3, asymmetrical if ncols = 4 with type depending on envelope is true or not.)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/band.html#examples",
    "href": "documentation/modules/band.html#examples",
    "title": "band",
    "section": "Examples",
    "text": "Examples\nPlot the sinc function with a green band of width 0.1 (above and below the sinc line)\n\nusing GMT\nx = y = -10:0.11:10;\nband(x, sin.(x)./x, width=0.1, fill=\"green@80\", show=true)"
  },
  {
    "objectID": "documentation/modules/band.html#source-code",
    "href": "documentation/modules/band.html#source-code",
    "title": "band",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nband(cmd0::String; ...) - plot.jl:1386\nband(cmd0::String, arg1; first, width, envelope, kwargs...) - plot.jl:1386\nband(f::Function, rang; first, width, envelope, kw...) - plot.jl:1429\nband(f::Function; ...) - plot.jl:1429\nband(; ...) - plot.jl:1386\nband(arg; width, envelope, kw...) - plot.jl:1419\nband(arg1, arg2; width, envelope, kw...) - plot.jl:1422\nband(arg1, arg2, arg3; kw...) - plot.jl:1426"
  },
  {
    "objectID": "documentation/alphabetical.html",
    "href": "documentation/alphabetical.html",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "This page lists all documented functions in GMT.jl alphabetically.\n\n\n\n\n\n\nTip\n\n\n\nUse your browser’s search function (Ctrl+F or Cmd+F) to quickly find a specific function.\n\n\nJump to: A | B | C | D | E | F | G | H | I | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nablines\nUtilities\n\n\nanaglyph\nUtilities\n\n\nappend2fig\nUtilities\n\n\narccircle\nGDAL Functions\n\n\narcellipse\nGDAL Functions\n\n\narrows\nModules\n\n\nautocor\nUtilities\n\n\nautocov\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nband\nModules\n\n\nbar\nModules\n\n\nbar3\nModules\n\n\nbasemap\nModules\n\n\nbezier\nUtilities\n\n\nbinarize\nImage Processing\n\n\nbinstats\nModules\n\n\nbiplot\nModules\n\n\nblockmean\nModules\n\n\nblockmedian\nModules\n\n\nblockmode\nModules\n\n\nboundary\nGDAL Functions\n\n\nboxes\nModules\n\n\nboxplot\nModules\n\n\nbubblechart\nModules\n\n\nbuffer\nGDAL Functions\n\n\nbuffergeo\nGDAL Functions\n\n\nbwareaopen\nImage Processing\n\n\nbwconncomp\nImage Processing\n\n\nbwdist\nImage Processing\n\n\nbwdist_idx\nImage Processing\n\n\nbwhitmiss\nImage Processing\n\n\nbwlabel\nImage Processing\n\n\nbwperim\nImage Processing\n\n\nbwskell\nImage Processing\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\ncart2pol\nUtilities\n\n\ncart2sph\nUtilities\n\n\ncc2bw\nImage Processing\n\n\ncentroid\nGDAL Functions\n\n\ncircfit\nUtilities\n\n\ncircgeo\nGDAL Functions\n\n\ncirclepts\nUtilities\n\n\nclip\nModules\n\n\ncoast\nModules\n\n\ncoastlinesproj\nUtilities\n\n\ncolorbar\nModules\n\n\ncolorscale\nModules\n\n\nconcavehull\nGDAL Functions\n\n\ncontains\nGDAL Functions\n\n\ncontour\nModules\n\n\ncontourf\nModules\n\n\nconv\nUtilities\n\n\nconvexhull\nGDAL Functions\n\n\ncornerplot\nModules\n\n\ncoupe\nModules\n\n\ncpt4dcw\nUtilities\n\n\ncrop\nUtilities\n\n\ncrosses\nGDAL Functions\n\n\ncube\nUtilities\n\n\ncubeplot\nUtilities\n\n\ncubeslice\nUtilities\n\n\ncylinder\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\ndate2doy\nUtilities\n\n\ndecorated\nModules\n\n\ndelaunay\nGDAL Functions\n\n\ndelrows\nUtilities\n\n\ndensity\nModules\n\n\ndestroy\nGDAL Functions\n\n\ndf2ds\nUtilities\n\n\ndifference\nGDAL Functions\n\n\ndisjoint\nGDAL Functions\n\n\ndistance\nGDAL Functions\n\n\ndither\nGDAL Functions\n\n\ndodecahedron\nUtilities\n\n\ndoy2date\nUtilities\n\n\nds2df\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nearthregions\nModules\n\n\nearthtide\nModules\n\n\necdfplot\nModules\n\n\necmwf\nUtilities\n\n\nellipse3D\nUtilities\n\n\nenvelope\nGDAL Functions\n\n\nenvelope3d\nGDAL Functions\n\n\nepsg2proj\nGDAL Functions\n\n\nepsg2wkt\nGDAL Functions\n\n\nequals\nGDAL Functions\n\n\nera5time\nUtilities\n\n\nera5vars\nUtilities\n\n\neulermat\nUtilities\n\n\nevents\nModules\n\n\nextrude\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nfeather\nModules\n\n\nfields\nUtilities\n\n\nfileparts\nUtilities\n\n\nfill_between\nModules\n\n\nfillnodata\nGDAL Functions\n\n\nfillsinks\nImage Processing\n\n\nfilter1d\nModules\n\n\nfindpeaks\nUtilities\n\n\nfitcircle\nModules\n\n\nflatfv\nUtilities\n\n\nflipdim\nUtilities\n\n\nfliplr\nUtilities\n\n\nflipud\nUtilities\n\n\nfromWKT\nGDAL Functions\n\n\nfv2fv\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\ngadm\nUtilities\n\n\nGantijoin\nUtilities\n\n\nGcrossjoin\nUtilities\n\n\ngd2gmt\nGDAL Functions\n\n\ngdalbuildvrt\nGDAL Functions\n\n\ngdaldem\nGDAL Functions\n\n\ngdaldrivers\nGDAL Functions\n\n\ngdalgrid\nGDAL Functions\n\n\ngdalinfo\nGDAL Functions\n\n\ngdalrasterize\nGDAL Functions\n\n\ngdalread\nGDAL Functions\n\n\ngdalshade\nGDAL Functions\n\n\ngdaltranslate\nGDAL Functions\n\n\ngdalvectortranslate\nGDAL Functions\n\n\ngdalwarp\nGDAL Functions\n\n\ngdalwrite\nGDAL Functions\n\n\ngeocoder\nUtilities\n\n\ngeod\nGDAL Functions\n\n\ngeodesic\nGDAL Functions\n\n\ngeodesicarea\nGDAL Functions\n\n\ngeodetic2enu\nUtilities\n\n\ngeomarea\nGDAL Functions\n\n\ngeomlength\nGDAL Functions\n\n\ngetband\nGDAL Functions\n\n\ngetbyattrib\nUtilities\n\n\ngetdriver\nGDAL Functions\n\n\ngetgeom\nGDAL Functions\n\n\ngetgeotransform\nGDAL Functions\n\n\ngetlayer\nGDAL Functions\n\n\ngetproj\nGDAL Functions\n\n\ngetprovider\nUtilities\n\n\ngetregion\nUtilities\n\n\nGinnerjoin\nUtilities\n\n\nGleftjoin\nUtilities\n\n\ngmt\nModules\n\n\ngmt2gd\nGDAL Functions\n\n\ngmt2kml\nModules\n\n\ngmtbegin\nModules\n\n\ngmtbinstats\nModules\n\n\ngmtconnect\nModules\n\n\ngmtconvert\nModules\n\n\ngmtend\nModules\n\n\ngmtfig\nModules\n\n\ngmtgravmag3d\nModules\n\n\ngmthelp\nModules\n\n\ngmtinfo\nModules\n\n\ngmtisf\nModules\n\n\ngmtmath\nModules\n\n\ngmtread\nUtilities\n\n\ngmtregress\nModules\n\n\ngmtselect\nModules\n\n\ngmtset\nModules\n\n\ngmtsimplify\nModules\n\n\ngmtspatial\nModules\n\n\ngmtsplit\nModules\n\n\ngmtvector\nModules\n\n\ngmtwhich\nModules\n\n\ngmtwrite\nUtilities\n\n\nGouterjoin\nUtilities\n\n\ngraticules\nUtilities\n\n\ngravfft\nModules\n\n\ngravmag3d\nModules\n\n\ngravprisms\nModules\n\n\ngraydist\nImage Processing\n\n\ngrays2cube\nImage Processing\n\n\ngrays2rgb\nImage Processing\n\n\ngrd2cpt\nModules\n\n\ngrd2kml\nModules\n\n\ngrd2xyz\nModules\n\n\ngrdblend\nModules\n\n\ngrdclip\nModules\n\n\ngrdcontour\nModules\n\n\ngrdconvert\nModules\n\n\ngrdcut\nModules\n\n\ngrdedit\nModules\n\n\ngrdfft\nModules\n\n\ngrdfill\nModules\n\n\ngrdfilter\nModules\n\n\ngrdgradient\nModules\n\n\ngrdgravmag3d\nModules\n\n\ngrdhisteq\nModules\n\n\ngrdimage\nModules\n\n\ngrdinfo\nModules\n\n\ngrdinterpolate\nModules\n\n\ngrdlandmask\nModules\n\n\ngrdmask\nModules\n\n\ngrdmath\nModules\n\n\ngrdpaste\nModules\n\n\ngrdproject\nModules\n\n\ngrdrotater\nModules\n\n\ngrdsample\nModules\n\n\ngrdseamount\nModules\n\n\ngrdtrack\nModules\n\n\ngrdtrend\nModules\n\n\ngrdvector\nModules\n\n\ngrdview\nModules\n\n\ngrdvolume\nModules\n\n\ngreenspline\nModules\n\n\ngrid2img\nImage Processing\n\n\ngrid2tri\nUtilities\n\n\ngridit\nUtilities\n\n\nGrightjoin\nUtilities\n\n\ngroupby\nUtilities\n\n\nGsemijoin\nUtilities\n\n\ngunique\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nhampel\nUtilities\n\n\nharalick\nImage Processing\n\n\nhband\nModules\n\n\nhistogram\nModules\n\n\nhlines\nUtilities\n\n\nhspan\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nicosahedron\nUtilities\n\n\nimage\nModules\n\n\nimagesc\nUtilities\n\n\nimbothat\nImage Processing\n\n\nimclearborder\nImage Processing\n\n\nimclose\nImage Processing\n\n\nimcomplement\nImage Processing\n\n\nimdilate\nImage Processing\n\n\nimerode\nImage Processing\n\n\nimfill\nImage Processing\n\n\nimfilter\nImage Processing\n\n\nimg2grid\nImage Processing\n\n\nimhdome\nImage Processing\n\n\nimhmax\nImage Processing\n\n\nimhmin\nImage Processing\n\n\nimmorphgrad\nImage Processing\n\n\nimopen\nImage Processing\n\n\nimportEPSG\nGDAL Functions\n\n\nimportPROJ4\nGDAL Functions\n\n\nimportWKT\nGDAL Functions\n\n\nimrankfilter\nImage Processing\n\n\nimreconstruct\nImage Processing\n\n\nimregionalmax\nImage Processing\n\n\nimregionalmin\nImage Processing\n\n\nimresize\nImage Processing\n\n\nimsegment\nImage Processing\n\n\nimshow\nUtilities\n\n\nimsobel\nImage Processing\n\n\nimtophat\nImage Processing\n\n\ninbbox\nGDAL Functions\n\n\nind2bool\nUtilities\n\n\nind2rgb\nUtilities\n\n\ninfo\nUtilities\n\n\ninpolygon\nUtilities\n\n\ninset\nModules\n\n\nintersection\nGDAL Functions\n\n\nintersects\nGDAL Functions\n\n\ninvgeod\nGDAL Functions\n\n\ninwhichpolygon\nUtilities\n\n\nisclockwise\nUtilities\n\n\nisnodata\nUtilities\n\n\nisodata\nImage Processing\n\n\nISOtime2unix\nUtilities\n\n\nisoutlier\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nkmeans\nUtilities\n\n\nkml2gmt\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nlasread\nUtilities\n\n\nlaswrite\nUtilities\n\n\nlazinfo\nUtilities\n\n\nlazread\nUtilities\n\n\nlazwrite\nUtilities\n\n\nleepacific\nUtilities\n\n\nlegend\nModules\n\n\nlelandshade\nUtilities\n\n\nlinearfitxy\nUtilities\n\n\nlines\nModules\n\n\nlinspace\nUtilities\n\n\nlistecmwfvars\nUtilities\n\n\nloft\nUtilities\n\n\nlogo\nUtilities\n\n\nlogspace\nUtilities\n\n\nlonlat2xy\nGDAL Functions\n\n\nlowess\nUtilities\n\n\nloxodrome\nGDAL Functions\n\n\nloxodrome_direct\nGDAL Functions\n\n\nloxodrome_inverse\nGDAL Functions\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nmad\nUtilities\n\n\nmagic\nUtilities\n\n\nmagref\nModules\n\n\nmakecpt\nModules\n\n\nmakeDCWs\nUtilities\n\n\nmapproject\nModules\n\n\nmapsize2region\nUtilities\n\n\nmaregrams\nUtilities\n\n\nmarginalhist\nModules\n\n\nmask\nModules\n\n\nmat2ds\nUtilities\n\n\nmat2grid\nUtilities\n\n\nmat2img\nUtilities\n\n\nmbgetdata\nUtilities\n\n\nmbimport\nUtilities\n\n\nmblevitus\nUtilities\n\n\nmbsvplist\nUtilities\n\n\nmeca\nModules\n\n\nmeshgrid\nUtilities\n\n\nmeteostat\nUtilities\n\n\nmgd77magref\nModules\n\n\nmksymbol\nUtilities\n\n\nmosaic\nUtilities\n\n\nmovie\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nnanmean\nUtilities\n\n\nnanstd\nUtilities\n\n\nnearneighbor\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\noctahedron\nUtilities\n\n\nODE2ds\nUtilities\n\n\nogr2ogr\nGDAL Functions\n\n\nokada\nUtilities\n\n\norbits\nUtilities\n\n\northodrome\nGDAL Functions\n\n\noverlaps\nGDAL Functions\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\npadarray\nImage Processing\n\n\nparallelplot\nModules\n\n\nparkergrav\nUtilities\n\n\nparkermag\nUtilities\n\n\npastplates\nUtilities\n\n\npca\nUtilities\n\n\npcolor\nUtilities\n\n\npeaks\nUtilities\n\n\npiechart\nModules\n\n\nplot\nModules\n\n\nplot3\nModules\n\n\nplot3d\nModules\n\n\nplotlinefit\nUtilities\n\n\nplotyy\nUtilities\n\n\npointalongline\nGDAL Functions\n\n\npol2cart\nUtilities\n\n\npolyfit\nUtilities\n\n\npolygonize\nGDAL Functions\n\n\npolygonlevels\nUtilities\n\n\npolyunion\nGDAL Functions\n\n\npolyval\nUtilities\n\n\npow\nUtilities\n\n\nproj2wkt\nGDAL Functions\n\n\nproject\nModules\n\n\npsbasemap\nModules\n\n\npsclip\nModules\n\n\npscoast\nModules\n\n\npscontour\nModules\n\n\npsconvert\nModules\n\n\npscoupe\nModules\n\n\npsevents\nModules\n\n\npshistogram\nModules\n\n\npsimage\nModules\n\n\npslegend\nModules\n\n\npsmask\nModules\n\n\npsmeca\nModules\n\n\npsrose\nModules\n\n\npsscale\nModules\n\n\npssolar\nModules\n\n\npsternary\nModules\n\n\npstext\nModules\n\n\npsvelo\nModules\n\n\npswiggle\nModules\n\n\npsxy\nModules\n\n\npsxyz\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nqqnorm\nModules\n\n\nqqplot\nModules\n\n\nquadbounds\nUtilities\n\n\nquadkey\nUtilities\n\n\nquiver\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nradar\nModules\n\n\nrandgeo\nGDAL Functions\n\n\nrandinpolygon\nUtilities\n\n\nrasterzones\nUtilities\n\n\nreadgeom\nGDAL Functions\n\n\nreadraster\nGDAL Functions\n\n\nregiongeog\nUtilities\n\n\nregress\nModules\n\n\nremotegrid\nUtilities\n\n\nreplicant\nUtilities\n\n\nrescale\nUtilities\n\n\nresetGMT\nUtilities\n\n\nrevolve\nUtilities\n\n\nrgb2gray\nImage Processing\n\n\nrgb2lab\nImage Processing\n\n\nrgb2YCbCr\nImage Processing\n\n\nrgb2ycbcr\nImage Processing\n\n\nrose\nModules\n\n\nrotate\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nsample1d\nModules\n\n\nscatter\nModules\n\n\nscatter3\nModules\n\n\nsealand\nUtilities\n\n\nseismicity\nModules\n\n\nsetproj\nGDAL Functions\n\n\nshowfig\nModules\n\n\nsimplify\nGDAL Functions\n\n\nslicecube\nUtilities\n\n\nsolar\nModules\n\n\nsortslicesperm\nUtilities\n\n\nspatialjoin\nUtilities\n\n\nspectrum1d\nModules\n\n\nsph2cart\nUtilities\n\n\nsphdistance\nModules\n\n\nsphere\nUtilities\n\n\nsphinterpolate\nModules\n\n\nsphtriangulate\nModules\n\n\nspinmat\nUtilities\n\n\nsqueeze\nUtilities\n\n\nstackgrids\nUtilities\n\n\nstairs\nModules\n\n\nstats\nUtilities\n\n\nstem\nModules\n\n\nstereonet\nUtilities\n\n\nstreamlines\nUtilities\n\n\nstrel\nImage Processing\n\n\nsubplot\nModules\n\n\nsurf2fv\nUtilities\n\n\nsurface\nModules\n\n\nsymdifference\nGDAL Functions\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\ntern2cart\nUtilities\n\n\nternary\nModules\n\n\nterramar\nUtilities\n\n\ntetrahedron\nUtilities\n\n\ntext\nModules\n\n\ntext_record\nUtilities\n\n\ntexture_img\nUtilities\n\n\ntheme\nUtilities\n\n\ntic\nUtilities\n\n\ntoc\nUtilities\n\n\ntogglemask\nUtilities\n\n\ntoPROJ4\nGDAL Functions\n\n\ntorus\nUtilities\n\n\ntouches\nGDAL Functions\n\n\ntoWKT\nGDAL Functions\n\n\ntranslate\nUtilities\n\n\ntrend1d\nModules\n\n\ntrend2d\nModules\n\n\ntriangulate\nModules\n\n\ntriplot\nModules\n\n\ntrisurf\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nuniqueind\nUtilities\n\n\nupGMT\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nvband\nModules\n\n\nvecangles\nUtilities\n\n\nvector_attrib\nUtilities\n\n\nvelo\nModules\n\n\nviolin\nModules\n\n\nviz\nUtilities\n\n\nvizpdf\nUtilities\n\n\nvlines\nUtilities\n\n\nvspan\nModules\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nweather\nUtilities\n\n\nwhereami\nUtilities\n\n\nwhittaker\nUtilities\n\n\nwiggle\nModules\n\n\nwindbarbs\nModules\n\n\nwithin\nGDAL Functions\n\n\nwkt2proj\nGDAL Functions\n\n\nwmsinfo\nUtilities\n\n\nwmsread\nUtilities\n\n\nwmstest\nUtilities\n\n\nworldrectangular\nUtilities\n\n\nworldrectcoast\nUtilities\n\n\nworldrectgrid\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nxcorr\nUtilities\n\n\nxcov\nUtilities\n\n\nxy2lonlat\nGDAL Functions\n\n\nxyz2grd\nModules\n\n\nxyzw2cube\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nyeardecimal\nUtilities\n\n\n\n\n\n\n\n\n\nFunction\nCategory\n\n\n\n\nzonal_statistics\nUtilities\n\n\nzonal_stats\nUtilities\n\n\nzscores\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#a",
    "href": "documentation/alphabetical.html#a",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nablines\nUtilities\n\n\nanaglyph\nUtilities\n\n\nappend2fig\nUtilities\n\n\narccircle\nGDAL Functions\n\n\narcellipse\nGDAL Functions\n\n\narrows\nModules\n\n\nautocor\nUtilities\n\n\nautocov\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#b",
    "href": "documentation/alphabetical.html#b",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nband\nModules\n\n\nbar\nModules\n\n\nbar3\nModules\n\n\nbasemap\nModules\n\n\nbezier\nUtilities\n\n\nbinarize\nImage Processing\n\n\nbinstats\nModules\n\n\nbiplot\nModules\n\n\nblockmean\nModules\n\n\nblockmedian\nModules\n\n\nblockmode\nModules\n\n\nboundary\nGDAL Functions\n\n\nboxes\nModules\n\n\nboxplot\nModules\n\n\nbubblechart\nModules\n\n\nbuffer\nGDAL Functions\n\n\nbuffergeo\nGDAL Functions\n\n\nbwareaopen\nImage Processing\n\n\nbwconncomp\nImage Processing\n\n\nbwdist\nImage Processing\n\n\nbwdist_idx\nImage Processing\n\n\nbwhitmiss\nImage Processing\n\n\nbwlabel\nImage Processing\n\n\nbwperim\nImage Processing\n\n\nbwskell\nImage Processing"
  },
  {
    "objectID": "documentation/alphabetical.html#c",
    "href": "documentation/alphabetical.html#c",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\ncart2pol\nUtilities\n\n\ncart2sph\nUtilities\n\n\ncc2bw\nImage Processing\n\n\ncentroid\nGDAL Functions\n\n\ncircfit\nUtilities\n\n\ncircgeo\nGDAL Functions\n\n\ncirclepts\nUtilities\n\n\nclip\nModules\n\n\ncoast\nModules\n\n\ncoastlinesproj\nUtilities\n\n\ncolorbar\nModules\n\n\ncolorscale\nModules\n\n\nconcavehull\nGDAL Functions\n\n\ncontains\nGDAL Functions\n\n\ncontour\nModules\n\n\ncontourf\nModules\n\n\nconv\nUtilities\n\n\nconvexhull\nGDAL Functions\n\n\ncornerplot\nModules\n\n\ncoupe\nModules\n\n\ncpt4dcw\nUtilities\n\n\ncrop\nUtilities\n\n\ncrosses\nGDAL Functions\n\n\ncube\nUtilities\n\n\ncubeplot\nUtilities\n\n\ncubeslice\nUtilities\n\n\ncylinder\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#d",
    "href": "documentation/alphabetical.html#d",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\ndate2doy\nUtilities\n\n\ndecorated\nModules\n\n\ndelaunay\nGDAL Functions\n\n\ndelrows\nUtilities\n\n\ndensity\nModules\n\n\ndestroy\nGDAL Functions\n\n\ndf2ds\nUtilities\n\n\ndifference\nGDAL Functions\n\n\ndisjoint\nGDAL Functions\n\n\ndistance\nGDAL Functions\n\n\ndither\nGDAL Functions\n\n\ndodecahedron\nUtilities\n\n\ndoy2date\nUtilities\n\n\nds2df\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#e",
    "href": "documentation/alphabetical.html#e",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nearthregions\nModules\n\n\nearthtide\nModules\n\n\necdfplot\nModules\n\n\necmwf\nUtilities\n\n\nellipse3D\nUtilities\n\n\nenvelope\nGDAL Functions\n\n\nenvelope3d\nGDAL Functions\n\n\nepsg2proj\nGDAL Functions\n\n\nepsg2wkt\nGDAL Functions\n\n\nequals\nGDAL Functions\n\n\nera5time\nUtilities\n\n\nera5vars\nUtilities\n\n\neulermat\nUtilities\n\n\nevents\nModules\n\n\nextrude\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#f",
    "href": "documentation/alphabetical.html#f",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nfeather\nModules\n\n\nfields\nUtilities\n\n\nfileparts\nUtilities\n\n\nfill_between\nModules\n\n\nfillnodata\nGDAL Functions\n\n\nfillsinks\nImage Processing\n\n\nfilter1d\nModules\n\n\nfindpeaks\nUtilities\n\n\nfitcircle\nModules\n\n\nflatfv\nUtilities\n\n\nflipdim\nUtilities\n\n\nfliplr\nUtilities\n\n\nflipud\nUtilities\n\n\nfromWKT\nGDAL Functions\n\n\nfv2fv\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#g",
    "href": "documentation/alphabetical.html#g",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\ngadm\nUtilities\n\n\nGantijoin\nUtilities\n\n\nGcrossjoin\nUtilities\n\n\ngd2gmt\nGDAL Functions\n\n\ngdalbuildvrt\nGDAL Functions\n\n\ngdaldem\nGDAL Functions\n\n\ngdaldrivers\nGDAL Functions\n\n\ngdalgrid\nGDAL Functions\n\n\ngdalinfo\nGDAL Functions\n\n\ngdalrasterize\nGDAL Functions\n\n\ngdalread\nGDAL Functions\n\n\ngdalshade\nGDAL Functions\n\n\ngdaltranslate\nGDAL Functions\n\n\ngdalvectortranslate\nGDAL Functions\n\n\ngdalwarp\nGDAL Functions\n\n\ngdalwrite\nGDAL Functions\n\n\ngeocoder\nUtilities\n\n\ngeod\nGDAL Functions\n\n\ngeodesic\nGDAL Functions\n\n\ngeodesicarea\nGDAL Functions\n\n\ngeodetic2enu\nUtilities\n\n\ngeomarea\nGDAL Functions\n\n\ngeomlength\nGDAL Functions\n\n\ngetband\nGDAL Functions\n\n\ngetbyattrib\nUtilities\n\n\ngetdriver\nGDAL Functions\n\n\ngetgeom\nGDAL Functions\n\n\ngetgeotransform\nGDAL Functions\n\n\ngetlayer\nGDAL Functions\n\n\ngetproj\nGDAL Functions\n\n\ngetprovider\nUtilities\n\n\ngetregion\nUtilities\n\n\nGinnerjoin\nUtilities\n\n\nGleftjoin\nUtilities\n\n\ngmt\nModules\n\n\ngmt2gd\nGDAL Functions\n\n\ngmt2kml\nModules\n\n\ngmtbegin\nModules\n\n\ngmtbinstats\nModules\n\n\ngmtconnect\nModules\n\n\ngmtconvert\nModules\n\n\ngmtend\nModules\n\n\ngmtfig\nModules\n\n\ngmtgravmag3d\nModules\n\n\ngmthelp\nModules\n\n\ngmtinfo\nModules\n\n\ngmtisf\nModules\n\n\ngmtmath\nModules\n\n\ngmtread\nUtilities\n\n\ngmtregress\nModules\n\n\ngmtselect\nModules\n\n\ngmtset\nModules\n\n\ngmtsimplify\nModules\n\n\ngmtspatial\nModules\n\n\ngmtsplit\nModules\n\n\ngmtvector\nModules\n\n\ngmtwhich\nModules\n\n\ngmtwrite\nUtilities\n\n\nGouterjoin\nUtilities\n\n\ngraticules\nUtilities\n\n\ngravfft\nModules\n\n\ngravmag3d\nModules\n\n\ngravprisms\nModules\n\n\ngraydist\nImage Processing\n\n\ngrays2cube\nImage Processing\n\n\ngrays2rgb\nImage Processing\n\n\ngrd2cpt\nModules\n\n\ngrd2kml\nModules\n\n\ngrd2xyz\nModules\n\n\ngrdblend\nModules\n\n\ngrdclip\nModules\n\n\ngrdcontour\nModules\n\n\ngrdconvert\nModules\n\n\ngrdcut\nModules\n\n\ngrdedit\nModules\n\n\ngrdfft\nModules\n\n\ngrdfill\nModules\n\n\ngrdfilter\nModules\n\n\ngrdgradient\nModules\n\n\ngrdgravmag3d\nModules\n\n\ngrdhisteq\nModules\n\n\ngrdimage\nModules\n\n\ngrdinfo\nModules\n\n\ngrdinterpolate\nModules\n\n\ngrdlandmask\nModules\n\n\ngrdmask\nModules\n\n\ngrdmath\nModules\n\n\ngrdpaste\nModules\n\n\ngrdproject\nModules\n\n\ngrdrotater\nModules\n\n\ngrdsample\nModules\n\n\ngrdseamount\nModules\n\n\ngrdtrack\nModules\n\n\ngrdtrend\nModules\n\n\ngrdvector\nModules\n\n\ngrdview\nModules\n\n\ngrdvolume\nModules\n\n\ngreenspline\nModules\n\n\ngrid2img\nImage Processing\n\n\ngrid2tri\nUtilities\n\n\ngridit\nUtilities\n\n\nGrightjoin\nUtilities\n\n\ngroupby\nUtilities\n\n\nGsemijoin\nUtilities\n\n\ngunique\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#h",
    "href": "documentation/alphabetical.html#h",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nhampel\nUtilities\n\n\nharalick\nImage Processing\n\n\nhband\nModules\n\n\nhistogram\nModules\n\n\nhlines\nUtilities\n\n\nhspan\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#i",
    "href": "documentation/alphabetical.html#i",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nicosahedron\nUtilities\n\n\nimage\nModules\n\n\nimagesc\nUtilities\n\n\nimbothat\nImage Processing\n\n\nimclearborder\nImage Processing\n\n\nimclose\nImage Processing\n\n\nimcomplement\nImage Processing\n\n\nimdilate\nImage Processing\n\n\nimerode\nImage Processing\n\n\nimfill\nImage Processing\n\n\nimfilter\nImage Processing\n\n\nimg2grid\nImage Processing\n\n\nimhdome\nImage Processing\n\n\nimhmax\nImage Processing\n\n\nimhmin\nImage Processing\n\n\nimmorphgrad\nImage Processing\n\n\nimopen\nImage Processing\n\n\nimportEPSG\nGDAL Functions\n\n\nimportPROJ4\nGDAL Functions\n\n\nimportWKT\nGDAL Functions\n\n\nimrankfilter\nImage Processing\n\n\nimreconstruct\nImage Processing\n\n\nimregionalmax\nImage Processing\n\n\nimregionalmin\nImage Processing\n\n\nimresize\nImage Processing\n\n\nimsegment\nImage Processing\n\n\nimshow\nUtilities\n\n\nimsobel\nImage Processing\n\n\nimtophat\nImage Processing\n\n\ninbbox\nGDAL Functions\n\n\nind2bool\nUtilities\n\n\nind2rgb\nUtilities\n\n\ninfo\nUtilities\n\n\ninpolygon\nUtilities\n\n\ninset\nModules\n\n\nintersection\nGDAL Functions\n\n\nintersects\nGDAL Functions\n\n\ninvgeod\nGDAL Functions\n\n\ninwhichpolygon\nUtilities\n\n\nisclockwise\nUtilities\n\n\nisnodata\nUtilities\n\n\nisodata\nImage Processing\n\n\nISOtime2unix\nUtilities\n\n\nisoutlier\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#k",
    "href": "documentation/alphabetical.html#k",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nkmeans\nUtilities\n\n\nkml2gmt\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#l",
    "href": "documentation/alphabetical.html#l",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nlasread\nUtilities\n\n\nlaswrite\nUtilities\n\n\nlazinfo\nUtilities\n\n\nlazread\nUtilities\n\n\nlazwrite\nUtilities\n\n\nleepacific\nUtilities\n\n\nlegend\nModules\n\n\nlelandshade\nUtilities\n\n\nlinearfitxy\nUtilities\n\n\nlines\nModules\n\n\nlinspace\nUtilities\n\n\nlistecmwfvars\nUtilities\n\n\nloft\nUtilities\n\n\nlogo\nUtilities\n\n\nlogspace\nUtilities\n\n\nlonlat2xy\nGDAL Functions\n\n\nlowess\nUtilities\n\n\nloxodrome\nGDAL Functions\n\n\nloxodrome_direct\nGDAL Functions\n\n\nloxodrome_inverse\nGDAL Functions"
  },
  {
    "objectID": "documentation/alphabetical.html#m",
    "href": "documentation/alphabetical.html#m",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nmad\nUtilities\n\n\nmagic\nUtilities\n\n\nmagref\nModules\n\n\nmakecpt\nModules\n\n\nmakeDCWs\nUtilities\n\n\nmapproject\nModules\n\n\nmapsize2region\nUtilities\n\n\nmaregrams\nUtilities\n\n\nmarginalhist\nModules\n\n\nmask\nModules\n\n\nmat2ds\nUtilities\n\n\nmat2grid\nUtilities\n\n\nmat2img\nUtilities\n\n\nmbgetdata\nUtilities\n\n\nmbimport\nUtilities\n\n\nmblevitus\nUtilities\n\n\nmbsvplist\nUtilities\n\n\nmeca\nModules\n\n\nmeshgrid\nUtilities\n\n\nmeteostat\nUtilities\n\n\nmgd77magref\nModules\n\n\nmksymbol\nUtilities\n\n\nmosaic\nUtilities\n\n\nmovie\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#n",
    "href": "documentation/alphabetical.html#n",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nnanmean\nUtilities\n\n\nnanstd\nUtilities\n\n\nnearneighbor\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#o",
    "href": "documentation/alphabetical.html#o",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\noctahedron\nUtilities\n\n\nODE2ds\nUtilities\n\n\nogr2ogr\nGDAL Functions\n\n\nokada\nUtilities\n\n\norbits\nUtilities\n\n\northodrome\nGDAL Functions\n\n\noverlaps\nGDAL Functions"
  },
  {
    "objectID": "documentation/alphabetical.html#p",
    "href": "documentation/alphabetical.html#p",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\npadarray\nImage Processing\n\n\nparallelplot\nModules\n\n\nparkergrav\nUtilities\n\n\nparkermag\nUtilities\n\n\npastplates\nUtilities\n\n\npca\nUtilities\n\n\npcolor\nUtilities\n\n\npeaks\nUtilities\n\n\npiechart\nModules\n\n\nplot\nModules\n\n\nplot3\nModules\n\n\nplot3d\nModules\n\n\nplotlinefit\nUtilities\n\n\nplotyy\nUtilities\n\n\npointalongline\nGDAL Functions\n\n\npol2cart\nUtilities\n\n\npolyfit\nUtilities\n\n\npolygonize\nGDAL Functions\n\n\npolygonlevels\nUtilities\n\n\npolyunion\nGDAL Functions\n\n\npolyval\nUtilities\n\n\npow\nUtilities\n\n\nproj2wkt\nGDAL Functions\n\n\nproject\nModules\n\n\npsbasemap\nModules\n\n\npsclip\nModules\n\n\npscoast\nModules\n\n\npscontour\nModules\n\n\npsconvert\nModules\n\n\npscoupe\nModules\n\n\npsevents\nModules\n\n\npshistogram\nModules\n\n\npsimage\nModules\n\n\npslegend\nModules\n\n\npsmask\nModules\n\n\npsmeca\nModules\n\n\npsrose\nModules\n\n\npsscale\nModules\n\n\npssolar\nModules\n\n\npsternary\nModules\n\n\npstext\nModules\n\n\npsvelo\nModules\n\n\npswiggle\nModules\n\n\npsxy\nModules\n\n\npsxyz\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#q",
    "href": "documentation/alphabetical.html#q",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nqqnorm\nModules\n\n\nqqplot\nModules\n\n\nquadbounds\nUtilities\n\n\nquadkey\nUtilities\n\n\nquiver\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#r",
    "href": "documentation/alphabetical.html#r",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nradar\nModules\n\n\nrandgeo\nGDAL Functions\n\n\nrandinpolygon\nUtilities\n\n\nrasterzones\nUtilities\n\n\nreadgeom\nGDAL Functions\n\n\nreadraster\nGDAL Functions\n\n\nregiongeog\nUtilities\n\n\nregress\nModules\n\n\nremotegrid\nUtilities\n\n\nreplicant\nUtilities\n\n\nrescale\nUtilities\n\n\nresetGMT\nUtilities\n\n\nrevolve\nUtilities\n\n\nrgb2gray\nImage Processing\n\n\nrgb2lab\nImage Processing\n\n\nrgb2YCbCr\nImage Processing\n\n\nrgb2ycbcr\nImage Processing\n\n\nrose\nModules\n\n\nrotate\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#s",
    "href": "documentation/alphabetical.html#s",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nsample1d\nModules\n\n\nscatter\nModules\n\n\nscatter3\nModules\n\n\nsealand\nUtilities\n\n\nseismicity\nModules\n\n\nsetproj\nGDAL Functions\n\n\nshowfig\nModules\n\n\nsimplify\nGDAL Functions\n\n\nslicecube\nUtilities\n\n\nsolar\nModules\n\n\nsortslicesperm\nUtilities\n\n\nspatialjoin\nUtilities\n\n\nspectrum1d\nModules\n\n\nsph2cart\nUtilities\n\n\nsphdistance\nModules\n\n\nsphere\nUtilities\n\n\nsphinterpolate\nModules\n\n\nsphtriangulate\nModules\n\n\nspinmat\nUtilities\n\n\nsqueeze\nUtilities\n\n\nstackgrids\nUtilities\n\n\nstairs\nModules\n\n\nstats\nUtilities\n\n\nstem\nModules\n\n\nstereonet\nUtilities\n\n\nstreamlines\nUtilities\n\n\nstrel\nImage Processing\n\n\nsubplot\nModules\n\n\nsurf2fv\nUtilities\n\n\nsurface\nModules\n\n\nsymdifference\nGDAL Functions"
  },
  {
    "objectID": "documentation/alphabetical.html#t",
    "href": "documentation/alphabetical.html#t",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\ntern2cart\nUtilities\n\n\nternary\nModules\n\n\nterramar\nUtilities\n\n\ntetrahedron\nUtilities\n\n\ntext\nModules\n\n\ntext_record\nUtilities\n\n\ntexture_img\nUtilities\n\n\ntheme\nUtilities\n\n\ntic\nUtilities\n\n\ntoc\nUtilities\n\n\ntogglemask\nUtilities\n\n\ntoPROJ4\nGDAL Functions\n\n\ntorus\nUtilities\n\n\ntouches\nGDAL Functions\n\n\ntoWKT\nGDAL Functions\n\n\ntranslate\nUtilities\n\n\ntrend1d\nModules\n\n\ntrend2d\nModules\n\n\ntriangulate\nModules\n\n\ntriplot\nModules\n\n\ntrisurf\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#u",
    "href": "documentation/alphabetical.html#u",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nuniqueind\nUtilities\n\n\nupGMT\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#v",
    "href": "documentation/alphabetical.html#v",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nvband\nModules\n\n\nvecangles\nUtilities\n\n\nvector_attrib\nUtilities\n\n\nvelo\nModules\n\n\nviolin\nModules\n\n\nviz\nUtilities\n\n\nvizpdf\nUtilities\n\n\nvlines\nUtilities\n\n\nvspan\nModules"
  },
  {
    "objectID": "documentation/alphabetical.html#w",
    "href": "documentation/alphabetical.html#w",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nweather\nUtilities\n\n\nwhereami\nUtilities\n\n\nwhittaker\nUtilities\n\n\nwiggle\nModules\n\n\nwindbarbs\nModules\n\n\nwithin\nGDAL Functions\n\n\nwkt2proj\nGDAL Functions\n\n\nwmsinfo\nUtilities\n\n\nwmsread\nUtilities\n\n\nwmstest\nUtilities\n\n\nworldrectangular\nUtilities\n\n\nworldrectcoast\nUtilities\n\n\nworldrectgrid\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#x",
    "href": "documentation/alphabetical.html#x",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nxcorr\nUtilities\n\n\nxcov\nUtilities\n\n\nxy2lonlat\nGDAL Functions\n\n\nxyz2grd\nModules\n\n\nxyzw2cube\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#y",
    "href": "documentation/alphabetical.html#y",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nyeardecimal\nUtilities"
  },
  {
    "objectID": "documentation/alphabetical.html#z",
    "href": "documentation/alphabetical.html#z",
    "title": "Alphabetical Function List",
    "section": "",
    "text": "Function\nCategory\n\n\n\n\nzonal_statistics\nUtilities\n\n\nzonal_stats\nUtilities\n\n\nzscores\nUtilities"
  },
  {
    "objectID": "documentation/common_features/units.html",
    "href": "documentation/common_features/units.html",
    "title": "Units",
    "section": "",
    "text": "Units\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (spherical=:greatcircle) using the authalic radius (see PROJ_MEAN_RADIUS). You can use spherical=:flat to perform “Flat Earth” calculations (quicker but less accurate) or spherical=:ellipsoidal to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/common_features/symbols.html",
    "href": "documentation/common_features/symbols.html",
    "title": "Symbols",
    "section": "",
    "text": "Symbols\n\ncircle | c\ncross | x\ncube | u\ncustom | k\ndiamond | d\nhexagon | h\ninverted_tri | i | v\nletter | l\noctagon | g\npentagon | n\npoint | p\nplus | +\nstar | *\nsquare | s\ntriangle | t | ^\nTriangle | T\nx-dash | -\ny-dash | y"
  },
  {
    "objectID": "documentation/common_features/justify.html",
    "href": "documentation/common_features/justify.html",
    "title": "Justify",
    "section": "",
    "text": "Justify\njustify = \"code\"\nWhere code is a two chars code made up of the initials of the six: - three letter codes for horizontal (Left, Center, Right) - vertical (Top, Middle, Bottom) alignments. This gives the Nine anchor points relative to any text string may be specified by combining any of three letter codes for horizontal and vertical.\nSee here for graphical display.\nExamples:\n\njustify=“LB”\nfont=:CM"
  },
  {
    "objectID": "documentation/common_features/decorated.html",
    "href": "documentation/common_features/decorated.html",
    "title": "Line decorations",
    "section": "",
    "text": "There are two different types of decorated lines. Lines decorated with text (quoted lines) and lines decorated with symbols. This second category is still subdivided in two algorithms. They are all specified by a keyword (decorated) and a named tuple.\ndecorated=(dist=..., symbol=..., pen=..., quoted=true, etc)\n\n\n\ndist=xx or distance=xx\nDistance gap between symbols and symbol size. If xx is a two elements array or tuple the first element is gap and second the size. However, size may be ommited (defaulting to 30% of the gap) and in this case xx may be a scalar or a string.\nnumber=xx\nInstead of the above, use this option to set the number of symbols along the front instead, but in this case xx must be a two elements array or tuple with the number and size.\nleft=true\nPlot symbols on the left side of the front\nright=true\nPlot symbols on the right side of the front\nside=left|right\nAlternative to the above left or right keywords.\nlen=xx or length=xx\nLength of the vector head. xx may be numeric, a string with the length and the units attached (as in len=“2c”) or a tuple with length and units as in len=(2,:centimeters)\npen=pen\nUse an alternate pen. The pen value may contain any of valid ways of specifying pens.\nnoline=true\nMake the main front line invisible.\nsymbol= – Specify which symbol to plot:\n\nsymbol=:box\nsymbol=:circle\nsymbol=:fault\nsymbol=:triangle\nsymbol=:slip – Left-lateral or right-lateral strike-slip arrows.\nsymbol=:arcuate – Draws arcuate arrow heads\n\noffset=xx – Offset the first symbol from the beginning of the front by that amount [0].\n\n\n\n\nTo select this type the dec2=true keyword/value must be present in the decorated args. The required setting controls the placement of symbols along the quoted lines. Choose among the controlling algorithms.\n\n\n\ndist=xx or distance=xx\nGive distances between symbols on the plot in your preferred measurement unit. xx may be a scalar or a string. Use strings when appending the units c (cm), i (inch), or p (points).\ndistmap=xx\nLike above but specify distances in map units and append the unit; choose among e (m), k (km), n (nautical mile), and d (arc degree), m (arc minute), or s (arc second).\nlocations=“fname” or locations=array\nRead the text file “file.txt” and place symbols at locations in the file that matches locations along the decorated lines. Optionally, passa a Mx2 array (or GMTdataset) with the symbols location. Symbols will only be placed if the coordinates match the line coordinates to within a distance of slop (append desired unit or we use PROJ_LENGTH_UNIT). The default slop is zero, meaning only exact coordinate matches will do.\nline=xx\nGive the coordinates of the end points for one or more straight line segments. Symbols will be placed where these lines intersect the decorated lines. xx format is a Mx4 array with the coordinates of the line’s end points. The format of each line specification is [start_x start_y stop_x stop_y]. These can be replaced by either a 2-character key that uses the justification format employed in text to indicate a point on the frame or center of the map, given as [LCR][BMT] or their explicit versions (for example line=(:TopLeft,:BottomRight)). In addition, you can use min, max to mean the global minimum and maximum locations in the grid (i.e. line=(:min,:max)).\nLine=xx\nLike line But will interpret the point pairs as defining great circles.\nn_labels=xx or :n_symbols=xx\nSpecifies the number of equidistant labels for quoted lines [1].\nN_labels=xx or :N_symbols=xx\nSame as above but starts labeling exactly at the start of the line [Default centers them along the line]. Optionally, append /min_dist[c|i|p] to enforce that a minimum distance separation between successive labels is enforced. In this case xx must obviously be a string.\n\n\n\n\n\nmarker=symb or symbol=symb\nSelects the decorating symbol symb. See the [Symbols] for the list of symbols available. Custom symbols may be set with (for example, but unit can be drop) symbol=(custom=\"arrow\", size=0.3, unit=:c)\nsize=xx or markersize or ms or symbolsize\nUse any of these to set the symbol size. Sizes can be scalars, strings or tuples if a unit is used.\nangle=xx\nFor symbols at a fixed angle.\ndebug=true\nTurns on debug which will draw helper points and lines to illustrate the workings of the decorated line setup.\nfill=color\nSets the symbol fill. The color is a [Setting color] element.\npen=pen\nDraws the outline of symbols; optionally specify pen for outline [Default is width = 0.25p, color = black, style = solid]. The pen value may contain any of valid ways of specifying pens.\nnudge=xx\nNudges the placement of symbols by the specified amount. xx may be a scalar, a 2 elements array (to separate x and y nudges) or a string. Must use a string if units are used.\nn_data=xx\nSpecifies how many (x,y) points will be used to estimate symbol angles [Default is 10].\n\n\n\n\n\nTo select this type the quoted=true keyword/value must be present in the decorated args. Lines with annotations such as contours. The required setting controls the placement of labels along the quoted lines. Choose among the controlling algorithms.\n\n\n\ndist=xx or distance=xx\nGive distances between symbols on the plot in your preferred measurement unit. xx may be a scalar or a string. Use strings when appending the units c (cm), i (inch), or p (points).\ndistmap=xx\nSimilar to above but specify distances in map units and append the unit; choose among e (m), f (foot), k (km), M (mile), n (nautical mile) or u (US survey foot), and d (arc degree), m (arc minute), or s (arc second).\nlocations=“fname” or locations=array\nRead the text file “file.txt” and place symbols at locations in the file that matches locations along the decorated lines. Optionally, passa a Mx2 array (or GMTdataset) with the symbols location. Symbols will only be placed if the coordinates match the line coordinates to within a distance of slop (append desired unit or we use PROJ_LENGTH_UNIT). The default slop is zero, meaning only exact coordinate matches will do.\nline=xx\nGive the coordinates of the end points for one or more straight line segments. Symbols will be placed where these lines intersect the quoted lines. xx format is a Mx4 array with the coordinates of the line’s end points. The format of each line specification is [start_x start_y stop_x stop_y]. These can be replaced by a 2-character key that uses the justification format employed in text to indicate a point on the frame or center of the map, given as [LCR][BMT].\nLine=xx\nLike line But will interpret the point pairs as defining great circles.\nn_labels=xx or :n_symbols=xx\nSpecifies the number of equidistant labels for quoted lines [1].\nN_labels=xx or :N_symbols=xx\nSame as above but starts labeling exactly at the start of the line [Default centers them along the line]. Optionally, append /min_dist[c|i|p] to enforce that a minimum distance separation between successive labels is enforced. In this case xx must obviously be a string.\n\n\n\n\n\nangle=xx\nFor symbols at a fixed angle.\nclearance=xx\nSets the clearance between label and optional text box. xx may be a scalar, a 2 elements array (to separate x and y clearances) or a string. Must use a string if units are used. Use % to indicate a percentage of the label font size [15%].\ncolor=color\nSelects opaque text boxes [Default is transparent]; optionally specify the color [Default is PS_PAGE_COLOR]. The color is a [Setting color] element.\nconst_label=“xx”\nSets the constant label text.\ncurved=true\nSpecifies curved labels following the path [Default is straight labels].\ndebug=true\nTurns on debug which will draw helper points and lines to illustrate the workings of the decorated line setup.\ndelay=true\nDelay the plotting of the text. This is used to build a clip path based on the text, then lay down other overlays while that clip path is in effect, then turning of clipping with clip -Cs which finally plots the original text.\nfont=xx\nSets the desired font [Default FONT_ANNOT_PRIMARY with its size changed to 9p]. xx is a [Setting fonts] element.\njustify=xx\nSets label justification [Default is MC]. xx is a two char justification code (see [Justify]).\nlabel=xx\nSets the label text according to the specified option. Where xx may be a symbol or a tuple:\n\nlabel=:header – Take the label from the current segment header\nlabel=:input – Use text after the 2nd column in the fixed label location file as the label. Requires the fixed label location setting.\nlabel=(:plot_dist,“unit”) – Take the Cartesian plot distances along the line as the label. Use any of c|i|p as the unit.\nlabel=(:map_dist,“unit”) – Calculate actual map distances. Use any of d|e|f|k|n|M|n|s as the unit.\n\nmin_rad=xx\nDo not place labels where the line’s radius of curvature is less than min_rad [Default is 0].\nnudge=xx\nNudges the placement of symbols by the specified amount. xx may be a scalar, a 2 elements array (to separate x and y nudges) or a string. Must use a string if units are used.\nn_data=xx\nSpecifies how many (x,y) points will be used to estimate symbol angles [Default is 10].\npen=pen\nDraws the outline of text boxes; optionally specify pen for outline [Default is width = 0.25p, color = black, style = solid]. The pen value may contain any of valid ways of specifying pens.\nprefix=xx\nPrepends prefix (xx is a string) to all line labels. If prefix starts with a leading hyphen (-) then there will be no space between label value and the prefix.\nrounded=true\nSelects rounded rectangular text box [Default is rectangular].\nsuffices=“first,last”\nAppend the suffices first and last to the corresponding labels. Used to annotate the start and end of a line [Default just adds a prime to the second label].\nunit=xx\nAppends unit (xx is a string) to all line labels. If unit starts with a leading hyphen (-) then there will be no space between label value and the unit. [Default is no unit]."
  },
  {
    "objectID": "documentation/common_features/decorated.html#front-lines",
    "href": "documentation/common_features/decorated.html#front-lines",
    "title": "Line decorations",
    "section": "",
    "text": "dist=xx or distance=xx\nDistance gap between symbols and symbol size. If xx is a two elements array or tuple the first element is gap and second the size. However, size may be ommited (defaulting to 30% of the gap) and in this case xx may be a scalar or a string.\nnumber=xx\nInstead of the above, use this option to set the number of symbols along the front instead, but in this case xx must be a two elements array or tuple with the number and size.\nleft=true\nPlot symbols on the left side of the front\nright=true\nPlot symbols on the right side of the front\nside=left|right\nAlternative to the above left or right keywords.\nlen=xx or length=xx\nLength of the vector head. xx may be numeric, a string with the length and the units attached (as in len=“2c”) or a tuple with length and units as in len=(2,:centimeters)\npen=pen\nUse an alternate pen. The pen value may contain any of valid ways of specifying pens.\nnoline=true\nMake the main front line invisible.\nsymbol= – Specify which symbol to plot:\n\nsymbol=:box\nsymbol=:circle\nsymbol=:fault\nsymbol=:triangle\nsymbol=:slip – Left-lateral or right-lateral strike-slip arrows.\nsymbol=:arcuate – Draws arcuate arrow heads\n\noffset=xx – Offset the first symbol from the beginning of the front by that amount [0]."
  },
  {
    "objectID": "documentation/common_features/decorated.html#decorated-lines",
    "href": "documentation/common_features/decorated.html#decorated-lines",
    "title": "Line decorations",
    "section": "",
    "text": "To select this type the dec2=true keyword/value must be present in the decorated args. The required setting controls the placement of symbols along the quoted lines. Choose among the controlling algorithms.\n\n\n\ndist=xx or distance=xx\nGive distances between symbols on the plot in your preferred measurement unit. xx may be a scalar or a string. Use strings when appending the units c (cm), i (inch), or p (points).\ndistmap=xx\nLike above but specify distances in map units and append the unit; choose among e (m), k (km), n (nautical mile), and d (arc degree), m (arc minute), or s (arc second).\nlocations=“fname” or locations=array\nRead the text file “file.txt” and place symbols at locations in the file that matches locations along the decorated lines. Optionally, passa a Mx2 array (or GMTdataset) with the symbols location. Symbols will only be placed if the coordinates match the line coordinates to within a distance of slop (append desired unit or we use PROJ_LENGTH_UNIT). The default slop is zero, meaning only exact coordinate matches will do.\nline=xx\nGive the coordinates of the end points for one or more straight line segments. Symbols will be placed where these lines intersect the decorated lines. xx format is a Mx4 array with the coordinates of the line’s end points. The format of each line specification is [start_x start_y stop_x stop_y]. These can be replaced by either a 2-character key that uses the justification format employed in text to indicate a point on the frame or center of the map, given as [LCR][BMT] or their explicit versions (for example line=(:TopLeft,:BottomRight)). In addition, you can use min, max to mean the global minimum and maximum locations in the grid (i.e. line=(:min,:max)).\nLine=xx\nLike line But will interpret the point pairs as defining great circles.\nn_labels=xx or :n_symbols=xx\nSpecifies the number of equidistant labels for quoted lines [1].\nN_labels=xx or :N_symbols=xx\nSame as above but starts labeling exactly at the start of the line [Default centers them along the line]. Optionally, append /min_dist[c|i|p] to enforce that a minimum distance separation between successive labels is enforced. In this case xx must obviously be a string.\n\n\n\n\n\nmarker=symb or symbol=symb\nSelects the decorating symbol symb. See the [Symbols] for the list of symbols available. Custom symbols may be set with (for example, but unit can be drop) symbol=(custom=\"arrow\", size=0.3, unit=:c)\nsize=xx or markersize or ms or symbolsize\nUse any of these to set the symbol size. Sizes can be scalars, strings or tuples if a unit is used.\nangle=xx\nFor symbols at a fixed angle.\ndebug=true\nTurns on debug which will draw helper points and lines to illustrate the workings of the decorated line setup.\nfill=color\nSets the symbol fill. The color is a [Setting color] element.\npen=pen\nDraws the outline of symbols; optionally specify pen for outline [Default is width = 0.25p, color = black, style = solid]. The pen value may contain any of valid ways of specifying pens.\nnudge=xx\nNudges the placement of symbols by the specified amount. xx may be a scalar, a 2 elements array (to separate x and y nudges) or a string. Must use a string if units are used.\nn_data=xx\nSpecifies how many (x,y) points will be used to estimate symbol angles [Default is 10]."
  },
  {
    "objectID": "documentation/common_features/decorated.html#quoted-lines",
    "href": "documentation/common_features/decorated.html#quoted-lines",
    "title": "Line decorations",
    "section": "",
    "text": "To select this type the quoted=true keyword/value must be present in the decorated args. Lines with annotations such as contours. The required setting controls the placement of labels along the quoted lines. Choose among the controlling algorithms.\n\n\n\ndist=xx or distance=xx\nGive distances between symbols on the plot in your preferred measurement unit. xx may be a scalar or a string. Use strings when appending the units c (cm), i (inch), or p (points).\ndistmap=xx\nSimilar to above but specify distances in map units and append the unit; choose among e (m), f (foot), k (km), M (mile), n (nautical mile) or u (US survey foot), and d (arc degree), m (arc minute), or s (arc second).\nlocations=“fname” or locations=array\nRead the text file “file.txt” and place symbols at locations in the file that matches locations along the decorated lines. Optionally, passa a Mx2 array (or GMTdataset) with the symbols location. Symbols will only be placed if the coordinates match the line coordinates to within a distance of slop (append desired unit or we use PROJ_LENGTH_UNIT). The default slop is zero, meaning only exact coordinate matches will do.\nline=xx\nGive the coordinates of the end points for one or more straight line segments. Symbols will be placed where these lines intersect the quoted lines. xx format is a Mx4 array with the coordinates of the line’s end points. The format of each line specification is [start_x start_y stop_x stop_y]. These can be replaced by a 2-character key that uses the justification format employed in text to indicate a point on the frame or center of the map, given as [LCR][BMT].\nLine=xx\nLike line But will interpret the point pairs as defining great circles.\nn_labels=xx or :n_symbols=xx\nSpecifies the number of equidistant labels for quoted lines [1].\nN_labels=xx or :N_symbols=xx\nSame as above but starts labeling exactly at the start of the line [Default centers them along the line]. Optionally, append /min_dist[c|i|p] to enforce that a minimum distance separation between successive labels is enforced. In this case xx must obviously be a string.\n\n\n\n\n\nangle=xx\nFor symbols at a fixed angle.\nclearance=xx\nSets the clearance between label and optional text box. xx may be a scalar, a 2 elements array (to separate x and y clearances) or a string. Must use a string if units are used. Use % to indicate a percentage of the label font size [15%].\ncolor=color\nSelects opaque text boxes [Default is transparent]; optionally specify the color [Default is PS_PAGE_COLOR]. The color is a [Setting color] element.\nconst_label=“xx”\nSets the constant label text.\ncurved=true\nSpecifies curved labels following the path [Default is straight labels].\ndebug=true\nTurns on debug which will draw helper points and lines to illustrate the workings of the decorated line setup.\ndelay=true\nDelay the plotting of the text. This is used to build a clip path based on the text, then lay down other overlays while that clip path is in effect, then turning of clipping with clip -Cs which finally plots the original text.\nfont=xx\nSets the desired font [Default FONT_ANNOT_PRIMARY with its size changed to 9p]. xx is a [Setting fonts] element.\njustify=xx\nSets label justification [Default is MC]. xx is a two char justification code (see [Justify]).\nlabel=xx\nSets the label text according to the specified option. Where xx may be a symbol or a tuple:\n\nlabel=:header – Take the label from the current segment header\nlabel=:input – Use text after the 2nd column in the fixed label location file as the label. Requires the fixed label location setting.\nlabel=(:plot_dist,“unit”) – Take the Cartesian plot distances along the line as the label. Use any of c|i|p as the unit.\nlabel=(:map_dist,“unit”) – Calculate actual map distances. Use any of d|e|f|k|n|M|n|s as the unit.\n\nmin_rad=xx\nDo not place labels where the line’s radius of curvature is less than min_rad [Default is 0].\nnudge=xx\nNudges the placement of symbols by the specified amount. xx may be a scalar, a 2 elements array (to separate x and y nudges) or a string. Must use a string if units are used.\nn_data=xx\nSpecifies how many (x,y) points will be used to estimate symbol angles [Default is 10].\npen=pen\nDraws the outline of text boxes; optionally specify pen for outline [Default is width = 0.25p, color = black, style = solid]. The pen value may contain any of valid ways of specifying pens.\nprefix=xx\nPrepends prefix (xx is a string) to all line labels. If prefix starts with a leading hyphen (-) then there will be no space between label value and the prefix.\nrounded=true\nSelects rounded rectangular text box [Default is rectangular].\nsuffices=“first,last”\nAppend the suffices first and last to the corresponding labels. Used to annotate the start and end of a line [Default just adds a prime to the second label].\nunit=xx\nAppends unit (xx is a string) to all line labels. If unit starts with a leading hyphen (-) then there will be no space between label value and the unit. [Default is no unit]."
  },
  {
    "objectID": "documentation/common_features/arrows_control.html",
    "href": "documentation/common_features/arrows_control.html",
    "title": "Vector Attributes",
    "section": "",
    "text": "Vector Attributes\nSet arrow parameters. They are specified by a keyword (arrow) and a named tuple. Several modifiers may be provided for specifying the placement of vector heads, their shapes, and the justification of the vector. Below, left and right refers to the side of the vector line when viewed from the start point to the end point of a segment:\narrow=(length=..., start=..., shape=..., pen=..., norm=..., etc)\n\nlen=xx or length=xx\nLength of the vector head. xx may be numeric, a string with the length and the units attached (as in len=“2c”) or a tuple with length and units as in len=(2,:centimeters)\nangle=xx\nSets the angle of the vector head apex [default 30]\nmagcolor=true\nSelects the vector data quantity magnitude for use with CPT color look-up [Default requires a separate data column following the 2 or 3 coordinates]. Requires that data quantity scaling (via scale or uv) and a CPT have been selected.\nstart=true\nPlaces a vector head at the beginning of the vector path [none]. Optionally, set\n\nstart=:line – For a terminal line\nstart=:arrow – For a arrow (the default)\nstart=:circle – For a circle\nstart=:tail – For a tail\nstart=:open_arrow – For a plain open arrow\nstart=:open_tail – For a plain open tail\nstart=:left – For draw the left half-side\nstart=:right – For draw the right half-side\n\nstop=true\nPlaces a vector head at the end of the vector path [none]. Optionally, set the same values as the start case.\nmiddle=true\nPlaces a vector head at the mid-point of the vector path [none]. Optionally, set the same values as the start case but it can’t be used with the start and stop options. But it accepts two further options:\n\nmiddle=:forward\nForward direction of the vector [the default]\nmiddle=:reverse\nReverse direction of the vector.\n\nfill=color\nSets the vector head fill. The color value may contain any of valid ways ways of specifying color.\n\nfill=:none\nTurns off vector head fill.\n\nshape=xx\nSets the shape of the vector head (range -2/2). Determines the shape of the head of a vector. Normally (i.e., for vector_shape = 0), the head will be triangular, but can be changed to an arrow (1) or an open V (2). Intermediate settings give something in between. Negative values (up to -2) are allowed as well. Shortcuts available as:\n\nshape=:triang same as shape=0\nshape=:arrow same as shape=1\nshape=:V same as shape=2\n\nhalf=:left\nDraw half-arrows, using only the left side of specified heads [default is both sides].\nhalf=:right\nDraw half-arrows, using only the right side of specified heads [default is both sides].\nnorm=xx\nScales down vector attributes (pen thickness, head size) with decreasing length, where vector plot lengths shorter than norm will have their attributes scaled by length/norm. xx may be a number or a string (number&unit). Optionally, append /min for the minimum shrink factor (in the 0-1 range) that we will shrink to.\npole=(plon,plat) – Specifies the oblique pole for the great or small circles.\npen=pen\nSets the vector pen attributes. The pen value may contain any of valid ways of specifying pens. If pen has a leading ‘-’ (and hence the pen value must be a string) then the head outline is not drawn.\nang1_ang2=true or start_stop=true\nMeans that input angle, length data instead represent the start and stop opening angles of the arc segment relative to the given point. See pole to specify a specific pole for the arc [north pole].\ntrim=trim\nShift the beginning or end point (or both) along the vector segment by the given trim. To select begin or end prepend a b or a e to the trim value (hence it must be a string). Append suitable unit (c, i, or p). If the modifiers b|e are not used then trim may be two values separated by a slash, which is used to specify different trims for the beginning and end. Positive trims will short the vector while negative trims will lengthen it [no trim].\n\nIn addition, all but circular vectors may take these options:\n\njustify=??\nDetermines how the input x,y point relates to the vector. Choose from\n\njustify=:begin – The default\njustify=:end\njustify=:center\n\nendpoint=true or endpt=true\nMeans that input angle and length are provided instead the x, y coordinates of the vector end point. ATTENTION: when used from within arrows() use this directly as an arrows option instead of the arrow=(...) option because we need to know in advance the meaning of 3 & 4rth columns.\n\nFinally, Cartesian vectors may take this option:\n\nscale=[i|l]scale\nExpects a scale to magnify the polar length in the given unit. If i is prepended we use the inverse scale while if l is prepended then it is taken as a fixed length to override input lengths. Append char q if input magnitudes are given in data quantity units and we will scale them to current plot unit for Cartesian vectors or to km for geovectors. In addition, if magcolor is selected then the vector magnitudes may be used for CPT color-lookup (and no extra data column is required by the module’s cmap option).\nuv=true or uv=scale\nExpects input vx,vy vector components and uses the scale to convert to polar coordinates with length in given unit. ATTENTION: when used from within arrows() use this directly as an arrows option instead of the arrow=(...) option."
  },
  {
    "objectID": "documentation/extensions.html",
    "href": "documentation/extensions.html",
    "title": "GMT.jl Extensions",
    "section": "",
    "text": "GMT.jl provides additional high-level plotting functions and data access utilities that extend GMT’s core capabilities with Julia-specific features."
  },
  {
    "objectID": "documentation/extensions.html#quick-links",
    "href": "documentation/extensions.html#quick-links",
    "title": "GMT.jl Extensions",
    "section": "Quick Links",
    "text": "Quick Links\n\nPlotting Extensions - High-level plotting and visualization\nData Processing - Smoothing, filtering, and statistical analysis\nData Conversion - Format and coordinate transformations\nData Manipulation - Grid and data operations\nData Access - Geographic data and remote datasets\nGeographic Utilities - Geographic and geospatial tools\nGeophysical - Geophysical and Earth science applications\nTable Operations - DataFrame-style table joins\nMiscellaneous - Other utilities"
  },
  {
    "objectID": "documentation/extensions.html#plotting-extensions",
    "href": "documentation/extensions.html#plotting-extensions",
    "title": "GMT.jl Extensions",
    "section": "Plotting Extensions",
    "text": "Plotting Extensions\nHigh-level plotting functions for common visualization tasks.\n\n\n\nablines \n\nCreates a straight line(s) defined by Y = a + b * X.\n\n\n\n\n\nanaglyph \n\nCreate 3D anaglyph images\n\n\n\n\n\nappend2fig \n\nAppend elements to existing figure\n\n\n\n\n\ncoastlinesproj \n\nProject coastlines to map\n\n\n\n\n\ncolorzones \n\nApply color palettes to segmented data\n\n\n\n\n\ncubeplot \n\n3D cube plotting\n\n\n\n\n\nearthregions \n\nPlot or extract named geographic regions\n\n\n\n\n\ngraticules \n\nCreate map graticules\n\n\n\n\n\nhlines \n\nPlot horizontal reference lines\n\n\n\n\n\nimagesc \n\nScaled image display.\n\n\n\n\n\nimshow \n\nDisplay the created figures.\n\n\n\n\n\nleepacific \n\nLee’s Pacific projection utilities.\n\n\n\n\n\nlelandshade \n\nLee’s landshading utilities.\n\n\n\n\n\nlinearfitxy \n\nPlot data with fitted line.\n\n\n\n\n\nlogo \n\nPlot the GMT & Julia logos.\n\n\n\n\n\npcolor \n\nPseudocolor plot with scaled colors.\n\n\n\n\n\npiechart \n\nCreate pie charts.\n\n\n\n\n\nplotlinefit \n\nPlot data with linear fit.\n\n\n\n\n\nplotyy \n\nDual y-axis plots.\n\n\n\n\n\npolygonlevels \n\nCreate polygons from contour levels.\n\n\n\n\n\nqqplot \n\nQuantile-quantile plots.\n\n\n\n\n\nquiver \n\nVector field plots with arrows\n\n\n\n\n\nradar \n\nCreate radar/spider plots\n\n\n\n\n\nrasterzones \n\nCreate rasterized zone maps\n\n\n\n\n\nscatter3 \n\n3D scatter plots\n\n\n\n\n\ntrisurf \n\nTriangulated surface plots\n\n\n\n\n\nvband \n\nPlot vertical bands/shaded regions\n\n\n\n\n\nvlines \n\nPlot vertical reference lines\n\n\n\n\n\nworldrectangular \n\nWorld in rectangular projection\n\n\n\n\n\nworldrectcoast \n\nWorld coastlines rectangular.\n\n\n\n\n\nworldrectgrid \n\nWorld graticules rectangular."
  },
  {
    "objectID": "documentation/extensions.html#data-processing",
    "href": "documentation/extensions.html#data-processing",
    "title": "GMT.jl Extensions",
    "section": "Data Processing",
    "text": "Data Processing\nFunctions for data smoothing, filtering, and statistical analysis.\n\n\n\nautocor \n\nAutocorrelation function.\n\n\n\n\n\nautocov \n\nAutocovariance function.\n\n\n\n\n\nconv \n\nConvolution.\n\n\n\n\n\ncrop \n\nCrop grids or images.\n\n\n\n\n\ndelrows \n\nDelete rows from dataset.\n\n\n\n\n\nfindpeaks \n\nFind peaks in data.\n\n\n\n\n\nflipdim \n\nFlip array dimensions.\n\n\n\n\n\nfliplr \n\nFlip left-right.\n\n\n\n\n\nflipud \n\nFlip up-down.\n\n\n\n\n\ngunique \n\nGet unique elements with indices.\n\n\n\n\n\nhampel \n\nHampel outlier filter.\n\n\n\n\n\nisoutlier \n\nIdentify outliers.\n\n\n\n\n\nkmeans \n\nK-means clustering.\n\n\n\n\n\nlowess \n\nLocally weighted regression smoothing.\n\n\n\n\n\nmad \n\nMedian absolute deviation.\n\n\n\n\n\nnanmean \n\nMean ignoring NaNs\n\n\n\n\n\nnanstd \n\nStandard deviation ignoring NaNs\n\n\n\n\n\npca \n\nPrincipal component analysis\n\n\n\n\n\npolyfit \n\nPolynomial fitting\n\n\n\n\n\npolyval \n\nEvaluate polynomial\n\n\n\n\n\nrescale \n\nRescale data\n\n\n\n\n\nsortslicesperm \n\nSort with permutation\n\n\n\n\n\nsqueeze \n\nRemove singleton dimensions\n\n\n\n\n\nstats \n\nStatistical summary\n\n\n\n\n\nwhittaker \n\nWhittaker-Henderson smoothing\n\n\n\n\n\nxcorr \n\nCross-correlation\n\n\n\n\n\nxcov \n\nCross-covariance\n\n\n\n\n\nzscores \n\nCompute z-scores"
  },
  {
    "objectID": "documentation/extensions.html#data-conversion",
    "href": "documentation/extensions.html#data-conversion",
    "title": "GMT.jl Extensions",
    "section": "Data Conversion",
    "text": "Data Conversion\nFunctions for format and coordinate transformations.\n\n\n\nISOtime2unix \n\nISO time to Unix time\n\n\n\n\n\nODE2ds \n\nODE solution to dataset\n\n\n\n\n\ncart2pol \n\nCartesian to polar coordinates\n\n\n\n\n\ncart2sph \n\nCartesian to spherical coordinates\n\n\n\n\n\ndate2doy \n\nDate to day-of-year\n\n\n\n\n\ndf2ds \n\nDataFrame to GMTdataset\n\n\n\n\n\ndoy2date \n\nDay-of-year to date\n\n\n\n\n\nds2df \n\nGMTdataset to DataFrame\n\n\n\n\n\ngrid2tri \n\nGrid to triangulation\n\n\n\n\n\nind2bool \n\nIndices to boolean\n\n\n\n\n\nind2rgb \n\nIndexed to RGB image\n\n\n\n\n\nmat2ds \n\nMatrix to GMTdataset\n\n\n\n\n\nmat2grid \n\nMatrix to GMT grid\n\n\n\n\n\nmat2img \n\nMatrix to GMT image\n\n\n\n\n\npol2cart \n\nPolar to Cartesian\n\n\n\n\n\nsph2cart \n\nSpherical to Cartesian\n\n\n\n\n\ntern2cart \n\nTernary to Cartesian\n\n\n\n\n\nxyzw2cube \n\nTable to data cube\n\n\n\n\n\nyeardecimal \n\nDecimal year conversion"
  },
  {
    "objectID": "documentation/extensions.html#data-manipulation",
    "href": "documentation/extensions.html#data-manipulation",
    "title": "GMT.jl Extensions",
    "section": "Data Manipulation",
    "text": "Data Manipulation\nFunctions for grid and data operations.\n\n\n\ncubeslice \n\nSlice data cubes\n\n\n\n\n\nfields \n\nGet structure fields\n\n\n\n\n\nfileparts \n\nParse file paths\n\n\n\n\n\ngetbyattrib \n\nGet data by attribute\n\n\n\n\n\ngetregion \n\nGet data region\n\n\n\n\n\ngridit \n\nGrid scattered data\n\n\n\n\n\ngroupby \n\nGroup data by values\n\n\n\n\n\ninfo \n\nGet data information\n\n\n\n\n\nisclockwise \n\nCheck polygon orientation\n\n\n\n\n\nisnodata \n\nCheck for no-data values\n\n\n\n\n\nmakeDCWs \n\nMake DCW polygons\n\n\n\n\n\nmeshgrid \n\nCreate coordinate arrays\n\n\n\n\n\nmksymbol \n\nMake custom symbols\n\n\n\n\n\npeaks \n\nGenerate peaks function\n\n\n\n\n\npow \n\nPower function\n\n\n\n\n\nquadbounds \n\nQuadtree bounds\n\n\n\n\n\nquadkey \n\nQuadtree key\n\n\n\n\n\nrandinpolygon \n\nRandom points in polygon\n\n\n\n\n\nslicecube \n\nSlice through cube\n\n\n\n\n\nspatialjoin \n\nSpatial join operations\n\n\n\n\n\nstackgrids \n\nStack multiple grids\n\n\n\n\n\ntexture_img \n\nApply texture to image\n\n\n\n\n\ntogglemask \n\nToggle mask values\n\n\n\n\n\nvector_attrib \n\nVector attributes\n\n\n\n\n\nzonal_statistics \n\nZonal statistics (alias)\n\n\n\n\n\nzonal_stats \n\nZonal statistics"
  },
  {
    "objectID": "documentation/extensions.html#data-access",
    "href": "documentation/extensions.html#data-access",
    "title": "GMT.jl Extensions",
    "section": "Data Access",
    "text": "Data Access\nFunctions for accessing geographic datasets and remote data sources.\n\n\n\necmwf \n\nAccess ECMWF weather data\n\n\n\n\n\nera5time \n\nERA5 time information\n\n\n\n\n\nera5vars \n\nERA5 variable information\n\n\n\n\n\ngadm \n\nAccess GADM administrative boundaries\n\n\n\n\n\ngmtread \n\nRead GMT data files\n\n\n\n\n\ngmtwrite \n\nWrite GMT data files\n\n\n\n\n\nlasread \n\nRead LAS point cloud\n\n\n\n\n\nlaswrite \n\nWrite LAS point cloud\n\n\n\n\n\nlazinfo \n\nLAZ file information\n\n\n\n\n\nlazread \n\nRead LAZ point cloud\n\n\n\n\n\nlazwrite \n\nWrite LAZ point cloud\n\n\n\n\n\nlistecmwfvars \n\nList ECMWF variables\n\n\n\n\n\nmaregrams \n\nPlot tidal mareograms\n\n\n\n\n\nmbgetdata \n\nGet MB-System data\n\n\n\n\n\nmbimport \n\nImport MB-System data\n\n\n\n\n\nmblevitus \n\nLevitus database access\n\n\n\n\n\nmbsvplist \n\nSound velocity profiles\n\n\n\n\n\nmeteostat \n\nMeteostat weather data\n\n\n\n\n\nmosaic \n\nCreate image mosaics from tiles\n\n\n\n\n\npastplates \n\nTectonic plate reconstructions\n\n\n\n\n\nremotegrid \n\nAccess remote grid datasets\n\n\n\n\n\nsealand \n\nMask grid/image by land/sea\n\n\n\n\n\nweather \n\nWeather data and forecasts\n\n\n\n\n\nwmsinfo \n\nWMS service information\n\n\n\n\n\nwmsread \n\nFetch Web Map Service data\n\n\n\n\n\nwmstest \n\nTest WMS service"
  },
  {
    "objectID": "documentation/extensions.html#geographic-utilities",
    "href": "documentation/extensions.html#geographic-utilities",
    "title": "GMT.jl Extensions",
    "section": "Geographic Utilities",
    "text": "Geographic Utilities\nSpecialized geographic and geospatial tools.\n\n\n\ncpt4dcw \n\nColor palette for DCW\n\n\n\n\n\ngeocoder \n\nGeocoding utilities\n\n\n\n\n\ngeodetic2enu \n\nGeodetic to ENU coordinates\n\n\n\n\n\ngetprovider \n\nGet tile provider info.\n\n\n\n\n\ninpolygon \n\nTest points in polygon.\n\n\n\n\n\ninwhichpolygon \n\nFind containing polygon.\n\n\n\n\n\nmapsize2region \n\nMap size to region.\n\n\n\n\n\norbits \n\nSatellite orbit calculations.\n\n\n\n\n\nregiongeog \n\nGeographic region utilities.\n\n\n\n\n\nterramar \n\nLand/sea utilities.\n\n\n\n\n\nvecangles \n\nVector angle calculations.\n\n\n\n\n\nwhereami \n\nLocation information."
  },
  {
    "objectID": "documentation/extensions.html#geophysical",
    "href": "documentation/extensions.html#geophysical",
    "title": "GMT.jl Extensions",
    "section": "Geophysical",
    "text": "Geophysical\nSpecialized functions for geophysical and Earth science applications.\n\n\n\nokada \n\nOkada deformation model.\n\n\n\n\n\nparkergrav \n\nCalculate gravity anomalies.\n\n\n\n\n\nparkermag \n\nCalculate magnetic anomalies.\n\n\n\n\n\nseismicity \n\nPlot earthquake data.\n\n\n\n\n\nstereonet \n\nStereonets for structural geology.\n\n\n\n\n\nstreamlines \n\nCompute and plot streamlines."
  },
  {
    "objectID": "documentation/extensions.html#table-operations",
    "href": "documentation/extensions.html#table-operations",
    "title": "GMT.jl Extensions",
    "section": "Table Operations",
    "text": "Table Operations\nDataFrame-style operations for GMT datasets.\n\n\n\nGantijoin \n\nAnti join operation\n\n\n\n\n\nGcrossjoin \n\nCross join operation\n\n\n\n\n\nGinnerjoin \n\nInner join operation\n\n\n\n\n\nGleftjoin \n\nLeft join operation\n\n\n\n\n\nGouterjoin \n\nOuter join operation\n\n\n\n\n\nGrightjoin \n\nRight join operation\n\n\n\n\n\nGsemijoin \n\nSemi join operation"
  },
  {
    "objectID": "documentation/extensions.html#miscellaneous",
    "href": "documentation/extensions.html#miscellaneous",
    "title": "GMT.jl Extensions",
    "section": "Miscellaneous",
    "text": "Miscellaneous\nOther utility functions.\n\n\n\nbezier \n\nBezier curve generation\n\n\n\n\n\ncircfit \n\nFit circle to points\n\n\n\n\n\nlinspace \n\nLinearly spaced vector\n\n\n\n\n\nlogspace \n\nLogarithmically spaced vector\n\n\n\n\n\nmagic \n\nMagic square generation\n\n\n\n\n\nresetGMT \n\nReset GMT session\n\n\n\n\n\ntheme \n\nSet plot theme\n\n\n\n\n\ntic \n\nStart timer\n\n\n\n\n\ntoc \n\nStop timer\n\n\n\n\n\nuniqueind \n\nUnique with indices\n\n\n\n\n\nupGMT \n\nUpdate GMT\n\n\n\n\n\nvizpdf \n\nVisualize PDF"
  },
  {
    "objectID": "documentation/general/types.html",
    "href": "documentation/general/types.html",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "The GMTgrid type is how grids, (geo)referenced or not, comunicate in/out with the GMT library. They implement the AbstractArray interface.\nstruct GMTgrid{T&lt;:Real,N} &lt;: AbstractArray{T,N}      # The type holding a local header and data of a GMT grid\n    proj4::String                      # Projection string in PROJ4 syntax (Optional)\n    wkt::String                        # Projection string in WKT syntax (Optional)\n    epsg::Int                          # EPSG code\n    geog::Int                          # Is geographic coords? 0 -&gt; No; 1 -&gt; [-180 180]; 2 -&gt; [0 360]\n    range::Array{Float64,1}            # 1x6[8] vector with [x_min, x_max, y_min, y_max, z_min, z_max [, v_min, v_max]]\n    inc::Array{Float64,1}              # 1x2[3] vector with [x_inc, y_inc [,v_inc]]\n    registration::Int                  # Registration type: 0 -&gt; Grid registration; 1 -&gt; Pixel registration\n    nodata::Union{Float64, Float32}    # The value of nodata\n    title::String                      # Title (Optional)\n    comment::String                    # Remark (Optional)\n    command::String                    # Command used to create the grid (Optional)\n    cpt::String                        # Name of a recommended GMT CPT name for this grid.\n    names::Vector{String}              # To use whith multi-layered and when layers have names (Optional)\n    x::Array{Float64,1}                # [1 x n_columns] vector with XX coordinates\n    y::Array{Float64,1}                # [1 x n_rows]    vector with YY coordinates\n    v::Union{Vector{&lt;:Real}, Vector{String}}    # [v x n_bands]   vector with VV (vertical for 3D grids) coordinates\n    z::Array{T,N}                      # [n_rows x n_columns] grid array\n    x_unit::String                     # Units of XX axis (Optional)\n    y_unit::String                     # Units of YY axis (Optional)\n    v_unit::String                     # Units of Vertical axis (Optional)\n    z_unit::String                     # Units of z vlues (Optional)\n    layout::String                     # A three character string describing the grid memory layout\n    scale::Union{Float64, Float32}=1f0 # When saving in file apply `z = z * scale + offset`\n    offset::Union{Float64, Float32}=0f0\n    pad::Int=0                         # When != 0 means that the array is placed in a padded array of PAD rows/cols\n    hasnans::Int=0                     # 0 -&gt; \"don't know\"; 1 -&gt; confirmed, \"have no NaNs\"; 0 -&gt; confirmed, \"have NaNs\"\nend\n\n\n\nstruct GMTimage{T&lt;:Unsigned, N} &lt;: AbstractArray{T,N}   # The type holding a local header and data of a GMT image\n    proj4::String              # Projection string in PROJ4 syntax (Optional)\n    wkt::String                # Projection string in WKT syntax (Optional)\n    epsg::Int                  # EPSG code\n    geog::Int                  # Is geographic coords? 0 -&gt; No; 1 -&gt; [-180 180]; 2 -&gt; [0 360]\n    range::Vector{Float64}     # 1x6 vector with [x_min x_max y_min y_max z_min z_max]\n    inc::Vector{Float64}       # 1x2 vector with [x_inc y_inc]\n    registration::Int          # Registration type: 0 -&gt; Grid registration; 1 -&gt; Pixel registration\n    nodata::Unsigned           # The value of nodata\n    color_interp::String       # If equal to \"Gray\" an indexed image with no cmap will get a gray cmap\n    metadata::Vector{String}   # To store any metadata that can eventually be passed to GDAL (Optional)\n    names::Vector{String}      # To use whith multi-band and when bands have names (Optional)\n    x::Vector{Float64}         # [1 x n_columns] vector with XX coordinates\n    y::Vector{Float64}         # [1 x n_rows]    vector with YY coordinates\n    v::Vector{Float64}         # [v x n_bands]   vector with vertical coords or wavelengths in hypercubes (Optional)\n    image::Array{T,N}          # [n_rows x n_columns x n_bands] image array\n    labels::Vector{String}     # Labels of a Categorical CPT\n    n_colors::Int              # Number of colors stored in the vector 'colormap'\n    colormap::Vector{Int32}    # A vector with n_colors-by-4 saved column-wise\n    alpha::Matrix{UInt8}       # A [n_rows x n_columns] alpha array\n    layout::String             # A four character string describing the image memory layout\n    pad::Int                   # When != 0 means that the array is placed in a padded array of PAD rows/cols\nend\n\n\n\nstruct GMTdataset{T&lt;:Real, N} &lt;: AbstractArray{T,N}\n    data::Array{T,N}           # Mx2 Matrix with segment data\n    ds_bbox::Vector{Float64}   # Global BoundingBox (for when there are many segments)\n    bbox::Vector{Float64}      # Segment BoundingBox\n    attrib::Dict{String, String} # Dictionary with attributes/values (optional)\n    colnames::Vector{String}   # Column names. Antecipate using this with a future Tables inerface\n    text::Vector{String}       # Array with text after data coordinates (mandatory only when plotting Text)\n    header::String             # String with segment header (Optional but sometimes very useful)\n    comment::Vector{String}    # Array with any dataset comments [empty after first segment]\n    proj4::String              # Projection string in PROJ4 syntax (Optional)\n    wkt::String                # Projection string in WKT syntax (Optional)\n    epsg::Int                  # EPSG projection code (Optional)\n    geom::Integer              # Geometry type. One of the GDAL's enum (wkbPoint, wkbPolygon, etc...)\nend\n\n\n\nstruct GMTcpt\n    colormap::Array{Float64,2} # Mx3 matrix equal to the first three columns of cpt\n    alpha::Array{Float64,1}    # Vector of alpha values. One for each color.\n    range::Array{Float64,2}    # Mx2 matrix with z range for each slice\n    minmax::Array{Float64,1}   # Two elements Vector with zmin,zmax\n    bfn::Array{Float64,2}      # A 3x3(4?) matrix with BFN colors (one per row) in [0 1] interval\n    depth::Cint                # Color depth: 24, 8, 1\n    hinge::Cdouble             # Z-value at discontinuous color break, or NaN\n    cpt::Array{Float64,2}      # Mx6 matrix with r1 g1 b1 r2 g2 b2 for z1 z2 of each slice\n    categorical::Int           # Is this CPT categorical? 0 = No, 1 = Yes, 2 = Yes and keys are strings.\n    label::Vector{String}      # Labels of a Categorical CPT\n    key::Vector{String}        # Keys of a Categorical CPT\n    model::String              # String with color model rgb, hsv, or cmyk [rgb]\n    comment::Vector{String}    # Cell array with any comments\nend\n\n\n\nstruct GMTps\n    postscript::String         # Actual PS plot (text string)\n    length::Int                # Byte length of postscript\n    mode::Int                  # 1 = Has header, 2 = Has trailer, 3 = Has both\n    comment::Vector{String}    # Cell array with any comments\nend\n\n\n\nstruct GMTfv{T&lt;:AbstractFloat} &lt;: AbstractMatrix{T}\n    verts::AbstractMatrix{T}    # Mx3 Matrix with the data vertices\n    faces::Vector{&lt;:AbstractMatrix{&lt;:Integer}}  # A vector of matrices with the faces. Each row is a face\n    faces_view::Vector{Matrix{Int}}             # A subset of `faces` with only the visible faces from a certain perspective\n    bbox::Vector{Float64}       # The vertices BoundingBox\n    zscale::Float64             # A multiplicative factor to scale the z values\n    bfculling::Bool             # If culling of invisible faces is wished\n    proj4::String               # Projection string in PROJ4 syntax (Optional)\n    wkt::String                 # Projection string in WKT syntax (Optional)\n    epsg::Int                   # EPSG projection code (Optional)\nend"
  },
  {
    "objectID": "documentation/general/types.html#sec-grid-type",
    "href": "documentation/general/types.html#sec-grid-type",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "The GMTgrid type is how grids, (geo)referenced or not, comunicate in/out with the GMT library. They implement the AbstractArray interface.\nstruct GMTgrid{T&lt;:Real,N} &lt;: AbstractArray{T,N}      # The type holding a local header and data of a GMT grid\n    proj4::String                      # Projection string in PROJ4 syntax (Optional)\n    wkt::String                        # Projection string in WKT syntax (Optional)\n    epsg::Int                          # EPSG code\n    geog::Int                          # Is geographic coords? 0 -&gt; No; 1 -&gt; [-180 180]; 2 -&gt; [0 360]\n    range::Array{Float64,1}            # 1x6[8] vector with [x_min, x_max, y_min, y_max, z_min, z_max [, v_min, v_max]]\n    inc::Array{Float64,1}              # 1x2[3] vector with [x_inc, y_inc [,v_inc]]\n    registration::Int                  # Registration type: 0 -&gt; Grid registration; 1 -&gt; Pixel registration\n    nodata::Union{Float64, Float32}    # The value of nodata\n    title::String                      # Title (Optional)\n    comment::String                    # Remark (Optional)\n    command::String                    # Command used to create the grid (Optional)\n    cpt::String                        # Name of a recommended GMT CPT name for this grid.\n    names::Vector{String}              # To use whith multi-layered and when layers have names (Optional)\n    x::Array{Float64,1}                # [1 x n_columns] vector with XX coordinates\n    y::Array{Float64,1}                # [1 x n_rows]    vector with YY coordinates\n    v::Union{Vector{&lt;:Real}, Vector{String}}    # [v x n_bands]   vector with VV (vertical for 3D grids) coordinates\n    z::Array{T,N}                      # [n_rows x n_columns] grid array\n    x_unit::String                     # Units of XX axis (Optional)\n    y_unit::String                     # Units of YY axis (Optional)\n    v_unit::String                     # Units of Vertical axis (Optional)\n    z_unit::String                     # Units of z vlues (Optional)\n    layout::String                     # A three character string describing the grid memory layout\n    scale::Union{Float64, Float32}=1f0 # When saving in file apply `z = z * scale + offset`\n    offset::Union{Float64, Float32}=0f0\n    pad::Int=0                         # When != 0 means that the array is placed in a padded array of PAD rows/cols\n    hasnans::Int=0                     # 0 -&gt; \"don't know\"; 1 -&gt; confirmed, \"have no NaNs\"; 0 -&gt; confirmed, \"have NaNs\"\nend"
  },
  {
    "objectID": "documentation/general/types.html#sec-image-type",
    "href": "documentation/general/types.html#sec-image-type",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "struct GMTimage{T&lt;:Unsigned, N} &lt;: AbstractArray{T,N}   # The type holding a local header and data of a GMT image\n    proj4::String              # Projection string in PROJ4 syntax (Optional)\n    wkt::String                # Projection string in WKT syntax (Optional)\n    epsg::Int                  # EPSG code\n    geog::Int                  # Is geographic coords? 0 -&gt; No; 1 -&gt; [-180 180]; 2 -&gt; [0 360]\n    range::Vector{Float64}     # 1x6 vector with [x_min x_max y_min y_max z_min z_max]\n    inc::Vector{Float64}       # 1x2 vector with [x_inc y_inc]\n    registration::Int          # Registration type: 0 -&gt; Grid registration; 1 -&gt; Pixel registration\n    nodata::Unsigned           # The value of nodata\n    color_interp::String       # If equal to \"Gray\" an indexed image with no cmap will get a gray cmap\n    metadata::Vector{String}   # To store any metadata that can eventually be passed to GDAL (Optional)\n    names::Vector{String}      # To use whith multi-band and when bands have names (Optional)\n    x::Vector{Float64}         # [1 x n_columns] vector with XX coordinates\n    y::Vector{Float64}         # [1 x n_rows]    vector with YY coordinates\n    v::Vector{Float64}         # [v x n_bands]   vector with vertical coords or wavelengths in hypercubes (Optional)\n    image::Array{T,N}          # [n_rows x n_columns x n_bands] image array\n    labels::Vector{String}     # Labels of a Categorical CPT\n    n_colors::Int              # Number of colors stored in the vector 'colormap'\n    colormap::Vector{Int32}    # A vector with n_colors-by-4 saved column-wise\n    alpha::Matrix{UInt8}       # A [n_rows x n_columns] alpha array\n    layout::String             # A four character string describing the image memory layout\n    pad::Int                   # When != 0 means that the array is placed in a padded array of PAD rows/cols\nend"
  },
  {
    "objectID": "documentation/general/types.html#sec-dataset-type",
    "href": "documentation/general/types.html#sec-dataset-type",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "struct GMTdataset{T&lt;:Real, N} &lt;: AbstractArray{T,N}\n    data::Array{T,N}           # Mx2 Matrix with segment data\n    ds_bbox::Vector{Float64}   # Global BoundingBox (for when there are many segments)\n    bbox::Vector{Float64}      # Segment BoundingBox\n    attrib::Dict{String, String} # Dictionary with attributes/values (optional)\n    colnames::Vector{String}   # Column names. Antecipate using this with a future Tables inerface\n    text::Vector{String}       # Array with text after data coordinates (mandatory only when plotting Text)\n    header::String             # String with segment header (Optional but sometimes very useful)\n    comment::Vector{String}    # Array with any dataset comments [empty after first segment]\n    proj4::String              # Projection string in PROJ4 syntax (Optional)\n    wkt::String                # Projection string in WKT syntax (Optional)\n    epsg::Int                  # EPSG projection code (Optional)\n    geom::Integer              # Geometry type. One of the GDAL's enum (wkbPoint, wkbPolygon, etc...)\nend"
  },
  {
    "objectID": "documentation/general/types.html#sec-cpt-type",
    "href": "documentation/general/types.html#sec-cpt-type",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "struct GMTcpt\n    colormap::Array{Float64,2} # Mx3 matrix equal to the first three columns of cpt\n    alpha::Array{Float64,1}    # Vector of alpha values. One for each color.\n    range::Array{Float64,2}    # Mx2 matrix with z range for each slice\n    minmax::Array{Float64,1}   # Two elements Vector with zmin,zmax\n    bfn::Array{Float64,2}      # A 3x3(4?) matrix with BFN colors (one per row) in [0 1] interval\n    depth::Cint                # Color depth: 24, 8, 1\n    hinge::Cdouble             # Z-value at discontinuous color break, or NaN\n    cpt::Array{Float64,2}      # Mx6 matrix with r1 g1 b1 r2 g2 b2 for z1 z2 of each slice\n    categorical::Int           # Is this CPT categorical? 0 = No, 1 = Yes, 2 = Yes and keys are strings.\n    label::Vector{String}      # Labels of a Categorical CPT\n    key::Vector{String}        # Keys of a Categorical CPT\n    model::String              # String with color model rgb, hsv, or cmyk [rgb]\n    comment::Vector{String}    # Cell array with any comments\nend"
  },
  {
    "objectID": "documentation/general/types.html#sec-postscript-type",
    "href": "documentation/general/types.html#sec-postscript-type",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "struct GMTps\n    postscript::String         # Actual PS plot (text string)\n    length::Int                # Byte length of postscript\n    mode::Int                  # 1 = Has header, 2 = Has trailer, 3 = Has both\n    comment::Vector{String}    # Cell array with any comments\nend"
  },
  {
    "objectID": "documentation/general/types.html#sec-fv-type",
    "href": "documentation/general/types.html#sec-fv-type",
    "title": "The GMT.jl types (important)",
    "section": "",
    "text": "struct GMTfv{T&lt;:AbstractFloat} &lt;: AbstractMatrix{T}\n    verts::AbstractMatrix{T}    # Mx3 Matrix with the data vertices\n    faces::Vector{&lt;:AbstractMatrix{&lt;:Integer}}  # A vector of matrices with the faces. Each row is a face\n    faces_view::Vector{Matrix{Int}}             # A subset of `faces` with only the visible faces from a certain perspective\n    bbox::Vector{Float64}       # The vertices BoundingBox\n    zscale::Float64             # A multiplicative factor to scale the z values\n    bfculling::Bool             # If culling of invisible faces is wished\n    proj4::String               # Projection string in PROJ4 syntax (Optional)\n    wkt::String                 # Projection string in WKT syntax (Optional)\n    epsg::Int                   # EPSG projection code (Optional)\nend"
  },
  {
    "objectID": "documentation/general/modules.html",
    "href": "documentation/general/modules.html",
    "title": "By Modules",
    "section": "",
    "text": "In this mode we access the individual GMT modules directly by their name, and options are set using keyword arguments. The general syntax is (where the brackets mean optional parameters):\n    [output objects] = modulename([cmd::String=\"\",] [argi=[],] opt1=val1, opt2=val2, kwargs...);\nwhere modulename is the program name (e.g. coast), cmd is used to transmit a file name for modules that will read data from files and argi is one or, and for certain modules, more data arrays or GMT.jl data types. opti named arguments common to many modules used for example to set the output format. Finally kwargs are keyword parameters used to set the individual module options. But contrary to the Monolithic usage, the one letter GMT option syntax may be replaced by more verbose aliases. To make it clear let us look at couple of examples.\n    coast(region=:global, proj=(name=:laea, center=[300,30]), figsize=6, axes=\"g\", land=\"navy\")\nThis command creates a map in PotScript file called GMTjl_tmp.ps and save it in your system’s tmp directory. For comparison, the same command could have been written, using the classical one letter option syntax, as:\n    coast(R=\"g\", J=\"A300/30/6c\", B=\"g\", D=\"c\", G=\"navy\")\nSo, each module defines a set of aliases to the one letter options that are reported in each module man page.\nBefore diving more in the way options may be transmitted into the module, we have to understand what happens with the output image file. By not directly specifying any format we are using the default output image format which is PNG (actually, except for grdimage -A, the only format that GMT can write PostScript). But we can select other formats by using the fmt keyword, for example fmt=“jpg” or fmt=:pdf. In such cases, the ghostscript program (that gets installed by default) will take care of converting the ps file into the selected format.\nWhen runing from Jupyter notebooks one does not need to worry about the image format. In fact the only allowed is png but that is taken care automatically, meaning that any fmt=xxx will be ignored.\nNote that we used either strings (““) or symbols (:) to represent the format. Here the rule is we can use symbols for any string argument that can be safely written as a symbol. Example, this is valid =:abc, but this is not =:+a (apparently parser will try to add to a). The use of symbols may be preferred for a question of laziness (less typing).\nThe above example, however, does not use any input data (coast knows how to find its own data). One way of providing it to modules that work on them is to send in a file name with the data to operate on. This example\n    grdimage(\"@tut_relief.nc\", shade=\"+ne0.8+a100\", proj=:merc, axes=:a, show=true)\nreads a the netCDF grid tut_relief.nc and displays it as a Mercator projected image. The ‘@’ prefix is used by GMT to know that the grid file should be downloaded from a server and cached locally. This example introduces also the show=true keyword. It means that we want to see right way the image that has just been created. While it might seem obvious that one wants to see the result, the result might not be ready with only one GMT module call. And that’s why the GMT philosophy uses a layer cake model to construct potentially highly complex figures. Next example illustrates a slightly more evolved example\ntopo = makecpt(color=:rainbow, range=(1000,5000,500), Z=[]);\ngrdimage(\"@tut_relief.nc\", shade=\"+ne0.8+a100\", proj=:merc, axes=:a, color=topo)\ncolorbar!(position=\"jTC+w5i/0.25i+h+o0/-1i\", region=\"@tut_relief.nc\", color=topo,\n          axes=\"y+lm\", fmt=:jpg, show=true)\nHere we use the makecpt command to compute a colormap object and used it as the value of the color keyword of both grdimage and colorbar modules. The final image is made up of two layers, the first one is the part created by grdimage, which is complemented by the color scale plot performed by colorbar. But since this was an appending operation we HAD to use the ! form. This form tells GMT to append to a previous initiated image. The image layer cake is finalized by the show=true keyword. If our example had more layers, we would have used the same rule: second and on layers use the ! construct and the last is signaled by show=true.\nBy default the image files are written into tmp system directory under the name GMTjl_tmp.ps (remember PostScript is the default format) and GMTjl_tmp.xxx when user specifies a different format with the fmt keyword. It’s one of this files that shows up when show=true is used. But we may want to save the image file permanently under a different name and location. For that use the keyword savefig=name, where name is relative or full file name.\nThe examples above show also that we didn’t completely get rid of the compact GMT syntax. For example the shade=“+ne0.8+a100” in grdimage means that we are computing the shade using a normalized a cumulative Laplace distribution and setting the Sun direction from the 100 azimuth direction. For as much we would like to simplify that, it’s just not possible for the time being. To access the (very) high degree of control that GMT provides one need to use its full syntax. As such, readers are redirected to the main GMT documentation to learn about the fine details of those options.\nSetting line and symbol attributes has received, however, a set of aliases. So, instead of declaring the pen line attributes like -W0.5,blue,–, one can use the aliases lw=0.5, lc=“blue”, ls=“–”. An example would be:\nplot(collect(1:10),rand(10), lw=0.5, lc=:blue, ls=\"--\", marker=:circle,\n     markeredgecolor=0, size=0.2, markerfacecolor=:red, title=\"Bla Bla\",\n     x_label=:Spoons, y_label=:Forks, show=true)\nThis example introduces also keywords to plot symbols and set their attributes. Also shown are the parameters used to set the image’s title and labels.\nBut setting pen attributes like illustrated above may be complicated if one has more that one set of graphical objects (lines and polygons) that need to receive different settings. A good example of this is again provided by a coast command. Imagine that we want to plot coast lines as well as country borders with different line colors and thickness. Here we cannot simple state lw=1 because the program wouldn’t know which of the shore line or borders this attribute applies to. The solution for this is to use tuples as values of corresponding keyword options.\ncoast(limits=[-10 0 35 45], proj=:merc, shore=(0.5,\"red\"), axes=:a,\n      show=true, borders=(1,(1,\"green\")))\nHere we used tuples to set the pen attributes, where the tuple may have 1 to 3 elements in the form (width[c|i|p]], [color], [style[c|i|p|]). The borders=(1,(1,“green”)) option is actually a tuple-in-a-tuple because here we need also to specify the political boundary level to plot (1 = National Boundaries).\n\n\nSo, in summary, a pen attribute may be set in three different ways:\n\nWith a text string that follows the width, color, style specs as explained in Specifying pen attributes\nBy using the lw or linewidth keyword where its value is either a number, meaning the line thickness in points, or a string like the width above; the color is set with the lc or linecolor and the value is either a number between [0 255] (meaning a gray shade) or a color name (for example “red”); and a ls or linestyle with the value specified as a string (example: “- -” plot a dashed line).\nA tuple with one to three elements: ([width], [color], [style]) where each of the elements follow the same syntax as explained in the case (2) above.\n\n\n\n\nThe axes are controlled by the B or frame or axes keywords. The easiest form it can have is the axes=:a, which means do an automatic annotation of the 4 map boundaries – left, bottom, right and top – axes. To annotate only the left and bottom boundaries, one would do axes=“a WSne” (note the space between a and WSne). For a higher level of control the user must really consult the original -B documentation.\nOther than setting titles and labels with a axes string we can also do it by using the keywords title, x_label and y_label.\nThe figure limits is set with the R, region or limits keywords. Again, the full docs for this option are explained in -R documentation. But other than the string version, the numeric form region=[x_min x_max y_min y_max] is also permitted. And when dealing with grids, even the region=mygrid.grd is a valid operation. Where mygrid.grd is a GMTgrid type. The plot() function allows a no limits setting, in which case it will default to the data’s bounding box.\n\n\n\nThere are almost 150 parameters which can be adjusted individually to modify the appearance of plots or affect the manipulation of data. When a program is run, it initializes all parameters to the GMTdefaults (see more at GMT defaults). At times it may be desirable to temporarily override some of those defaults. We can do that easily by using any of the keywords conf, par or params, which are recognized by all modules. Its usage follows closely the syntax described at gmt.conf but using Named Tuples. The parameter names are always given in UPPER CASE. The parameter values are case-insensitive unless otherwise noted and can be given as strings or numeric. Provide as many parameters as you want in the named tuple. Example\n    basemap(...., conf=(MAP_TICK_LENGTH_PRIMARY=0.25, FORMAT_GEO_MAP=\"ddd:mm:ssF\"))\n\n\n\nFigure sizes are automatically set to 12x8 cm for basic case of Cartesian xy plots done with the plot() function but otherwise in general they need to be user specified using the J or proj or projection keywords. See the full doc at -J documentation. For Cartesian plots one can also use the figsize=width or figsize=[width height] keyword, where the dimensions are in centimeters. The array form allows also set height or width to 0 to have it recomputed based on the implied scale of the other axis. Use negative sizes to reverse the direction of an axis (e.g., to have y be positive down). If neither of these forms is used, the figure width defaults to 14 cm.\n\n\n\nIt was referred above that the fmt determines the output format and that the default is PostScript. Actually, the default format is chosen by the contents of the global FMT variable set at the top of the GMT.jl file. Eventually this will evolve to using an environment variable but for the moment users will have to edit that file to set a different default format.\nAn interesting alternative is to set FMT=““, that is to not specify any image format. This will result in NOT saving any file on disk but to keep the PS figure internally stored in the program’s memory. In other words, the figure is built and kept in memory only. This allows converting to another format directly without the use of an intermediary disk file. The conversion is performed by the psconvert GMT module that would be used like this (to convert to PDF):\n    psconvert(in_memory=true, adjust=true, format=:f, out_name=\"myfig.pdf\")\nThe issue with this solution, that could be implemented internally without user intervention, is that it currently only works on Windows.\nAnother alternative to a file format is the option to create RGB images with psconvert and return it to Julia as a GMTimage type.\n    I = psconvert(in_memory=true, adjust=true)\nbut again, so far on Windows only. A cool thing to develop would be the possibility to display this I image with the Images.jl package.\n\n\n\nAs referred in the Monolithic section, we have two programs to do read and writing. Their module names are gmtread and gmtwrite. These modules allow to import and export any of the GMT data types to and from external files. For instance, to save the grid G stored into a GMTgrid type into the file relief.nc we run\n    gmtwrite(\"relief.nc\", G)\nHere there is no need to inform about the type of data that we are dealing with because that can be inferred from the type of the numeric argument. There are cases, however, where we may want to save the result of a computation directly on disk instead of assigning it to a Julia variable and latter save it with gmtwrite. For computations that deal with grids that is easy. Just provide ask for an output name using the outgrid keyword, like\n    grdcut(G, limits=[3 9 2 8], outgrid=\"lixo.grd\");\nbut for table data the GMT programs normally output their results to stdout so if we want to save data directly to disk (as would do the corresponding GMT shell command) we use the write or |&gt; keywords. We can also use this mechanism to append to an existing file, but then we use the append keyword. Use together with the bo option to save as a binary file. The following converts the grid G to x,y,z triplets and save the result in an ASCII disk file.\n    grd2xyz(G, write=\"lixo.xyz\")\n\n\n\nDifferent modules take different number of inputs (for example grdblend accepts a variable number of grids) and some modules accept primary input and optionally a secondary input (for example the weights option in grdtrend). The primary input(s) can be sent as text strings with the names of files to be read or as Julia variables holding the appropriate data type, and that as the first argument to the module call. Alternatively, the numeric input can be sent via the data keyword whose value can be a tuple when the expected input is composed by more than one variable. The same applies when an option is expected to receive more than one arguments (for example the three R,G,B in grdview). Examples:\ngrdimage(G, intens=I, J=:merc, color=C, B=\"1 WSne\", X=:c, Y=0.5, show=1)\n\ngrdimage(data=G, intens=I, J=:merc, color=C, B=\"1 WSne\", X=:c, Y=0.5, show=1)\n\ngrdview(G, intens=:+, J=:merc, zsize=\"2i\", view=(145,35), G=(Gr,Gg,Gb), Q=:i, show=1)"
  },
  {
    "objectID": "documentation/general/modules.html#specifying-the-pen-attributes",
    "href": "documentation/general/modules.html#specifying-the-pen-attributes",
    "title": "By Modules",
    "section": "",
    "text": "So, in summary, a pen attribute may be set in three different ways:\n\nWith a text string that follows the width, color, style specs as explained in Specifying pen attributes\nBy using the lw or linewidth keyword where its value is either a number, meaning the line thickness in points, or a string like the width above; the color is set with the lc or linecolor and the value is either a number between [0 255] (meaning a gray shade) or a color name (for example “red”); and a ls or linestyle with the value specified as a string (example: “- -” plot a dashed line).\nA tuple with one to three elements: ([width], [color], [style]) where each of the elements follow the same syntax as explained in the case (2) above."
  },
  {
    "objectID": "documentation/general/modules.html#specifying-the-axes",
    "href": "documentation/general/modules.html#specifying-the-axes",
    "title": "By Modules",
    "section": "",
    "text": "The axes are controlled by the B or frame or axes keywords. The easiest form it can have is the axes=:a, which means do an automatic annotation of the 4 map boundaries – left, bottom, right and top – axes. To annotate only the left and bottom boundaries, one would do axes=“a WSne” (note the space between a and WSne). For a higher level of control the user must really consult the original -B documentation.\nOther than setting titles and labels with a axes string we can also do it by using the keywords title, x_label and y_label.\nThe figure limits is set with the R, region or limits keywords. Again, the full docs for this option are explained in -R documentation. But other than the string version, the numeric form region=[x_min x_max y_min y_max] is also permitted. And when dealing with grids, even the region=mygrid.grd is a valid operation. Where mygrid.grd is a GMTgrid type. The plot() function allows a no limits setting, in which case it will default to the data’s bounding box."
  },
  {
    "objectID": "documentation/general/modules.html#axes-and-other-configuration",
    "href": "documentation/general/modules.html#axes-and-other-configuration",
    "title": "By Modules",
    "section": "",
    "text": "There are almost 150 parameters which can be adjusted individually to modify the appearance of plots or affect the manipulation of data. When a program is run, it initializes all parameters to the GMTdefaults (see more at GMT defaults). At times it may be desirable to temporarily override some of those defaults. We can do that easily by using any of the keywords conf, par or params, which are recognized by all modules. Its usage follows closely the syntax described at gmt.conf but using Named Tuples. The parameter names are always given in UPPER CASE. The parameter values are case-insensitive unless otherwise noted and can be given as strings or numeric. Provide as many parameters as you want in the named tuple. Example\n    basemap(...., conf=(MAP_TICK_LENGTH_PRIMARY=0.25, FORMAT_GEO_MAP=\"ddd:mm:ssF\"))"
  },
  {
    "objectID": "documentation/general/modules.html#specifying-the-figure-size",
    "href": "documentation/general/modules.html#specifying-the-figure-size",
    "title": "By Modules",
    "section": "",
    "text": "Figure sizes are automatically set to 12x8 cm for basic case of Cartesian xy plots done with the plot() function but otherwise in general they need to be user specified using the J or proj or projection keywords. See the full doc at -J documentation. For Cartesian plots one can also use the figsize=width or figsize=[width height] keyword, where the dimensions are in centimeters. The array form allows also set height or width to 0 to have it recomputed based on the implied scale of the other axis. Use negative sizes to reverse the direction of an axis (e.g., to have y be positive down). If neither of these forms is used, the figure width defaults to 14 cm."
  },
  {
    "objectID": "documentation/general/modules.html#the-output-format",
    "href": "documentation/general/modules.html#the-output-format",
    "title": "By Modules",
    "section": "",
    "text": "It was referred above that the fmt determines the output format and that the default is PostScript. Actually, the default format is chosen by the contents of the global FMT variable set at the top of the GMT.jl file. Eventually this will evolve to using an environment variable but for the moment users will have to edit that file to set a different default format.\nAn interesting alternative is to set FMT=““, that is to not specify any image format. This will result in NOT saving any file on disk but to keep the PS figure internally stored in the program’s memory. In other words, the figure is built and kept in memory only. This allows converting to another format directly without the use of an intermediary disk file. The conversion is performed by the psconvert GMT module that would be used like this (to convert to PDF):\n    psconvert(in_memory=true, adjust=true, format=:f, out_name=\"myfig.pdf\")\nThe issue with this solution, that could be implemented internally without user intervention, is that it currently only works on Windows.\nAnother alternative to a file format is the option to create RGB images with psconvert and return it to Julia as a GMTimage type.\n    I = psconvert(in_memory=true, adjust=true)\nbut again, so far on Windows only. A cool thing to develop would be the possibility to display this I image with the Images.jl package."
  },
  {
    "objectID": "documentation/general/modules.html#saving-data-to-disk",
    "href": "documentation/general/modules.html#saving-data-to-disk",
    "title": "By Modules",
    "section": "",
    "text": "As referred in the Monolithic section, we have two programs to do read and writing. Their module names are gmtread and gmtwrite. These modules allow to import and export any of the GMT data types to and from external files. For instance, to save the grid G stored into a GMTgrid type into the file relief.nc we run\n    gmtwrite(\"relief.nc\", G)\nHere there is no need to inform about the type of data that we are dealing with because that can be inferred from the type of the numeric argument. There are cases, however, where we may want to save the result of a computation directly on disk instead of assigning it to a Julia variable and latter save it with gmtwrite. For computations that deal with grids that is easy. Just provide ask for an output name using the outgrid keyword, like\n    grdcut(G, limits=[3 9 2 8], outgrid=\"lixo.grd\");\nbut for table data the GMT programs normally output their results to stdout so if we want to save data directly to disk (as would do the corresponding GMT shell command) we use the write or |&gt; keywords. We can also use this mechanism to append to an existing file, but then we use the append keyword. Use together with the bo option to save as a binary file. The following converts the grid G to x,y,z triplets and save the result in an ASCII disk file.\n    grd2xyz(G, write=\"lixo.xyz\")"
  },
  {
    "objectID": "documentation/general/modules.html#how-inputs-are-transmitted-to-modules",
    "href": "documentation/general/modules.html#how-inputs-are-transmitted-to-modules",
    "title": "By Modules",
    "section": "",
    "text": "Different modules take different number of inputs (for example grdblend accepts a variable number of grids) and some modules accept primary input and optionally a secondary input (for example the weights option in grdtrend). The primary input(s) can be sent as text strings with the names of files to be read or as Julia variables holding the appropriate data type, and that as the first argument to the module call. Alternatively, the numeric input can be sent via the data keyword whose value can be a tuple when the expected input is composed by more than one variable. The same applies when an option is expected to receive more than one arguments (for example the three R,G,B in grdview). Examples:\ngrdimage(G, intens=I, J=:merc, color=C, B=\"1 WSne\", X=:c, Y=0.5, show=1)\n\ngrdimage(data=G, intens=I, J=:merc, color=C, B=\"1 WSne\", X=:c, Y=0.5, show=1)\n\ngrdview(G, intens=:+, J=:merc, zsize=\"2i\", view=(145,35), G=(Gr,Gg,Gb), Q=:i, show=1)"
  },
  {
    "objectID": "documentation/general/introduction.html",
    "href": "documentation/general/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "By Modules Monolithic Quick learn\n\nIntroduction\nAccess to GMT from Julia is accomplished via a main function (also called gmt), which offers full access to all of GMT’s ~140 modules as well as fundamental import, formatting, and export of GMT data objects. Internally, the GMT5 C API defines six high-level data structures (GMT6 will define only five) that handle input and output of data via GMT modules. These are data tables (representing one or more sets of points, lines, or polygons), grids (2-D equidistant data matrices), raster images (with 1–4 color bands), raw PostScript code, text tables (free-form text/data mixed records) and color palette tables (i.e., color maps). Correspondingly, we have defined five data structures that we use at the interface between GMT and Julia via the gmt function. The GMT.jl wrapper is responsible for translating between the GMT structures and native Julia structures, which are:\n\nGrids: Many tools consider equidistant grids a particular data type and numerous file formats exist for saving such data. Because GMT relies on GDAL we are able to read and write almost all such formats in addition to a native netCDF4 format that complies with both the COARDS and CF netCDF conventions. We have designed a native Julia grid structure GMTgrid that holds header information from the GMT grid as well as the data matrix representing the gridded values. These structures may be passed to GMT modules that expect grids and are returned from GMT modules that produce such grids. In addition, we supply the function mat2grid to convert a matrix and some metadata into a grid structure.\nImages: The raster image shares many characteristics with the grid structure except the bytes representing each node reflect gray shade, color bands (1, 3, or 4 for indexed, RGB and RGBA, respectively), and possibly transparency values. We therefore represent images in another native structure GMTimage that among other items contains three components: The image matrix, a color map (present for indexed images only), and an alpha matrix (for images specifying transparency on a per-pixel level). As for grids, the wrapper function mat2img for creating the correct structure is available.\nSegments: GMT considers point, line, and polygon data to be organized in one or more segments in a data table. Modules that return segments uses a native Julia segment structure GMTdataset that holds the segment data, which may be either numerical, text, or both; it also holds a segment header string which GMT uses to pass metadata. Thus, GMT modules returning segments will typically produce arrays of segments and you may pass these to any other module expecting points, lines, or polygons or use them directly in Julia. Since a matrix is one fundamental data type you can also pass a matrix directly to GMT modules as well. Consequently, it is very easy to pass data from Julia into GMT modules that process data tables as well as to receive data segments from GMT modules that process and produce data tables as output.\nColor palettes: GMT uses its flexible Color Palette Table (CPT) format to describe how the color (or pattern) of symbols, lines, polygons or grids should vary as a function of a state variable. In Julia, this information is provided in another structure GMTcpt that holds the color map as well as an optional alpha array for transparency values. Like grids, these structures may be passed to GMT modules that expect CPTs and will be returned from GMT modules that normally would produce CPT files.\nPostScript: While most users of the GMT.jl wrapper are unlikely to manipulate PostScript directly, it allows for the passing of PostScript via another data structure GMTps.\n\nGiven this design the Julia wrapper is designed to work in two distinct ways.\n\nThe first way, referred as the monolithic, is the more feature reach and follows closely the GMT usage from shell(s) command line but still provide all the facilities of the Julia language. See the Monolithic for the Reference on how to use the Package.\nThe second way uses an upper level set of functions that abstract aspects that make the monolithic usage more complex. It provides an interface to some of the GMT modules using a option=val list type syntax. This makes it more appropriate for new commers but it won’t release you from understanding the monolithic way. See the Modules\n\n\n\nBy Modules\nMonolithic\nQuick learn"
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "Browse through the different sections below to learn about the various modules, utilities, and features available.\n\n\n\nModules\nComplete reference for all GMT plotting and processing modules like plot, coast, grdimage, and more.\n\n\n\n\nGMT.jl Types\nEssential data types: GMTgrid, GMTimage, GMTdataset, GMTcpt, GMTps, and GMTfv with complete field descriptions.\n\n\n\n\nGMT.jl Extensions\nHigh-level plotting functions and data access utilities: earthregions, pcolor, quiver, weather data, and geophysical tools.\n\n\n\n\nGDAL Functions\nGeospatial data processing functions using GDAL/OGR for format conversion, projections, and geometric operations.\n\n\n\n\nSolids\nFunctions for creating and manipulating 3D geometric solids, platonic shapes, and mesh structures.\n\n\n\n\nImage Processing\nImage processing functions including morphological operations, filtering, segmentation, and color space conversions.\n\n\n\n\nCommon Features\nLearn about colors, pens, fonts, symbols, and other features used across GMT functions.\n\n\n\n\nAlphabetical List\nComplete alphabetical listing of all 308 documented functions with quick links and category information."
  },
  {
    "objectID": "comp_other_pkgs.html",
    "href": "comp_other_pkgs.html",
    "title": "Comparison with Other Packages",
    "section": "",
    "text": "Q - Is GMT.jl different from the other plotting packages in Julia?\nA - Yes and No.\n\n\n\n\nGMT.jl uses a Plots like syntax and is a general purpose plotting package but doesn’t provide (yet) the more exotic plot types that can be found in Plots, Makie, PyPlot, etc…\nIt is not interactive like GLMakie.\nIt works in a similar way of Luxor and CairoMakie in the sense that a vector graphics is generated and at the end rasterized for displaying. The plot quality should be similar to that of those packages (they use the Cairo library and GMT uses its own PostScript library). A prof of this quality is that GMT has been used for the last 30 years in publishing papers in the highest ranked journals.\n\n\n\n\n\nGMT.jl builds on 30 years of experience in fine-tunning details for producing highest quality maps (BTW GMT stands for Generic Mapping Tools) with lots of mapping projections and a deep knowledge that the Earth is round.\nThe figure dimensions in GMT are stated in physical units of cm (or inch), not pixels. The internal PS machinery uses integer numbers at an effective DPI of 1200. This allows to keep PostScript files reasonably small and at same time permits to create figures that can go as big as 11 x 11 meters.\nGMT.jl is not a map/plotting package only. It has innumerous tools for grid and vector data processing. e.g. read virtually almost all formats (directly or via GDAL), grid interpolations, 1 and 2D filtering, coordinate conversions, direct access to many of GDAL, PROJ, GEOS functions, dedicated tools for seismology, geodesy, potential methods (gravity and geomagnetism), etc…\nThanks to Julia’s FFI (Foreign Function Interface) GMT.jl can interface with the MB-system software from swath-bathymetry data processing."
  },
  {
    "objectID": "comp_other_pkgs.html#comparison-with-other-plotting-packages",
    "href": "comp_other_pkgs.html#comparison-with-other-plotting-packages",
    "title": "Comparison with Other Packages",
    "section": "",
    "text": "Q - Is GMT.jl different from the other plotting packages in Julia?\nA - Yes and No.\n\n\n\n\nGMT.jl uses a Plots like syntax and is a general purpose plotting package but doesn’t provide (yet) the more exotic plot types that can be found in Plots, Makie, PyPlot, etc…\nIt is not interactive like GLMakie.\nIt works in a similar way of Luxor and CairoMakie in the sense that a vector graphics is generated and at the end rasterized for displaying. The plot quality should be similar to that of those packages (they use the Cairo library and GMT uses its own PostScript library). A prof of this quality is that GMT has been used for the last 30 years in publishing papers in the highest ranked journals.\n\n\n\n\n\nGMT.jl builds on 30 years of experience in fine-tunning details for producing highest quality maps (BTW GMT stands for Generic Mapping Tools) with lots of mapping projections and a deep knowledge that the Earth is round.\nThe figure dimensions in GMT are stated in physical units of cm (or inch), not pixels. The internal PS machinery uses integer numbers at an effective DPI of 1200. This allows to keep PostScript files reasonably small and at same time permits to create figures that can go as big as 11 x 11 meters.\nGMT.jl is not a map/plotting package only. It has innumerous tools for grid and vector data processing. e.g. read virtually almost all formats (directly or via GDAL), grid interpolations, 1 and 2D filtering, coordinate conversions, direct access to many of GDAL, PROJ, GEOS functions, dedicated tools for seismology, geodesy, potential methods (gravity and geomagnetism), etc…\nThanks to Julia’s FFI (Foreign Function Interface) GMT.jl can interface with the MB-system software from swath-bathymetry data processing."
  },
  {
    "objectID": "comp_other_pkgs.html#comparison-with-other-packages",
    "href": "comp_other_pkgs.html#comparison-with-other-packages",
    "title": "Comparison with Other Packages",
    "section": "Comparison with other packages",
    "text": "Comparison with other packages\n\nQ - Does GMT.jl offer the same functionality of other packages in Julia?\nA - Yes.\n\nThe list is long, non exaustive, but we are not going to do a comparison here and, besides, for many cases the overlap is only partial. And why is there such a overlap with other packages? Well, GMT (the C lib) already existed before most of them.\n\nArchGDAL\nContour\nFITSIO\nGADM\nGeoJSON\nGeodesy\nHDF5\nInterpolations\nLibGEOS\nNetCDF\nProj\nRasters\nShapefile\nTriangleMesh, Triangulate.jl, Triangle.jl"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to GMT.jl",
    "section": "",
    "text": "Welcome to GMT.jl\nGMT is a data processing and visualization package for the Julia programming language, with high performance and extensibility. It provides the ability for drawing simple and very complex static vector graphics as well as conversion to the most common raster formats (PNG, JPG, GeoTIFF, etc…). Although it is a package more tailored for Earth Sciences, it can also be used for a general purpose plotting of 2 and 3D (perspective, not volumetric) graphics.\n\n\n\n\nIntroduction\n\n\n\n\nQuick learn\n\n\n\n\nInteroperability\n\n\n\n\nComparison with other packages\n\n\n\n\nInstallation and use\nUse the Julia’s inbuilt package manager to install GMT.\n] add GMT\nusing GMT\n\n\n\n\nBrowse the complete documentation\n\n\n\n\nFirst Steps - Example Gallery\n\n\n\n\nFrames Layout \n\n\n\n\nPlot Examples \n\n\n\n\nProjections \n\n\n\n\nColor maps \n\n\n\n\nImages \n\n\n\n\nContours \n\n\n\n\nArrows \n\n\n\n\nLegends \n\n\n\n\nChoropleth Maps \n\n\n\n\nTernary Plots \n\n\n\n\nSubplots \n\n\n\n\nThemes \n\n\n\n\nMiscellaneous \n\n\n\n\nEmbellishments \n\n\n\n\nArt \n\n\n\nGetting Help\n\nUse the REPL ? help mode\nVisit the Julia Discourse with questions tagged GMT\nFor technical issues and bug reports, open an issue in the GMT.jl GitHub repository"
  },
  {
    "objectID": "Interoperability.html",
    "href": "Interoperability.html",
    "title": "Interoperability with Other Packages",
    "section": "",
    "text": "GMT.jl types are plain and not fancy types built around matrices that implement the AbstractArray and Tables interfaces. So, if one wants to make a x,y or x,y,z plot out of data stored in a type with some other internal organization, the simplest is to extract the data in a Mxn matrix and pass it directly to the plot or plot3 or, often even simpler, the viz\nfunction.\nGMT.jl does not have a recipes system like Plots or Makie but it can still find its way to recognize types that it has no clue what they are. The next three sections show how we can make x,y[,z] plots as well as maps from DataFrames, ODE (SciML) and Rasters types (other commonly used types may be added in future). And that, repeating, without having no clue of what packages implement those types.\n\n\nAs an example, we show an alternative to the Plots solution presented in this [SO question] (https://stackoverflow.com/questions/69795215/plot-dataframes-in-julia-using-plots)\n\nCreate and plot a DataFrame\n\n\nusing GMT, DataFrames\ndf = DataFrame(t = 1:10, series1 = sin.(1:10), series2=rand(10));\nplot(df, show=true)\n\n\nPrecompiling packages...\n\n\n  50861.8 ms  ✓ GMT\n\n  1 dependency successfully precompiled in 52 seconds. 80 already precompiled.\n\n\n[ Info: Precompiling GMTParkerFFTExt [35a23bc9-6f20-5cbc-8971-9cdf66427582]\n\n[ Info: Precompiling GMTDataFramesExt [b0121151-b40e-578b-8798-214dacfa5da6]\n\n\n\n\n\n\n\n\n\n\n\nBut one problem with the above solution is that although the df has three columns it only plotted a single curve. This happens because in GMT 3rd and on columns may be used to control color, symbol sizes etc and cannot therefore be assumed to plotting data by default. If we want that all columns are interpreted as data, we use the multicol option, like:\n\nusing GMT, DataFrames\n\ndf = DataFrame(t = 1:10, series1 = sin.(1:10), series2=rand(10));\nplot(df, legend=:colnames, multicol=true, show=true)\n\n\n\n\n\n\n\n\nin the example above we took the legend entry from the column names, but if we want to use other labels we can do:\nplot(df, legend=(\"A\",\"B\"), multicol=true, show=true)\n\n\n\nThe examples in this section were taken from DifferentialEquations.jl examples\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\n\nplot(sol, multi=true, legend=:colnames, show=true)\n\nIf we make a 3D plot of the sol result, we get the following because first dimension in the converted type is the time.\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\n\nplot3(sol, show=true)\n\nTo plot the parametric curve with the three u1, u2, u3 components, we do:\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\nplot3(sol, x=:u1, y=:u2, z=:u3, show=true)\n\nTo interpolate the solution (must be done manually) at 5 times more points that original, do:\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\nplot3(sol, x=:u1, y=:u2, z=:u3, interp=5, show=true)\n\n\n\n\nThough many of the use cases shown could be reproduced by GMT.jl directly (it also reads netCDF and multi-layred files) the Rasters.jl package is able to keep some metadata (namely the time axis) and lazy reading of large files that GMT is not yet able to match. Here we will reproduce some of the examples from this Rasters.jl docs.\nusing GMT\nusing Rasters, RasterDataSources, ArchGDAL\n\nENV[\"RASTERDATASOURCES_PATH\"] = tempdir();\nA = Raster(WorldClim{BioClim}, 5);\nviz(A, colorbar=true)\n\n\nusing GMT, Rasters\nimport NCDatasets\n\nurl = \"https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename);\nviz(A[Ti=6], proj=:guess, coast=true, colorbar=true)\n\n\n\n\n\n\n\n\n\nurl = \"https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename);\nviz(A[Ti=1:6], proj=:Robinson, coast=true, colorbar=true)\n\n\n\n\n\n\n\n\nBut I Don’t like Kelvins. Fine, want centigrade? Just offset the z values.\n\nurl = \"https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename);\n\nG = mat2grid(A[Ti=1:6], offset=-273.15);\nviz(G, proj=:Robinson, coast=true, colorbar=true)"
  },
  {
    "objectID": "Interoperability.html#interoperability-with-some-other-packages",
    "href": "Interoperability.html#interoperability-with-some-other-packages",
    "title": "Interoperability with Other Packages",
    "section": "",
    "text": "GMT.jl types are plain and not fancy types built around matrices that implement the AbstractArray and Tables interfaces. So, if one wants to make a x,y or x,y,z plot out of data stored in a type with some other internal organization, the simplest is to extract the data in a Mxn matrix and pass it directly to the plot or plot3 or, often even simpler, the viz\nfunction.\nGMT.jl does not have a recipes system like Plots or Makie but it can still find its way to recognize types that it has no clue what they are. The next three sections show how we can make x,y[,z] plots as well as maps from DataFrames, ODE (SciML) and Rasters types (other commonly used types may be added in future). And that, repeating, without having no clue of what packages implement those types.\n\n\nAs an example, we show an alternative to the Plots solution presented in this [SO question] (https://stackoverflow.com/questions/69795215/plot-dataframes-in-julia-using-plots)\n\nCreate and plot a DataFrame\n\n\nusing GMT, DataFrames\ndf = DataFrame(t = 1:10, series1 = sin.(1:10), series2=rand(10));\nplot(df, show=true)\n\n\nPrecompiling packages...\n\n\n  50861.8 ms  ✓ GMT\n\n  1 dependency successfully precompiled in 52 seconds. 80 already precompiled.\n\n\n[ Info: Precompiling GMTParkerFFTExt [35a23bc9-6f20-5cbc-8971-9cdf66427582]\n\n[ Info: Precompiling GMTDataFramesExt [b0121151-b40e-578b-8798-214dacfa5da6]\n\n\n\n\n\n\n\n\n\n\n\nBut one problem with the above solution is that although the df has three columns it only plotted a single curve. This happens because in GMT 3rd and on columns may be used to control color, symbol sizes etc and cannot therefore be assumed to plotting data by default. If we want that all columns are interpreted as data, we use the multicol option, like:\n\nusing GMT, DataFrames\n\ndf = DataFrame(t = 1:10, series1 = sin.(1:10), series2=rand(10));\nplot(df, legend=:colnames, multicol=true, show=true)\n\n\n\n\n\n\n\n\nin the example above we took the legend entry from the column names, but if we want to use other labels we can do:\nplot(df, legend=(\"A\",\"B\"), multicol=true, show=true)\n\n\n\nThe examples in this section were taken from DifferentialEquations.jl examples\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\n\nplot(sol, multi=true, legend=:colnames, show=true)\n\nIf we make a 3D plot of the sol result, we get the following because first dimension in the converted type is the time.\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\n\nplot3(sol, show=true)\n\nTo plot the parametric curve with the three u1, u2, u3 components, we do:\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\nplot3(sol, x=:u1, y=:u2, z=:u3, show=true)\n\nTo interpolate the solution (must be done manually) at 5 times more points that original, do:\nusing GMT, DifferentialEquations\n\nfunction lorenz(du, u, p, t)\n    du[1] = p[1] * (u[2] - u[1])\n    du[2] = u[1] * (p[2] - u[3]) - u[2]\n    du[3] = u[1] * u[2] - p[3] * u[3]\nend\n\nu0 = [1.0, 5.0, 10.0];\ntspan = (0.0, 100.0);\np = (10.0, 28.0, 8 / 3);\nprob = ODEProblem(lorenz, u0, tspan, p);\nsol = solve(prob);\nplot3(sol, x=:u1, y=:u2, z=:u3, interp=5, show=true)\n\n\n\n\nThough many of the use cases shown could be reproduced by GMT.jl directly (it also reads netCDF and multi-layred files) the Rasters.jl package is able to keep some metadata (namely the time axis) and lazy reading of large files that GMT is not yet able to match. Here we will reproduce some of the examples from this Rasters.jl docs.\nusing GMT\nusing Rasters, RasterDataSources, ArchGDAL\n\nENV[\"RASTERDATASOURCES_PATH\"] = tempdir();\nA = Raster(WorldClim{BioClim}, 5);\nviz(A, colorbar=true)\n\n\nusing GMT, Rasters\nimport NCDatasets\n\nurl = \"https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename);\nviz(A[Ti=6], proj=:guess, coast=true, colorbar=true)\n\n\n\n\n\n\n\n\n\nurl = \"https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename);\nviz(A[Ti=1:6], proj=:Robinson, coast=true, colorbar=true)\n\n\n\n\n\n\n\n\nBut I Don’t like Kelvins. Fine, want centigrade? Just offset the z values.\n\nurl = \"https://archive.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename);\n\nG = mat2grid(A[Ti=1:6], offset=-273.15);\nviz(G, proj=:Robinson, coast=true, colorbar=true)"
  },
  {
    "objectID": "documentation/general.html",
    "href": "documentation/general.html",
    "title": "General Information",
    "section": "",
    "text": "Welcome to the GMT.jl general information section. These pages provide essential background and tutorials for getting started with GMT.jl.\n\n\n\nIntroduction - Getting started with GMT.jl\nQuick Learn - Quick tutorial to learn the basics\nModules Overview - Understanding GMT modules\nMonolithic Mode - Using GMT in monolithic mode\nGMT.jl Types - Important data types used in GMT.jl"
  },
  {
    "objectID": "documentation/general.html#contents",
    "href": "documentation/general.html#contents",
    "title": "General Information",
    "section": "",
    "text": "Introduction - Getting started with GMT.jl\nQuick Learn - Quick tutorial to learn the basics\nModules Overview - Understanding GMT modules\nMonolithic Mode - Using GMT in monolithic mode\nGMT.jl Types - Important data types used in GMT.jl"
  },
  {
    "objectID": "documentation/general/quick_learn.html",
    "href": "documentation/general/quick_learn.html",
    "title": "Quick learn",
    "section": "",
    "text": "So you already know GMT and how to consult the GMT manual pages. Then the easiest way to start is to use the option letters and options arguments as strings. Since (nearly) all base modules received a wrapper you would call pscoast (or its alias coast) like this:\ncoast(R=\"-10/0/35/45\", J=\"M15c\", B=\"afg\", W=\"0.5p\", show=true)\nbut what if you need to make a map with some data, a grid for example. Simple, give it as a first argument as in:\ngrdimage(\"@earth_relief_20m\", J=\"R15c\", B=\"a\", show=true)\nThis will compute a cpt under the hood and use it. But what if you want to use another cpt? Also simple, just make one and use it in the above command. i.e.:\nCPT = makecpt(T=\"-10000/8000/1000\");\ngrdimage(\"@earth_relief_20m\", J=\"R15c\", B=\"a\", C=CPT, show=true)\nThe last command introduced a novelty in using the C option and that’s where things start to be interesting. Instead of using a previously existing cpt file, e.g. a file called color.cpt and used it as C=“color.cpt”, we created a GMTcpt object that resides only in Julia memory space and passed it directly via the C option. The same could have been done if we had the earth_relief_20m grid in memory, which, for example sake, can be achieved by previously reading the grid file.\nCPT = makecpt(T=\"-10000/8000/1000\");\nG = gmtread(\"@earth_relief_20m\");\ngrdimage(G, J=\"R15c\", B=\"a\", C=CPT, show=true)\nThough not particularly useful nor memory more efficient to read the grid first this example illustrates typical usage. That is, use GMT to process and map/plot data resident in Julia memory. GMT modules know how to manipulate import/create data stored in GMTgrid, GMTimage, GMTdataset, GMTcpt and GMTps objects. The helper functions mat2grid, mat2img and mat2ds exist to allow creating those objects from 2D arrays of floats, uint8, uint16 and MxN matrices respectively.\nExample: create three grids with random data, compute their average and display it\nG1 = mat2grid(rand(128,128));\nG2 = mat2grid(rand(128,128));\nG3 = mat2grid(rand(128,128));\nGavg = (G1 .+ G2 .+ G3) ./ 3;\nimshow(Gavg)\nHere we introduced also the use of a module that does not exist in GMT, imshow, but one that is in fact a mockup made with grdimage, grdview, plot and plot3d and with a set of defaults and guesswork that allows quick and easy display of grids and images. It also opens the door for a more vast ensemble of tools that go beyond the use of pure GMT syntax.\n\n\n\nThe GMT terse syntax is extremely versatile but also more cryptical and less on the likes of current times where explicit is better. So all of the one letter options in GMT modules were given an alias as well as many of its arguments. But there are so many of them (options + sub-options) that this raises a problem of documentation. Some modules have received an adapted version of the GMT official documentation but this is such a huge task that many modules do not have one yet. Most modules have a on-line help (type ? prog_name) that maps the one letter option to its aliases (there often more than one alias). This still leaves, however, the issue of how the sub-options have been expanded. This has been addressed for the modules that have so far a Julia manual, but not for all the others. For those, the recommended way is to use the helper program gmthelp. It lists the mapping between the options aliases (and, for some, the sub-options) and the GMT syntax. Let’s, see the example of the plot (psxy) module\n    gmthelp(plot)\n    Option: R, or region, or limits =&gt; GMTgrid | NamedTuple |Tuple | Array | String\n    Option: J, or proj, or projection =&gt; NamedTuple | String\n    Option: B, or frame, or axes, or xaxis, or yaxis, or zaxis, or axis2, or xaxis2, or yaxis2 =&gt; NamedTuple | String\n    Option: a, or e, or f, or g, or l, or p, or t, or params =&gt; (Common options)\n    Option: D, or shift, or offset =&gt; Tuple | String | Number | Bool [Possibly not yet expanded]\n    Option: I, or intens =&gt; Tuple | String | Number | Bool [Possibly not yet expanded]\n    Option: N, or no_clip, or noclip =&gt; Tuple | String | Number | Bool [Possibly not yet expanded]\n    Option: A, or steps, or straight_lines =&gt; (x=?(x), y=?(y), meridian=?(m), parallel=?(p), )\n    Option: F, or conn, or connection =&gt; (continuous=?(c), net=?(n), network=?(n), refpoint=?(r), ignore_hdr=Any(a), single_group=Any(f), segments=Any(s), segments_reset=Any(r), anchor=?(), )\n    Option: C, or color, or cmap =&gt; GMTcpt | Tuple | Array | String | Number\n    Option: G, or fill =&gt; NamedTuple | Tuple | Array | String | Number\n    Option: G, or markerfacecolor, or MarkerFaceColor, or mc =&gt; NamedTuple | Tuple | Array | String | Number\n    Option: L, or close, or polygon =&gt; (left=Any(+xl), right=Any(+xr), x0=?(+x), bot=Any(+yb), top=Any(+yt), y0=?(+y), sym=Any(+d), asym=Any(+D), envelope=Any(+b), pen=?(+p), )\n    Option: W, or pen =&gt; NamedTuple | Tuple | String | Number\n    Option: S, or symbol =&gt; (symb=?(1), size=?(), unit=?(1), )\nLet’s look for example at option C that is called color or cmap in the expanded form. It can take as argument a GMTcpt argument (the example above), or a Tuple with the three (R,G,B) color elements with values between 0 and 255, or in a Array form [R, G, B], or a String (e.g. color=“color.cpt”, or color=“red”), or as a Number (color=200).\nLet’s also look at the L or close or polygon option. It says that this option can be expanded in form a named tuple with keys like bot, top, x0, etc… (they describe how to connect first and last point). The Any in sub-options like bot=Any(+yb) informs that Anything will do and the (+yb) is the GMT terse syntax modifier. This info is useful when one needs to consult the pure GMT documentation. On the other hand when we see pen=?(+p) the ? means that one have to give the required info. So, for example polygon=(bot=true, pen=(1, :red)) means “close the poly-line trough ymin and outline it with a red pen with 1 point thickness”\nOther options end with (Common options). This means they are options common to all GMT programs and that, for the ones that are currently implemented, one can do\ngmthelp(:b)\n    Option: b, or binary =&gt; (ncols=?(), type=?(), swapp_bytes=Any(w), little_endian=Any(+l), big_endian=?(+b), )\nbut for many we still get\ngmthelp(:i)\n    Option: i, or incol =&gt; (Common option not yet expanded)\nmeaning we must use the terse syntax arguments in form of strings. e.g. incol=\"0,2\" to read only first and third column of input data.\nStill other options end with [Possibly not yet expanded]. It means that sub-options have not yet received aliases so you must use either arguments in string form or in Tuple form in case the input is numeric and GMT expects numbers separated by slashes. For example (invented option) shift=(1,2) will translate to s1/2\nThe plot command is hugely vast, so a series of avatars have been derived from it. Namely, lines, specialized in plotting lines only; scater & scater3 for scatter plots; bar & bar3, for bar plots, arrows for drawing arrows; plot3, ternary, plotyy. They all share the same argument syntax that mimics in many cases the matplotlib syntax with also many Matlab synonyms.\nExamples\n# A Scatter plot\nscatter(rand(100),rand(100), markersize=rand(100), marker=:c, color=:ocean,\n        zcolor=rand(100), alpha=50, Y=4, title=\"Scatter\", show=true)\n# Colored bar plot\nbar(rand(15), color=:rainbow, figsize=(14,8), title=\"Colored bars\", Y=3, show=true)\n# Arrow\narrows([0.5 0.5 0 8], limits=(-0.1,3,0,2.5), figsize=(16,5), arrow=(len=2,stop=1,shape=0.5),\n       pen=6, B=\"a WSrt\", title=\"Arrow\", show=true)\n# Peaks 3D bars\nG = GMT.peaks();    cmap = grd2cpt(G);      # Compute a colormap with the grid's data range\nbar3(G, lw=:thinnest, color=cmap, figsize=14, Y=5, show=true)\n# Contours\nG = GMT.peaks();\ngrdcontour(G, color=makecpt(range=(-6,8,1)), pen=\"+c\", region=(-3,3,-3,3), title=\"Contours\", show=true)"
  },
  {
    "objectID": "documentation/general/quick_learn.html#case-1.-you-are-already-a-gmt-user",
    "href": "documentation/general/quick_learn.html#case-1.-you-are-already-a-gmt-user",
    "title": "Quick learn",
    "section": "",
    "text": "So you already know GMT and how to consult the GMT manual pages. Then the easiest way to start is to use the option letters and options arguments as strings. Since (nearly) all base modules received a wrapper you would call pscoast (or its alias coast) like this:\ncoast(R=\"-10/0/35/45\", J=\"M15c\", B=\"afg\", W=\"0.5p\", show=true)\nbut what if you need to make a map with some data, a grid for example. Simple, give it as a first argument as in:\ngrdimage(\"@earth_relief_20m\", J=\"R15c\", B=\"a\", show=true)\nThis will compute a cpt under the hood and use it. But what if you want to use another cpt? Also simple, just make one and use it in the above command. i.e.:\nCPT = makecpt(T=\"-10000/8000/1000\");\ngrdimage(\"@earth_relief_20m\", J=\"R15c\", B=\"a\", C=CPT, show=true)\nThe last command introduced a novelty in using the C option and that’s where things start to be interesting. Instead of using a previously existing cpt file, e.g. a file called color.cpt and used it as C=“color.cpt”, we created a GMTcpt object that resides only in Julia memory space and passed it directly via the C option. The same could have been done if we had the earth_relief_20m grid in memory, which, for example sake, can be achieved by previously reading the grid file.\nCPT = makecpt(T=\"-10000/8000/1000\");\nG = gmtread(\"@earth_relief_20m\");\ngrdimage(G, J=\"R15c\", B=\"a\", C=CPT, show=true)\nThough not particularly useful nor memory more efficient to read the grid first this example illustrates typical usage. That is, use GMT to process and map/plot data resident in Julia memory. GMT modules know how to manipulate import/create data stored in GMTgrid, GMTimage, GMTdataset, GMTcpt and GMTps objects. The helper functions mat2grid, mat2img and mat2ds exist to allow creating those objects from 2D arrays of floats, uint8, uint16 and MxN matrices respectively.\nExample: create three grids with random data, compute their average and display it\nG1 = mat2grid(rand(128,128));\nG2 = mat2grid(rand(128,128));\nG3 = mat2grid(rand(128,128));\nGavg = (G1 .+ G2 .+ G3) ./ 3;\nimshow(Gavg)\nHere we introduced also the use of a module that does not exist in GMT, imshow, but one that is in fact a mockup made with grdimage, grdview, plot and plot3d and with a set of defaults and guesswork that allows quick and easy display of grids and images. It also opens the door for a more vast ensemble of tools that go beyond the use of pure GMT syntax."
  },
  {
    "objectID": "documentation/general/quick_learn.html#case-2.-you-are-a-new-gmt-user-or-one-that-wants-to-use-long-verbose-options",
    "href": "documentation/general/quick_learn.html#case-2.-you-are-a-new-gmt-user-or-one-that-wants-to-use-long-verbose-options",
    "title": "Quick learn",
    "section": "",
    "text": "The GMT terse syntax is extremely versatile but also more cryptical and less on the likes of current times where explicit is better. So all of the one letter options in GMT modules were given an alias as well as many of its arguments. But there are so many of them (options + sub-options) that this raises a problem of documentation. Some modules have received an adapted version of the GMT official documentation but this is such a huge task that many modules do not have one yet. Most modules have a on-line help (type ? prog_name) that maps the one letter option to its aliases (there often more than one alias). This still leaves, however, the issue of how the sub-options have been expanded. This has been addressed for the modules that have so far a Julia manual, but not for all the others. For those, the recommended way is to use the helper program gmthelp. It lists the mapping between the options aliases (and, for some, the sub-options) and the GMT syntax. Let’s, see the example of the plot (psxy) module\n    gmthelp(plot)\n    Option: R, or region, or limits =&gt; GMTgrid | NamedTuple |Tuple | Array | String\n    Option: J, or proj, or projection =&gt; NamedTuple | String\n    Option: B, or frame, or axes, or xaxis, or yaxis, or zaxis, or axis2, or xaxis2, or yaxis2 =&gt; NamedTuple | String\n    Option: a, or e, or f, or g, or l, or p, or t, or params =&gt; (Common options)\n    Option: D, or shift, or offset =&gt; Tuple | String | Number | Bool [Possibly not yet expanded]\n    Option: I, or intens =&gt; Tuple | String | Number | Bool [Possibly not yet expanded]\n    Option: N, or no_clip, or noclip =&gt; Tuple | String | Number | Bool [Possibly not yet expanded]\n    Option: A, or steps, or straight_lines =&gt; (x=?(x), y=?(y), meridian=?(m), parallel=?(p), )\n    Option: F, or conn, or connection =&gt; (continuous=?(c), net=?(n), network=?(n), refpoint=?(r), ignore_hdr=Any(a), single_group=Any(f), segments=Any(s), segments_reset=Any(r), anchor=?(), )\n    Option: C, or color, or cmap =&gt; GMTcpt | Tuple | Array | String | Number\n    Option: G, or fill =&gt; NamedTuple | Tuple | Array | String | Number\n    Option: G, or markerfacecolor, or MarkerFaceColor, or mc =&gt; NamedTuple | Tuple | Array | String | Number\n    Option: L, or close, or polygon =&gt; (left=Any(+xl), right=Any(+xr), x0=?(+x), bot=Any(+yb), top=Any(+yt), y0=?(+y), sym=Any(+d), asym=Any(+D), envelope=Any(+b), pen=?(+p), )\n    Option: W, or pen =&gt; NamedTuple | Tuple | String | Number\n    Option: S, or symbol =&gt; (symb=?(1), size=?(), unit=?(1), )\nLet’s look for example at option C that is called color or cmap in the expanded form. It can take as argument a GMTcpt argument (the example above), or a Tuple with the three (R,G,B) color elements with values between 0 and 255, or in a Array form [R, G, B], or a String (e.g. color=“color.cpt”, or color=“red”), or as a Number (color=200).\nLet’s also look at the L or close or polygon option. It says that this option can be expanded in form a named tuple with keys like bot, top, x0, etc… (they describe how to connect first and last point). The Any in sub-options like bot=Any(+yb) informs that Anything will do and the (+yb) is the GMT terse syntax modifier. This info is useful when one needs to consult the pure GMT documentation. On the other hand when we see pen=?(+p) the ? means that one have to give the required info. So, for example polygon=(bot=true, pen=(1, :red)) means “close the poly-line trough ymin and outline it with a red pen with 1 point thickness”\nOther options end with (Common options). This means they are options common to all GMT programs and that, for the ones that are currently implemented, one can do\ngmthelp(:b)\n    Option: b, or binary =&gt; (ncols=?(), type=?(), swapp_bytes=Any(w), little_endian=Any(+l), big_endian=?(+b), )\nbut for many we still get\ngmthelp(:i)\n    Option: i, or incol =&gt; (Common option not yet expanded)\nmeaning we must use the terse syntax arguments in form of strings. e.g. incol=\"0,2\" to read only first and third column of input data.\nStill other options end with [Possibly not yet expanded]. It means that sub-options have not yet received aliases so you must use either arguments in string form or in Tuple form in case the input is numeric and GMT expects numbers separated by slashes. For example (invented option) shift=(1,2) will translate to s1/2\nThe plot command is hugely vast, so a series of avatars have been derived from it. Namely, lines, specialized in plotting lines only; scater & scater3 for scatter plots; bar & bar3, for bar plots, arrows for drawing arrows; plot3, ternary, plotyy. They all share the same argument syntax that mimics in many cases the matplotlib syntax with also many Matlab synonyms.\nExamples\n# A Scatter plot\nscatter(rand(100),rand(100), markersize=rand(100), marker=:c, color=:ocean,\n        zcolor=rand(100), alpha=50, Y=4, title=\"Scatter\", show=true)\n# Colored bar plot\nbar(rand(15), color=:rainbow, figsize=(14,8), title=\"Colored bars\", Y=3, show=true)\n# Arrow\narrows([0.5 0.5 0 8], limits=(-0.1,3,0,2.5), figsize=(16,5), arrow=(len=2,stop=1,shape=0.5),\n       pen=6, B=\"a WSrt\", title=\"Arrow\", show=true)\n# Peaks 3D bars\nG = GMT.peaks();    cmap = grd2cpt(G);      # Compute a colormap with the grid's data range\nbar3(G, lw=:thinnest, color=cmap, figsize=14, Y=5, show=true)\n# Contours\nG = GMT.peaks();\ngrdcontour(G, color=makecpt(range=(-6,8,1)), pen=\"+c\", region=(-3,3,-3,3), title=\"Contours\", show=true)"
  },
  {
    "objectID": "documentation/general/monolitic.html",
    "href": "documentation/general/monolitic.html",
    "title": "Monolithic",
    "section": "",
    "text": "In this mode all GMT options are put in a single text string that is passed, plus the data itself when it applies, to the gmt() command. This function is invoked with the syntax (where the brackets mean optional parameters):\n    [output objects] = gmt(\"modulename optionstring\" [, input objects]);\nwhere modulename is a string with the name of a GMT module (e.g., surface, grdimage, psmeca, or even a custom extension), while the optionstring is a text string with the options passed to this module. If the module requires data inputs from the Julia environment, then these are provided as optional comma-separated arguments following the option string. Should the module produce output(s) then these are captured by assigning the result of gmt to one or more comma-separated variables. Some modules do not require an option string or input objects, or neither, and some modules do not produce any output objects.\nIn addition, it can also use two i/o modules that are irrelevant on the command line: the read and write modules. These modules allow to import and export any of the GMT data types to and from external files. For instance, to import a grid from the file relief.nc we run\n    G = gmt(\"read -Tg relief.nc\");\nWe use the -T option to specify grid (g), image (i), PostScript (p), color palette (c), dataset (d) or textset (t). Results kept in Julia can be written out at any time via the write module, e.g., to save the grid Z to a file we use\n    gmt(\"write model_surface.nc\", Z);\nBecause GMT data tables often contain headers followed by many segments, each with their individual segment headers, it is best to read such data using the read module since native Julia import functions risk to choke on such headers.\n\n\nEach GMT module knows what its primary input and output objects should be. Some modules only produce output (e.g., psbasemap makes a basemap plot with axes annotations) while other modules only expect input and do not return any items back (e.g., the write module writes the data object it is given to a file). Typically, (i.e., on the command line) users must carefully specify the input filenames and sometimes give these via a module option. Because users of this wrapper will want to provide input from data already in memory and likewise wish to assign results to variables, the syntax between the command line and Julia commands necessarily must differ. For example, here is a basic GMT command that reads the time-series raw_data.txt and filters it using a 15-unit full-width (6 sigma) median filter:\n    gmt filter1d raw_data.txt –Fm15 &gt; filtered_data.txt\nHere, the input file is given on the command line but input could instead come via the shell’s standard input stream via piping. Most GMT modules that write tables will write these to the shell’s output stream and users will typically redirect these streams to a file (as in our example) or pipe the output into another process. When using GMT.jl there are no shell redirections available. Instead, we wish to pass data to and from the Julia environment. If we assume that the content in raw_data.txt exists in a array named raw_data and we wish to receive the filtered result as a segment array named filtered, we would run the command\n    filtered = gmt(\"filter1d -Fm15\", raw_data);\nThis illustrates the main difference between command line and Julia usage: Instead of redirecting output to a file we return it to an internal object (here, a segment array) using standard Julia assignments of output.\nFor data types where piping and redirection of output streams are inappropriate (including most grid file formats) the GMT modules use option flags to specify where grids should be written. Consider a GMT command that reads (x, y, z) triplets from the file depths.txt and produces an equidistant grid using a Green’s function-based spline-in-tension gridding routine:\n    gmt greenspline depths.txt -R-50/300/200/600 -I5 -D1 -St0.3 -Gbathy.nc\nHere, the result of gridding Cartesian data (-D1) within the specified region (an equidistant lattice from x from -50 to 300 and y from 200 to 600, both with increments of 5) using moderately tensioned cubic splines (-St0.3) is written to the netCDF file bathy.nc. When using GMT.jl we do not want to write a file but wish to receive the resulting grid as a new Julia variable. Again, assuming we already loaded in the input data, the equivalent command is\n    bathy = gmt(\"greenspline -R-50/300/200/600 -I5 -D1 -St0.3\", depths);\nNote that -G is no longer specified among the options. In this case the wrapper uses the GMT API to determine that the primary output of greenspline is a grid and that this is specified via the -G option. If no such option is given (or given without specifying a filename), then we instead return the grid via memory, provided a left-side assignment is specified. GMT only allows this behavior when called via an external API such as this wrapper: Not specifying the -G option on the command line would result in an error message. However, it is perfectly fine to specify the option -Gbathy.nc in Julia – it simply means you are saving the result to a file instead of returning it to Julia.\nSome GMT modules can produce more than one output (here called a secondary outputs) or can read more than one input type (i.e., secondary inputs). Secondary inputs or outputs are always specified by explicit module options on the command line, e.g., -Fpolygon.txt. In these cases, the gmt() enforces the following rules: When a secondary input is passed as an object then we must specify the corresponding option flag but provide no file argument (e.g., just -F in the above case). Likewise, for secondary output we supply the option flag and add additional objects to the left-hand side of the assignment. All secondary items, whether input or output, must appear after all primary items, and if more than one secondary item is given then their order must match the order of the corresponding options in option string.\nHere are two examples contrasting the GMT command line versus gmt() usage. In the first example we wish to determine all the data points in the file all_points.txt that happen to be located inside the polygon specified in the file polygon.txt. On the command line this would be achieved by\n    gmt select points.txt -Fpolygon.txt &gt; points_inside.txt\nwhile in Julia (assuming the points and polygon already reside in memory) we would run\n    inside = gmt(\"gmtselect -F\", points, polygon);\nHere, the points object must be listed first since it is the primary data expected.\nOur second example considers the joining of line segments into closed polygons. We wish to create one file with all closed polygons and another file with any remaining disjointed lines. Not expecting perfection, we allow segment end-points closer than 0.1 units to be connected. On the command line we would run\n    gmt connect all_segments.txt -Cclosed.txt -T0.1 &gt; rest.txt\nwhere all_segments.txt are the input lines, closed.txt is the file that will hold closed polygons made from the relevant lines, while any remaining lines (i.e., open polygons) are written to standard output and redirected to the file rest.txt. Equivalent Julia usage would be\nall = gmt(\"read -Td all_segments.txt\");\nrest, closed = gmt(\"gmtconnect -T0.1 -C\", all);\nNote the primary output (here rest) must be listed before any secondary outputs (here closed) in the left-hand side of the assignment.\nSo far, the gmt() function has been able to understand where inputs and outputs objects should be inserted, provided we follow the rules introduced above. However, there are two situations where more information must be provided. The first situation involves two GMT modules that allow complete freedom in how arguments are passed. These are gmtmath and grdmath, our reverse polish notation calculators for tables and grids, respectively. While the command-line versions require placement of arguments in the right order among the desired operators, the gmt() necessarily expects all inputs at the end of the function call. Hence we must assist the command by placing markers where the input arguments should be used; the marker we chose is the question mark (?). We will demonstrate this need using an example of grdmath. Imagine that we have created two separate grids: kei.nc contains an evaluation of the radial z = bei(r) Kelvin-Bessel function while cos.nc contains a cylindrical undulation in the x-direction. We create these two grids on the command line by\ngmt grdmath -R-4/4/-4/4 -I256+ X Y HYPOT KEI = kei.nc\ngmt grdmath -R -I256+ X COS = cos.nc\nLater, we decide we need pi plus the product of these two grids, so we compute\n    gmt grdmath kei.nc cos.nc MUL PI ADD = answer.nc\nIn Julia the first two commands are straightforward:\nkei = gmt(\"grdmath -R-4/4/-4/4 -I256+ X Y HYPOT KEI\");\nC   = gmt(\"grdmath -R -I256+ X COS\");\nbut when time comes to perform the final calculation we cannot simply do\n    answer = gmt(\"grdmath MUL PI ADD\", kei, C);\nsince grdmath would not know where kei and C should be put in the context of the operators MUL and ADD. We could probably teach grdmath to discover the only possible solution since the MUL operator requires two operands but none are listed on the command line. The logical choice then is to take kei and C as operands. However, in the general case it may not be possible to determine a unique layout, but more importantly it is simply too confusing to separate all operators from their operands (other than constants) as we would lose track of the mathematical operation we are performing. For this reason, we will assist the module by inserting question marks where we wish the module to use the next unused input object in the list. Hence, the valid command becomes\n    answer = gmt(\"grdmath ? ? MUL PI ADD\", kei, C);\nOf course, all these calculations could have been done at once with no input objects but often we reuse results in different contexts and then the markers are required. The second situation arises if you wish to use a grid as argument to the -R option (i.e., to set the current region to that of the grid). On the command line this may look like\n    gmt pscoast -Reurope.nc -JM5i –P -Baf -Gred &gt; map.ps\nHowever, in Julia we cannot simply supply -R with no argument since that is already an established shorthand for selecting the previously specified region. The solution is to supply –R?. Assuming our grid is called europe then the Julia command would become\n    map = gmt(\"pscoast -R? -JM5i -P -Baf -Gred\", europe);"
  },
  {
    "objectID": "documentation/general/monolitic.html#how-input-and-output-are-assigned",
    "href": "documentation/general/monolitic.html#how-input-and-output-are-assigned",
    "title": "Monolithic",
    "section": "",
    "text": "Each GMT module knows what its primary input and output objects should be. Some modules only produce output (e.g., psbasemap makes a basemap plot with axes annotations) while other modules only expect input and do not return any items back (e.g., the write module writes the data object it is given to a file). Typically, (i.e., on the command line) users must carefully specify the input filenames and sometimes give these via a module option. Because users of this wrapper will want to provide input from data already in memory and likewise wish to assign results to variables, the syntax between the command line and Julia commands necessarily must differ. For example, here is a basic GMT command that reads the time-series raw_data.txt and filters it using a 15-unit full-width (6 sigma) median filter:\n    gmt filter1d raw_data.txt –Fm15 &gt; filtered_data.txt\nHere, the input file is given on the command line but input could instead come via the shell’s standard input stream via piping. Most GMT modules that write tables will write these to the shell’s output stream and users will typically redirect these streams to a file (as in our example) or pipe the output into another process. When using GMT.jl there are no shell redirections available. Instead, we wish to pass data to and from the Julia environment. If we assume that the content in raw_data.txt exists in a array named raw_data and we wish to receive the filtered result as a segment array named filtered, we would run the command\n    filtered = gmt(\"filter1d -Fm15\", raw_data);\nThis illustrates the main difference between command line and Julia usage: Instead of redirecting output to a file we return it to an internal object (here, a segment array) using standard Julia assignments of output.\nFor data types where piping and redirection of output streams are inappropriate (including most grid file formats) the GMT modules use option flags to specify where grids should be written. Consider a GMT command that reads (x, y, z) triplets from the file depths.txt and produces an equidistant grid using a Green’s function-based spline-in-tension gridding routine:\n    gmt greenspline depths.txt -R-50/300/200/600 -I5 -D1 -St0.3 -Gbathy.nc\nHere, the result of gridding Cartesian data (-D1) within the specified region (an equidistant lattice from x from -50 to 300 and y from 200 to 600, both with increments of 5) using moderately tensioned cubic splines (-St0.3) is written to the netCDF file bathy.nc. When using GMT.jl we do not want to write a file but wish to receive the resulting grid as a new Julia variable. Again, assuming we already loaded in the input data, the equivalent command is\n    bathy = gmt(\"greenspline -R-50/300/200/600 -I5 -D1 -St0.3\", depths);\nNote that -G is no longer specified among the options. In this case the wrapper uses the GMT API to determine that the primary output of greenspline is a grid and that this is specified via the -G option. If no such option is given (or given without specifying a filename), then we instead return the grid via memory, provided a left-side assignment is specified. GMT only allows this behavior when called via an external API such as this wrapper: Not specifying the -G option on the command line would result in an error message. However, it is perfectly fine to specify the option -Gbathy.nc in Julia – it simply means you are saving the result to a file instead of returning it to Julia.\nSome GMT modules can produce more than one output (here called a secondary outputs) or can read more than one input type (i.e., secondary inputs). Secondary inputs or outputs are always specified by explicit module options on the command line, e.g., -Fpolygon.txt. In these cases, the gmt() enforces the following rules: When a secondary input is passed as an object then we must specify the corresponding option flag but provide no file argument (e.g., just -F in the above case). Likewise, for secondary output we supply the option flag and add additional objects to the left-hand side of the assignment. All secondary items, whether input or output, must appear after all primary items, and if more than one secondary item is given then their order must match the order of the corresponding options in option string.\nHere are two examples contrasting the GMT command line versus gmt() usage. In the first example we wish to determine all the data points in the file all_points.txt that happen to be located inside the polygon specified in the file polygon.txt. On the command line this would be achieved by\n    gmt select points.txt -Fpolygon.txt &gt; points_inside.txt\nwhile in Julia (assuming the points and polygon already reside in memory) we would run\n    inside = gmt(\"gmtselect -F\", points, polygon);\nHere, the points object must be listed first since it is the primary data expected.\nOur second example considers the joining of line segments into closed polygons. We wish to create one file with all closed polygons and another file with any remaining disjointed lines. Not expecting perfection, we allow segment end-points closer than 0.1 units to be connected. On the command line we would run\n    gmt connect all_segments.txt -Cclosed.txt -T0.1 &gt; rest.txt\nwhere all_segments.txt are the input lines, closed.txt is the file that will hold closed polygons made from the relevant lines, while any remaining lines (i.e., open polygons) are written to standard output and redirected to the file rest.txt. Equivalent Julia usage would be\nall = gmt(\"read -Td all_segments.txt\");\nrest, closed = gmt(\"gmtconnect -T0.1 -C\", all);\nNote the primary output (here rest) must be listed before any secondary outputs (here closed) in the left-hand side of the assignment.\nSo far, the gmt() function has been able to understand where inputs and outputs objects should be inserted, provided we follow the rules introduced above. However, there are two situations where more information must be provided. The first situation involves two GMT modules that allow complete freedom in how arguments are passed. These are gmtmath and grdmath, our reverse polish notation calculators for tables and grids, respectively. While the command-line versions require placement of arguments in the right order among the desired operators, the gmt() necessarily expects all inputs at the end of the function call. Hence we must assist the command by placing markers where the input arguments should be used; the marker we chose is the question mark (?). We will demonstrate this need using an example of grdmath. Imagine that we have created two separate grids: kei.nc contains an evaluation of the radial z = bei(r) Kelvin-Bessel function while cos.nc contains a cylindrical undulation in the x-direction. We create these two grids on the command line by\ngmt grdmath -R-4/4/-4/4 -I256+ X Y HYPOT KEI = kei.nc\ngmt grdmath -R -I256+ X COS = cos.nc\nLater, we decide we need pi plus the product of these two grids, so we compute\n    gmt grdmath kei.nc cos.nc MUL PI ADD = answer.nc\nIn Julia the first two commands are straightforward:\nkei = gmt(\"grdmath -R-4/4/-4/4 -I256+ X Y HYPOT KEI\");\nC   = gmt(\"grdmath -R -I256+ X COS\");\nbut when time comes to perform the final calculation we cannot simply do\n    answer = gmt(\"grdmath MUL PI ADD\", kei, C);\nsince grdmath would not know where kei and C should be put in the context of the operators MUL and ADD. We could probably teach grdmath to discover the only possible solution since the MUL operator requires two operands but none are listed on the command line. The logical choice then is to take kei and C as operands. However, in the general case it may not be possible to determine a unique layout, but more importantly it is simply too confusing to separate all operators from their operands (other than constants) as we would lose track of the mathematical operation we are performing. For this reason, we will assist the module by inserting question marks where we wish the module to use the next unused input object in the list. Hence, the valid command becomes\n    answer = gmt(\"grdmath ? ? MUL PI ADD\", kei, C);\nOf course, all these calculations could have been done at once with no input objects but often we reuse results in different contexts and then the markers are required. The second situation arises if you wish to use a grid as argument to the -R option (i.e., to set the current region to that of the grid). On the command line this may look like\n    gmt pscoast -Reurope.nc -JM5i –P -Baf -Gred &gt; map.ps\nHowever, in Julia we cannot simply supply -R with no argument since that is already an established shorthand for selecting the previously specified region. The solution is to supply –R?. Assuming our grid is called europe then the Julia command would become\n    map = gmt(\"pscoast -R? -JM5i -P -Baf -Gred\", europe);"
  },
  {
    "objectID": "documentation/modules.html",
    "href": "documentation/modules.html",
    "title": "GMT Modules",
    "section": "",
    "text": "Complete reference documentation for all GMT plotting and processing modules."
  },
  {
    "objectID": "documentation/modules.html#core-programs",
    "href": "documentation/modules.html#core-programs",
    "title": "GMT Modules",
    "section": "Core Programs",
    "text": "Core Programs\n\n\n\nbasemap \n\nPlot base maps and frames.\n\n\n\n\n\nblockmean \n\nBlock average (x,y,z) data tables by mean estimation.\n\n\n\n\n\nblockmedian\n\n\nBlock average (x,y,z) data tables by median estimation\n\n\n\n\n\nblockmode\n\n\nBlock average (x,y,z) data tables by mode estimation\n\n\n\n\n\nclip\n\n\nInitialize or terminate polygonal clip paths\n\n\n\n\n\ncoast\n\n\nPlot continents, countries, shorelines, rivers, and borders\n\n\n\n\n\ncolorbar\n\n\nPlot gray scale or color scale bar\n\n\n\n\n\ncontour\n\n\nContour table data by triangulation\n\n\n\n\n\ndimfilter\n\n\nDirectional filtering of grids in the space domain\n\n\n\n\n\nevents\n\n\nPlot event symbols, lines, polygons and labels for one moment in time\n\n\n\n\n\nfilter1d\n\n\nTime domain filtering of 1-D data tables\n\n\n\n\n\nfitcircle\n\n\nFind mean position and best-fit great or small circle\n\n\n\n\n\ngmt2kml\n\n\nConvert tables to KML files for Google Earth\n\n\n\n\n\ngmtbinstats\n\n\nBin spatial data and compute various statistics\n\n\n\n\n\ngmtconnect\n\n\nConnect individual lines whose end points match\n\n\n\n\n\ngmtconvert\n\n\nConvert, paste, or extract columns from tables\n\n\n\n\n\ngmtdefaults\n\n\nList current GMT default settings\n\n\n\n\n\ngmtinfo\n\n\nGet information about data tables\n\n\n\n\n\ngmtlogo\n\n\nPlot the GMT & Julia logos\n\n\n\n\n\ngmtmath\n\n\nReverse Polish Notation calculator for data tables\n\n\n\n\n\ngmtregress\n\n\nLinear regression of 1-D data sets\n\n\n\n\n\ngmtselect\n\n\nSelect data table subsets based on multiple spatial criteria\n\n\n\n\n\ngmtset\n\n\nChange individual GMT default parameters\n\n\n\n\n\ngmtsimplify\n\n\nLine reduction using the Douglas-Peucker algorithm\n\n\n\n\n\ngmtspatial\n\n\nGeospatial operations on points, lines and polygons\n\n\n\n\n\ngmtsplit\n\n\nSplit xyz[dh] data tables into individual segments\n\n\n\n\n\ngmtwhich\n\n\nFind full path to specified files\n\n\n\n\n\ngrd2cpt\n\n\nMake linear or histogram-equalized color palette from grid\n\n\n\n\n\ngrd2kml\n\n\nCreate KML image quadtree from single grid\n\n\n\n\n\ngrd2xyz\n\n\nConvert grid to data table\n\n\n\n\n\ngrdclip\n\n\nClip the range of grid values\n\n\n\n\n\ngrdcontour\n\n\nMake contour map using a grid\n\n\n\n\n\ngrdcut\n\n\nExtract subregion from a grid\n\n\n\n\n\ngrdedit\n\n\nModify header or content of a grid\n\n\n\n\n\ngrdfft\n\n\nMathematical operations on grids in the spectral domain\n\n\n\n\n\ngrdfill\n\n\nFill blank areas in grids\n\n\n\n\n\ngrdfilter\n\n\nFilter a grid in the space or time domain\n\n\n\n\n\ngrdgradient\n\n\nCompute directional gradients from a grid\n\n\n\n\n\ngrdhisteq\n\n\nPerform histogram equalization for a grid\n\n\n\n\n\ngrdimage\n\n\nProject and plot grids or images\n\n\n\n\n\ngrdinfo\n\n\nExtract information from grids\n\n\n\n\n\ngrdlandmask\n\n\nCreate “wet-dry” mask grid from shoreline data base\n\n\n\n\n\ngrdmask\n\n\nCreate mask grid from polygons or point coverage\n\n\n\n\n\ngrdmath\n\n\nReverse Polish Notation calculator for grids\n\n\n\n\n\ngrdpaste\n\n\nJoin two grids along their common edge\n\n\n\n\n\ngrdproject\n\n\nForward and inverse map transformation of grids\n\n\n\n\n\ngrdsample\n\n\nResample a grid onto a new lattice\n\n\n\n\n\ngrdtrack\n\n\nSample grids at specified (x,y) locations\n\n\n\n\n\ngrdtrend\n\n\nFit trend surface to grids and compute residuals\n\n\n\n\n\ngrdvector\n\n\nPlot vector field from two component grids\n\n\n\n\n\ngrdview\n\n\nCreate 3-D perspective image or surface mesh from a grid\n\n\n\n\n\ngrdvolume\n\n\nCalculate grid volume and area constrained by a contour\n\n\n\n\n\ngreenspline\n\n\nInterpolate using Green’s functions for splines\n\n\n\n\n\nhistogram\n\n\nPlot a histogram\n\n\n\n\n\nimage\n\n\nPlot raster or EPS images\n\n\n\n\n\ninset\n\n\nManage figure inset setup and completion\n\n\n\n\n\nkml2gmt\n\n\nExtract GMT table data from Google Earth KML files\n\n\n\n\n\nlegend\n\n\nPlot a legend\n\n\n\n\n\nmakecpt\n\n\nMake GMT color palette tables\n\n\n\n\n\nmapproject\n\n\nForward and inverse map transformations of 2-D coordinates\n\n\n\n\n\nmask\n\n\nClip or mask map areas with no data coverage\n\n\n\n\n\nmovie\n\n\nCreate animation sequences and movies\n\n\n\n\n\nnearneighbor\n\n\nGrid table data using a “Nearest neighbor” algorithm\n\n\n\n\n\nplot\n\n\nPlot lines, polygons, and symbols\n\n\n\n\n\nplot3d\n\n\nPlot lines, polygons, and symbols in 3-D\n\n\n\n\n\nproject\n\n\nProject data onto lines or great circles\n\n\n\n\n\nrose\n\n\nPlot a polar histogram (rose diagram)\n\n\n\n\n\nsample1d\n\n\nResample 1-D table data using splines\n\n\n\n\n\nsolar\n\n\nPlot day-light terminators and other sunlight parameters\n\n\n\n\n\nspectrum1d\n\n\nCompute auto- and cross-spectra from one or two time series\n\n\n\n\n\nsph2grd\n\n\nCompute grid from spherical harmonic coefficients\n\n\n\n\n\nsphdistance\n\n\nCreate Voronoi distance, node, or natural nearest-neighbor grid on a sphere\n\n\n\n\n\nsphinterpolate\n\n\nSpherical gridding in tension of data on a sphere\n\n\n\n\n\nsphtriangulate\n\n\nDelaunay or Voronoi construction of spherical data\n\n\n\n\n\nsplitxyz\n\n\nSplit xyz[dh] data tables into individual segments\n\n\n\n\n\nsubplot\n\n\nManage modern mode figure subplot configuration and selection\n\n\n\n\n\nsurface\n\n\nGrid table data using adjustable tension continuous curvature splines\n\n\n\n\n\nternary\n\n\nPlot data on ternary diagrams\n\n\n\n\n\ntext\n\n\nPlot or typeset text\n\n\n\n\n\ntrend1d\n\n\nFit a polynomial trend to time series\n\n\n\n\n\ntrend2d\n\n\nFit a polynomial trend to grids\n\n\n\n\n\ntriangulate\n\n\nDelaunay triangulation or Voronoi partitioning and gridding\n\n\n\n\n\nwiggle\n\n\nPlot z = f(x,y) anomalies along tracks\n\n\n\n\n\nxyz2grd\n\n\nConvert data table to a grid"
  },
  {
    "objectID": "documentation/modules.html#supplements",
    "href": "documentation/modules.html#supplements",
    "title": "GMT Modules",
    "section": "Supplements",
    "text": "Supplements\n\n\n\nearthtide\n\n\nCompute grids or time-series of solid Earth tides\n\n\n\n\n\nimg2grd \n\nExtract a subset from an img file in Mercator or Geographic format\n\n\n\n\n\nflexure \n\nCompute flexural deformation of 2-D loads, forces, and bending moments.\n\n\n\n\n\nsegy2grd \n\nConverting SEGY data to a grid.\n\n\n\n\n\ngrdrotater \n\nFinite rotation reconstruction of geographic grid.\n\n\n\n\n\ngpsgridder \n\nInterpolate GPS velocities using Green’s functions for elastic deformation.\n\n\n\n\n\nmgd77convert \n\nConvert MGD77 data to other formats.\n\n\n\n\n\ngravfft \n\nSpectral calculations of gravity, isostasy, admittance, and coherence for grids.\n\n\n\n\n\nsegy \n\nPlot a SEGY file in 2-D.\n\n\n\n\n\nsegyz \n\nPlot a SEGY file in 3-D.\n\n\n\n\n\ngrdspotter \n\nCreate CVA grid from a gravity or topography grid.\n\n\n\n\n\nvelo \n\nPlot velocity vectors, crosses, anisotropy bars and wedges.\n\n\n\n\n\nmagref \n\nEvaluate the IGRF or CM4 magnetic field models.\n\n\n\n\n\nmgd77track \n\nPlot track-lines of MGD77 cruises.\n\n\n\n\n\ngravmag3d \n\nCompute the gravity/magnetic anomaly of a 3-D body by the method of Okabe.\n\n\n\n\n\nhotspotter \n\nCreate CVA grid from seamount locations.\n\n\n\n\n\ngravprisms \n\nCompute geopotential anomalies over 3-D vertical prisms.\n\n\n\n\n\ncoupe \n\nPlot cross-sections of focal mechanisms.\n\n\n\n\n\noriginater \n\nAssociate seamounts with nearest hotspot point sources.\n\n\n\n\n\ngrdflexure \n\nCompute flexural deformation of 3-D surfaces for various rheologies.\n\n\n\n\n\nmeca \n\nPlot focal mechanisms.\n\n\n\n\n\npmodeler \n\nEvaluate a plate motion model at given locations.\n\n\n\n\n\ngrdgravmag3d \n\nComputes the gravity effect of one (or two) grids by the method of Okabe.\n\n\n\n\n\ngmtisf \n\nRead seismicity data in the ISF formated file.\n\n\n\n\n\npolespotter \n\nFind stage poles given fracture zones and abyssal hills.\n\n\n\n\n\ngrdredpol \n\nCompute the Continuous Reduction To the Pole, AKA differential RTP.\n\n\n\n\n\npolar \n\nPlot polarities on the lower hemisphere of the focal sphere.\n\n\n\n\n\nrotconverter \n\nManipulate total reconstruction and stage rotations.\n\n\n\n\n\ngrdseamount \n\nCreate synthetic seamounts (Gaussian, parabolic, polynomial, cone or disc; circular or elliptical).\n\n\n\n\n\nsac \n\nPlot seismograms in SAC format.\n\n\n\n\n\nrotsmoother \n\nGet mean rotations and covariance matrices from set of finite rotations.\n\n\n\n\n\ntalwani2d \n\nCompute geopotential anomalies over 2-D bodies by the method of Talwani.\n\n\n\n\n\ntalwani3d \n\nCompute geopotential anomalies over 3-D bodies by the method of Talwani\n\n\n\n\n\nbacktracker \n\nGenerate forward and backward flowlines and hotspot tracks.\n\n\n\n\n\ngrdpmodeler \n\nEvaluate a plate motion model on a geographic grid.\n\n\n\n\n\nwindbarbs \n\nPlot wind barb field from two component grids."
  },
  {
    "objectID": "documentation/modules.html#plotting-programs",
    "href": "documentation/modules.html#plotting-programs",
    "title": "GMT Modules",
    "section": "Plotting Programs",
    "text": "Plotting Programs\nPrograms for creating maps, plots, charts, and other visualizations.\n\n\n\narrows\n\n\nPlot arrow fields.\n\n\n\n\n\nband\n\n\nPlot line with symmetrical or asymmetrical band.\n\n\n\n\n\nbar\n\n\nPlot bar graph.\n\n\n\n\n\nbar3\n\n\nPlot 3D bar graph.\n\n\n\n\n\nbasemap\n\n\nPlot base maps and frames.\n\n\n\n\n\nbiplot\n\n\nCreate 2D biplot of PCA analysis.\n\n\n\n\n\nboxplot\n\n\nDraw box-and-whisker plot.\n\n\n\n\n\nbubblechart\n\n\nPlot bubbles at (x,y) locations.\n\n\n\n\n\ncoast\n\n\nPlot continents, shorelines, rivers, and borders on maps.\n\n\n\n\n\ncolorbar\n\n\nPlot a gray or color scale-bar on maps.\n\n\n\n\n\ncontour\n\n\nContour plot from table data by direct triangulation.\n\n\n\n\n\ncontourf\n\n\nCreate filled contour maps.\n\n\n\n\n\ncornerplot\n\n\nDensity plots of multi-dimensional data combinations.\n\n\n\n\n\nearthregions\n\n\nExtract or plot named geographic regions.\n\n\n\n\n\necdfplot\n\n\nPlot empirical cumulative distribution function.\n\n\n\n\n\nfeather\n\n\nPlot arrows originating from x-axis.\n\n\n\n\n\nfill_between\n\n\nFill area between two horizontal curves.\n\n\n\n\n\ngrdcontour\n\n\nMake contour plot or map (using a projection) from a grid.\n\n\n\n\n\ngrdimage\n\n\nProject grids or images and plot them on maps.\n\n\n\n\n\ngrdview\n\n\nCreate 3-D perspective image or surface mesh from a grid.\n\n\n\n\n\nhband\n\n\nPlot horizontal bands (see vband).\n\n\n\n\n\nhistogram\n\n\nCalculate and plot histograms.\n\n\n\n\n\nhlines\n\n\nPlot horizontal reference lines.\n\n\n\n\n\nlegend\n\n\nMakes legends that can be overlaid on maps.\n\n\n\n\n\nlines\n\n\nPlot lines with decoration options.\n\n\n\n\n\nlogo\n\n\nPlot the GMT logo.\n\n\n\n\n\nmarginalhist\n\n\nScatter plot with marginal histograms.\n\n\n\n\n\nparallelplot\n\n\nCreate parallel coordinates plots.\n\n\n\n\n\npastplates\n\n\nPlot tectonic plate reconstructions.\n\n\n\n\n\npcolor\n\n\nCreate colored cells plot.\n\n\n\n\n\npiechart\n\n\nCreate pie charts.\n\n\n\n\n\nplot\n\n\nReads (x,y) pairs and plot lines, polygons, or symbols with different levels of decoration.\n\n\n\n\n\nplotlinefit\n\n\nPlot data with fitted line.\n\n\n\n\n\nqqplot\n\n\nCompare quantiles of two distributions.\n\n\n\n\n\nquiver\n\n\nPlot vector fields from component grids.\n\n\n\n\n\nradar\n\n\nCreate radar/spider plots.\n\n\n\n\n\nscatter\n\n\nPlot symbols at (x,y) locations.\n\n\n\n\n\nscatter3\n\n\nPlot symbols at (x,y,z) locations.\n\n\n\n\n\nseismicity\n\n\nPlot earthquake data from USGS.\n\n\n\n\n\nstairs\n\n\nPlot stairstep graphs.\n\n\n\n\n\nstem\n\n\nPlot data as stems from baseline.\n\n\n\n\n\nstereonet\n\n\nPlot stereonets for structural geology.\n\n\n\n\n\nstreamlines\n\n\nCompute and plot 2D streamlines.\n\n\n\n\n\nternary\n\n\nPlot data on ternary diagrams.\n\n\n\n\n\ntriplot\n\n\nPlot 2D triangulation or Voronoi polygons.\n\n\n\n\n\ntrisurf\n\n\nPlot 3D triangular surfaces.\n\n\n\n\n\nvband\n\n\nPlot vertical or horizontal bands.\n\n\n\n\n\nviolins\n\n\nCreate violin plots.\n\n\n\n\n\nvlines\n\n\nPlot vertical reference lines."
  },
  {
    "objectID": "documentation/modules.html#grid-operations",
    "href": "documentation/modules.html#grid-operations",
    "title": "GMT Modules",
    "section": "Grid Operations",
    "text": "Grid Operations\nFunctions for creating, modifying, and analyzing gridded datasets.\n\n\n\ngrd2cpt\n\n\nMake linear or histogram-equalized color palette from grid\n\n\n\n\n\ngrd2xyz\n\n\nConvert grid to data table\n\n\n\n\n\ngrdclip\n\n\nClip the range of grid values\n\n\n\n\n\ngrdcut\n\n\nExtract subregion from a grid\n\n\n\n\n\ngrdedit\n\n\nModify header or content of a grid\n\n\n\n\n\ngrdfft\n\n\nMathematical operations on grids in the spectral domain\n\n\n\n\n\ngrdfill\n\n\nFill blank areas in grids\n\n\n\n\n\ngrdfilter\n\n\nFilter a grid in the space or time domain\n\n\n\n\n\ngrdgradient\n\n\nCompute directional gradients from a grid\n\n\n\n\n\ngrdhisteq\n\n\nPerform histogram equalization for a grid\n\n\n\n\n\ngrdinfo\n\n\nExtract information from grids\n\n\n\n\n\ngrdlandmask\n\n\nCreate “wet-dry” mask grid from shoreline data base\n\n\n\n\n\ngrdmask\n\n\nCreate mask grid from polygons or point coverage\n\n\n\n\n\ngrdmath\n\n\nReverse Polish Notation calculator for grids\n\n\n\n\n\ngrdpaste\n\n\nJoin two grids along their common edge\n\n\n\n\n\ngrdproject\n\n\nForward and inverse map transformation of grids\n\n\n\n\n\ngrdsample\n\n\nResample a grid onto a new lattice\n\n\n\n\n\ngrdtrack\n\n\nSample grids at specified (x,y) locations\n\n\n\n\n\ngrdtrend\n\n\nFit trend surface to grids and compute residuals\n\n\n\n\n\ngrdvolume\n\n\nCalculate grid volume and area constrained by a contour"
  },
  {
    "objectID": "documentation/modules.html#data-processing",
    "href": "documentation/modules.html#data-processing",
    "title": "GMT Modules",
    "section": "Data Processing",
    "text": "Data Processing\nFunctions for filtering, transforming, and analyzing data.\n\n\n\nblockmean\n\n\nBlock average (x,y,z) data tables by mean estimation\n\n\n\n\n\nblockmedian\n\n\nBlock average (x,y,z) data tables by median estimation\n\n\n\n\n\nblockmode\n\n\nBlock average (x,y,z) data tables by mode estimation\n\n\n\n\n\nfilter1d\n\n\nTime domain filtering of 1-D data tables\n\n\n\n\n\nfitcircle\n\n\nFind mean position and best-fit great or small circle\n\n\n\n\n\ngmtconnect\n\n\nConnect individual lines whose end points match\n\n\n\n\n\ngmtconvert\n\n\nConvert, paste, or extract columns from tables\n\n\n\n\n\ngmtmath\n\n\nReverse Polish Notation calculator for data tables\n\n\n\n\n\ngmtselect\n\n\nSelect data table subsets based on multiple spatial criteria\n\n\n\n\n\ngmtsimplify\n\n\nLine reduction using the Douglas-Peucker algorithm\n\n\n\n\n\ngmtspatial\n\n\nGeospatial operations on points, lines and polygons\n\n\n\n\n\ngreenspline\n\n\nInterpolate using Green’s functions for splines\n\n\n\n\n\nmakecpt\n\n\nMake GMT color palette tables\n\n\n\n\n\nnearneighbor\n\n\nGrid table data using a “Nearest neighbor” algorithm\n\n\n\n\n\nspectrum1d\n\n\nCompute auto- and cross-spectra from one or two time series\n\n\n\n\n\nsurface\n\n\nGrid table data using adjustable tension continuous curvature splines\n\n\n\n\n\ntrend1d\n\n\nFit a polynomial trend to time series\n\n\n\n\n\ntrend2d\n\n\nFit a polynomial trend to grids\n\n\n\n\n\ntriangulate\n\n\nDelaunay triangulation or Voronoi partitioning and gridding\n\n\n\n\n\nxyz2grd\n\n\nConvert data table to a grid"
  },
  {
    "objectID": "documentation/common_features.html",
    "href": "documentation/common_features.html",
    "title": "Common Features",
    "section": "",
    "text": "Colors, pens, fonts, symbols, and other features used across GMT functions.\n\n\nArrows Control\n\n\nColor\n\n\nDecorated\n\n\nFonts\n\n\nJustify\n\n\nPens\n\n\nSymbols\n\n\nThemes\n\n\nUnits"
  },
  {
    "objectID": "documentation/common_features/color.html",
    "href": "documentation/common_features/color.html",
    "title": "Setting color",
    "section": "",
    "text": "Setting color\nColor can be selected in several different ways. One of the is to create color maps with the makecpt and grd2cpt modules. This is the method we use to colorize images, sets of points, etc. The other option sets the color via keyword/value pairs and is appropriate to color fill polygons, individual symbols, etc and the one documented here.\nWe may use this in modules that expect the color or fill keywords, then the value can be a string or a symbol with the color’s name (or names separated by commas); a number in the [0 255] range to indicate a gray shade tone; or a 3-elements tuple (more tricky) or array (simpler) where each element contains the R,G,B component in either [0 255] or [0 1] range.\nExamples:\n\ncolor=:red Single color\ncolor=200 Single gray\ncolor=“#aabbcc” Single color\ncolor=“30/20/180” Single color\ncolor=“yellow,brown” Two colors\ncolor=(30,180) Two gray levels\ncolor=((30,20,180),) Single color\ncolor=((10,50,99),(20,60,90)) Two colors\ncolor=[0.118 0.078 0.706] Single color in [0 1]\ncolor=[10 50 99; 20 60 90] Two colors\ncolor=(:red,:green,:blue) Three colors\n\nBut there are other options that expect color in one of its elements. For example, to set a text font we may want to choose a color (i.e. not use the default which is black). Then we would do drop the color= and use the value in that other option value. For example font=(12, “Helvetica”, (30,20,180)), where the color is the third element in the font keyword option."
  },
  {
    "objectID": "documentation/common_features/fonts.html",
    "href": "documentation/common_features/fonts.html",
    "title": "Setting fonts",
    "section": "",
    "text": "Setting fonts\nfont = (size, fontname, color)\nA text font is composed of three parts: 1) a size; 2) a fontname; 3) the font color. The size may be a scalar, a string with the units appended or a tuple with (size, units). The fontname is a string or symbol with the font name. e.g “Helvetica”. See here for the available font names. The color is a color element, See [Setting color]\nBoth fontname and color are optional. So a font=10 is a valid setting, meaning a default font of size 10 points. It’s also valid to provide a all font parametrs in a string using the compact GMT syntax. The GMT docs has further details on this option.\nExamples:\n\nfont=“24p”\nfont=(“14p”,:red)\nfont=(12, :Helvetica, (30,20,180))\nfont=“12p,Helvetica-Bold,red”"
  },
  {
    "objectID": "documentation/common_features/pens.html",
    "href": "documentation/common_features/pens.html",
    "title": "Pen attributes",
    "section": "",
    "text": "Pen attributes\nA pen in GMT has three attributes: width, color, and style. Most programs will accept pen attributes in the form of an option argument, with commas separating the given attributes, e.g.,\npen=(width, color, style)\nor\npen=(width=?, color=?, style=?)\n\nwidth\nWidth is by default measured in points (1/72 of an inch). Append c, i, or p to specify pen width in cm, inch, or points, respectively (but note that this form requires using a string instead of a number). Minimum-thickness pens can be achieved by giving zero width. The result is device-dependent but typically means that as you zoom in on the feature in a display, the line thickness stays at the minimum. For plotting poly-lines width can be a vector of thicknesses in which case a line of varible thickness will be plotted. Linear interpolation to is applyied to the thickness vector in order to obtain an idividual thickness for each of the segments of the poly-line.\n\n\ncolor\nThe color can be specified in each following ways:\n\nGray. Specify a gray shade in the range 0–255 (linearly going from black [0] to white [255]).\nRGB. Specify r/g/b, each ranging from 0–255. Here 0/0/0 is black, 255/255/255 is white, 255/0/0 is red, etc. Alternatively, you can give RGB in hexadecimal using the #rrggbb format. All of these forms must be provided as strings\nHSV. Specify hue-saturation-value, with the former in the 0–360 degree range while the latter two take on the range 0–1 17 (string).\nCMYK. Specify cyan/magenta/yellow/black, each ranging from 0–100% (string).\nName. Specify one of 663 valid color names. See gmtcolors for a list of all valid names. A very small yet versatile subset consists of the 29 choices white, black, and [light|dark] {red, orange, yellow, green, cyan, blue, magenta, gray|grey, brown}. The color names are case-insensitive, so mixed upper and lower case can be used (like DarkGreen). This can be provided as a String or Symbol.\nFor 2D or 3D polylines grad or gradient means each line segment will be colored by consulting a colormap. If that colormap is not provided we create one based on the poly-line number of segments. ### line style\n\nThe style attribute controls the appearance of the line. Giving dot or . yields a dotted line, whereas a dashed pen is requested with dash or -. Also combinations of dots and dashes, like .- for a dot-dashed line, are allowed. The lengths of dots and dashes are scaled relative to the pen width (dots has a length that equals the pen width while dashes are 8 times as long; gaps between segments are 4 times the pen width). It is however not possible to mix the word and char forms. Valid styles are for example DashDot, dashdashdot, dotdotdash, -. , --. The style words are case-insensitive.\nFor more detailed attributes including exact dimensions you may specify string, where string is a series of numbers separated by underscores. These numbers represent a pattern by indicating the length of line segments and the gap between segments. For example, if you want a yellow line of width 0.1 cm that alternates between long dashes (4 points), an 8 point gap, then a 5 point dash, then another 8 point gap, specify pen=(\"0.1c\",:yellow,\"4_8_5_8\"). Just as with pen width, the default style units are points, but can also be explicitly specified in cm, inch, or points.\nLine styles can also be provided autonomously via the linestyle (or short ls) keywords. For example, ls=:dash. An interesting extension to the above line styles is when we add also a symbol and make an annotated line. The syntax is to add the symbol name to the style specification separated by one the three characters &, _ or !. e.g. \"Line&Circ\" or :DashDot!Square. This will draw an open symbol with outline color and thickness equal to line width. The symbols size and spacing are computed to be 4 times the line width and spacing. Append a non-letter char like # or % (e.g. \"Line&Triang#\") to plot symbols with a white outline and filled with line color. If you want to annotate with a text string, wrap whatever text in a pair of those three characters. For example \"Line&Silly saying&\"\nFront lines can also be drawn with the linestyle mechanism. For that, use the form: “FrontSymbol[left|right]” where Symbol can be any of Circle, Box, Triangle, Slip, Fault (case-insensitive and only first char is parsed). The Left or Right options mean that only half of the symbol will be plotted. Either on the left or right side of the line. Example ls=FrontTriangleLeft will draw a subduction zone line.\nThe above line and symbol at fixed spacing is nice but there are many instances where one wants to have a line and symbols only at vertex locations. While that can generally be achieved by using the marker, markersize (ms), markercolor (mc) and linecolor (lc), linewidth (lw) keywords we can also use a condensed form similar to the annotated lines above. In this case we drop the separating char and compose it only with the line style and symbol name, e.g. \"LineCirc\".\nThe annotated, quoted and front lines short forms presented here use several heuristics to decide on symbol size, symbol separation, fill collor, outline pen, etc … But one can overwrite most of those guesses by using the markersize, markecolor, markerline options of the plot module.\nIn addition to these pen settings there are several PostScript settings that can affect the appearance of lines. These are controlled via the GMT defaults settings PS_LINE_CAP, PS_LINE_JOIN, and PS_MITER_LIMIT. See the end of the GMT CookBook section on Specifying pen attributes for a visual display on the effect of changing these defaults.\nFinaly, lines can be terminated with arrows, See [Vector attributes]"
  },
  {
    "objectID": "documentation/common_features/themes.html",
    "href": "documentation/common_features/themes.html",
    "title": "theme",
    "section": "",
    "text": "theme\nCurrently GMT.jl offers 3 themes (classic, modern, and dark). Classic theme has been the default up to version 0.34.0. Starting in 0.35.0 the so called (by GMT) modern theme has become the default. Differences may not be obvious at first (except for the default axes line width that was decreased to half-width [0.75p]) but it holds a significant improvement in its capability to scale the size of fonts and line thicknesses in function of figure size.\nA third theme is the dark mode. Besides these 3 themes the last two (modern and dark) can still be tweaked with some other parameters. Basically one can use the theme as a function or as an option in the plot (and its avatars) module.\ntheme(name; kwrgs...)\n\nmodern: - This is the default theme (same as GMT modern theme but with thinner FRAME_PEN [0.75p])\nclassic: - The GMT classic theme\ndrak: - A modern theme variation with dark background.\nA0|2[XY|XX|YY][atg][ag][g][H][V][NT|nt][ITit][Graph][Dark] Make a composition of these to select a theme. The main condition is that it starts with an A (Annotate). Hence A2 means annotate two axis and A0 means no axes at all. XY means to plot only left and bottom axes, YY only left and right and XX bottom and top. atg (or afg) means annotate, tick and grid lines. ag does not tick. H and V means grid lines will only be horizontal or vertical. Note, these require atg or ag. NT stands for no ticks at all and IT plots the ticks inside the axes. Graph adds a vector to the end of each axis (sets XY), and Dark put the background in dark mode.\n\nExample: A2YYg -&gt; plot left and right axes (only) and add grid lines.\nExample: A2Graph -&gt; plot left and right axes (only) and adds arrows at the end of them.\n\n\nOn top of the modern mode variations (so far dark only) one can set the following kwargs options:\n\nnoticks or no_ticks: Axes will have annotations but no tick marks\ninner_ticks or innerticks: - Ticks will be drawn inside the axes instead of outside.\ngray_grid or graygrid: - When drawing grid line use gray instead of black\nsave: - Save the name in the directory printed in shell by gmt –show-userdir and make it permanent.\nreset: - Remove the saved theme name and return to the default modern theme.\n\nNote: Except save and reset, the changes operated by the kwargs are temporary and operate only until an image is show(n) or saved.\nThis function can be called alone, e.g. theme(\"dark\") or as an keyword option in the plot() module. e.g. plot(..., theme=:dark) or plot(..., theme=(modern, noticks=true))"
  },
  {
    "objectID": "documentation/common_opts.html",
    "href": "documentation/common_opts.html",
    "title": "Common Options",
    "section": "",
    "text": "Common Options\nShared options and parameters used across multiple GMT functions.\n\n\n\nAuto Legend Info\n\n\n\n\nContour Notes\n\n\n\n\nCreate Cpt\n\n\n\n\nExplain Acoast\n\n\n\n\nExplain Ccontours\n\n\n\n\nExplain F Box\n\n\n\n\nExplain Fft\n\n\n\n\nExplain Float\n\n\n\n\nExplain Grd Coord\n\n\n\n\nExplain Gshhg\n\n\n\n\nExplain Inside\n\n\n\n\nExplain Refpoint\n\n\n\n\nExplain Transparency\n\n\n\n\nOpt -Grid\n\n\n\n\nOpt Asteps\n\n\n\n\nOpt B\n\n\n\n\nOpt I\n\n\n\n\nOpt J\n\n\n\n\nOpt R\n\n\n\n\nOpt R 3D\n\n\n\n\nOpt U\n\n\n\n\nOpt V\n\n\n\n\nOpt X\n\n\n\n\nOpt Y\n\n\n\n\nOpt Distunits\n\n\n\n\nOpt I\n\n\n\n\nOpt J\n\n\n\n\nOpt R\n\n\n\n\nOpt W\n\n\n\n\nOpt X\n\n\n\n\nOpt A\n\n\n\n\nOpt Bi\n\n\n\n\nOpt Bo\n\n\n\n\nOpt Box\n\n\n\n\nOpt Compass\n\n\n\n\nOpt Di\n\n\n\n\nOpt E\n\n\n\n\nOpt F\n\n\n\n\nOpt G\n\n\n\n\nOpt H\n\n\n\n\nOpt L\n\n\n\n\nOpt Map Scale\n\n\n\n\nOpt Mfc\n\n\n\n\nOpt N\n\n\n\n\nOpt O\n\n\n\n\nOpt P\n\n\n\n\nOpt Pen\n\n\n\n\nOpt Q\n\n\n\n\nOpt Qi\n\n\n\n\nOpt Range\n\n\n\n\nOpt Rose\n\n\n\n\nOpt S\n\n\n\n\nOpt Save Fig\n\n\n\n\nOpt Save Grd\n\n\n\n\nOpt T\n\n\n\n\nOpt Xy\n\n\n\n\nUse Cpt Grd"
  },
  {
    "objectID": "documentation/modules/backtracker.html",
    "href": "documentation/modules/backtracker.html",
    "title": "backtracker",
    "section": "",
    "text": "Generate forward and backward flowlines and hotspot tracks.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/bar.html",
    "href": "documentation/modules/bar.html",
    "title": "bar",
    "section": "",
    "text": "bar(cmd0::String=\"\", arg1=[]; kwargs...)\nReads (x,y) pairs and plots a bar graph. This module is a subset of plot to make it simpler to draw bar plots. So not all (fine) controlling parameters are listed here. For a finer control, user should consult the plot module.\nIf input is a MxN array and N &gt; 2 it will plot a bar-group with M groups and N-1 bars in each group (first column holds always the coordinates)."
  },
  {
    "objectID": "documentation/modules/bar.html#parameters",
    "href": "documentation/modules/bar.html#parameters",
    "title": "bar",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nbar\nVertical bar extending from base to y. By default, base is 0 and the bar widths are 0.8 of the width in x-units. You can change this by using (in alternative):\n\nwidth=xx\nwhere xx is the bar width in x-units (bar base remains = 0).\nbase=xx\nwhere xx is the base value (bar width remains = 0.8).\nbar=??\nwhere ?? is a string with a full GMT syntax for this option (-Sb)\nbar=(width=xx,unit=xx,base=xx,height=xx)\nAttention, the order of members matters but only width is mandatory.\n\nwidth\nThe bar width in x-units. To specify it in plot units, use the unit member with cm, inch or point.\nunit\nIn case width is given in plot units. Valid units are cm, inch or point.\nbase=xx\nwhere xx is the base value.\nheight\nIf the bar height is measured relative to base xx [Default is relative to origin]. Cannot be used together with base.\n\n\nbargap\nControls the gap between the bars. The default is to let a space of 20% of the bar width but this can be changed by providing eithe a gap in the [0-1] interval or in percentage. i.e. bargap=40 or bargap=0.4 will create a space of 40% between the bars.\nhbar\nHorizontal bar extending from base to x. Same as bar but now with respect to y axis, except that one cannot use width or base to change just those defaults (the use of it is restricted to the vertical bars case).\nfill=[“color1”, “color2”, …] | fill=(“color1”, “color2”, …) | fill=(1,2,…)\nList of colors used to wrapp the bars inside each group. When using numbers that means patterns codes.\nfillalpha=[…]\nWhen fill was used, control the transparency level. Numbers can be floats &lt;= 1.0 or integeres in 0-100 range.\nstack\nPlot a vertically (or horizontally if hbar=true) stacked group plot. The particular setting stack=:waterfall creates a waterfall chart, which is a form of data visualization that helps in understanding the cumulative effect of sequentially introduced positive or negative values. The input data for this option is a vector or one row matrix with the heights of each bar. A height o zero (0) has the special meaning of plotting the total accumulated up to that value. For these plots we can connect the bars with the connector=true or connector=pen option. Bar colors (three for the waterfall type) are controlled with the fill option but default values are provided. See example below.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/bar.html#examples",
    "href": "documentation/modules/bar.html#examples",
    "title": "bar",
    "section": "Examples",
    "text": "Examples\nA simple bar plot with 10 bars and automatic limits.\n\nusing GMT\n\nbar(rand(10), show=true)\n\n\n\n\n\n\n\n\nA bar group with selected colors and transparency.\n\nbar([0. 1 2 3; 1 2 3 4], fillalpha=[0.3 0.5 0.7], fill=[\"red\" \"green\" \"blue\"], show=true)\n\n\n\n\n\n\n\n\nA bar group with bars filled with patterns.\n\nbar([0 1 2 3; 1 2 3 4], fill=(1,2,3), show=1)\n\n\n\n\n\n\n\n\nA bar group with error bars\n\nbar([0. 1 2 3; 1 2 3 4], error_bars=(y=[0.1 0.2 0.33; 0.2 0.3 0.4],), show=true)\n\n\n\n\n\n\n\n\nA waterfall chart.\n\nbar([1 2 3 0 -1 -2 0], stacked=:water, connector=true, bargap=25,\n    xticks=(:A, :B, :C, :Partial, :D, :E, :Total), show=true)"
  },
  {
    "objectID": "documentation/modules/bar.html#see-also",
    "href": "documentation/modules/bar.html#see-also",
    "title": "bar",
    "section": "See also",
    "text": "See also\n[Bar plots] examples.\nThe GMT man page"
  },
  {
    "objectID": "documentation/modules/bar.html#source-code",
    "href": "documentation/modules/bar.html#source-code",
    "title": "bar",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbar(cmd0::String; ...) - plot.jl:465\nbar(; ...) - plot.jl:465\nbar(f::Function; ...) - plot.jl:490\nbar(arg; kw...) - plot.jl:498\nbar(cmd0::String, arg; first, kw...) - plot.jl:465\nbar(f::Function, range_x; first, kw...) - plot.jl:490\nbar(arg1, arg2; first, kw...) - plot.jl:496"
  },
  {
    "objectID": "documentation/modules/basemap.html",
    "href": "documentation/modules/basemap.html",
    "title": "basemap",
    "section": "",
    "text": "basemap(; kwargs...)\nPlot base maps and frames"
  },
  {
    "objectID": "documentation/modules/basemap.html#description",
    "href": "documentation/modules/basemap.html#description",
    "title": "basemap",
    "section": "Description",
    "text": "Description\nCreates a basic or fancy basemap with axes, fill, and titles. Several map projections are available, and the user may specify separate tick-mark intervals for boundary annotation, ticking, and (optionally) gridlines. A simple map scale (map_scale) or directional rose (rose) may also be plotted. At least one of the options [frame], map_scale, or rose must be specified.\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nA or polygon : polygon=true or polygon=fname\nNo plotting is performed. Instead, we determine the geographical coordinates of the polygon outline for the (possibly oblique) rectangular map domain. The plot domain must be given via [limits] and [proj], with no other options allowed. The sampling interval is controlled via MAP_LINE_STEP parameter. The coordinates are return in a GMTdataset or written to fname if a file name is specified.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nF or box : – box=(clearance=gap, pen=pen, fill=fill, inner=(gap,pen), rounded=xx, shaded=(dx,dy[,shade]))\nWithout further options, draws a rectangular border around the map scale or rose using MAP_FRAME_PEN; specify a different pen with pen=new_pen. Add fill=fill_value to fill the logo box [no fill]. Append clearance=gap where gap is either a scalar, or tuples with (xgap, ygap), or (lgap,rgap,bgap,tgap) where these items are uniform, separate in x- and y-direction, or individual side spacings between logo and border. Append inner to draw a secondary, inner border as well. We use a uniform gap between borders of 2p and the MAP_DEFAULT_PEN unless other values are specified. Append rounded=6 to draw rounded rectangular borders instead, with a 6p corner radius. You can override this radius by appending another value. Finally, append shaded=(dx,dy[,shade]) to draw an offset background shaded region. Here, dx,dy indicates the shift relative to the foreground frame [4p,4p] and shade sets the fill style to use for shading [gray50]. Requires map_scale or rose. If both map_scale or rose, you may repeat box after each of these but remember to put repeated settings inside a tuple of tuples.\nL or map_scale : – map_scale=([map=true, inside=true, norm=true, paper=true,] anchor=refpoint, scale_at_lat=lat, length=len [,align=side, justify=code, fancy=true, label=lab, offset=(dx,dy), units=unit, vertical=true])\nDraws a simple map scale centered on the reference point specified using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inner=code for setting refpoint via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). Scale is calculated for latitude slat (optionally supply longitude slon for oblique projections [Default is central meridian]), length=len when len is in km, or append unit from e or f or k or M ot n or u. Change the label alignment with align=:left|:right|:top|:bottom. Use fancy=true to get a “fancy” scale [Default is plain]. By default, the anchor point on the map scale is assumed to be the center of the scale (MC), but this can be changed by adding justify=code, where code is a 2-char justification code (see [  ]{.quarto-shortcode__ data-is-shortcode=“1” data-raw=“{{&lt; gmtref text &gt;}}”} for list and explanation of codes). label=lab selects the default label, which equals the distance unit (meter, foot, km, mile, nautical mile, US survey foot) and is justified on top of the scale. Change this by giving your own label lab. Add offset=(dx,dy) to offset the map scale by dx,dy away from the anchor in the direction implied by justify. Select units=unit to append the unit to all distance annotations along the scale (for the plain scale, this will instead select the unit to be appended to the distance length). Cartesian projections: Origin scale_at_lat is not required, fancy is not allowed, and no units should be specified in length. You must set any Cartesian data units via label. For a vertical rather than horizontal Cartesian scale, append vertical=true. Note: Use [FONT_LABEL] to change the label font and [FONT_ANNOT_PRIMARY] to change the annotation font. The height of the map scale is controlled by [MAP_SCALE_HEIGHT], and the pen thickness is set by [MAP_TICK_PEN_PRIMARY]. See box on how to place a panel behind the scale.\nTd or rose : – rose=([map=true, inside=true, outside=true, norm=true, paper=true,] anchor=refpoint, width=width [,justify=code, fancy=level, labels=labels, offset=(dx,dy)])\nDraws a map directional rose on the map at the location defined by the reference and anchor points: Give the reference point on the map for the rose using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inside=code for setting refpoint via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). You can offset the reference point with offset=(dx,dy) in the direction implied by justify=code. By default, the anchor point is assumed to be the center of the rose (MC), but this can be changed by using justify=code where code is a 2-char justification code (see text for list and explanation of codes). Note: If outside=true is used then justify defaults to the same as refpoint, if outside=true is used then justify defaults to the mirror opposite of refpoint. Use width=width to set the width of the rose in plot coordinates (in inches, cm, or points). Add fancy=true to get a “fancy” rose, and specify in level what you want drawn. The default [1 or true] draws the two principal E-W, N-S orientations, 2 adds the two intermediate NW-SE and NE-SW orientations, while 3 adds the eight minor orientations WNW-ESE, NNW-SSE, NNE-SSW, and ENE-WSW. Label the cardinal points W,E,S,N by adding labels and append your own four comma-separated string to override the default. Skip a specific label by leaving it blank. See Placing-dir-map-roses and box on how to place a panel behind the scale.\nTm or compass : – compass=([map=true, inside=true, outside=true, norm=true, paper=true,] anchor=refpoint, width=width, [dec=(dec, dlabel), justify=code, labels=labels, rose_primary=pen, rose_secondary=pen, offset=(dx,dy)])\nDraws a map magnetic rose on the map at the location defined by the reference and anchor points: Give the reference point on the map for the rose using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inner=code for setting refpoint via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). You can offset the reference point with offset=(dx,dy) in the direction implied by justify=code. By default, the anchor point is assumed to be the center of the rose (MC), but this can be changed by using justify=code where code is a 2-char justification code (see text for list and explanation of codes). Note: If outside=true is used then justify defaults to the same as refpoint, if outside=true is used then justify defaults to the mirror opposite of refpoint. Use width=width to set the width of the rose in plot coordinates (in inches, cm, or points). Use dec=dec to assign the magnetic declination or dec=(dec, dlabel) to set dlabel, which is a label for the magnetic compass needle (use “-” as dlabel to bypass labeling). With dec, both directions to geographic and magnetic north are plotted [Default is geographic only]. If the north label is a star * as in dec=(1,“W,E,S,*”) then a north star is plotted instead of the north label. Annotation and two levels of tick intervals for both geographic and magnetic directions default to 30/5/1 degrees; override these settings by appending annot=(…,…,.), and enter six intervals to set both the geographic (first three) and magnetic (last three) intervals. Label the cardinal points W,E,S,N by adding label=lab where lab is your own four comma-separated string to override the default. Skip a specific label by leaving it blank. The rose_primary=pen and rose_secondary=pen modify the pens used to plot the outter and inner circles of the comapss. A number GMT default parameters control pens, fonts, and color. See Placing-dir-map-roses and box on how to place a panel behind the scale.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats."
  },
  {
    "objectID": "documentation/modules/basemap.html#examples",
    "href": "documentation/modules/basemap.html#examples",
    "title": "basemap",
    "section": "Examples",
    "text": "Examples\nThe following section illustrates the use of the options by giving some examples for the available map projections. Note how scales may be given in several different ways depending on the projection. Also note the use of upper case letters to specify map width instead of map scale.\nWARNING: the examples have not yet been translated to GMT.jl"
  },
  {
    "objectID": "documentation/modules/basemap.html#non-geographical-projections",
    "href": "documentation/modules/basemap.html#non-geographical-projections",
    "title": "basemap",
    "section": "Non-geographical Projections",
    "text": "Non-geographical Projections\n\nLinear x-y plot\nTo make a linear x/y frame with all axes, but with only left and bottom axes annotated, using xscale = yscale = 1 cm per unit, ticking every 1 unit and annotating every 2, and using xlabel = “Distance” and ylabel = “No of samples”, use\n\nusing GMT\n\nbasemap(region=(0,9,0,5), figscale=1,\n        frame=(axes=:WeSn, annot=2, ticks=1, xlabel=:Distance, ylabel=\"No of samples\"), show=true)\n\n\n\n\n\n\n\n\n\n\nLog-log plot\nTo make a log-log frame with only the left and bottom axes, where the x-axis is 25 cm and annotated every 1-2-5 and the y-axis is 15 cm and annotated every power of 10 but has tick-marks every 0.1, run\n\nusing GMT\n\nbasemap(region=(1,10000,1e20,1e25), figsize=(25,15), proj=:logxy, frame=(axes=:WS,),\nxaxis=(annot=2, label=:Wavelength),\nyaxis=(annot=1, ticks=3, label=:Power, scale=:pow), show=1)\n\n\n\n\n\n\n\n\n\n\nPower axes\nTo design an axis system to be used for a depth-sqrt(age) plot with depth positive down, ticked and annotated every 500m, and ages (in millions of years) annotated at 1 My, 4 My, 9 My etc., use\n\nusing GMT\n    # This still fails to generate the intended GMT command. (maybe let scale=\"pow0.5\")\n    #basemap(region=(0,100,0,5000), figscale=(1,-0.001), xaxis=(annot=1, label=\"Crustal age\", scale=:pow), yaxis=(annot=500, label=:Depth), show=true)\nbasemap(region=(0,100,0,5000), frame=\"x1p+l\\\"Crustal age\\\" y500+lDepth\", proj=\"x1cp0.5/-0.001c\", show=true)\n\n\n\n\n\n\n\n\n\n\nPolar (theta,r) plot\nFor a base map for use with polar coordinates, where the radius from 0 to 1000 should correspond to 5 cm and with gridlines and ticks intervals automatically determined, use\n\nusing GMT\nbasemap(region=(0,360,0,1000), figsize=10, frame=:afg, proj=:polar, show=true)"
  },
  {
    "objectID": "documentation/modules/basemap.html#cylindrical-map-projections",
    "href": "documentation/modules/basemap.html#cylindrical-map-projections",
    "title": "basemap",
    "section": "Cylindrical Map Projections",
    "text": "Cylindrical Map Projections\n\nCassini\nA 10-cm-wide basemap using the Cassini projection may be obtained by\n    gmt basemap -R20/50/20/35 -JC35/28/10c -Bafg -B+tCassini\n\n\nMercator [conformal]\nA Mercator map with scale 0.025 inch/degree along equator, and showing the length of 5000 km along the equator (centered on 1/1 inch), may be plotted as\n    gmt basemap -R90/180/-50/50 -Jm0.025i -Bafg -B+tMercator -Lx1i/1i+c0+w5000k\n\n\nMiller\nA global Miller cylindrical map with scale 1:200,000,000 may be plotted as\n    gmt basemap -Rg -Jj180/1:200000000 -Bafg -B+tMiller\n\n\nOblique Mercator [conformal]\nTo create a page-size global oblique Mercator basemap for a pole at (90,30) with gridlines every 30 degrees, run\n    gmt basemap -R0/360/-70/70 -Joc0/0/90/30/0.064cd -B30g30 -B+t\"Oblique Mercator\"\n\n\nTransverse Mercator [conformal]\nA regular Transverse Mercator basemap for some region may look like\n    gmt basemap -R69:30/71:45/-17/-15:15 -Jt70/1:1000000 -Bafg -B+t\"Survey area\"\n\n\nEquidistant Cylindrical Projection\nThis projection only needs the central meridian and scale. A 25 cm wide global basemap centered on the 130E meridian is made by\n    gmt basemap -R-50/310/-90/90 -JQ130/25c -Bafg -B+t\"Equidistant Cylindrical\"\n\n\nUniversal Transverse Mercator [conformal]\nTo use this projection you must know the UTM zone number, which defines the central meridian. A UTM basemap for Indo-China can be plotted as\n    gmt basemap -R95/5/108/20+r -Ju46/1:10000000 -Bafg -B+tUTM\n\n\nCylindrical Equal-Area\nFirst select which of the cylindrical equal-area projections you want by deciding on the standard parallel. Here we will use 45 degrees which gives the Gall projection. A 9 inch wide global basemap centered on the Pacific is made by\n    gmt basemap -Rg -JY180/45/9i -Bafg -B+tGall"
  },
  {
    "objectID": "documentation/modules/basemap.html#conic-map-projections",
    "href": "documentation/modules/basemap.html#conic-map-projections",
    "title": "basemap",
    "section": "Conic Map Projections",
    "text": "Conic Map Projections\n\nAlbers [equal-area]\nA basemap for middle Europe may be created by\n    gmt basemap -R0/90/25/55 -Jb45/20/32/45/0.25c -Bafg -B+t\"Albers Equal-area\"\n\n\nLambert [conformal]\nAnother basemap for middle Europe may be created by\n    gmt basemap -R0/90/25/55 -Jl45/20/32/45/0.1i -Bafg -B+t\"Lambert Conformal Conic\"\n\n\nConic Equidistant\nYet another basemap of width 6 inch for middle Europe may be created by\n    gmt basemap -R0/90/25/55 -JD45/20/32/45/6i -Bafg -B+t\"Equidistant conic\"\n\n\nPolyconic\nA basemap for north America may be created by\n    gmt basemap -R-180/-20/0/90 -JPoly/4i -Bafg -B+tPolyconic"
  },
  {
    "objectID": "documentation/modules/basemap.html#azimuthal-map-projections",
    "href": "documentation/modules/basemap.html#azimuthal-map-projections",
    "title": "basemap",
    "section": "Azimuthal Map Projections",
    "text": "Azimuthal Map Projections\n\nLambert [equal-area]\nA 15-cm-wide global view of the world from the vantage point -80/-30 will give the following basemap:\n    basemap -Rg -JA-80/-30/15c -Bafg -B+t\"Lambert Azimuthal\"\nFollow the instructions for stereographic projection if you want to impose rectangular boundaries on the azimuthal equal-area map but substitute [proj] a for [proj] s.\n\n\nAzimuthal Equidistant\nA 15-cm-wide global map in which distances from the center (here 125/10) to any point is true can be obtained by:\n    gmt basemap -Rg -JE125/10/15c -Bafg -B+tEquidistant\n\n\nGnomonic\nA view of the world from the vantage point -100/40 out to a horizon of 60 degrees from the center can be made using the Gnomonic projection:\n    gmt basemap -Rg -JF-100/40/60/6i -Bafg -B+tGnomonic\n\n\nOrthographic\nA global perspective (from infinite distance) view of the world from the vantage point 125/10 will give the following 6-inch-wide basemap:\n    gmt basemap -Rg -JG125/10/6i -Bafg -B+tOrthographic\n\n\nGeneral Perspective\nThe [proj] G option can be used in a more generalized form, specifying altitude above the surface, width and height of the view point, and twist and tilt. A view from 160 km above -74/41.5 with a tilt of 55 and azimuth of 210 degrees, and limiting the viewpoint to 30 degrees width and height will product a 6-inch-wide basemap:\n    gmt basemap -Rg -JG-74/41.5/6i+z160+a210+t55+v30 -Bafg -B+t\"General Perspective\"\n\n\nStereographic [conformal]\nTo make a polar stereographic projection basemap with radius = 12 cm to -60 degree latitude, with plot title “Salinity measurements”, using 5 degrees annotation/tick interval and 1 degree gridlines, run\n    gmt basemap -R-45/45/-90/-60 -Js0/-90/12c/-60 -B5g1 -B+t\"Salinity measurements\"\nTo make a 12-cm-wide stereographic basemap for Australia from an arbitrary view point (not the poles), and use a rectangular boundary, we must give the pole for the new projection and use the [limits] option to indicate the lower left and upper right corners (in lon/lat) that will define our rectangle. We choose a pole at 130/-30 and use 100/-45 and 160/-5 as our corners. The command becomes\n    gmt basemap -R100/-45/160/-5+r -JS130/-30/12c -Bafg -B+t\"General Stereographic View\""
  },
  {
    "objectID": "documentation/modules/basemap.html#miscellaneous-map-projections",
    "href": "documentation/modules/basemap.html#miscellaneous-map-projections",
    "title": "basemap",
    "section": "Miscellaneous Map Projections",
    "text": "Miscellaneous Map Projections\n\nHammer [equal-area]\nThe Hammer projection is mostly used for global maps and thus the spherical form is used. To get a world map centered on Greenwich at a scale of 1:200000000, use\n    gmt basemap -Rd -Jh0/1:200000000 -Bafg -B+tHammer\n\n\nSinusoidal [equal-area]\nTo make a sinusoidal world map centered on Greenwich, with a scale along the equator of 0.02 inch/degree, use\n    gmt basemap -Rd -Ji0/0.02i -Bafg -B+tSinusoidal\nTo make an interrupted sinusoidal world map with breaks at 160W, 20W, and 60E, with a scale along the equator of 0.02 inch/degree, run the following sequence of commands:\n    gmt begin\n    gmt basemap -R-160/-20/-90/90 -Ji-90/0.02i -Bx30g30 -By15g15 -BWesn\n    gmt basemap -Bx30g30 -By15g15 -Bwesn -X2.8i\n    gmt basemap -Bx30g30 -By15g15 -BwEsn -X1.6i\n    gmt end show\n\n\nEckert IV [equal-area]\nPseudo-cylindrical projection typically used for global maps only. Set the central longitude and scale, e.g.,\n    gmt basemap -Rg -Jkf180/0.064c -Bafg -B+t\"Eckert IV\"\n\n\nEckert VI [equal-area]\nAnother pseudo-cylindrical projection typically used for global maps only. Set the central longitude and scale, e.g.,\n    gmt basemap -Rg -Jks180/0.064c -Bafg -B+t\"Eckert VI\"\n\n\nRobinson\nProjection designed to make global maps “look right”. Set the central longitude and width, e.g.,\n    gmt basemap -Rd -JN0/8i -Bafg -B+tRobinson\n\n\nWinkel Tripel\nYet another projection typically used for global maps only. You can set the central longitude, e.g.,\n    gmt basemap -R90/450/-90/90 -JR270/25c -Bafg -B+t\"Winkel Tripel\"\n\n\nMollweide [equal-area]\nThe Mollweide projection is also mostly used for global maps and thus the spherical form is used. To get a 25-cm-wide world map centered on the Dateline:\n    gmt basemap -Rg -JW180/25c -Bafg -B+tMollweide\n\n\nVan der Grinten\nThe Van der Grinten projection is also mostly used for global maps and thus the spherical form is used. To get a 18-cm-wide world map centered on the Dateline:\n    gmt basemap -Rg -JV180/18c -Bafg -B+t\"Van der Grinten\"\n\n\nArbitrary rotation\nIf you need to plot a map but have it rotated about a vertical axis then use the |-p| option. For instance, to rotate the basemap below 90 degrees about an axis centered on the map, try\n    gmt basemap -R10/40/10/40 -JM10c -Bafg -B+t\"I am rotated\" -p90+w25/25 -Xc"
  },
  {
    "objectID": "documentation/modules/basemap.html#custom-labels-or-intervals",
    "href": "documentation/modules/basemap.html#custom-labels-or-intervals",
    "title": "basemap",
    "section": "Custom Labels or Intervals",
    "text": "Custom Labels or Intervals\nThe [frame] option sets up a regular annotation interval and the annotations derive from the corresponding x, y, or z coordinates. However, some applications requires special control on which annotations to plot and even replace the annotation with other labels. This is achieved by using c intfile in the [frame] option, where intfile contains all the information about annotations, ticks, and even gridlines. Each record is of the form coord type [label], where coord is the coordinate for this annotation (or tick or gridline), type is one or more letters from a (annotation), i interval annotation, f tickmark, and g gridline. Note that a and i are mutually exclusive and cannot both appear in the same intfile. Both a and i requires you to supply a label which is used as the plot annotation. If not given then a regular formatted annotation based on the coordinate will occur."
  },
  {
    "objectID": "documentation/modules/basemap.html#restrictions",
    "href": "documentation/modules/basemap.html#restrictions",
    "title": "basemap",
    "section": "Restrictions",
    "text": "Restrictions\nFor some projections, a spherical earth is implicitly assumed. A warning will notify the user if verbose is set."
  },
  {
    "objectID": "documentation/modules/basemap.html#bugs",
    "href": "documentation/modules/basemap.html#bugs",
    "title": "basemap",
    "section": "Bugs",
    "text": "Bugs\nThe [frame] option is somewhat complicated to explain and comprehend. However, it is fairly simple for most applications (see examples)."
  },
  {
    "objectID": "documentation/modules/basemap.html#source-code",
    "href": "documentation/modules/basemap.html#source-code",
    "title": "basemap",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/blockmean.html",
    "href": "documentation/modules/blockmean.html",
    "title": "blockmean",
    "section": "",
    "text": "blockmean(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/blockmean.html#description",
    "href": "documentation/modules/blockmean.html#description",
    "title": "blockmean",
    "section": "Description",
    "text": "Description\nBlock average (x,y,z) data tables by mean estimation.\nReads arbitrarily located (x,y,z) triples [or optionally weighted quadruples (x,y,z,w)] and computes a mean position and value for every non-empty block in a grid region defined by the region and increment parameters.\nTakes a Mx3 matrix, a GMTdataset, or a file name as input and returns either a table (a GMTdataset) or one or more grids (GMTgrid). Aternatively, save the result directly in a disk file."
  },
  {
    "objectID": "documentation/modules/blockmean.html#required-arguments",
    "href": "documentation/modules/blockmean.html#required-arguments",
    "title": "blockmean",
    "section": "Required Arguments",
    "text": "Required Arguments\ntable\n3 (or 4, see weights) column data table file (or binary, see binary_in) holding (x,y,z[,w]) data values, where [ w] is an optional weight for the data.\n\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/blockmean.html#optional-arguments",
    "href": "documentation/modules/blockmean.html#optional-arguments",
    "title": "blockmean",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or field or fields: – field=mean|std|highest|lowest|weights\nOutput is a grid with one of the select fields. field=mean writes the mean of z. Other options are: std (standard deviation), lowest (lowest value), highest (highest value) and weights (the output weight; requires the weights option). The deafault is field=mean. Alternatively, one can use a condensed form which uses the first character (except the mean) of the above options, separated by commas, to compute more than one grid. For example: fields=\"z,s\" computes two grids; one with the means and the other with the standard deviations.\nC or center : – center=true\nUse the center of the block as the output location [Default uses the mean location]. Not used whith fields.\nE or extend : — extend=true | extend=“+p” | extend=“+P”\nProvide Extended report which includes s (the standard deviation about the mean), l, the lowest value, and h, the high value for each block. Output order becomes x,y,z,s,l,h[,w]. Default outputs x,y,z[ ,w]. See weights for enabling w output. If extend=\"+p\" or extend=\"+P\" is used then input data uncertainties are expected and s becomes the propagated error of the weighted (+p) or simple (+P) z mean.\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nS or statistic : – statistic=:m|:n|:s|:w\nUse statistic=:m to report the mean value in each blaock, statistic=:n to report the number of points inside each block, statistic=:s to report the sum of all z-values inside a block, statistic=:w to report the sum of weights [Default (or statistic=:m reports mean value]. This option works both for returning the result in a table in a GMTdataset or in a grid. For this later case, however, one must use the grid=true option.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weights : – weights=:i | weights=:o | weights=“i+s” | weights=“i|o+s|+w”\nWeighted modifier[s]. Unweighted input and output have 3 columns x,y,z; Weighted i/o has 4 columns x,y,z,w. Weights can be used in input to construct weighted mean values for each block. Weight sums can be reported in output for later combining several runs, etc. Use weights for weighted i/o, weights=:i for weighted input only, and weights=:o for weighted output only. [Default uses unweighted i/o]. If your weights are actually uncertainties (one sigma) then append the string +s (as in weights=“i+s”) and we compute weight = 1/sigma. Otherwise (or via +w) we use the weights directly.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/blockmean.html#examples",
    "href": "documentation/modules/blockmean.html#examples",
    "title": "blockmean",
    "section": "Examples",
    "text": "Examples\nTo find 5 by 5 minute block mean values from the ASCII data in ship_15.txt, run\n    D = blockmean(\"@ship_15.txt\", region=(245,255,20,30), inc=\"5m\");\nTo determine how many values were found in each 5x5 minute bin, try\n    D = blockmean(\"@ship_15.txt\", region=(245,255,20,30), inc=\"5m\", count=true);\nTo determine the mean and standard deviation per 10 minute bin and save these to two separate grids called field_z.nc and field_s.nc, run\n    blockmean(\"@ship_15.txt\", spacing=\"10m\", region=(-115,-105,20,30), extend=true, save=\"field_%s.nc\", fields=\"z,s\")\nThe same as above but this time returns the two grids to the Julia REPL\n    Z,S = blockmean(\"@ship_15.txt\", spacing=\"10m\", region=(-115,-105,20,30), extend=true, fields=\"z,s\")"
  },
  {
    "objectID": "documentation/modules/blockmean.html#source-code",
    "href": "documentation/modules/blockmean.html#source-code",
    "title": "blockmean",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nblockmean(cmd0::String; kwargs...) - blocks.jl:58\nblockmean(arg1; kwargs...) - blocks.jl:59"
  },
  {
    "objectID": "documentation/modules/blockmean.html#see-also",
    "href": "documentation/modules/blockmean.html#see-also",
    "title": "blockmean",
    "section": "See Also",
    "text": "See Also\nblockmedian blockmode"
  },
  {
    "objectID": "documentation/modules/blockmode.html",
    "href": "documentation/modules/blockmode.html",
    "title": "blockmode",
    "section": "",
    "text": "blockmode(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/blockmode.html#description",
    "href": "documentation/modules/blockmode.html#description",
    "title": "blockmode",
    "section": "Description",
    "text": "Description\nBlock average (x,y,z) data tables by mode estimation.\nReads arbitrarily located (x,y,z) triples [or optionally weighted quadruples (x,y,z,w)] and computes a mode position and value for every non-empty block in a grid region defined by the region and increment parameters.\nTakes a Mx3 matrix, a GMTdataset, or a file name as input and returns either a table (a GMTdataset) or one or more grids (GMTgrid). Aternatively, save the result directly in a disk file."
  },
  {
    "objectID": "documentation/modules/blockmode.html#required-arguments",
    "href": "documentation/modules/blockmode.html#required-arguments",
    "title": "blockmode",
    "section": "Required Arguments",
    "text": "Required Arguments\ntable\n3 (or 4, see weights) column data table file (or binary, see binary_in) holding (x,y,z[,w]) data values, where [ w] is an optional weight for the data.\n\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/blockmode.html#optional-arguments",
    "href": "documentation/modules/blockmode.html#optional-arguments",
    "title": "blockmode",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or field or fields: – field=mode|scale|highest|lowest|weights\nOutput is a grid with one of the select fields. field=mode writes the modal data z. Other options are: scale (the L1 scale of the mode), lowest (lowest value), highest (highest value) and weights (the output weight; requires the weights option). The default is field=mode. Alternatively, one can use a condensed form which uses the first character (except the mean) of the above options, separated by commas, to compute more than one grid. For example: fields=\"z,h\" computes two grids; one with the modes and the other with the highest values in blocks.\nC or center : – center=true\nUse the center of the block as the output location [Default uses the modal xy location (but see quick)]. center overrides quick.\nD or histogram_binning : – histogram_binning=true | histogram_binning=[width][+c][+a|+l|+h]\nPerform unweighted mode calculation via histogram binning, using the specified histogram width. Append +c to center bins so that their mid point is a multiple of width [uncentered]. If multiple modes are found for a block we return the average mode [+a]. Append +l or +h to return the low of high mode instead, respectively. If width is not given it will default to 1 provided your data set only contains integers. Also, for integer data and integer bin width we enforce bin centering (+c) and select the lowest mode (+l) if there are multiples. Default mode is normally the Least Median of Squares (LMS) statistic.\nE or extend : — extend=true | extend=“r|s[+l|+h]”\nProvide Extended report which includes s (the L1 scale of the mode), l, the lowest value, and h, the high value for each block. Output order becomes x,y,z,s,l,h[,w]. Default outputs x,y,z[ ,w]. See weights for enabling w output.\nIf extend=\"r|s[+l|+h]\" is used then provide source id s or record number r output, i.e., append the source id or record number associated with the median value. If tied then report the record number of the higher of the two values (i.e., +h is the default); append +l to instead report the record number of the lower value.\nNote that extend may be repeated so that both extend=true and extend=\"r[+l|+h]\" can be specified. But in this case (repeated extend option) one must encapsulate the intire option in a Tuple because option names can not be repeated (not yet imlemented). For extend=:s we expect input records of the form x,y,z[,w],sid, where sid is an unsigned integer source id.\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nQ or quick : – quick=true\n(Quicker) Finds median z and (x,y) at that the median z [Default finds median x, median y independent of z]. Also see center.\nT or quantile : – quantile=val\nSets the quantile of the distribution to be returned [Default is 0.5 which returns the median z]. Here, 0 &lt; val &lt; 1.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weights : – weights=:i | weights=:o | weights=“i+s” | weights=“i|o+s|+w”\nWeighted modifier[s]. Unweighted input and output have 3 columns x,y,z; Weighted i/o has 4 columns x,y,z,w. Weights can be used in input to construct weighted mean values for each block. Weight sums can be reported in output for later combining several runs, etc. Use weights for weighted i/o, weights=:i for weighted input only, and weights=:o for weighted output only. [Default uses unweighted i/o]. If your weights are actually uncertainties (one sigma) then append the string +s (as in weights=“i+s”) and we compute weight = 1/sigma. Otherwise (or via +w) we use the weights directly.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/blockmode.html#examples",
    "href": "documentation/modules/blockmode.html#examples",
    "title": "blockmode",
    "section": "Examples",
    "text": "Examples\nTo find 5 by 5 minute block mode values from the ASCII data in ship_15.txt, run\n    D = blockmode(\"@ship_15.txt\", region=(245,255,20,30), inc=\"5m\");\nTo determine the most frequently occurring values per 2x2 block using histogram binning, with data representing integer counts, try:\n    D = blockmode(\"@ship_15.txt\", region=:global, inc=\"5m\", center=true, histogram_binning=true);\nTo determine the mode and L1 scale (MAD) on the mode per 10 minute bin and save these to two separate grids called field_z.nc and field_s.nc, run:\n    blockmode(\"@ship_15.txt\", spacing=\"10m\", region=(-115,-105,20,30), extend=true, save=\"field_%s.nc\", fields=\"z,s\")"
  },
  {
    "objectID": "documentation/modules/blockmode.html#source-code",
    "href": "documentation/modules/blockmode.html#source-code",
    "title": "blockmode",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nblockmode(cmd0::String; kwargs...) - blocks.jl:110\nblockmode(arg1; kwargs...) - blocks.jl:111"
  },
  {
    "objectID": "documentation/modules/blockmode.html#see-also",
    "href": "documentation/modules/blockmode.html#see-also",
    "title": "blockmode",
    "section": "See Also",
    "text": "See Also\nblockmean blockmedian"
  },
  {
    "objectID": "documentation/modules/bubblechart.html",
    "href": "documentation/modules/bubblechart.html",
    "title": "bubblechart",
    "section": "",
    "text": "bubblechart(cmd0::String=\"\", arg1=nothing; size=?, kwargs...)\nReads (x,y) pairs and plot bubbles at those locations on a map/figure. The input can either be a file name of a file with at least two columns (x,y), but optionally more, a GMTdatset object with also two or more columns.\nbubblechart(D::GMTdatset,yvar,szvar=?, kwargs…) plots the specified variable from the GMTdatset against the row indices of the table and uses the variable szvar (or svar or sizevar) for the bubble sizes. To plot one set of y-values, specify one variable for yvar. This can take the form of column names or column numbers. To plot multiple sets of y-values, specify multiple variables for yvar. Example yvar=:Y or yvar=(2,3), or yvar=[:Y, :Z1, :Z2]. szvar selects a column with the bubble sizes, which defaukt to 5 pt if no column is selected."
  },
  {
    "objectID": "documentation/modules/bubblechart.html#examples",
    "href": "documentation/modules/bubblechart.html#examples",
    "title": "bubblechart",
    "section": "Examples",
    "text": "Examples\nA simple bubble plot of 50 bubbles plotted with random sizes.\n\nusing GMT\nbubblechart(1:50,rand(50), size=rand(50), fill=:blue, alpha=50, aspect=\"1:1\", show=1)\n\n\n\n\n\n\n\n\nA plot where bubbles’s size grows exponentialy between 2 and 40 points.\n\nusing GMT\nbubblechart(1:50, rand(50), size=(exp10, [2,40]), fill=:blue, alpha=50, aspect=\"1:1\", show=1)"
  },
  {
    "objectID": "documentation/modules/bubblechart.html#source-code",
    "href": "documentation/modules/bubblechart.html#source-code",
    "title": "bubblechart",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nscatter(cmd0::String; ...) - plot.jl:387\nscatter(cmd0::String, arg1; kw...) - plot.jl:387\nscatter(D::Vector{&lt;:GMTdataset{Float64, 2}}; first, kw...) - plot.jl:399\nscatter(f::Function; ...) - plot.jl:376\nscatter(f1::Function, f2::Function; ...) - plot.jl:382\nscatter(f::Function, range_x; first, kw...) - plot.jl:376\nscatter(f1::Function, f2::Function, range_t; first, kw...) - plot.jl:382\nscatter(; ...) - plot.jl:387\nscatter(arg1, arg2; kw...) - plot.jl:393\nscatter(arg; kw...) - plot.jl:390"
  },
  {
    "objectID": "documentation/modules/coast.html",
    "href": "documentation/modules/coast.html",
    "title": "coast",
    "section": "",
    "text": "coast(cmd0::String=\"\"; kwargs...)\nPlot continents, shorelines, rivers, and borders on maps"
  },
  {
    "objectID": "documentation/modules/coast.html#description",
    "href": "documentation/modules/coast.html#description",
    "title": "coast",
    "section": "Description",
    "text": "Description\nPlots grayshaded, colored, or textured land-masses [or water-masses] on maps and optionally draws coastlines, rivers, and political boundaries. Alternatively, it can (1) issue clip paths that will contain all land or all water areas, or (2) dump the data to an ASCII table. The data files come in 5 different resolutions: (f)ull, (h)igh, (i)ntermediate, (l)ow, and (c)rude. The full resolution files amount to more than 55 Mb of data and provide great detail; for maps of larger geographical extent it is more economical to use one of the other resolutions. If the user selects to paint the land-areas and does not specify fill of water-areas then the latter will be transparent (i.e., earlier graphics drawn in those areas will not be overwritten). Likewise, if the water-areas are painted and no land fill is set then the land-areas will be transparent. A map projection must be supplied.\n\nJ or proj or projection : – proj=\nSelect map projection. More at  [proj] \nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\n-A or area : – area=(min_area[,min_level,max_level]), river_lake=true, lake=true, antarctica_ground=true, skip60S=true, skipN60S=true, percent=pct)\nFeatures with an area smaller than min_area in km^2 or of hierarchical level that is lower than min_level or higher than max_level will not be plotted [Default is 0/0/4 (all features)]. Level 2 (lakes) contains regular lakes and wide river bodies which we normally include as lakes; use river_lake=true to just get river-lakes or lake=true to just get regular lakes. By default we select the ice shelf boundary as the coastline for Antarctica; use antarctica_ground=true to instead select the ice grounding line as coastline. For expert users who wish to print their own Antarctica coastline and islands via plot you can use skip60S=true to skip all GSHHG features below 60S or skipN60S=true to instead skip all features north of 60S. Finally, append percent=pct to exclude polygons whose percentage area of the corresponding full-resolution feature is less than pct.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or river_fill : – river_fill=fill | river_fill=(lake=true, river_lake=true, fill=fill)\nSet the shade, color, or pattern for lakes and river-lakes [Default is the fill chosen for “wet” areas (water)]. Optionally, specify separate fills by using river_fill=(lake=true, fill=fill) for lakes and river_fill=(river_lake=true, fill=fill) for river-lakes. To repeate the river_fill option use a tuple of tuples.\nclip : – clip=:land | clip=:water|ocean | clip=:end\nclip=:land or clip=:water|ocean starts a clipping path. clip=:end marks end of existing clip path. No projection information is needed. Also supply X and Y settings if you have moved since the clip started.\nD or res or resolution : – res=:full | res=:auto\nSelects the resolution of the data set to use full, high, intermediate, low, and crude. The resolution drops off by 80% between data sets. The default is res=:auto, which chooses to automatically select the best resolution given the chosen map scale.\nE or DCW : – DCW=code1,code2,… | DCW=(country=code, continent=code, states=code, pen=pen, fill=fill, file=fname, inside=true, outside=false, adjust_r=??, , adjust_R=??, , adjust_e=??, headers=false)\nSelect painting country polygons from the Digital Chart of the World. This is another dataset independent of GSHHG and hence the area and resolution options do not apply. DCW=“+l” just list the countries and their codes [plotting takes place] and DCW=“+L” shows states/territories for Argentina (AR), Australia (AU), Brazil (BR), Canada (CA), China (CN), Great Britan (GB), India (IR), Russia (RU), and the US (US). country or name=code(s), where code(s) is a one or more comma-separated countries using the 2-character ISO 3166-1 alpha-2 convention. To select a state of a country (if available), append .state, e.g, US.TX for Texas. To get all states in a country, use states=code or DCW=+code (only available for AR, AU, BR, CA, CN, GB, IN, NO, RU, and US). To specify a whole continent, use continent=code, with continent codes AF (Africa), AN (Antarctica), AS (Asia), EU (Europe), OC (Oceania), NA (North America), or SA (South America). Use pen=pen (see [Pen attributes]) to draw polygon outlines and fill=fill (see [Fill color/pattern]) to fill them [default is no fill]. At least one of these must be specified unless dump is in effect, in which case only one DCW option can be given. It is also possible to specify the parameters using simple Tuples. For example: DCW=(“PT”, (0.5,“red”,“–”), “blue”) plots the polygon PT with a 0.5p red dashed line and filled with blue and DCW=:PT uses a default pen of 0.5. DCW=(:PT, :blue) fills with blue. You may repeat DCW to give different groups of items their own pen/fill settings. However, since we cannot repeat a keyword, the solution to setting different groupes is to use a tuple of tuples. An example would be DCW=((country=:PT, pen=(2,:red), fill=:blue), (country=:ES, pen=(2,:blue)) ). If neither proj nor dump are set then we just print the region. The file=fname is a option to let users select alternative DCW files. Available options by default are: ODS, NE10m or NE110m. For example: DCW=(country=:CH, file=:ODS) extracts the Swiss polygon from (small) ODS.nc file. The inside=true (the default) means that data is kept inside the clipping polygon. Use outside=true if want the reverse. adjust_r=?? adjusts the region boundaries to be multiples of the steps indicated by inc or xinc/yinc or winc/einc/sinc/ninc. adjust_R=?? adjusts the region boundaries adding the amounts specified by inc or xinc/yinc or winc/einc/sinc/ninc. headers=true place the country code in the segment headers via -Zcode settings (for use with the dump option).\ngetR or getregion or get_region : – getR=code1,code2,…\nReturn the region corresponding to the code/list-of-codes passed in as argument. The code(s) are the same as in the DCW option above.\nF or box : – box=(clearance=gap, pen=pen, fill=fill, inner=(gap,pen), rounded=xx, shaded=(dx,dy[,shade]))\nWithout further options, draws a rectangular border around the map scale or rose using MAP_FRAME_PEN; specify a different pen with pen=new_pen. Add fill=fill_value to fill the logo box [no fill]. Append clearance=gap where gap is either a scalar, or tuples with (xgap, ygap), or (lgap,rgap,bgap,tgap) where these items are uniform, separate in x- and y-direction, or individual side spacings between logo and border. Append inner to draw a secondary, inner border as well. We use a uniform gap between borders of 2p and the MAP_DEFAULT_PEN unless other values are specified. Append rounded=6 to draw rounded rectangular borders instead, with a 6p corner radius. You can override this radius by appending another value. Finally, append shaded=(dx,dy[,shade]) to draw an offset background shaded region. Here, dx,dy indicates the shift relative to the foreground frame [4p,4p] and shade sets the fill style to use for shading [gray50]. Requires map_scale or rose. If both map_scale or rose, you may repeat box after each of these but remember to put repeated settings inside a tuple of tuples.\nG or land : – land=fill\nSelect filling (see [Fill color/pattern]) “dry” areas. Append the shade, color, or pattern.\nI or rivers : – rivers=type | rivers=(type, pen) | rivers=(type=type, pen=pen)\nDraw rivers. Specify the type of rivers and [optionally] append pen attributes [Default pen: width = default, color = black, style = solid].\nChoose type from the list of river types below; To repeat this option, use a tuple of tuples but only the NamedTuple version is allowed (the simpler rivers=(type, pen) doesn’t allow repetitions).\n0 = Double-lined rivers (river-lakes)\n1 = Permanent major rivers\n2 = Additional major rivers\n3 = Additional rivers\n4 = Minor rivers\n5 = Intermittent rivers - major\n6 = Intermittent rivers - additional\n7 = Intermittent rivers - minor\n8 = Major canals\n9 = Minor canals\n10 = Irrigation canals\n\nYou can also choose from several preconfigured river groups:\n\na = All rivers and canals (0-10)\nA = All rivers and canals except river-lakes (1-10)\nr = All permanent rivers (0-4)\nR = All permanent rivers except river-lakes (1-4)\ni = All intermittent rivers (5-7)\nc = All canals (8-10)\nL or map_scale : – map_scale=([map=true, inside=true, norm=true, paper=true,] anchor=refpoint, scale_at_lat=lat, length=len [,align=side, justify=code, fancy=true, label=lab, offset=(dx,dy), units=unit, vertical=true])\nDraws a simple map scale centered on the reference point specified using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inner=code for setting refpoint via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). Scale is calculated for latitude slat (optionally supply longitude slon for oblique projections [Default is central meridian]), length=len when len is in km, or append unit from e or f or k or M ot n or u. Change the label alignment with align=:left|:right|:top|:bottom. Use fancy=true to get a “fancy” scale [Default is plain]. By default, the anchor point on the map scale is assumed to be the center of the scale (MC), but this can be changed by adding justify=code, where code is a 2-char justification code (see [  ]{.quarto-shortcode__ data-is-shortcode=“1” data-raw=“{{&lt; gmtref text &gt;}}”} for list and explanation of codes). label=lab selects the default label, which equals the distance unit (meter, foot, km, mile, nautical mile, US survey foot) and is justified on top of the scale. Change this by giving your own label lab. Add offset=(dx,dy) to offset the map scale by dx,dy away from the anchor in the direction implied by justify. Select units=unit to append the unit to all distance annotations along the scale (for the plain scale, this will instead select the unit to be appended to the distance length). Cartesian projections: Origin scale_at_lat is not required, fancy is not allowed, and no units should be specified in length. You must set any Cartesian data units via label. For a vertical rather than horizontal Cartesian scale, append vertical=true. Note: Use [FONT_LABEL] to change the label font and [FONT_ANNOT_PRIMARY] to change the annotation font. The height of the map scale is controlled by [MAP_SCALE_HEIGHT], and the pen thickness is set by [MAP_TICK_PEN_PRIMARY]. See box on how to place a panel behind the scale.\nM or dump : – dump=true\nDumps a single multisegment ASCII (or binary, see -bo) file to standard output. No plotting occurs. Specify one of DCW, rivers, borders or shore. Note: if dump is used with DCW then region or the +r modifier to DCW are not required as we automatically determine the region given the selected geographic entities.\nminpts : – minpts=??\nMinimum number of points in a DCW polygon. If the number of points in a polygon is less than this value, it will be dropped. This option is only available when used together with E or DCW. Useful when the country polygons are used in zonal_stats and you want to get rid of the small polygons that only consume time.\nN or borders : – borders=type | borders=(type, pen) | borders=(type=type, pen=pen)\nDraw political boundaries. Specify the type of boundary and optionally append pen attributes [Default pen: width = default, color = black, style = solid].\nChoose type from the list of boundaries below. To repeat this option, use a tuple of tuples but only the NamedTuple version is allowed (the simpler borders=(type, pen) doesn’t allow repetitions).\n1 = National boundaries\n2 = State boundaries within the Americas\n3 = Marine boundaries\na = All boundaries (1-3)\nS or water or ocean : – water=fill\nSelect filling of “wet” areas. Append the shade, color, or pattern; [Default is no fill].\nTd or rose : – rose=([map=true, inside=true, outside=true, norm=true, paper=true,] anchor=refpoint, width=width [,justify=code, fancy=level, labels=labels, offset=(dx,dy)])\nDraws a map directional rose on the map at the location defined by the reference and anchor points: Give the reference point on the map for the rose using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inside=code for setting refpoint via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). You can offset the reference point with offset=(dx,dy) in the direction implied by justify=code. By default, the anchor point is assumed to be the center of the rose (MC), but this can be changed by using justify=code where code is a 2-char justification code (see text for list and explanation of codes). Note: If outside=true is used then justify defaults to the same as refpoint, if outside=true is used then justify defaults to the mirror opposite of refpoint. Use width=width to set the width of the rose in plot coordinates (in inches, cm, or points). Add fancy=true to get a “fancy” rose, and specify in level what you want drawn. The default [1 or true] draws the two principal E-W, N-S orientations, 2 adds the two intermediate NW-SE and NE-SW orientations, while 3 adds the eight minor orientations WNW-ESE, NNW-SSE, NNE-SSW, and ENE-WSW. Label the cardinal points W,E,S,N by adding labels and append your own four comma-separated string to override the default. Skip a specific label by leaving it blank. See Placing-dir-map-roses and box on how to place a panel behind the scale.\nTm or compass : – compass=([map=true, inside=true, outside=true, norm=true, paper=true,] anchor=refpoint, width=width, [dec=(dec, dlabel), justify=code, labels=labels, rose_primary=pen, rose_secondary=pen, offset=(dx,dy)])\nDraws a map magnetic rose on the map at the location defined by the reference and anchor points: Give the reference point on the map for the rose using one of four coordinate systems: (1) Use map=true for map (user) coordinates, (2) use inner=code for setting refpoint via a 2-char justification code that refers to the (invisible) map domain rectangle, (3) use norm=true for normalized (0-1) coordinates, or (4) use paper=true for plot coordinates (inches, cm, etc.). You can offset the reference point with offset=(dx,dy) in the direction implied by justify=code. By default, the anchor point is assumed to be the center of the rose (MC), but this can be changed by using justify=code where code is a 2-char justification code (see text for list and explanation of codes). Note: If outside=true is used then justify defaults to the same as refpoint, if outside=true is used then justify defaults to the mirror opposite of refpoint. Use width=width to set the width of the rose in plot coordinates (in inches, cm, or points). Use dec=dec to assign the magnetic declination or dec=(dec, dlabel) to set dlabel, which is a label for the magnetic compass needle (use “-” as dlabel to bypass labeling). With dec, both directions to geographic and magnetic north are plotted [Default is geographic only]. If the north label is a star * as in dec=(1,“W,E,S,*”) then a north star is plotted instead of the north label. Annotation and two levels of tick intervals for both geographic and magnetic directions default to 30/5/1 degrees; override these settings by appending annot=(…,…,.), and enter six intervals to set both the geographic (first three) and magnetic (last three) intervals. Label the cardinal points W,E,S,N by adding label=lab where lab is your own four comma-separated string to override the default. Skip a specific label by leaving it blank. The rose_primary=pen and rose_secondary=pen modify the pens used to plot the outter and inner circles of the comapss. A number GMT default parameters control pens, fonts, and color. See Placing-dir-map-roses and box on how to place a panel behind the scale.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or shore or shorelines or coast or coastlines : – shore=pen | shore=(level=lev, pen=pen)\nDraw shorelines [the Default]. Append pen attributes (see [Pen attributes]) [Defaults: width = default, color = black,style = solid] which apply to all four levels. To set the pen for each level differently, use the form shore=(level=levnum, pen=pen), where levnum is 1-4 and represent coastline, lakeshore, island-in-lake shore, and lake-in-island-in-lake shore. To repeat the shore option, use a tuple of tuples. When specific level pens are set, those not listed will not be drawn [Default draws all levels; but see area]. Note, the equivalent of the borders and rivers form shore=(level,pen) is not possible here because the parser cannot tell if shore=(2,:red) means plot level=2 in red or all levels with a line thicknes of 2 points and color red.\nZ : – Z=true | Z=grid\nAdd a third column to the dump option (Z is ignored if dump is not set). This third column will be filled with zeros when Z=true or it interpolates the grid grid (a file name or a GMTgrid object) with grdrack at the locations of the coastline. This is particularly useful if one wants to drape a coastline on top of a grdview plot.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/coast.html#examples",
    "href": "documentation/modules/coast.html#examples",
    "title": "coast",
    "section": "Examples",
    "text": "Examples\nTo plot Great Britain, Italy, and France in blue with a red outline and Spain, Portugal and Greece in yellow (no outline), and pick up the plot domain form the extents of these countries, use:\n\nusing GMT\ncoast(proj=:Mercator, DCW=((country=\"GB,IT,FR\", fill=:blue, pen=(0.25,:red)),\n                           (country=\"ES,PT,GR\", fill=:yellow)), show=true)"
  },
  {
    "objectID": "documentation/modules/coast.html#gshhg-information",
    "href": "documentation/modules/coast.html#gshhg-information",
    "title": "coast",
    "section": "GSHHG Information",
    "text": "GSHHG Information\nThe coastline database is GSHHG (formerly GSHHS) which is compiled from three sources: World Vector Shorelines (WVS, not including Antarctica), CIA World Data Bank II (WDBII), and Atlas of the Cryosphere (AC, for Antarctica only). Apart from Antarctica, all level-1 polygons (ocean-land boundary) are derived from the more accurate WVS while all higher level polygons (level 2-4, representing land/lake, lake/island-in-lake, and island-in-lake/lake-in-island-in-lake boundaries) are taken from WDBII. The Antarctica coastlines come in two flavors: ice-front or grounding line, selectable via the area option. Much processing has taken place to convert WVS, WDBII, and AC data into usable form for GMT: assembling closed polygons from line segments, checking for duplicates, and correcting for crossings between polygons. The area of each polygon has been determined so that the user may choose not to draw features smaller than a minimum area (see area); one may also limit the highest hierarchical level of polygons to be included (4 is the maximum). The 4 lower-resolution databases were derived from the full resolution database using the Douglas-Peucker line-simplification algorithm. The classification of rivers and borders follow that of the WDBII. See The Global Self-consistent, Hierarchical, High-resolution Geography Database (GSHHG) for further details."
  },
  {
    "objectID": "documentation/modules/coast.html#source-code",
    "href": "documentation/modules/coast.html#source-code",
    "title": "coast",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncoast(cmd0::String; clip, first, kwargs...) - pscoast.jl:78\ncoast(; ...) - pscoast.jl:78"
  },
  {
    "objectID": "documentation/modules/contour.html",
    "href": "documentation/modules/contour.html",
    "title": "contour",
    "section": "",
    "text": "contour(cmd0::String=\"\", arg1=nothing; kwargs...)\nContour plot from table data by direct triangulation"
  },
  {
    "objectID": "documentation/modules/contour.html#description",
    "href": "documentation/modules/contour.html#description",
    "title": "contour",
    "section": "Description",
    "text": "Description\nReads data from file or table and produces a raw contour plot by triangulation. By default, the optimal Delaunay triangulation is performed using Shewchuk’s [1996], but the user may optionally provide a second file with network information, such as a triangular mesh used for finite element modeling. In addition to contours, the area between contours may be painted according to the CPT. Alternatively, the x, y, z positions of the contour lines may be saved to one or more output files (or standard output) and no plot is produced."
  },
  {
    "objectID": "documentation/modules/contour.html#required-arguments",
    "href": "documentation/modules/contour.html#required-arguments",
    "title": "contour",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/contour.html#optional-arguments",
    "href": "documentation/modules/contour.html#optional-arguments",
    "title": "contour",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or annot or annotation : – annot=annot_int | annot=(int=annot_int, disable=true, single=true, labels=labelinfo)\nannot_int is annotation interval in data units; it is ignored if contour levels are given in a file. [Default is no annotations]. Use annot=(disable=true,) to disable all annotations implied by cont. Alternatively do annot=(single=true, int=val) to plot val as a single contour. The optional labelinfo controls the specifics of the label formatting and consists of a named tuple with the following control arguments [Label formatting]\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or cont or contours or levels : – cont=cont_int\nThe contours to be drawn may be specified in one of four possible ways:\n\nIf cont_int has the suffix “.cpt” and can be opened as a file, it is assumed to be a CPT. The color boundaries are then used as contour levels. If the CPT has annotation flags in the last column then those contours will be annotated. By default all contours are labeled; use annot=(disable=true,)) (or annot=:none) to disable all annotations.\nIf cont_int is a file but not a CPT, it is expected to contain contour levels in column 1 and a C(ontour) OR A(nnotate) in col 2. The levels marked C (or c) are contoured, while the levels marked A (or a) are contoured and annotated. If the annotation angle is present we will plot the label at that fixed angle [aligned with the contour]. Finally, a contour- specific pen may be present and will override the pen set by pen for this contour level only. Note: Please specify pen in proper format so it can be distinguished from a plain number like angle. If only cont-level columns are present then we set type to C\nIf cont_int is a constant or an array it means plot those contour intervals. This works also to draw single contours. E.g. contour=[0] will draw only the zero contour. The annot option offers the same list choice so they may be used together to plot a single annotated contour and another single non-annotated contour, as in anot=[10], cont=[5] that plots an annotated 10 contour and an non-annotated 5 contour. If annot is set and cont is not, then the contour interval is set equal to the specified annotation interval.\nIf no argument is given in modern mode then we select the current CPT.\nOtherwise, cont_int is interpreted as a constant contour interval.\n\nIf a file is given and ticks is set, then only contours marked with upper case C or A will have tick-marks. In all cases the contour values have the same units as the grid. Finally, if neither cont nor annot are set then we auto-compute suitable contour and annotation intervals from the data range, yielding 10-20 contours.\nD or dump : – dump=fname\nDump contours as data line segments; no plotting takes place. Append filename template which may contain C-format specifiers. If no filename template is given we return the result in a GMTdataset. If filename has no specifiers then we write all lines to a single file. If a float format (e.g., %6.2f) is found we substitute the contour z-value. If an integer format (e.g., %06d) is found we substitute a running segment count. If an char format (%c) is found we substitute C or O for closed and open contours. The 1-3 specifiers may be combined and appear in any order to produce the the desired number of output files (e.g., just %c gives two files, just %f would separate segments into one file.\nE or index : – index=“indexfile[+b]” | index=dataset\nGive name of file with network information. Each record must contain triplets of node numbers for a triangle [Default computes these using Delaunay triangulation (see triangulate)]. If the indexfile is binary and can be read the same way as the binary input table then you can append +b to spead up the reading [Default reads nodes as ASCII]. index=dataset uses a already in-memory matrix or GMTdataset.\nG or labels : – labels=()\nThe required argument controls the placement of labels along the quoted lines. Choose among five controlling algorithms as explained in [Placement methods]\nI or fill or colorize : – fill=true\nColor the triangles using the CPT.\nL or mesh : – mesh=pen  Draw the underlying triangular mesh using the specified pen attributes [Default is no mesh].\nN or no_clip : – no_clip=true\nDo NOT clip contours or image at the boundaries [Default will clip to fit inside region region].\nQ or cut : – cut=np | cut=length&unit[+z]\nDo not draw contours with less than np number of points [Draw all contours]. Alternatively, give instead a minimum contour length in distance units, including c (Cartesian distances using user coordinates) or C for plot length units in current plot units after projecting the coordinates. Optionally, append +z to exclude the zero contour.\nS or skip : – skip=true | skip=:p|:t\nSkip all input xyz* points that fall outside the region [Default uses all the data in the triangulation]. Alternatively, use skip=:t to skip triangles whose three vertices are all outside the region. skip=true is interpreted as skip=:p.\nT or ticks : – ticks=(local_high=true, local_low=true, gap=gap, closed=true, labels=labels)\nWill draw tick marks pointing in the downward direction every gap along the innermost closed contours only; set closed=true to tick all closed contours. Use gap=(gap,length) and optionally tick mark length (append units as c, i, or p) or use defaults [“15p/3p”]. User may choose to tick only local highs or local lows by specifying local_high=true, local_low=true, respectively. Set labels to annotate the centers of closed innermost contours (i.e., the local lows and highs). If no labels (i.e, set labels=““) is set, we use - and + as the labels. Appending exactly two characters, e.g., labels=:LH, will plot the two characters (here, L and H) as labels. For more elaborate labels, separate the low and hight label strings with a comma (e.g., labels=“lo,hi”). If a file is given by cont, and ticks is set, then only contours marked with upper case C or A will have tick marks [and annotations].\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format.\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\n\nNormally, the annotated contour is selected for the legend. You can select the regular contour instead, or both of them, by considering the label to be of the format [annotcontlabel][/contlabel]. If either label contains a slash (/) character then use | as the separator for the two labels instead. .. include:: explain_-l.rst_\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/contour.html#examples",
    "href": "documentation/modules/contour.html#examples",
    "title": "contour",
    "section": "Examples",
    "text": "Examples\nTo make a raw contour plot from the remote file Table_5.11.txt and draw the contours every 25 and annotate every 50, using the default Cartesian projection, try\n\nusing GMT\ncontour(\"@Table_5_11.txt\", pen=:thin, contour=25, annot=50, show=true)\n\n\n\n\n\n\n\n\nTo use the same data but only contour the values 750 and 800, use\n\nusing GMT\ncontour(\"@Table_5_11.txt\", annot=[750,800], pen=0.5, show=true)\n\n\n\n\n\n\n\n\nTo create a color plot of the numerical temperature solution obtained on a triangular mesh whose node coordinates and temperatures are stored in temp.xyz and mesh arrangement is given by the file mesh.ijk, using the colors in temp.cpt, run\n\ncontour(\"temp.xyz\", index=\"mesh.ijk\", region=(0,150,0,100), figscale=0.25,\n        cmap=\"temp.cpt\", labels=true, pen=0.25, show=true)\n\ngmtread [ERROR]: Cannot find file temp.xyz\ngmtread [ERROR]: Cannot find file temp.xyz\ngmtread [ERROR]: File temp.xyz not found\n[Session GMT (0)]: Error returned from GMT API: GMT_FILE_NOT_FOUND (16)\n\n\n\nSomething went wrong when calling the module. GMT error number = 16\n\nStacktrace:\n [1] error(s::String)\n   @ Base .\\error.jl:35\n [2] gmt(::String)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\gmt_main.jl:166\n [3] read_data(d::Dict{Symbol, Any}, fname::String, cmd::String, arg::Nothing, opt_R::String, is3D::Bool, get_info::Bool)\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\common_options.jl:3656\n [4] contour_helper(cmd0::String, arg1::Nothing, O::Bool, K::Bool, d::Dict{Symbol, Any})\n   @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\pscontour.jl:99\n [5] #contour_helper#936\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\pscontour.jl:82 [inlined]\n [6] contour_helper\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\pscontour.jl:80 [inlined]\n [7] #contour#932\n   @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\pscontour.jl:75 [inlined]\n [8] top-level scope\n   @ In[4]:1\n\n\n\nTo save the triangulated 100-m contour lines in topo.txt and separate them into multisegment files (one for each contour level), try\n    contour(\"topo.txt\", contour=100, dump=\"contours_%.0f.txt\")"
  },
  {
    "objectID": "documentation/modules/contour.html#references",
    "href": "documentation/modules/contour.html#references",
    "title": "contour",
    "section": "References",
    "text": "References\nWatson, D. F., 1982, Acord: Automatic contouring of raw data, Comp. & Geosci., 8, 97-101.\nShewchuk, J. R., 1996, Triangle: Engineering a 2D Quality Mesh Generator and Delaunay Triangulator, First Workshop on Applied Computational Geometry (Philadelphia, PA), 124-133, ACM, May 1996.\nhttp://www.cs.cmu.edu/~quake/triangle.html"
  },
  {
    "objectID": "documentation/modules/contour.html#auto-legend-entries",
    "href": "documentation/modules/contour.html#auto-legend-entries",
    "title": "contour",
    "section": "Auto-legend entries",
    "text": "Auto-legend entries\nThis module allows you to use the l option to specify an automatic legend entry. This option is available for lines or symbols only. If the symbol size is variable and computed from other information (which may be true for some symbols deriving their size from other input columns), then you need to supply a representative legend size via the +S modifier."
  },
  {
    "objectID": "documentation/modules/contour.html#source-code",
    "href": "documentation/modules/contour.html#source-code",
    "title": "contour",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncontour(cmd0::String; kwargs...) - pscontour.jl:75\ncontour(arg1; kwargs...) - pscontour.jl:76"
  },
  {
    "objectID": "documentation/modules/contour.html#see-also",
    "href": "documentation/modules/contour.html#see-also",
    "title": "contour",
    "section": "See Also",
    "text": "See Also\ngrdcontour, grdimage, nearneighbor, basemap, colorbar, surface, triangulate"
  },
  {
    "objectID": "documentation/modules/cornerplot.html",
    "href": "documentation/modules/cornerplot.html",
    "title": "cornerplot",
    "section": "",
    "text": "cornerplot(data; kwargs...)\nTakes a nSamples-by-nDimensions array, and makes density plots of every combination of the dimensions. Plots as a triangular matrix of subplots showing the correlation among input variables. Input data can be a MxN matrix, a GMTdataset or a file name that upon reading with gmtread returns a GMTdataset.\nThe plot consists of histograms of each column along the diagonal and scatter or hexagonal bining plots for the inter-variable relations, depending on if the the number of samples is &lt;= 1000. But this can be changed with options in kwargs.\ncornerplot(..., truths) indicates reference values on the plots. Note that truths must be a vector of length n dimensions, that is, number of columns in input data.\ncornerplot(..., scatter=true) Force scatter plots even when number of points &gt; 1000."
  },
  {
    "objectID": "documentation/modules/cornerplot.html#examples",
    "href": "documentation/modules/cornerplot.html#examples",
    "title": "cornerplot",
    "section": "Examples",
    "text": "Examples\nCreate a cornerplot plot with hexagonal bins, setting the color map, the vriable names, plot truth and title.\n\nusing GMT\ncornerplot(randn(4000,3), cmap=:viridis, truths=[0.25, 0.5, 0.75],\n           varnames=[\"Ai\", \"Oi\", \"Ui\"], title=\"Corner plot\", show=true)\n\n\n\n\n\n\n\n\nExample on how to control the symbol types, size and color.\n\nusing GMT\ncornerplot(randn(1500,3), scatter=true, marker=:cross, mec=:red, ms=\"3p\", show=true)"
  },
  {
    "objectID": "documentation/modules/cornerplot.html#source-code",
    "href": "documentation/modules/cornerplot.html#source-code",
    "title": "cornerplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncornerplot(fname::String; first, kw...) - statplots.jl:1300\ncornerplot(arg1; first, kwargs...) - statplots.jl:1301"
  },
  {
    "objectID": "documentation/modules/cornerplot.html#see-also",
    "href": "documentation/modules/cornerplot.html#see-also",
    "title": "cornerplot",
    "section": "See Also",
    "text": "See Also\n[binstats], histogram, marginalhist, plot"
  },
  {
    "objectID": "documentation/modules/earthregions.html",
    "href": "documentation/modules/earthregions.html",
    "title": "earthregions",
    "section": "",
    "text": "[GI = ] earthregions(name=\"\"; proj=\"guess\", country=false, dataset=\"\", grid=false,\n                     res, registration=\"\", exact=false)\nPlots or automatically extracts grid/image over a named geographic region.\nShow the contents of the Mainlands collection. We use this as example because it is a small one (contains only the continental parts of some countries that otherwise contain also distant islands) and therefore, good to show what information is displayed to the user.\nConsulting the UN collection we would have found that the “Caribbean” region has the code UN029. So, making a map of the Caribe is as simple as:\nusing GMT\nearthregions(\"UN029\")\nBut the examples above do not let us plot the country’s borders that help referencing a map. For the time being that is only possible when we use the DCW collection. Next example shows a case with country borders. Also note that for the regions in the DCW (there are 248 of them) we can combine as many countries as we want.\nusing GMT\nearthregions(\"PT,ES,FR\", country=true)\nOur last example shows how to extract a topo/bathymetric grid of the “Sea of Azov” and letting the earthregions select the grid resolution. We also show how to make a pretty map with very few commands. Note that for this later case we have much more plotting possibilities than with the earthregions function that is only a tool to select named regions and quickly visualize them.\nusing GMT\nG = earthregions(\"IHO31\", grid=true);\nviz(G, shade=true, coast=true, cmap=:earth)"
  },
  {
    "objectID": "documentation/modules/earthregions.html#source-code",
    "href": "documentation/modules/earthregions.html#source-code",
    "title": "earthregions",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nearthregions(name::String; proj, grid, dataset, res, exact, registration, country, round, show, Vd) - pscoast.jl:363\nearthregions(; ...) - pscoast.jl:363"
  },
  {
    "objectID": "documentation/modules/earthregions.html#see-also",
    "href": "documentation/modules/earthregions.html#see-also",
    "title": "earthregions",
    "section": "See Also",
    "text": "See Also\ncoast, mosaic"
  },
  {
    "objectID": "documentation/modules/ecdfplot.html",
    "href": "documentation/modules/ecdfplot.html",
    "title": "ecdfplot",
    "section": "",
    "text": "ecdfplot(x::AbstractVector{AbstractFloat}, y::AbstractVector{AbstractFloat}; kwargs...)\necdfplot(x, …) plot the empirical cumulative distribution function (ECDF) of x.\nusing GMT\necdfplot(randn(100), show=true)"
  },
  {
    "objectID": "documentation/modules/ecdfplot.html#source-code",
    "href": "documentation/modules/ecdfplot.html#source-code",
    "title": "ecdfplot",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/feather.html",
    "href": "documentation/modules/feather.html",
    "title": "feather",
    "section": "",
    "text": "feather(cmd0::String=\"\", arg1=nothing; kwargs...)\nPlot arrows originating from the x-axis. Specify the direction of arrows using the Cartesian components U and V or polar theta,r. The input can either be a file name of a file with at least two columns (u,v), but preferably three, a GMTdatset object with also two or more columns, or direct u,v inputs. In case data has only two columns the arrows are plotted in fuction of the number of points. If xx axis is time, provide the data as time u v or time theta r.\nfeather(D::GMTdatset, yvar, …) plots the specified variables from the GMTdatset against the row indices of the table. To select the two columns that make up the arrows, specify them via the variable yvar. This can take the form of column names or column numbers. Example yvar=[:Y1, :Y2] or yvar=(2,3)."
  },
  {
    "objectID": "documentation/modules/feather.html#examples",
    "href": "documentation/modules/feather.html#examples",
    "title": "feather",
    "section": "Examples",
    "text": "Examples\nCreate a feather plot by specifying the components of each arrow as Cartesian values..\n\nusing GMT\nuv= [0.0 0 2.0; 0.0 30 2; 0.0 60 2; 0.0 90 2; 0.0 120 2; 0.0 150 2; 0.0 180 2; 0.0 210 2; 0.0 240 2; 0.0 270 2; 0.0 300 2; 0.0 330 2; 0.0 360 2];\nfeather(uv, rtheta=true, aspect=\"1:1\", arrow=(len=0.5, shape=0.5,), lw=0.5, fill=:green, show=true)\n\n\n\n\n\n\n\n\nWith simple arrows and in function of number of arrows.\n\nusing GMT\nt = -pi/2:pi/8:pi/2; u = 10*sin.(t); v = 10*cos.(t);\nfeather(u,v, show=true)\n\n\n\n\n\n\n\n\nShow the data used in this example.\nusing GMT, PrettyTables   # hide\ngetpath4docs(file::String) = joinpath(\"..\", \"..\", \"..\", \"..\", \"..\", file) # hide\nio = IOBuffer() # hide\nD = gmtread(TESTSDIR * \"assets/wind_faro_s.dat\")\nPrettyTables.pretty_table(io, D.data; header=D.colnames, backend=Val(:html))    # hide\nprintln(\"~~~\" * String(take!(io)) * \"~~~\") # hide\nCreate a winbarb plot. Note that since the data has 4 columns we must select the 3 that we want to use in the plot. We select the columns from teir names in the D GMTdataset.\n\nusing GMT\nGMT.resetGMT()  # hide\nfeather(TESTSDIR * \"assets/wind_faro.dat\", xvar=:Time, yvar=[:azimuth, :vmean], rtheta=true, nohead=1, lw=0.1, show=true)"
  },
  {
    "objectID": "documentation/modules/feather.html#source-code",
    "href": "documentation/modules/feather.html#source-code",
    "title": "feather",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfeather(cmd0::String; ...) - plot.jl:1202\nfeather(; ...) - plot.jl:1202\nfeather(arg1, arg2, arg3, arg4; kw...) - plot.jl:1221\nfeather(arg1, arg2, arg3; kw...) - plot.jl:1219\nfeather(cmd0::String, arg1; first, kwargs...) - plot.jl:1202\nfeather(arg1, arg2; kw...) - plot.jl:1217\nfeather(arg1; kw...) - plot.jl:1215"
  },
  {
    "objectID": "documentation/modules/fill_between.html",
    "href": "documentation/modules/fill_between.html",
    "title": "fill_between",
    "section": "",
    "text": "fill_between(D1 [,D2]; kwargs...)\nFill the area between two horizontal curves.\nThe curves are defined by the points (x, y1, y2) in matrix or GMTdataset D1. This creates one or multiple polygons describing the filled area. Alternatively, give a second matrix, D2 (or a scalar y=cte) and the polygons are constructed from the intersections of curves D1 and D2. The D1 arg can also be a file name of a file that can be read with gmtread and return a GMTdataset.html) Note: D1 and D2 do not need to have the same number of points but they should have the same xx limits (or close), otherwise results my look weird.\nfill_between(..., fillalpha=[alpha1,alpha2]): Sets the transparency of the two sets of polygons (default 60%). alpha1 and alpha2 are numbers between [0-1] or [0-100], where 1 or 100 mean full transparency.\nfill_between(..., stairs=true) Plot stairs curves instead.\nfill_between(..., legend=...): If used as the above labels it behaves like wise, but its argument can also be a named tuple with legend=(labels=\"Lab1,Lab2\", position=poscode, box=(...)), where poscode is the same as used in text, e.g. TL means TopLeft and box controls the legend box details. See examples at"
  },
  {
    "objectID": "documentation/modules/fill_between.html#examples",
    "href": "documentation/modules/fill_between.html#examples",
    "title": "fill_between",
    "section": "Examples",
    "text": "Examples\nSee the intersections of two sinc curves.\n\nusing GMT\ntheta = linspace(-2π, 2π, 150);\ny1 = sin.(theta) ./ theta;\ny2 = sin.(2*theta) ./ theta;\nfill_between([theta y1 y2], legend=\"Sinc1,Sinc2\", show=true)\n\n\n\n\n\n\n\n\nControl the legend position.\n\nusing GMT\ntheta = linspace(-2π, 2π, 150);\ny1 = sin.(theta) ./ theta;\ny2 = sin.(2*theta) ./ theta;\nfill_between([theta y1], [theta y2], fill=(\"lightblue\",:orange), white=true,\n             legend=(labels=\"Sinc1,Sinc2\", pos=:TL, box=:none), show=true)\n\n\n\n\n\n\n\n\nUse a constant y for the second curve.\n\nusing GMT\ntheta = linspace(-2π, 2π, 150);\ny2 = sin.(2*theta) ./ theta;\nfill_between([theta y2], 0.0, white=true, lt=1, ls=:dash, show=true)"
  },
  {
    "objectID": "documentation/modules/fill_between.html#source-code",
    "href": "documentation/modules/fill_between.html#source-code",
    "title": "fill_between",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfill_between(fname::String; first, kw...) - plot.jl:686\nfill_between(arg1, arg2; first, kwargs...) - plot.jl:687\nfill_between(arg1; ...) - plot.jl:687"
  },
  {
    "objectID": "documentation/modules/fill_between.html#see-also",
    "href": "documentation/modules/fill_between.html#see-also",
    "title": "fill_between",
    "section": "See Also",
    "text": "See Also\nplot"
  },
  {
    "objectID": "documentation/modules/fitcircle.html",
    "href": "documentation/modules/fitcircle.html",
    "title": "fitcircle",
    "section": "",
    "text": "fitcircle(cmd0::String=\"\", arg1=nothing, kwargs...)\nFind mean position and great [or small] circle fit to points on sphere"
  },
  {
    "objectID": "documentation/modules/fitcircle.html#description",
    "href": "documentation/modules/fitcircle.html#description",
    "title": "fitcircle",
    "section": "Description",
    "text": "Description\nReads lon,lat [or lat,lon] values from the first two columns. These are converted to Cartesian three-vectors on the unit sphere. Then two locations are found: the mean of the input positions, and the pole to the great circle which best fits the input positions. The user may choose one or both of two possible solutions to this problem. The first is called L1 (i.e. norm=1) and the second is called L2 (i.e. norm=2). When the data are closely grouped along a great circle both solutions are similar. If the data have large dispersion, the pole to the great circle will be less well determined than the mean. Compare both solutions as a qualitative check.\nThe L1 solution is so called because it approximates the minimization of the sum of absolute values of cosines of angular distances. This solution finds the mean position as the Fisher average of the data, and the pole position as the Fisher average of the cross-products between the mean and the data. Averaging cross-products gives weight to points in proportion to their distance from the mean, analogous to the “leverage” of distant points in linear regression in the plane.\nThe L2 solution is so called because it approximates the minimization of the sum of squares of cosines of angular distances. It creates a 3 by 3 matrix of sums of squares of components of the data vectors. The eigenvectors of this matrix give the mean and pole locations. This method may be more subject to roundoff errors when there are thousands of data. The pole is given by the eigenvector corresponding to the smallest eigenvalue; it is the least-well represented factor in the data and is not easily estimated by either method."
  },
  {
    "objectID": "documentation/modules/fitcircle.html#required-arguments",
    "href": "documentation/modules/fitcircle.html#required-arguments",
    "title": "fitcircle",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nL or norm : – norm=1 | norm=2 | norm=3\nSpecify the desired norm as 1 or 2, or use or norm=3 to see both solutions."
  },
  {
    "objectID": "documentation/modules/fitcircle.html#optional-arguments",
    "href": "documentation/modules/fitcircle.html#optional-arguments",
    "title": "fitcircle",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nF or coord or coordinates : – coord=flags\nTraditionally, fitcircle will write its results in the form of a text report, with the values intermingled with report sentences. Use coord to only return data coordinates, and append flags to specify which coordinates you would like. You can choose one or more items from flat Earth mean location, mean location, north pole of great circle, south pole of great circle, and circle (pole of small circle and its colatitude, which requires small_circle).\nS or small_circle : – small_circle=true | small_circle=lat\nAttempt to fit a small circle instead of a great circle. The pole will be constrained to lie on the great circle connecting the pole of the best-fit great circle and the mean location of the data. Optionally append the desired fixed latitude of the small circle [Default will determine the optimal latitude].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/fitcircle.html#examples",
    "href": "documentation/modules/fitcircle.html#examples",
    "title": "fitcircle",
    "section": "Examples",
    "text": "Examples\nTo find the parameters of a great circle that most closely fits the (lon,lat) points in the remote file @sat_03.txt (hosted in a GMT server) in a least-squares sense, try\n    fitcircle(\"@sat_03.txt\", norm=2, coord=:mean)\nSuppose you have lon,lat,grav data along a twisty ship track in the file ship.xyg. You want to project this data onto a great circle and resample it in distance, in order to filter it or check its spectrum. Do the following:\n    Df = fitcircle(\"ship.xyg\", norm=2)\n    D1 = project(\"ship.xyg\", origin=(ox,oy), pole=(px,py), sort=true, outvars=:pz);\n    D2 = sample1d(D1, S=-100, I=1);\nHere, ox,oy is the lon/lat of the mean from fitcircle, and px,py is the lon/lat of the pole. The output has distance, gravity data sampled every 1 km along the great circle which best fits ship.xyg\nIf you have lon, lat points in the file data.txt and wish to return the northern hemisphere great circle pole location using the L2 norm, try\n    D = fitcircle(\"data.txt\", norm=2, coordinates=:north)"
  },
  {
    "objectID": "documentation/modules/fitcircle.html#source-code",
    "href": "documentation/modules/fitcircle.html#source-code",
    "title": "fitcircle",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfitcircle(cmd0::String; kwargs...) - fitcircle.jl:21\nfitcircle(arg1; kwargs...) - fitcircle.jl:22"
  },
  {
    "objectID": "documentation/modules/fitcircle.html#see-also",
    "href": "documentation/modules/fitcircle.html#see-also",
    "title": "fitcircle",
    "section": "See Also",
    "text": "See Also\ngmtvector, project, mapproject, sample1d"
  },
  {
    "objectID": "documentation/modules/gmtbinstats.html",
    "href": "documentation/modules/gmtbinstats.html",
    "title": "gmtbinstats",
    "section": "",
    "text": "gmtbinstats(cmd0::String=\"\", arg1=nothing; kwargs...)\nBin spatial data and determine statistics per bin."
  },
  {
    "objectID": "documentation/modules/gmtbinstats.html#description",
    "href": "documentation/modules/gmtbinstats.html#description",
    "title": "gmtbinstats",
    "section": "Description",
    "text": "Description\nReads arbitrarily located (x,y[,z][,w]) points (2-4 columns) and for each node in the specified grid layout determines which points are within the given radius. These point are then used in the calculation of the specified statistic. The results may be presented as is or may be normalized by the circle area to perhaps give density estimates. Alternatively, select hexagonal tiling instead or a rectangular grid layout."
  },
  {
    "objectID": "documentation/modules/gmtbinstats.html#required-arguments",
    "href": "documentation/modules/gmtbinstats.html#required-arguments",
    "title": "gmtbinstats",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable : – Either as a string with the filename in arg cmd0 or as Matrix or GMTdataset in arg1\nA 2-4 column matrix holding (x,y[,z][,w]) data values. You must use weights to indicate that you have weights. Only -Cn will accept 2 columns only.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/gmtbinstats.html#optional-arguments",
    "href": "documentation/modules/gmtbinstats.html#optional-arguments",
    "title": "gmtbinstats",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or stats or statistic : – stats=…\nChoose the statistic that will be computed per node based on the points that are within radius distance of the node. Select one of:\n\naverage or mean # mean (average)\nmad # median absolute deviation\nrange # full (max-min) range\niq or interquartil # 25-75% interquartile range\nmin or minimum # minimum (low)\nmin_pos or minimum_pos # minimum of positive values only\nmedian # median\nnumber or count # number of values\nLMS # LMS scale\nmode # mode (maximum likelihood)\nquantil[val] # selected quantile (append desired quantile in 0-100% range [50], e.g. “quantil25”)\nrms # the r.m.s.\nstd # standard deviation\nmax or maximum # maximum (upper)\nmax_neg or maximum_neg # maximum of negative values only\nsum # the sum\n\nnbins : – nbins=n\nSet the number of hexagonal cells along the horizontal direction. Grid increment (inc) is computed x-data range and this number of cells. Default, when figure size is known, uses a simple heuristic to st increment.\nthreshold : – threshold=xx\nRows with computed stats lower then threshold are removed. Note that this option is not to be used when computing grids (will be ignored).\nE or empty : – empty=-9999 Set the value assigned to empty nodes. By default we use NaN.\nN or normalize : – normalize=true\nNormalize the resulting grid values by the area represented by the search_radius [no normalization].\nS or search_radius : – search_radius=rad\nSets the search radius that determines which data points are considered close to a node. Append the distance unit if wished. Not compatible with tiling.\nT or tiling or bins : – tiling=rectangular or tiling=hexagonal\nInstead of circular, possibly overlapping areas, select non-overlapping tiling. Choose between tiling=rectangular or tiling=hexagonal binning. For rectangular, set bin sizes via spacing and we write the computed statistics to the grid file. For tiling=hexagonal, we write a table with the centers of the hexagons and the computed statistics. Here, the spacing setting is expected to set the y increment only and we compute the x-increment given the geometry. Because the horizontal spacing between hexagon centers in x and y have a ratio of sqrt(3), we will automatically adjust xmax in region to fit a whole number of hexagons. Note: Hexagonal tiling requires Cartesian data.\nW or weights : – weights=true or weights=“+s”\nInput data have an extra column containing observation point weight. If weights are given then weighted statistical quantities will be computed while the count will be the sum of the weights instead of number of points. If your weights are actually uncertainties (one sigma) then use weights=\"+s\" and we compute weight = 1/sigma.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/gmtbinstats.html#examples",
    "href": "documentation/modules/gmtbinstats.html#examples",
    "title": "gmtbinstats",
    "section": "Examples",
    "text": "Examples\nTo examine the population inside a circle of 1000 km radius for all nodes in a 5x5 arc degree grid, using the remote file @capitals.gmt, and plot the resulting grid using default projection and colors, try\nG = gmtbinstats(\"@capitals.gmt\", a=\"2=population\", region=:global360, inc=5, stats=:sum, search_radius=\"1000k\");\nimshow(G)\nMake a hexbin plot with random numbers.\nxy = rand(100,2) .* [5 3];\nD = binstats(xy, region=(0,5,0,3), inc=1, tiling=:hex, stats=:number);\nimshow(D, hexbin=true, ml=0.5, colorbar=true)"
  },
  {
    "objectID": "documentation/modules/gmtbinstats.html#source-code",
    "href": "documentation/modules/gmtbinstats.html#source-code",
    "title": "gmtbinstats",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbinstats(fname::String; nbins, kwargs...) - gmtbinstats.jl:41\nbinstats(arg1; nbins, kwargs...) - gmtbinstats.jl:47"
  },
  {
    "objectID": "documentation/modules/gmtconvert.html",
    "href": "documentation/modules/gmtconvert.html",
    "title": "gmtconvert",
    "section": "",
    "text": "gmtconvert(cmd0::String=\"\", arg1=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#warning-only-half-ported-to-gmt.jl-need-help-for-finishing",
    "href": "documentation/modules/gmtconvert.html#warning-only-half-ported-to-gmt.jl-need-help-for-finishing",
    "title": "gmtconvert",
    "section": "WARNING: ONLY HALF PORTED TO GMT.JL NEED HELP FOR FINISHING",
    "text": "WARNING: ONLY HALF PORTED TO GMT.JL NEED HELP FOR FINISHING"
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#description",
    "href": "documentation/modules/gmtconvert.html#description",
    "title": "gmtconvert",
    "section": "Description",
    "text": "Description\nCan do a combination of nine tasks: (1) convert between binary and ASCII data tables, (2) paste corresponding records from multiple files horizontally into a single file, (3) extract a subset of the available columns, (4) only extract segments whose header record matches a text pattern search, (5) only list segment headers and no data records, (6) extract first and/or last data record for each segment, (7) reverse the order of items on output, (8) output only ranges of segment numbers, and (9) output only segments whose record count matches criteria. Input (and hence output) may have multiple sub-headers, and ASCII tables may have regular headers as well."
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#required-arguments",
    "href": "documentation/modules/gmtconvert.html#required-arguments",
    "title": "gmtconvert",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns."
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#optional-arguments",
    "href": "documentation/modules/gmtconvert.html#optional-arguments",
    "title": "gmtconvert",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or hcat : – hcat=true\nThe records from the input files should be pasted horizontally, not appended vertically [Default]. All files must have the same number of segments and number of rows per segment. Note for binary input, all the files you want to paste must have the same number of columns (as set with -bi); ASCII tables can have different number of columns.\nC or n_records : – n_records=[+l min][+u max][+i]\nOnly output segments whose number of records matches your given criteria: Append +l min to ensure all segment must have at least min records to be written to output [0], and append +u max to ensure all segments must have at most max records to be written [inf]. You may append +i to invert the selection, i.e., only segments with record counts outside the given range will be output.\nD or dump : – dump=[template [+o orig]]\nFor multiple segment data, dump each segment to a separate output file [Default writes a multiple segment file to standard output]. Append a format template for the individual file names; this template must contain a C format specifier that can format an integer argument (the running segment number across all tables); this is usually %d but could be %08d which gives leading zeros, etc. [Default is gmtconvert_segment_%d.{txt|bin}, depending on -bo]. Append +o orig to start the numbering from orig instead of zero. Alternatively, give a template with two C format specifiers and we will supply the table number and the segment number within the table to build the file name. Append +o torig /sorig to start the numbering of tables from torig and numbering of segments within a table from sorig instead of zero. The +o modifier will be stripped off before the template is used.\nE or first_last : – first_last=[f|l|m|M stride]\nOnly extract the first and last record for each segment of interest [Default extracts all records]. Optionally, append f or l to only extract the first or last record of each segment, respectively. Alternatively, append m stride to extract every stride records; use M to also include the last record.\nF or conn_method : – conn_method=[c|n|p|v][**a|t|s|r| refpoint]\nAlter the way points are connected (by specifying a scheme) and data are grouped (by specifying a method). Append one of four line connection schemes:\n\nc : Form continuous line segments for each group [Default].\np : Form line segments from a reference point reset for each group.\nn : Form networks of line segments between all points in each group.\nv : Form vector line segments suitable for :doc:plot -Sv+s. Optionally, append the one of four segmentation methods to define the group:\na : Ignore all segment headers, i.e., let all points belong to a single group, and set group reference point to the very first point of the first file.\nt : Consider all data in each table to be a single separate group and reset the group reference point to the first point of each group.\ns : Segment headers are honored so each segment is a group; the group reference point is reset to the first point of each incoming segment [Default].\nr : Same as s, but the group reference point is reset after each record to the previous point (this method is only available with the Fp scheme).\n\nInstead of the codes a|f|s|r you may append the coordinates of a refpoint which will serve as a fixed external reference point for all groups.\nI or invert or reverse : – invert=true | invert=:tsr\nInvert the order of items, i.e., output the items in reverse order, starting with the last and ending up with the first item [Default keeps original order]. Append up to three items that should be reversed: t will reverse the order of tables, s will reverse the order of segments within each table, and r will reverse the order of records within each segment [Default].\nL or list_only : – list_only=true\nOnly output a listing of all segment header records and no data records (requires ASCII data).\nN or sort : – sort=col* [+a|d]\nNumerically sort each segment based on values in column col*. The data records will be sorted such that the chosen column will fall into ascending order [+a, which is Default]. Append +d to sort into descending order instead. The sort option can be combined with any other ordering scheme except conn_method (segmentation) and is applied at the end.\nQ or segments : – segments=[~] selection* \nOnly write segments whose number is included in selection* and skip all others. Cannot be used with |-S|. The selection syntax is range[,range,…] where each range of items is either a single segment number or a range with stepped increments given via start [:step:] :stop (step is optional and defaults to 1). A leading ~ will invert the selection and write all segments but the ones listed. Instead of a list of ranges, use +f file to supply a file list with one range per line.\nS or select_hdr : – select_hdr=[~] ”search string”| +f| file [+e] | |-S| [~]/ regexp/[i][+e]\nOnly output those segments whose header record contains the specified text string. To reverse the search, i.e., to output segments whose headers do not contain the specified pattern, use select_hdr=:~. Should your pattern happen to start with ~ you need to escape this character with a backslash [Default output all segments]. Cannot be used with |-Q|. For matching segments based on aspatial values (via OGR/GMT format), give the search string as varname = value and we will compare value against the value of varname for each segment. Note: If the features are polygons then a match of a particular polygon perimeter also means that any associated polygon holes will also be matched. For matching segment headers against extended regular expressions enclose the expression in slashes. Append i for case-insensitive matching. For a list of such patterns, give +f file with one pattern per line. To give a single pattern starting with “+f”, escape it with a backslash. Finally, append +e as last modifier to request an exact match [Default will match any sub-string in the target].\nT or skip : – skip=[h][d [[~] selection]]\nSuppress the writing of certain records on output. Append h to suppress segment headers [Default], and/or d to suppress duplicate data records. Use skip=:hd to suppress both types of records. By default, all columns must be identical across the two records to skip the record. Alternatively, append a column selection to only use those columns in the comparisons instead. The selection syntax is range [, range,…] where each range of items is either a single column number or a range with stepped increments given via start [:step:] :stop (step is optional and defaults to 1). A leading ~ will invert the selection and select all columns but the ones listed. To add the trailing text to the comparison as well, add the column t to the list. If no numerical columns are specified, just t, then we only consider trailing text.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or word2num : – word2num=true | word2num=“+n”\nAttempt to convert each word in the trailing text to a number and append such values to the numerical output columns. Text that cannot be converted (because they are not numbers) will appear as NaNs. Use modifier +n to exclude the columns with NaNs. Note: These columns are identified based on the first input record only.\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#examples",
    "href": "documentation/modules/gmtconvert.html#examples",
    "title": "gmtconvert",
    "section": "Examples",
    "text": "Examples\nTo convert the binary file test.b (single precision) with 4 columns to ASCII:\n    convert(\"test.b\", bi=\"4f\", save=\"test.dat\")\nTo convert the multiple segment ASCII table test.txt to a double precision binary file:\n    convert(\"test.txt\", b=:o, save=\"test.b\")\nIf the file instead is the binary file results.b which has 9 single-precision values per record, we extract the last column and columns 4-6 with the command:\n    D = convert(\"results.b\", outcol=\"8,4-6\", binary_in=\"9s\")\nTo extract all segments in the file big_file.txt whose headers contain the string “RIDGE AXIS”, try:\n    D = convert(\"big_file.txt\", select_hdr=\"RIDGE AXIS\")\nTo only get the segments in the file big_file.txt whose headers exactly matches the string “Spitsbergen”, try:\n    D = convert(\"big_file.txt\", select_hdr=\"Spitsbergen+e\")\nTo invert the selection of segments whose headers begin with “profile” followed by an integer number and any letter between “g” and “l”, try:\n    D = convert(select_hdr=\"~\\\"/^profile [0-9]+[g-l]$/\\\"\")\nTo reverse the order of segments in a file without reversing the order of records within each segment, try:\n    convert(\"lots_of_segments.txt\", invert=:s)\nTo extract segments 20 to 40 in steps of 2, plus segment 0 in a file, try:\n    convert(\"lots_of_segments.txt\", segments=\"0,20:2:40\")\nTo extract the attribute ELEVATION from an ogr gmt file like this:\n    # @VGMT1.0 @GPOINT\n    ...\n    # @NELEVATION|DISPX|DISPY\n    # @Tdouble|double|double\n    # FEATURE_DATA\n    # @D4.945000|-106500.00000000|-32700.00000000\n    -9.36890245902635 39.367156766570389\ndo\n    D = convert(\"file.gmt\", aspatial=\"ELEVATION\")\nTo connect all points in the file sensors.txt with the specified origin at 23.5/19, try:\n    Dlines = convert(\"sensors.txt\", conn_method=(23.5,19))\nTo write all segments in the two files A.txt and B.txt to individual files named profile_005000.txt, profile_005001.txt, etc., where we reset the origin of the sequential numbering from 0 to 5000, try:\n    convert(\"A.txt\", \"B.txt\", D=\"profile_%6.6d.txt+o5000\")\nTo only read rows 100-200 and 500-600 from file junk.txt, try:\n    D = convert(\"junk.txt\", q=\"100-200,500-600\")\nTo get all rows except those bad ones between rows 1000-2000, try:\n    D = convert(\"junk.txt\", q=\"~1000-2000\")"
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#source-code",
    "href": "documentation/modules/gmtconvert.html#source-code",
    "title": "gmtconvert",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtconvert(cmd0::String; kwargs...) - gmtconvert.jl:55\ngmtconvert(arg1; kwargs...) - gmtconvert.jl:56"
  },
  {
    "objectID": "documentation/modules/gmtconvert.html#see-also",
    "href": "documentation/modules/gmtconvert.html#see-also",
    "title": "gmtconvert",
    "section": "See Also",
    "text": "See Also\ngmtinfo, gmtselect"
  },
  {
    "objectID": "documentation/modules/gmtisf.html",
    "href": "documentation/modules/gmtisf.html",
    "title": "gmtisf",
    "section": "",
    "text": "gmtisf(cmd0::String; kwargs...)\nRead seismicity data in the a ISF formated file.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet received the proper attention to port the original manual.\n\n\n\n\n\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nD | date :: date=“datestart[/dateend]”\nLimit the output to data &gt;= datestart, or between datestart and dateend.  must be in ISO format, e.g, 2000-04-25.\nF | focal :: [Type =&gt; Bool or Str or Symbol]\nSelect only events that have focal mechanisms. The default is Global CMT convention. Use focal=:a for the AKI convention\nN | notime :: [Type =&gt; Bool]\nDo NOT output time information.\nabstime or unixtime :: [Type =&gt; Integer]\nConvert the YYYY, MM, DD, HH, MM columns into a unixtime. Default puts it as first column, use abstime=2 to put it as last column.\nyx :: [Type =&gt; Str or Bool or []] \\(Arg = [i|o]\\)\nSwap 1st and 2nd column on input and/or output.\n\nThis module can also be called via gmtread. I.,e. `gmtread(“file.isf”, opts…)_\n\n\n\nView the source code for this function.\n\n\n\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/gmtisf.html#parameters",
    "href": "documentation/modules/gmtisf.html#parameters",
    "title": "gmtisf",
    "section": "",
    "text": "R | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nD | date :: date=“datestart[/dateend]”\nLimit the output to data &gt;= datestart, or between datestart and dateend.  must be in ISO format, e.g, 2000-04-25.\nF | focal :: [Type =&gt; Bool or Str or Symbol]\nSelect only events that have focal mechanisms. The default is Global CMT convention. Use focal=:a for the AKI convention\nN | notime :: [Type =&gt; Bool]\nDo NOT output time information.\nabstime or unixtime :: [Type =&gt; Integer]\nConvert the YYYY, MM, DD, HH, MM columns into a unixtime. Default puts it as first column, use abstime=2 to put it as last column.\nyx :: [Type =&gt; Str or Bool or []] \\(Arg = [i|o]\\)\nSwap 1st and 2nd column on input and/or output.\n\nThis module can also be called via gmtread. I.,e. `gmtread(“file.isf”, opts…)_"
  },
  {
    "objectID": "documentation/modules/gmtisf.html#source-code",
    "href": "documentation/modules/gmtisf.html#source-code",
    "title": "gmtisf",
    "section": "",
    "text": "View the source code for this function."
  },
  {
    "objectID": "documentation/modules/gmtisf.html#see-also",
    "href": "documentation/modules/gmtisf.html#see-also",
    "title": "gmtisf",
    "section": "",
    "text": "Alphabetical Function List"
  },
  {
    "objectID": "documentation/modules/gmtselect.html",
    "href": "documentation/modules/gmtselect.html",
    "title": "gmtselect",
    "section": "",
    "text": "gmtselect(cmd0::String=\"\", arg1=nothing, kwargs...)\nSelect data table subsets based on multiple spatial criteria"
  },
  {
    "objectID": "documentation/modules/gmtselect.html#description",
    "href": "documentation/modules/gmtselect.html#description",
    "title": "gmtselect",
    "section": "Description",
    "text": "Description\nselect is a filter that reads (x, y) or (longitude, latitude) positions from the first 2 columns of infiles [or standard input] and uses a combination of 1-7 criteria to pass or reject the records. Records can be selected based on whether or not they are 1) inside a rectangular region (region [and proj]), 2) within dist km of any point in pointfile, 3) within dist km of any line in linefile, 4) inside one of the polygons in the polygonfile, 5) inside geographical features (based on coastlines), 6) has z-values within a given range, or 7) inside bins of a grid mask whose nodes are non-zero. The sense of the tests can be reversed for each of these 7 criteria by using the reverse option. See option yx on how to read (y,x) or (latitude,longitude) files (this option affects all module input data). Note: If no projection information is used then you must supply colinfo=:g to tell select that your data are geographical."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#required-arguments",
    "href": "documentation/modules/gmtselect.html#required-arguments",
    "title": "gmtselect",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#optional-arguments",
    "href": "documentation/modules/gmtselect.html#optional-arguments",
    "title": "gmtselect",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\n-A or area : – area=(min_area[,min_level,max_level]), river_lake=true, lake=true, antarctica_ground=true, skip60S=true, skipN60S=true, percent=pct)\nFeatures with an area smaller than min_area in km^2 or of hierarchical level that is lower than min_level or higher than max_level will not be plotted [Default is 0/0/4 (all features)]. Level 2 (lakes) contains regular lakes and wide river bodies which we normally include as lakes; use river_lake=true to just get river-lakes or lake=true to just get regular lakes. By default we select the ice shelf boundary as the coastline for Antarctica; use antarctica_ground=true to instead select the ice grounding line as coastline. For expert users who wish to print their own Antarctica coastline and islands via plot you can use skip60S=true to skip all GSHHG features below 60S or skipN60S=true to instead skip all features north of 60S. Finally, append percent=pct to exclude polygons whose percentage area of the corresponding full-resolution feature is less than pct.\nC or dist2pt : – dist2pt=(pts=pointfile, dist=dist) | dist2pt=(pts=(lon,lat), dist=dist)\nPass all records whose location is within dist of any of the points in the ASCII file pointfile or a in-memory matrix. If dist is zero then the 3rd column of pointfile must have each point’s individual radius of influence. If you only have a single point then you can specify dist2pt=(pts=(lon,lat), dist=dist) instead of pointfile. Distances are Cartesian and in user units; specify colinfo=:g to indicate spherical distances and append a distance unit, even if the distance specified is 0. (see [Units]). Alternatively, if region and proj are used then geographic coordinates are projected to map coordinates (in cm, inch, or points, as determined by PROJ_LENGTH_UNIT) before Cartesian distances are compared to dist.\nD or res or resolution : – res=:full | res=:auto\nSelects the resolution of the data set to use full, high, intermediate, low, and crude. The resolution drops off by 80% between data sets. The default is res=:auto, which chooses to automatically select the best resolution given the chosen map scale.\nE or boundary : – boundary=:f|:n|:fn\nSpecify how points exactly on a polygon boundary should be considered. By default, such points are considered to be inside the polygon. Append :f and/or :n to change this behavior for the polygon and/or mask options, respectively, so that boundary points are considered to be outside.\nF or polygon : – polygon=polygonfile | polygon=matrix\nPass all records whose location is within one of the closed polygons in the multiple-segment file polygonfile (or GMTdataset with in-memory data). For spherical polygons (lon, lat), make sure no consecutive points are separated by 180 degrees or more in longitude. Note that polygonfile must be in ASCII.\nG or gridmask : – gridmask=“grid”\nPass all locations that are inside the valid data area of the gridR, which can be either a file name or an in-memory grid object. Nodes that are outside are either NaN or zero.\nI or invert or reverse : – invert=:c|f|l|r|s|z\nReverses the sense of the test for each of the criteria specified:\n\nc - select records NOT inside any point’s circle of influence.\nf - select records NOT inside any of the polygons.\ng - pass records inside the cells with z equal zero of the grid mask in gridmask.\nl - select records NOT within the specified distance of any line.\nr - select records NOT inside the specified rectangular region.\ns - select records NOT considered inside as specified by mask (and area, resolution).\nz - select records NOT within the range specified by |-Z|.\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or dist2line : – dist2line=(line=“linefile”, dist=dist [,ortho=true]) | dist2line=(line=[pt1; pt2], dist=dist [,ortho=true])\nPass all records whose location is within dist of any of the line segments in the ASCII multiple-segment file linefile or in-memory matrix or GMTdataset. If dist is zero then we will scan each sub-header in the linefile for an embedded -D dist setting that sets each line’s individual distance value. Distances are Cartesian and in user units; specify colinfo=:f to indicate spherical distances append a distance unit (see [Units]). Alternatively, if region and proj are used then geographic coordinates are projected to map coordinates (in cm, inch, m, or points, as determined by PROJ_LENGTH_UNIT) before Cartesian distances are compared to dist. Use ortho=true to ensure only points whose orthogonal projections onto the nearest line-segment fall within the segments endpoints [Default considers points “beyond” the line’s endpoints.\nN or mask : – mask=maskvalues\nPass all records whose location is inside specified geographical features. Specify if records should be skipped (s) or kept (k) using 1 of 2 formats:\n\nmask=(wet,dry)\nmask=(ocean,land,lake,island,pond)\n\nDefault is (:s,:k,:s,:k,:s) (i.e., (:s,:k)), which passes all points on dry land.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or in_range : – in_range=(min,max) | in_range=min\nPass all records whose 3rd column lies within the given range or is NaN (use -s to skip NaN records). If max is omitted then we test if z equals min instead. This means equality within 5 ULPs unit of least precision. Input file must have at least three columns. To indicate no limit on min or max, specify a hyphen (-). If your 3rd column is absolute time then remember to supply colinfo=“2T”. To specify another column, append “+ccol”. Be warned, these last options imply that the arguments to this option are all passed as a string. Note: repeating this option with different tests is not yet implemented.\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#note-on-processing-ascii-input-records",
    "href": "documentation/modules/gmtselect.html#note-on-processing-ascii-input-records",
    "title": "gmtselect",
    "section": "Note On Processing ASCII Input Records",
    "text": "Note On Processing ASCII Input Records\nUnless you are using the yx option, selected ASCII input records are copied verbatim to output. That means that options like colinfo=:oT and settings like FORMAT_FLOAT_OUT and FORMAT_GEO_OUT will not have any effect on the output. On the other hand, it allows selecting records with diverse content, including character strings, quoted or not, comments, and other non-numerical content."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#note-on-distances",
    "href": "documentation/modules/gmtselect.html#note-on-distances",
    "title": "gmtselect",
    "section": "Note On Distances",
    "text": "Note On Distances\nIf options dist2pt or dist2line are selected then distances are Cartesian and in user units; use colinfo=:g to imply spherical distances in km and geographical (lon, lat) coordinates. Alternatively, specify region and proj to measure projected Cartesian distances in map units (cm, inch, or points, as determined by PROJ_LENGTH_UNIT).\nThis program has evolved over the years. Originally, the region and proj were mandatory in order to handle geographic data, but now there is full support for spherical calculations. Thus, proj should only be used if you want the tests to be applied on projected data and not the original coordinates. If proj is used the distances given via dist2pt and dist2line are projected distances."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#note-on-segments",
    "href": "documentation/modules/gmtselect.html#note-on-segments",
    "title": "gmtselect",
    "section": "Note On Segments",
    "text": "Note On Segments\nSegment headers in the input files are copied to output if one or more records from a segment passes the test. Selection is always done point by point, not by segment. That means only points from a segment that pass the test will be included in the output. If you wish to clip the lines and include the new boundary points at the segment ends you must use gmtspatial instead."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#examples",
    "href": "documentation/modules/gmtselect.html#examples",
    "title": "gmtselect",
    "section": "Examples",
    "text": "Examples\nTo only return the data points from the remote file @ship_15.txt that lie within the region between longitudes 246 and 247 and latitudes 20 and 21, try:\n\nusing GMT\nD = gmtselect(\"@ship_15.txt\", region=(246,247,20,21));\nplot(D, marker=:point, show=true)\n\n\n\n\n\n\n\n\nTo return all the points except those inside that square, use:\n    D = gmtselect(\"@ship_15.txt\", region=(246,247,20,21), reverse=:r)\nTo extract the subset of data set that is within 300 km of any of the points in pts.txt but more than 100 km away from the lines in lines.txt, run\n    D = gmtselect(lonlat, colinfo=:g, dist2pts=(pts=\"pts.txt\", dist=\"300k\"),\n                  dist2lines=(lines=\"lines.txt\", dist=\"100k\"), reverse=:l)\nHere, you must specify colinfo=:g so the program knows you are processing geographical data.\nTo keep all points in data.txt within the specified region, except the points on land (as determined by the high-resolution coastlines), use\n    D = gmtselect(\"data.txt\", region=(246,247,20,21), res=:high, mask=(:k,:s))\nTo return all points in quakes.txt that are inside or on the spherical polygon lonlatpath.txt, try\n    D = gmtselect(\"quakes.txt\", polygon=\"lonlatpath.txt\", colinfo=:g)\nTo return all points in stations.txt that are within 5 cm of the point in origin.txt for a certain projection, try\n    gmtselect(\"stations.txt\", dist2pts=(pts=\"origin.txt\", dist=5), region=(20,50,-10,20), proj=:Merc, figsize=20)\nTo return all points in quakes.txt that are inside the grid topo.nc where the values are nonzero, try\n    D = gmtselect(\"quakes.txt\", gridmask=\"topo.nc\")"
  },
  {
    "objectID": "documentation/modules/gmtselect.html#gshhg-information",
    "href": "documentation/modules/gmtselect.html#gshhg-information",
    "title": "gmtselect",
    "section": "GSHHG Information",
    "text": "GSHHG Information\nThe coastline database is GSHHG (formerly GSHHS) which is compiled from three sources: World Vector Shorelines (WVS, not including Antarctica), CIA World Data Bank II (WDBII), and Atlas of the Cryosphere (AC, for Antarctica only). Apart from Antarctica, all level-1 polygons (ocean-land boundary) are derived from the more accurate WVS while all higher level polygons (level 2-4, representing land/lake, lake/island-in-lake, and island-in-lake/lake-in-island-in-lake boundaries) are taken from WDBII. The Antarctica coastlines come in two flavors: ice-front or grounding line, selectable via the area option. Much processing has taken place to convert WVS, WDBII, and AC data into usable form for GMT: assembling closed polygons from line segments, checking for duplicates, and correcting for crossings between polygons. The area of each polygon has been determined so that the user may choose not to draw features smaller than a minimum area (see area); one may also limit the highest hierarchical level of polygons to be included (4 is the maximum). The 4 lower-resolution databases were derived from the full resolution database using the Douglas-Peucker line-simplification algorithm. The classification of rivers and borders follow that of the WDBII. See The Global Self-consistent, Hierarchical, High-resolution Geography Database (GSHHG) for further details."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#insideoutside-status",
    "href": "documentation/modules/gmtselect.html#insideoutside-status",
    "title": "gmtselect",
    "section": "Inside/outside Status",
    "text": "Inside/outside Status\nTo determine if a point is inside, outside, or exactly on the boundary of a polygon we need to balance the complexity (and execution time) of the algorithm with the type of data and shape of the polygons. For any Cartesian data we use a non-zero winding algorithm, which is quite fast. For geographic data we will also use this algorithm as long as (1) the polygons do not include a geographic pole, and (2) the longitude extent of the polygons is less than 360. If this is the situation we also carefully adjust the test point longitude for any 360 degree offsets, if appropriate. Otherwise, we employ a full spherical ray-shooting method to determine a points status."
  },
  {
    "objectID": "documentation/modules/gmtselect.html#source-code",
    "href": "documentation/modules/gmtselect.html#source-code",
    "title": "gmtselect",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtselect(cmd0::String; ...) - gmtselect.jl:63\ngmtselect(; ...) - gmtselect.jl:63\ngmtselect(arg1; kw...) - gmtselect.jl:92\ngmtselect(cmd0::String, arg1, arg2, arg3, arg4; kwargs...) - gmtselect.jl:63\ngmtselect(cmd0::String, arg1, arg2, arg3; ...) - gmtselect.jl:63\ngmtselect(cmd0::String, arg1, arg2; ...) - gmtselect.jl:63\ngmtselect(cmd0::String, arg1; ...) - gmtselect.jl:63"
  },
  {
    "objectID": "documentation/modules/gmtselect.html#see-also",
    "href": "documentation/modules/gmtselect.html#see-also",
    "title": "gmtselect",
    "section": "See Also",
    "text": "See Also\ngmtconvert, gmtsimplify, gmtspatial, grdlandmask, coast"
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html",
    "href": "documentation/modules/gmtsimplify.html",
    "title": "gmtsimplify",
    "section": "",
    "text": "gmtsimplify(cmd0::String=\"\", arg1=nothing; kwargs...)\nLine reduction using the Douglas-Peucker algorithm"
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#description",
    "href": "documentation/modules/gmtsimplify.html#description",
    "title": "gmtsimplify",
    "section": "Description",
    "text": "Description\nsimplify reads one or more data files and apply the Douglas-Peucker line simplification algorithm. The method recursively subdivides a polygon until a run of points can be replaced by a straight line segment, with no point in that run deviating from the straight line by more than the tolerance. Have a look at this site to get a visual insight on how the algorithm works (https://en.wikipedia.org/wiki/Ramer–Douglas–Peucker_algorithm)"
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#required-arguments",
    "href": "documentation/modules/gmtsimplify.html#required-arguments",
    "title": "gmtsimplify",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\n\n-T or tol or tolerance : – tolerance=tol\nSpecifies the maximum mismatch tolerance in the user units. If the data are not Cartesian then append a suitable distance unit (see [Units])."
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#optional-arguments",
    "href": "documentation/modules/gmtsimplify.html#optional-arguments",
    "title": "gmtsimplify",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#examples",
    "href": "documentation/modules/gmtsimplify.html#examples",
    "title": "gmtsimplify",
    "section": "Examples",
    "text": "Examples\nTo reduce the remote high-resolution GSHHG polygon for Australia down to a tolerance of 500 km, use:\n\nusing GMT\nD = gmtsimplify(\"@GSHHS_h_Australia.txt\", tolerance=\"100k\")\nplot(\"@GSHHS_h_Australia.txt\", plot=(data=D, lc=:red), show=true)\n\n\n\n\n\n\n\n\nTo reduce the Cartesian lines xylines.txt using a tolerance of 0.45 and write the reduced lines to file new_xylines.txt, run:\n    D = gmtsimplify(\"xylines.txt\", tol=0.45)"
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#notes",
    "href": "documentation/modules/gmtsimplify.html#notes",
    "title": "gmtsimplify",
    "section": "Notes",
    "text": "Notes\nThere is a slight difference in how simplify processes lines versus closed polygons. Segments that are explicitly closed will be considered polygons, otherwise we treat them as line segments. Hence, segments recognized as polygons may reduce to a 3-point polygon with no area; these are suppressed from the output."
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#bugs",
    "href": "documentation/modules/gmtsimplify.html#bugs",
    "title": "gmtsimplify",
    "section": "Bugs",
    "text": "Bugs\nOne known issue with the Douglas-Peucker has to do with crossovers. Specifically, it cannot be guaranteed that the reduced line does not cross itself. Depending on how many lines you are considering it is also possible that reduced lines may intersect other reduced lines. Finally, the current implementation only does Flat Earth calculations even if you specify spherical; simplify will issue a warning and reset the calculation mode to Flat Earth."
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#references",
    "href": "documentation/modules/gmtsimplify.html#references",
    "title": "gmtsimplify",
    "section": "References",
    "text": "References\nDouglas, D. H., and T. K. Peucker, Algorithms for the reduction of the number of points required to represent a digitized line of its caricature, Can. Cartogr., 10, 112-122, 1973.\nThis implementation of the algorithm has been kindly provided by Dr. Gary J. Robinson, Department of Meteorology, University of Reading, Reading, UK; his subroutine forms the basis for this program."
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#source-code",
    "href": "documentation/modules/gmtsimplify.html#source-code",
    "title": "gmtsimplify",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtsimplify(cmd0::String; kwargs...) - gmtsimplify.jl:28\ngmtsimplify(arg1; kwargs...) - gmtsimplify.jl:29"
  },
  {
    "objectID": "documentation/modules/gmtsimplify.html#see-also",
    "href": "documentation/modules/gmtsimplify.html#see-also",
    "title": "gmtsimplify",
    "section": "See Also",
    "text": "See Also\ngmtconnect, gmtconvert, gmtselect"
  },
  {
    "objectID": "documentation/modules/gmtsplit.html",
    "href": "documentation/modules/gmtsplit.html",
    "title": "gmtsplit",
    "section": "",
    "text": "gmtsplit(cmd0::String=\"\", arg1=nothing; kwargs...)\nSplit xyz[dh] data tables into individual segments"
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#description",
    "href": "documentation/modules/gmtsplit.html#description",
    "title": "gmtsplit",
    "section": "Description",
    "text": "Description\ngmtsplit reads a series of (x,y[,z]) records [or optionally (x,y[,z],d,h); see |-S| option] from standard input [or xy[z][dh]file] and splits this into separate lists of (x,y[,z]) series, such that each series has a nearly constant azimuth through the x,y plane. There are options to choose only those series which have a certain orientation, to set a minimum length for series, and to high- or low-pass filter the z values and/or the x,y values. gmtsplit is a useful filter between data extraction and wiggle plotting, and can also be used to divide a large x,y[,z] dataset into segments."
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#required-arguments",
    "href": "documentation/modules/gmtsplit.html#required-arguments",
    "title": "gmtsplit",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nData from file or a in-memory array with 2, 3, or 5 columns holding (x,y,[z[,d,h]]) data values. To use (x,y,z,d,h) input, sorted so that d is non-decreasing, specify the dist_head option; default expects (x,y,z) only."
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#optional-arguments",
    "href": "documentation/modules/gmtsplit.html#optional-arguments",
    "title": "gmtsplit",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or azim_tol : – azim_tol=(azimuth,tolerance)\nWrite out only those segments which are within ±tolerance degrees of azimuth in heading,measured clockwise from North, [0 - 360]. [Default writes all acceptable segments, regardless of orientation].\nC or course_change : – course_change=ang\nTerminate a segment when a course change exceeding ang degrees of heading is detected [ignore course changes].\nD or min_dist or min_distance : – min_dist=distance Do not write a segment out unless it is at least distance units long [0].\nF or filter : – filter=(xy_filter,z_filter) Filter the z values and/or the x,y values, assuming these are functions of d coordinate. xy_filter and z_filter are filter widths in distance units. If a filter width is zero, the filtering is not performed. The absolute value of the width is the full width of a cosine-arch low-pass filter. If the width is positive, the data are low-pass filtered; if negative, the data are high-pass filtered by subtracting the low-pass value from the observed value. If z_filter is non-zero, the entire series of input z values is filtered before any segmentation is performed, so that the only edge effects in the filtering will happen at the beginning and end of the complete data stream. If xy_filter is non-zero, the data is first divided into segments and then the x,y values of each segment are filtered separately. This may introduce edge effects at the ends of each segment, but prevents a low-pass x,y filter from rounding off the corners of track segments. [Default = no filtering].\n\nN or multifile or multi : – multifile=true | multifile=“template”\nWrite each segment to a separate output file. Default returns data in a GMTdataset. Optionally append a format template for the individual file names; this template must contain a C format specifier that can format an integer argument (the running segment number across all tables); this is usually %d but could be %08d which gives leading zeros, etc. [Default is gmtsplit_segment_%d.{txt|bin}, depending on binary_out]. Alternatively, give a template with two C format specifiers and we will supply the table number and the segment number within the table to build the file name.\n\nQ or fields : – fields=:flags\nSpecify your desired output using any combination of xyzdh, in any order. Do not space between the letters. Use lower case. Default is fields=xyzdh (fields=xydh if only 2 input columns).\nS or dist_head : – dist_head=true\nBoth d and h are supplied. In this case, input contains x,y,z,d,h. [Default expects (x,y,z) input, and d,h are computed from delta x, delta y. Use colinfo=:g to indicate map data; then x,y are assumed to be in degrees of longitude, latitude, distances are considered to be in kilometers, and angles are actually azimuths. Otherwise, distances are Cartesian in same units as x,y and angles are counter-clockwise from horizontal].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\n\n.. |Add_-g| replace:: Do not let a segment have a gap exceeding gap; instead, split it into two segments. [Default ignores gaps]. - h or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\n\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#distance-calculations",
    "href": "documentation/modules/gmtsplit.html#distance-calculations",
    "title": "gmtsplit",
    "section": "Distance Calculations",
    "text": "Distance Calculations\nThe type of input data is dictated by the colinfo option. If colinfo=:g is given then x,y are in degrees of longitude, latitude, distances are in kilometers, and angles are azimuths. Otherwise, distances are Cartesian in same units as x,y and angles are counter-clockwise from horizontal."
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#examples",
    "href": "documentation/modules/gmtsplit.html#examples",
    "title": "gmtsplit",
    "section": "Examples",
    "text": "Examples\nSuppose you want to make a wiggle plot of magnetic anomalies on segments oriented approximately east-west from a NCEI-supplied cruise called JA020015 in the region region=(300,315,12,20). You want to use a 100 km low-pass filter to smooth the tracks and a 500km high-pass filter to detrend the magnetic anomalies. Try this:\n    D = gmt(\"mgd77list JA020015 -R300/315/12/20 -Flon,lat,mag,dist,azim\");\n    D = split(D, azim_tol=(90,15), filter=(100,-500), min_dist=100, disthead=true, colinfo=:g);\n    wiggle(region=(300,315,12,20), proj=:Merc, scale=1.5, title=\"JA020015\", track=1,\n           pen=0.75, fill=:gray, ampscale=200, show=true)\nMGD-77 users: For this application we recommend that you extract dist,azim from mgd77list &lt;supplements/mgd77/mgd77list&gt; rather than have gmtsplit compute them separately.\nSuppose you have been given a binary, double-precision file containing lat, lon, gravity values from a survey, and you want to split it into profiles named survey_###.txt (when gap exceeds 100 km). Try this:\n    gmtsplit(\"survey.bin\", multi=\"survey_%03d.txt\", gap=\"d100k\", min_dist=100,\n             yx=true, colinfo=:g, binary_in=\"3d\")"
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#source-code",
    "href": "documentation/modules/gmtsplit.html#source-code",
    "title": "gmtsplit",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngmtsplit(cmd0::String; kwargs...) - splitxyz.jl:52\ngmtsplit(arg1; kwargs...) - splitxyz.jl:53"
  },
  {
    "objectID": "documentation/modules/gmtsplit.html#see-also",
    "href": "documentation/modules/gmtsplit.html#see-also",
    "title": "gmtsplit",
    "section": "See Also",
    "text": "See Also\nfilter1d, wiggle"
  },
  {
    "objectID": "documentation/modules/gravfft.html",
    "href": "documentation/modules/gravfft.html",
    "title": "gravfft",
    "section": "",
    "text": "gravfft(cmd0::String=\"\", arg1=nothing, kwargs...)\nSpectral calculations of gravity, isostasy, admittance, and coherence for grids."
  },
  {
    "objectID": "documentation/modules/gravfft.html#synopsis",
    "href": "documentation/modules/gravfft.html#synopsis",
    "title": "gravfft",
    "section": "Synopsis",
    "text": "Synopsis"
  },
  {
    "objectID": "documentation/modules/gravfft.html#description",
    "href": "documentation/modules/gravfft.html#description",
    "title": "gravfft",
    "section": "Description",
    "text": "Description\ngravfft can be used into three main modes;\n\nMode 1: Simply compute the geopotential due to the surface given in the topo.grd file. Requires a density contrast (density) and possibly a different observation level(level). It will take the 2-D forward FFT of the grid and use the full Parker’s method up to the chosen terms.\nMode 2: Compute the geopotential response due to flexure of the topography file. It will take the 2-D forward FFT of the grid and use the full Parker’s method applied to the chosen isostatic model. The available models are the “loading from top”, or elastic plate model, and the “loading from below” which accounts for the plate’s response to a sub-surface load (appropriate for hot spot modeling). In both cases, the model parameters are set with topo_load and moho_depth options.\nMode 3: compute the admittance or coherence between two grids. The output is the average in the radial direction. Optionally, the model admittance may also be calculated. Given the number of choices this program offers, is difficult to state what are options and what are required arguments. It depends on what you are doing; see the examples for further guidance."
  },
  {
    "objectID": "documentation/modules/gravfft.html#required-argument",
    "href": "documentation/modules/gravfft.html#required-argument",
    "title": "gravfft",
    "section": "Required Argument",
    "text": "Required Argument\nOne or two 2-D gridded data sets to be processed."
  },
  {
    "objectID": "documentation/modules/gravfft.html#optional-arguments",
    "href": "documentation/modules/gravfft.html#optional-arguments",
    "title": "gravfft",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or tadmitt : – tadmitt=(n=?,wavelength=?,mean_depth=?, from_top=true, from_below=true, wavelengths=true)\nCompute only the theoretical admittance curves of the selected model and exit. n and wavelength are used to compute (n * wavelength) the total profile length in meters. mean_depth is the mean water depth. Append information if model is from_top or from_below and optionally wavelengths=true to write wavelength instead of frequency.\nD or density : – density=? | density=rhogrid\nSets density contrast across surface. Used, for example, to compute the gravity attraction of the water layer that can later be combined with the free-air anomaly to get the Bouguer anomaly. In this case do not use topo_load. It also implicitly sets dimentions=“+h”. Alternatively, specify a co-registered grid, rhogrid, either in the form of a file name or a GMTgrid objec, with density contrasts if a variable density contrast is required. Note: Any NaNs found in the density grid will be replaced with the minimum density found.\nE or nterms : – nterms=n\nNumber of terms used in Parker expansion (limit is 10, otherwise terms depending on n will blow out the program) [Default = 3].\nF or field : – field=(faa=true, slab=true, far_field=true, bouguer=true, geoid=true, vgg=true, east=true, north=true)\nSpecify desired geopotential field: compute geoid rather than gravity\n\nfaa = Free-air anomalies (mGal) [Default]. Add slab=true to add in the slab implied when removing the mean value from the topography. This requires zero topography to mean no mass anomaly. Alternatively, to force the far-field to be exactly zero (i.e., the corner nodes of the grid), select far_field=true instead.\nbouguer = Bouguer gravity anomalies (mGal).\ngeoid = Geoid anomalies (m).\nvgg = Vertical Gravity Gradient (VGG; 1 Eotvos = 0.1 mGal/km).\neast = East deflections of the vertical (micro-radian).\nnorth = North deflections of the vertical (micro-radian).\n\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nI or admitt : – admitt=(wavelengths=true, km=true, coherence=true, tadmitt=true, elastic=true)\nUse ingrid2 and ingrid1 (a grid with topography/bathymetry) to estimate admittance or coherence and rturn it in a GMTdataset (outgrid ignored if set). This grid should contain gravity or geoid for the same region of ingrid1. Default computes admittance. Output contains 3 or 4 columns. Frequency (wavelength), admittance (coherence) one sigma error bar and, optionally, a theoretical admittance. Use one to three from: wavelengths, km,     tadmitt, coherence, elastic, wavelengths writes wavelength instead of wavenumber, km selects km for wavelength unit [m], coherence computes coherence instead of admittance, tadmitt writes a fourth column with “loading from below” theoretical admittance, and elastic writes a fourth column with “elastic plate” theoretical admittance.\nN or dimensions or inquire : – dimensions=[a|f|m|r|s|nx/ny][+a|d|h|l][+e|n|m][+t_width_][+v][+w[suffix]][+z[p]]\nChoose or inquire about suitable grid dimensions for FFT and set optional parameters. Control the FFT dimension via these directives:\n\na - Let the FFT select dimensions yielding the most accurate result.\nf - Force the FFT to use the actual dimensions of the data.\nm - Let the FFT select dimensions using the least work memory.\nr - Let the FFT select dimensions yielding the most rapid calculation.\ns - Just present a list of optional dimensions, then exit. Without a directive we expect N_nx/ny_ which will do FFT on array size nx/ny (must be &gt;= grid file size). Default chooses dimensions &gt;= data which optimize speed and accuracy of FFT. If FFT dimensions &gt; grid file dimensions, data are extended and tapered to zero.\nControl detrending of data by appending a modifier for removing a linear trend. Consult module documentation for the default action:\n+d - Detrend data, i.e. remove best-fitting linear trend.\n+a - Only remove the mean value.\n+h - Only remove the mid value, i.e. 0.5 * (max + min).\n+l - Leave data alone. Control extension and tapering of data by appending a modifier to control how the extension and tapering are to be performed:\n+e - Extend the grid by imposing edge-point symmetry [Default].\n+m - Extends the grid by imposing edge mirror symmetry.\n+n - Turns off data extension. Tapering is performed from the data edge to the FFT grid edge [100%]. Change this percentage via modifier +t_width_. When +n is in effect, the tapering is applied instead to the data margins as no extension is available [0%].\nControl messages being reported:\n+v - Report suitable dimensions during processing. Control writing of temporary results: For detailed investigation you can write the intermediate grid being passed to the forward FFT; this is likely to have been detrended, extended by point-symmetry along all edges, and tapered. Use these modifiers to ave such grids:\n+w - Set the suffix from which output file name(s) will be created (i.e., ingrid_prefix.ext) [Default is “tapered”], where ext is your file extension\n+z - Save the complex grid produced by the forward FFT. By default we write the real and imaginary components to ingrid_real.ext and ingrid_imag.ext. Append p to instead use the polar form of magnitude and phase to files ingrid_mag.ext and ingrid_phase.ext.\n\nQ or flex_topo : – flex_topo=true\nReturn/saves out a grid with the flexural topography (with z positive up) whose average depth was set by moho_depth=zm and model parameters by topo_load. That is the “gravimetric Moho”. flex_topo implicitly sets -N+h.\nS or :S :subplate : – :S :subplate=true\nComputes predicted gravity or geoid grid due to a subplate load produced by the current bathymetry and the theoretical model. The necessary parameters are set within topo_load and moho_depth options. The number of powers in Parker expansion is restricted to 1. See an example further down.\nT or topo_load : – topo_load=(ethickness=?, rho_load=?, rho_mantle=?, rho_infill=?, moho=true)\nCompute the isostatic compensation from the topography load (input grid file) on an elastic plate of thickness ethickness. Also append densities for load, mantle, water and infill in SI units. If rho_infill is not provided it defaults to rho_load. Give average mantle depth via moho_depth. If the elastic thickness is &gt; 1e10 it will be interpreted as the flexural rigidity (by default it is computed from ethickness and Young modulus). Optionally, moho=true to write a grid with the Moho’s geopotential effect (see geopotential) from model selected by topo_load. If ethickness = 0 then the Airy response is returned. moho=true implicitly sets -N+h.\nW or level : – level=wd[k]\nSet the observation height relative to topography in meters [0]. Append k to indicate km. In this later case, the whole option must ofc be a string.\nZ or moho_depth : – moho_depth=zm[/zl]\nMoho [and swell] average compensation depths (in meters positive down – the depth). For the “load from top” model you only have to provide zm, but for the “loading from below” don’t forget to supply also zl.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at"
  },
  {
    "objectID": "documentation/modules/gravfft.html#grid-distance-units",
    "href": "documentation/modules/gravfft.html#grid-distance-units",
    "title": "gravfft",
    "section": "Grid Distance Units",
    "text": "Grid Distance Units\nIf the grid does not have meter as the horizontal unit, append +u unit to the input file name to convert from the specified unit to meter. If your grid is geographic, convert distances to meters by supplying colinfo instead."
  },
  {
    "objectID": "documentation/modules/gravfft.html#considerations",
    "href": "documentation/modules/gravfft.html#considerations",
    "title": "gravfft",
    "section": "Considerations",
    "text": "Considerations\nnetCDF COARDS grids will automatically be recognized as geographic. For other grids geographical grids were you want to convert degrees into meters, select colinfo. If the data are close to either pole, you should consider projecting the grid file onto a rectangular coordinate system using grdproject."
  },
  {
    "objectID": "documentation/modules/gravfft.html#handling-of-grids-with-nans",
    "href": "documentation/modules/gravfft.html#handling-of-grids-with-nans",
    "title": "gravfft",
    "section": "Handling of Grids with NaNs",
    "text": "Handling of Grids with NaNs\nSince we cannot take FFTs of 2-D grids that contain NaNs, we perform simple substitutions. If any of the input grids contain NaNs they will be replaced with zeros. In contrast, if density passes a grid with density contrasts then we replace any NaNs with the minimum density in the grid."
  },
  {
    "objectID": "documentation/modules/gravfft.html#data-detrending",
    "href": "documentation/modules/gravfft.html#data-detrending",
    "title": "gravfft",
    "section": "Data Detrending",
    "text": "Data Detrending\nThe default detrending mode follows Parker [1972] and removes the mid-value (+h). Consult and use inquire to select other modes."
  },
  {
    "objectID": "documentation/modules/gravfft.html#plate-flexure",
    "href": "documentation/modules/gravfft.html#plate-flexure",
    "title": "gravfft",
    "section": "Plate Flexure",
    "text": "Plate Flexure\nThe FFT solution to elastic plate flexure requires the infill density to equal the load density. This is typically only true directly beneath the load; beyond the load the infill tends to be lower-density sediments or even water (or air). Wessel [2001] proposed an approximation that allows for the specification of an infill density different from the load density while still allowing for an FFT solution. Basically, the plate flexure is solved for using the infill density as the effective load density but the amplitudes are adjusted by a factor A = sqrt ((rm - ri)/(rm - rl)), which is the theoretical difference in amplitude due to a point load using the two different load densities. The approximation is very good but breaks down for large loads on weak plates, a fairy uncommon situation."
  },
  {
    "objectID": "documentation/modules/gravfft.html#examples",
    "href": "documentation/modules/gravfft.html#examples",
    "title": "gravfft",
    "section": "Examples",
    "text": "Examples\n\nusing GMT, FFTW\n\nG = grdcut(\"@earth_relief_02m\", region=(-12.5,-10,35.5,37.5));\nG2 = gravfft(G, density=1700, field=(faa=6, slab=4), f=:g);\nimshow(G2, colorbar=true)\n\n\n\n\n\n\n\n\nOther hypothetic examples.\nTo compute the effect of the water layer above the bat.grd bathymetry using 2700 and 1035 for the densities of crust and water and returning the result on Gwater (computing up to the fourth power of bathymetry in Parker expansion):\n  Gwater = gravfft(\"bat.grd\", density=1665, nterms=4);\nNow subtract it from your free-air anomaly faa.grd and you will get the Bouguer anomaly. You may wonder why we are subtracting and not adding. After all the Bouguer anomaly pretends to correct the mass deficiency presented by the water layer, so we should add because water is less dense than the rocks below. The answer relies on the way gravity effects are computed by the Parker’s method and practical aspects of using the FFT.\n  Gbouguer = Gfaa - Gwater;\nWant an MBA anomaly? Well compute the crust mantle contribution and add it to the sea-bottom anomaly. Assuming a 6 km thick crust of density 2700 and a mantle with 3300 density we could repeat the command used to compute the water layer anomaly, using 600 (3300 - 2700) as the density contrast. But we now have a problem because we need to know the mean Moho depth. That is when the scale/offset that can be appended to the grid’s name comes in hand. Notice that we didn’t need to do that before because mean water depth was computed directly from data (notice also the negative sign of the offset due to the fact that z is positive up):\n  Gmoho = gravfft(\"bat.grd=+o-6000\", density=600);\nNow, subtract it from the Bouguer to obtain the MBA anomaly. That is:\n  Gmba = Gbouguer - Gmoho;\nTo compute the Moho gravity effect of an elastic plate bat.grd with Te = 7 km, density of 2700, over a mantle of density 3300, at an average depth of 9 km\n  Gelastic = gravfft(\"bat.grd\", topo_load=\"7000/2700/3300/1035+m\", moho_depth=9000);\nIf you add now the sea-bottom and Moho’s effects, you will get the full gravity response of your isostatic model. We will use here only the first term in Parker expansion.\n  Gwater = gravfft(\"bat.grd\", density=1665, nterms=1);\n  Gelastic = gravfft(\"bat.grd\", topo_load=\"7000/2700/3300/1035+m\", moho_depth=9000, nterms=1);\n  Gmodel = Gwater + Gelastic;\nThe same result can be obtained directly by the next command. However, PAY ATTENTION to the following. I don’t yet know if it’s because of a bug or due to some limitation, but the fact is that the following and the previous commands only give the same result if nterms=1 is used. For higher powers of bathymetry in Parker expansion, only the above example seams to give the correct result.\n  Gmodel = gravfft(\"bat.grd\", topo_load=\"7000/2700/3300/1035\", moho_depth=9000, nterms=1);\nAnd what would be the geoid anomaly produced by a load at 50 km depth, below a region whose bathymetry is given by bat.grd, a Moho at 9 km depth and the same densities as before?\n  Gswell_geoid = gravfft(\"topo.grd\", topo_load=(7000,2700,3300,1035), field=:geoid,\n                        moho_depth=(9000,50000), subplate=true, nterms=1);\nTo compute the admittance between the topo.grd bathymetry and faa.grd free-air anomaly grid using the elastic plate model of a crust of 6 km mean thickness with 10 km effective elastic thickness in a region of 3 km mean water depth:\nDadmitt = gravfft(Gtopo, Gfaa, admitt=:elastic, topo_load=(10000,2700,3300,1035), moho_depth=9000);\nTo compute the admittance between the topo.grd bathymetry and geoid.grd geoid grid with the “loading from below” (LFB) model with the same as above and sub-surface load at 40 km, but assuming now the grids are in geographic and we want wavelengths instead of frequency:\nDadmitt = gravfft(Gtopo, Ggeoid, admitt=(below=true,wavelengths=true),\n                  topo_load=(10000,2700,3300,1035), moho_depth=(9000,40000), colinfo=:g);\nTo compute the gravity theoretical admittance of a LFB along a 2000 km long profile using the same parameters as above\nDadmitt = gravfft(tadmitt=\"400/5000/3000/b\", topo_load=(10000,2700,3300,1035), moho_depth=(9000,40000));"
  },
  {
    "objectID": "documentation/modules/gravfft.html#references",
    "href": "documentation/modules/gravfft.html#references",
    "title": "gravfft",
    "section": "References",
    "text": "References\nLuis, J.F. and M.C. Neves. 2006, The isostatic compensation of the Azores Plateau: a 3D admittance and coherence analysis. J. Geothermal Volc. Res. Volume 156, Issues 1-2, Pages 10–22, https://doi.org/10.1016/j.jvolgeores.2006.03.010 &lt;https://doi.org/10.1016/j.jvolgeores.2006.03.010&gt;_\nParker, R. L., 1972, The rapid calculation of potential anomalies, Geophys. J., 31, 447–455.\nWessel. P., 2001, Global distribution of seamounts inferred from gridded Geosat/ERS-1 altimetry, J. Geophys. Res., 106(B9), 19,431–19,441, https://doi.org/10.1029/2000JB000083 &lt;https://doi.org/10.1029/2000JB000083&gt;_"
  },
  {
    "objectID": "documentation/modules/gravfft.html#source-code",
    "href": "documentation/modules/gravfft.html#source-code",
    "title": "gravfft",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngravfft(cmd0::String; ...) - gravfft.jl:52\ngravfft(; ...) - gravfft.jl:52\ngravfft(cmd0::String, arg1, arg2; kwargs...) - gravfft.jl:52\ngravfft(cmd0::String, arg1; ...) - gravfft.jl:52\ngravfft(arg1, arg2; kw...) - gravfft.jl:51\ngravfft(arg1; ...) - gravfft.jl:51"
  },
  {
    "objectID": "documentation/modules/gravfft.html#see-also",
    "href": "documentation/modules/gravfft.html#see-also",
    "title": "gravfft",
    "section": "See Also",
    "text": "See Also\nparkergrav, grdfft, grdproject"
  },
  {
    "objectID": "documentation/modules/gravprisms.html",
    "href": "documentation/modules/gravprisms.html",
    "title": "gravprisms",
    "section": "",
    "text": "gravprisms(fname::String=\"\", arg1=nothing, kwargs...)"
  },
  {
    "objectID": "documentation/modules/gravprisms.html#description",
    "href": "documentation/modules/gravprisms.html#description",
    "title": "gravprisms",
    "section": "Description",
    "text": "Description\nCompute the geopotential field over vertically oriented, rectangular prisms. We either read the multi-segment table from file (or standard input), which may contain up to 7 columns: The first four are x y z_low z_high, i.e., the center x, y coordinates and the vertical range of the prism from z_low to z_high, while the next two columns hold the dimensions dx dy of each prism (see xy_sizes if all prisms have the same x- and y-dimensions). Last column may contain individual prism densities (but will be overridden by fixed or variable density contrasts if given via density). Alternatively, we can use prisms to create the prisms needed to approximate the entire feature (topography) or just the volume between two surfaces (one of which may be a constant) that define a layer (set via base and top). If a variable density model (radial_rho) is selected then each vertical prism will be broken into constant-density, stacked sub-prisms using a prescribed vertical increment dz, otherwise single tall prisms are created with constant or spatially variable densities (density). We can compute anomalies on an equidistant grid (by specifying a new grid with region and inc** or provide an observation grid with desired elevations) or at arbitrary output points specified via track. Choose between free-air anomalies, vertical gravity gradient anomalies, or geoid anomalies. Options are available to control axes units and direction.\n\nThree density models modeled by prisms for a truncated Gaussian seamount via C: (left) Constant density (D), (middle) vertically-averaged density varying radially (D), and (right) density varies with r and z (H), requiring a stack of prisms."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#required-arguments",
    "href": "documentation/modules/gravprisms.html#required-arguments",
    "title": "gravprisms",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nfname or arg1 : – fname=file_name | arg1=matrix|D\nThe file name or a matrix/GMTdatset describing the prisms with record format x y z_lo z_hi [ dx dy ] [ rho ], where the optional items are controlled by options xy_sizes and density, respectively. Density contrasts can be given in \\(kg/m^3\\) or \\(g/cm^3\\). Note: If prisms is used then no table will be read.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#optional-arguments",
    "href": "documentation/modules/gravprisms.html#optional-arguments",
    "title": "gravprisms",
    "section": "Optional Arguments",
    "text": "Optional Arguments\nC or prisms : – prisms=(quit=true, save=file, dz=?)\nCreate prisms for the entire feature given by topography=height, or just for the layer between the two surfaces specified via base=base and top=top. For layers, either base or top may be a constant rather than a grid. If only height is given then we assume we will approximate the entire feature from base = 0 to height. If radial_rho is used to compute variable density contrasts then we must split each prism into a stack of sub-prisms with individual densities. This is controlled via these modifiers:\n- `quit` - Quit execution once that *file* set with `save` has been saved, i.e., no geopotential calculations\n  will take place.\n- `save` - Append *file* to save the prisms to a table.\n- `dz` - Append *dz* for the heights of these sub-prisms (the first and last sub-prisms in the stack may have\n  their heights adjusted to match the limits of the surfaces). Without **radial_rho** we only create a single\n  uniform-density prism, but those prisms may have spatially varying densities via a grid given in **density**.\nD or density : – density=fname[+c]|grid\nSets a fixed density contrast that overrides any individual prism settings in the prisms file, in \\(kg/m^3\\) or \\(g/cm^3\\). Append +c to instead subtract this density from the individual prism densities. Alternatively, give name of an input grid with spatially varying, vertically-averaged prism densities. This requires prisms and the grid must be co-registered with the grid provided by topography (or base and top). Note: If radial_rho is used then a fixed density may be set via this option provided its modifier +c is set. We will then compute density contrasts in the seamount relative to the fixed density (such as density of seawater for underwater seamounts).\nE or xy_sizes or dxdy : – xy_sizes=d | xy_sizes=(dx,dy)\nIf all prisms in table have constant x/y-dimensions then they can be set here. In that case table must only contain the centers of each prism and the z range (and optionally density; see density). If only dx is given then we set dy = dx. Note: For geographic coordinates the dx dimension is in geographic longitude increment and hence the physical width of the prism will decrease with latitude if dx stays numerically the same.\nF or component : – component=(faa=true, geoid=true, vgrad=true)\nSpecify desired gravitational field component. Choose between faa (free-air anomaly) [Default], geoid (geoid; optionally append average latitude for normal gravity reference value [Default is mid-grid (or mid-profile if track is used)]) or vgrad (vertical gravity gradient).\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\n\nH or radial_rho : – radial_rho=(height=?, lowhigh=(rho_l, rho_h), boost=?, pressure_rho=?, power=?)\nSet reference seamount parameters for an ad-hoc variable radial density function with depth. Give the rho_l and rho_h seamount densities as lowhigh=(rho_l, rho_h) in :math:\\mbox{kg/m}^3 or :math:\\mbox{g/cm}^3 and the fixed reference height in meters. The last three (optional) choices can be used for further changes:\n- *boost* - Simulate the higher starting densities in truncated guyots. You can *boost* the seamount\n  height by this factor [1]. Requires **topography** to know the full height of the seamount.\n- *pressure_rho* - Change the water-pressure-driven flank *densify* gradient over the\n  full reference height [0].\n- *power* - Change variable density profile exponent *power* [Default is 1, i.e., a linear change].\n\nSee grdseamount for more details.\nL or base : – base=fname|grid\nGive a file name or a GMTgrid of the base surface grid for a layer we wish to approximate with prisms, or give a constant z-level [0].\nM or units : – units=(horizontal=true, vertical=true)\nSets distance units used. Use units=:horizontal to indicate that both horizontal distances are in km [m], and units=:vertical to indicate vertical distances are in km [m]. To set both, use the syntax units=(horizontal=true, vertical=true). If selected, we will internally convert any affected distance provided by data input or command line options to meters. Note: Any output will retain the original units.\nN or track : – track=trackfile | track=matrix|GMTdatset\nSpecifies individual (x, y[, z]) locations where we wish to compute the predicted value. When this option is used there are no grids involved and the output data records are returned as a GMTdataset. If level is not set then track must have 3 columns and we take the z value as our observation level; otherwise a constant level must be set via level. Note: If outfile is used to set an output file we will write the output table to that file instead of returning it.\nS or topography : – topography=fname|grid\nGive name of grid with the full seamount heights, either for making prisms or as required by radial_rho.\nT or top : – top=fname|grid\nGive name of the top surface grid for a layer we wish to approximate with prisms, or give a constant z-level.\n\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\n\n-W or hvar_rho or avedens : – hvar_rho=fname|grid\nGive name of an output grid with spatially varying, vertically-averaged prism densities created by prisms and radial_rho.\nZ or level or reference_level : – level=0\nSet observation level, either as a constant or variable by giving the name of a grid with observation levels. If the latter is used then this grid determines the output grid region as well [0]. Note: the positive z-direction is up.\n\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nGeographic grids (dimensions of longitude, latitude) will be converted to meters via a “Flat Earth” approximation using the current ellipsoid parameters.\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#examples",
    "href": "documentation/modules/gravprisms.html#examples",
    "title": "gravprisms",
    "section": "Examples",
    "text": "Examples\nWe have prepared a set of 2828 prisms that represent a truncated Gaussian seamount of height 6000 m, radius 30 km, with the base at z = 0 m, available in the remote file @prisms.txt. A quick view of the 3-D model can be had via:\n\nusing GMT\n\nplot3d(\"@prisms.txt\", region=(-30, 30, -30, 30, 0, 7000), zsize=3, fill=:gray,\n       S=\"o1q+b\", lt=:faint, view=(200,20), show=true)\n\n\n\n\n\n\n\n\nTo compute the free-air anomalies on a grid over the set of prisms given in _@prisms.txt_, using 1700 \\(kg/m^3\\) as a fixed density contrast, with horizontal distances in km and vertical distances in meters, observed at 7000 m, try:\n\nusing GMT\n\nG = gravprisms(\"@prisms.txt\", region=(-40,40,-40,40), inc=1, units=:horizontal,\n               density=1700, component=:faa, level=7000);\nviz(G, colorbar=true)\n\n\n\n\n\n\n\n\nTo obtain the vertical gravity gradient anomaly along the track given in crossing.txt for the same model, try:\n\nusing GMT\n\nDcross = gmt(\"math -T-30/30/0.1 T 0 MUL =\");\nDvgg = gravprisms(\"@prisms.txt\", track=Dcross, density=1700, units=:horizontal, component=:vgrad, level=7000);\nviz(Dvgg, i=\"0,3\")\n\n\n\n\n\n\n\n\nFinally, redo the gravity calculation but now use the individual prism densities in the prism file and restrict calculations to the same crossing profile, i.e.:\n\nusing GMT\n\nDcross = gmt(\"math -T-30/30/0.1 T 0 MUL =\");\nDfaa = gravprisms(\"@prisms.txt\", track=Dcross, units=:horizontal, component=:faa, level=7000);\nviz(Dfaa, i=\"0,3\")\n\n\n\n\n\n\n\n\nTo build prisms using a variable density grid for an interface crossing the zero level and obtain prisms with the negative of the given density contrast if below zero and the positive density contrast if above zero, try:\ngravprisms(top=\"Flexure_surf.grd\", prisms=(quit=true, save=\"prisms_var.txt\"), density=\"Variable_drho.grd\")"
  },
  {
    "objectID": "documentation/modules/gravprisms.html#geometry-setup",
    "href": "documentation/modules/gravprisms.html#geometry-setup",
    "title": "gravprisms",
    "section": "Geometry Setup",
    "text": "Geometry Setup\nWe operate in a right-handed coordinate system where the positive z-axis is directed upwards. In this scenario, topographic surfaces may be above or below a reference surface (typically the observation level) but the positive direction is always up. Positive geopotential anomalies are thus aligned with the positive source (topographic relief) direction. If your input data are positive down (e.g., depths) then you will need to change the sign."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#grids-straddling-zero-level",
    "href": "documentation/modules/gravprisms.html#grids-straddling-zero-level",
    "title": "gravprisms",
    "section": "Grids Straddling Zero Level",
    "text": "Grids Straddling Zero Level\nWhen creating prisms from grids via prisms, a special case arises when a single surface (set via base or top) straddles zero. This may happen if the surface reflects flexure beneath a load, which has in a negative moat flanked by positive bulges. When such a interface grid is detected we build prisms going from z to zero for negative z and from 0 to z for positive z. As we flip below zero we also change the sign of the given density contrast. You can override this behavior by specifying the opposite layer surface either by a constant or another grid. E.g., if base specifies the base surface you can eliminate prisms exceeding zero via top=0, and by interchanging the base and top arguments you can eliminate prisms below zero. Note: When two surfaces are implied we keep the given density contrast as given."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#note-on-precision",
    "href": "documentation/modules/gravprisms.html#note-on-precision",
    "title": "gravprisms",
    "section": "Note on Precision",
    "text": "Note on Precision\nThe analytical expression for the geoid over a vertical prism (Nagy et al., 2000) is fairly involved and contains 48 terms. Due to various cancellations the end result is more unstable than the simpler expressions for gravity and VGG. Be aware that the result may have less significant digits that you may expect."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#references",
    "href": "documentation/modules/gravprisms.html#references",
    "title": "gravprisms",
    "section": "References",
    "text": "References\nGrant, F. S. and West, G. F., 1965, Interpretation Theory in Applied Geophysics, 583 pp., McGraw-Hill.\nKim, S.-S., and P. Wessel, 2016, New analytic solutions for modeling vertical gravity gradient anomalies, Geochem. Geophys. Geosyst., 17, https://doi.org/10.1002/2016GC006263 &lt;https://doi.org/10.1002/2016GC006263&gt;_.\nNagy D., Papp G., Benedek J., 2000, The gravitational potential and its derivatives for the prism, J. Geod., 74, 552–560, https://doi.org/10.1007/s001900000116 &lt;https://doi.org/10.1007/s001900000116&gt;_."
  },
  {
    "objectID": "documentation/modules/gravprisms.html#source-code",
    "href": "documentation/modules/gravprisms.html#source-code",
    "title": "gravprisms",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngravprisms(cmd0::String; ...) - gravprisms.jl:58\ngravprisms(; ...) - gravprisms.jl:58\ngravprisms(cmd0::String, arg1::GDtype; kwargs...) - gravprisms.jl:58"
  },
  {
    "objectID": "documentation/modules/gravprisms.html#see-also",
    "href": "documentation/modules/gravprisms.html#see-also",
    "title": "gravprisms",
    "section": "See Also",
    "text": "See Also\n[gravmag3d], grdgravmag3d, grdseamount, talwani2d, talwani3d"
  },
  {
    "objectID": "documentation/modules/grd2kml.html",
    "href": "documentation/modules/grd2kml.html",
    "title": "grd2kml",
    "section": "",
    "text": "grd2kml(cmd0::String=\"\", arg1=nothing, kwargs...)\nCreate KML image quadtree from single grid"
  },
  {
    "objectID": "documentation/modules/grd2kml.html#description",
    "href": "documentation/modules/grd2kml.html#description",
    "title": "grd2kml",
    "section": "Description",
    "text": "Description\ngrd2kml reads a 2-D grid and makes a quadtree of PNG or JPG images and KML wrappers for Google Earth using the selected tile size. We downsample the grid depending on the viewing level in the quadtree using a Gaussian filter, but other filters can be selected as well. Optionally, illumination may be added by providing a grid file with intensities in the (-1,+1) range or by giving instructions to derive intensities from the input data grid automatically (see shading). Values outside the (-1,+1) intensity range will be clipped. Map colors are specified via a color palette lookup table. Contour overlays are optional. If plain tiles are selected (i.e., no contours specified) then the PNG tiles are written directly from grdimage. Otherwise, we must first make a PostScript plot that is then converted to raster image via [psconvert]."
  },
  {
    "objectID": "documentation/modules/grd2kml.html#required-arguments",
    "href": "documentation/modules/grd2kml.html#required-arguments",
    "title": "grd2kml",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe 2-D gridded data set.\n\nN or prefix : – prefix=name\nSets a unique name prefixed used for the top-level KML filename and the directory where all referenced KML files and raster images will be written GMT_Quadtree."
  },
  {
    "objectID": "documentation/modules/grd2kml.html#optional-arguments",
    "href": "documentation/modules/grd2kml.html#optional-arguments",
    "title": "grd2kml",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or mode : – mode=:a|:g|s | mode=“a|g|saltitude”\nSelect one of three altitude modes recognized by Google Earth that determines the altitude (in m) of the tile layer: a absolute altitude, g altitude relative to sea surface or ground, s altitude relative to seafloor or ground. To plot the tiles at a fixed altitude, append an altitude altitude (in m). Use 0 to clamp the features to the chosen reference surface. [By default the tiles are clamped to the sea surface or ground].\nC or color or cmap or colorap or colorscale : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name (for grd_z only). Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. In this case color1 etc can be a (r,g,b) triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ) (see [Setting color](../common_features/color.html)). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map.\nE or url : – url=URL\nInstead of hosting all files on your computer, you may prepend a remote site URL. Then, the top-level prefix.kml file will use this URL to find all other files it references. After building completes you must place the entire prefix directory at the remote location pointed to by the URL [local files only]. With this arrangement you can share the prefix.kml with others (say, via email or for download) and users can open the file in their Google Earth and access the remote files from your server as needed.\nF or filter : – filter=type\nSpecifies the filter to use for the downsampling of the grid for more distant viewing. Choose among boxcar, cosine arch, gaussian, or median [Gaussian]. The filter width is set automatically depending on the level.\nH or subpixel : – subpixel=scale\nImprove the quality of rasterization by passing the sub-pixel smoothing scale to psconvert (same as H option in [psconvert]) [no sub-pixel smoothing]. Ignored when |-W| is not used.\nI or shade or shading or intensity : – shade=grid | shade=azim | shade=(azimuth=az, norm=params, auto=true)\nGives the name of a grid with intensities in the (-1,+1) range, or a constant intensity to apply everywhere (affects the ambient light). Alternatively, derive an intensity grid from the input data grid grd_z via a call to grdgradient; use shade=az or shade=(azimuth=az, norm=params) to specify azimuth and intensity arguments for that module or just give shade=true to select the default arguments (azim=-45,nom=:t1). If you want a more specific intensity scenario then run grdgradient separately first.\nL or tilesize : – tilesize=size\nSets the fixed size of the image building blocks. Must be an integer that is radix 2. Typical values are 256 or 512 [256]. Note: For global grids (here meaning 360-degree longitude range), we will select a tilesize of 360 if tilesize is not specified.\nS or extralayers or extra_layers : – extralayers=true | extralayers=extra\nAdd extra layers beyond that necessary to capture the full resolution of the data [none]. This will let GMT interpolate your grid and make more tiles, versus letting Google Earth interpolate the last resolution raster images.\nT or title : –title=XXX\nSets the title of the top-level document (i.e., its description).\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or contours : – contours=“cfile|pen[+sscale/limit]”\nSupply a file with records each holding a contour value and a contour pen. We then overlay the selected contour lines on top of the image [no contours]. Consequently, contours triggers the tile creation via PostScript and thus is slower. If cfile is not a valid file we assume you instead gave a pen and want to draw all the contours implied by the cpt specified in cmap. The contours are overlain via calls to grdcontour. Note: The contour pen width(s) refer to the highest tile level and are reduced by a factor of scale [sqrt(2)] for each lower level. Contours with scaled pen widths &lt; limit [0.1] points are skipped (except for pen widths that exactly equal 0 or “faint”). Use +s to change these values.\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)"
  },
  {
    "objectID": "documentation/modules/grd2kml.html#quadtree-building",
    "href": "documentation/modules/grd2kml.html#quadtree-building",
    "title": "grd2kml",
    "section": "Quadtree building",
    "text": "Quadtree building\nWe extend the input grid vi grdcut to obtain a square dimension that can be repeatedly divided by 2 until we arrive at tiles with the original grid increments. For global grids this mean we extend the grid to a 360 x 360 Cartesian region and an initial grid increment of one degree. This is the first global tile. As the quartering of tiles and halving of grid increment continue we may not end exactly at the original grid spacing but at the largest increment less than or equal to the original increment. For non-global grids, e.g., smaller (local or regional) grids, we extend the domain to a radix-2 multiple of the tilesize times the grid increment. This initial tile is then quartered and the grid increment halved until we reach the original grid increment. Tiles that have all NaNs are not produced. THe tiles are inherently pixel-registered. Thus, if a global grid has gridline-registration then we are down-sampling the extended grid onto a pixel-registered coarser grid. Because these nodes do not coincide with the original nodes we widen the filter width by a factor of sqrt(2). We detect if NaNs are present in any tile and if so produce a transparent PNG tile; otherwise we make an opaque JPG tile."
  },
  {
    "objectID": "documentation/modules/grd2kml.html#contour-overlays",
    "href": "documentation/modules/grd2kml.html#contour-overlays",
    "title": "grd2kml",
    "section": "Contour overlays",
    "text": "Contour overlays\nBecause each tile is a fixed size image (e.g., 512x512 pixels) but the amount of data represented changes by factors of 4 for each new level, we cannot use a constant thickness contour pen for all levels. Thus, the pen you supply must be considered the final pen applied to the highest resolution map overlays. Furthermore, because the dpi here is very small compared to regular GMT plots, it is important to improve the appearance of the contours by using sub-pixel smoothing (subpixel). Both generating PostScript tiles and using sub-pixel smoothing adds considerable processing time over plain tiles."
  },
  {
    "objectID": "documentation/modules/grd2kml.html#notes",
    "href": "documentation/modules/grd2kml.html#notes",
    "title": "grd2kml",
    "section": "Notes",
    "text": "Notes\nThe intensity grid can be created from the data grid using grdgradient and, optionally, modified by grdmath or grdhisteq. Custom intensity grids built with several different illumination angles can be combined with grdmath. For a single illumination angle the automatic illumination can be used instead."
  },
  {
    "objectID": "documentation/modules/grd2kml.html#examples",
    "href": "documentation/modules/grd2kml.html#examples",
    "title": "grd2kml",
    "section": "Examples",
    "text": "Examples\nTo test a quadtree image representation of the coarse topography grid earth_relief_06m, using the optimally determined tile size, auto color, and supplying a suitable title, try::\n    grd2kml(\"@earth_relief_06m\", prefix=\"Earth6m\", title=\"Earth Relief 6x6 arc minutes\", cmap=:earth)\nTo make a quadtree image representation of the large topography grid file ellice_basin.nc, supplying automatic shading based on the topography, and using 512x512 tiles, supplying a suitable title, and using color masking for unmapped area, try::\n    grd2kml(\"ellice_basin.nc\", shade=\"+d\", prefix=\"ellice\", -L512, title=\"Ellice Basin Bathymetry\")"
  },
  {
    "objectID": "documentation/modules/grd2kml.html#source-code",
    "href": "documentation/modules/grd2kml.html#source-code",
    "title": "grd2kml",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrd2kml(cmd0::String; ...) - grd2kml.jl:52\ngrd2kml(; ...) - grd2kml.jl:52\ngrd2kml(arg1; kw...) - grd2kml.jl:68\ngrd2kml(cmd0::String, arg1; kwargs...) - grd2kml.jl:52"
  },
  {
    "objectID": "documentation/modules/grd2kml.html#see-also",
    "href": "documentation/modules/grd2kml.html#see-also",
    "title": "grd2kml",
    "section": "See Also",
    "text": "See Also\ngmt2kml, grdgradient, grdhisteq, grdimage, grdmath, [kml2gmt], [psconvert]"
  },
  {
    "objectID": "documentation/modules/grdclip.html",
    "href": "documentation/modules/grdclip.html",
    "title": "grdclip",
    "section": "",
    "text": "grdclip(cmd0::String=\"\", arg1=nothing; kwargs...)\nClip the range of grid values"
  },
  {
    "objectID": "documentation/modules/grdclip.html#description",
    "href": "documentation/modules/grdclip.html#description",
    "title": "grdclip",
    "section": "Description",
    "text": "Description\nSets values &lt; low to below and/or values &gt; high to above. You can also specify one or more intervals where all values should be set to between, or replace individual values. Such operations are useful when you want all of a continent or an ocean to fall into one color or gray shade in image processing, when clipping of the range of data values is required, or for reclassification of data values. above, below, between, old and new can be any number or even NaN (Not a Number). You must choose at least one of the S? options. Use region to only extract a subset of the ingrid file."
  },
  {
    "objectID": "documentation/modules/grdclip.html#optional-arguments",
    "href": "documentation/modules/grdclip.html#optional-arguments",
    "title": "grdclip",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nSa or above or high : – above=“high/above”, | above=(high,above)\nSet all data[i] &gt; high to above.\nSb or below or low : – below=“low/below”, | below=(low,below)\nSet all data[i] &lt; low to below.\nSi or between : – between=“low/high/between” | between=(low,high,between)\nSet all data[i] &gt;= low and &lt;= high to between. Repeat the option for as many intervals as are needed.\nSr or old or new : – old=“old/new” | old=(old,new)\nSet all data[i] == old to new. This is mostly useful when your data are known to be integer values. Repeat the option for as many replacements as are needed.\nS : – S=“…”\nAny of the above must use the short form S?. The current use of this is when one wants to repeat an S? option, which we cannot do because we can’t repeat the kwargs* key names. Example usage: G2 = grdclip(G, S=\"a5/6 -Sb2/2 -Si3/4/3.5\")\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)"
  },
  {
    "objectID": "documentation/modules/grdclip.html#examples",
    "href": "documentation/modules/grdclip.html#examples",
    "title": "grdclip",
    "section": "Examples",
    "text": "Examples\nTo set all values &gt; 0 to NaN and all values &lt; 0 to 0 in the remote file AFR.nc:\n    Gnew_AFR = grdclip(\"@AFR.nc\", above=(0,NaN), below=(0,0))\nTo reclassify all values in the 25-30 range to 99, those in 35-39 to 55, exchange 17 for 11 and all values &lt; 10 to 0 in file classes.nc, try\n    Gnew_classes = grdclip(\"classes.nc\", S=\"i25/30/99, -Si35/39/55\", old=(17,11), between=(10,0))"
  },
  {
    "objectID": "documentation/modules/grdclip.html#source-code",
    "href": "documentation/modules/grdclip.html#source-code",
    "title": "grdclip",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdclip(cmd0::String; kwargs...) - grdclip.jl:51\ngrdclip(arg1; kwargs...) - grdclip.jl:52"
  },
  {
    "objectID": "documentation/modules/grdclip.html#see-also",
    "href": "documentation/modules/grdclip.html#see-also",
    "title": "grdclip",
    "section": "See Also",
    "text": "See Also\ngrdfill, grdlandmask, grdmask, grdmath, grd2xyz, xyz2grd"
  },
  {
    "objectID": "documentation/modules/grdcut.html",
    "href": "documentation/modules/grdcut.html",
    "title": "grdcut",
    "section": "",
    "text": "grdcut(cmd0::String=\"\", arg1=[], kwargs...)\nExtract subregion from a grid or image"
  },
  {
    "objectID": "documentation/modules/grdcut.html#description",
    "href": "documentation/modules/grdcut.html#description",
    "title": "grdcut",
    "section": "Description",
    "text": "Description\ngrdcut will produce a new outgrid which is a subregion of ingrid. The subregion may be specified with region as in other programs; the specified range must not exceed the range of ingrid (but see extend). If in doubt, run grdinfo to check range. Alternatively, define the subregion indirectly via a range check on the node values or via distances from a fixed point. Finally, you can use proj for oblique projections to determine the corresponding rectangular region setting that will give a subregion that fully covers the oblique domain. Note: If the input grid is actually an image (gray-scale, RGB, or RGBA), then options extend and z_subregion are unavailable, while for multi-layer Geotiff files only options region, circ_subregion are supported, i.e., you can cut out a sub-region only (which we do via gdal_translate if you have multiple bands). Complementary to grdcut there is grdpaste, which will join together two grid files (not images) along a common edge."
  },
  {
    "objectID": "documentation/modules/grdcut.html#required-arguments",
    "href": "documentation/modules/grdcut.html#required-arguments",
    "title": "grdcut",
    "section": "Required Arguments",
    "text": "Required Arguments\ningrid : – A grid file name or a GMTgrid\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/grdcut.html#optional-arguments",
    "href": "documentation/modules/grdcut.html#optional-arguments",
    "title": "grdcut",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nD or dryrun : – dryrun=true | dryrun=“+t”\nA “dry run”: Simply report the region and increment of what would be the extracted grid given the selected options. No grid is created (|-G| is disallowed) and instead we write a single data record with west east south north xinc yinc to standard output. The increments will reflect the input grid unless it is a remote gridded data set without implied resolution. Append +t to instead receive the information as the trailing string “-Rwest/east/south/north -Ixinc/yinc”.\nE or rowlice or colslice : – rowlice=coord | colslice=coord\nWe extract a vertical slice going along the x-column coord or along the y-row coord, depending on the given directive. Note: 1- Input file must be a 3-D netCDF cube, and this option resturns a GMTgrid. 2- coord must exactly match the coordinates given by the cube. We are not interpolating between nodes and only do a clean slice through existing cube nodes. 3- If using the terse GMT syntax (E), then argument must be a string and prefixed with either a x (for extracting a slice along a column) or a y. Example: E=\"x10.5\"\nF or clip or cutline : – cutline=polyg | cutline=(polygon=polyg, crop2cutline=true, invert=true)\nSpecify a multisegment closed polygon file. All grid nodes outside the polygon will be set to NaN. Use the NamedTuple way to say invert=true to invert that and set all nodes inside the polygon to NaN instead. Optionally, add crop2cutline=true to crop the grid region to reflect the bounding box of the polygon.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nN or extend : – extend=true | extend=nodata\nAllow grid to be extended if new region exceeds existing boundaries. Append nodata value to initialize nodes outside current region [Default is NaN].\nS or circ_subregion : – circ_subregion=(lon,lat,radius) | circ_subregion=“lon/lat/radius+n”\nSpecify an origin and radius; append a distance unit and we determine the corresponding rectangular region so that all grid nodes on or inside the circle are contained in the subset. If +n is appended (and hence all arg must be a string) we set all nodes outside the circle to NaN.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nZ or range : – z_subregion=true | range=(min,max) | range=“min/max|+n|N|r”\nDetermine a new rectangular region so that all nodes outside this region are also outside the given z-range [-inf/+inf]. To indicate no limit on min or max only, specify a hyphen (-) (and hence all arg must be a string). Normally, any NaNs encountered are simply skipped and not considered in the range-decision. Append +n (arg must be a string too) to consider a NaN to be outside the given z-range. This means the new subset will be NaN-free. Alternatively, append +r to consider NaNs to be within the data range. In this case we stop shrinking the boundaries once a NaN is found [Default simply skips NaNs when making the range decision]. Finally, if your core subset grid is surrounded by rows and/or columns that are all NaNs, append +N to strip off such columns before (optionally) considering the range of the core subset for further reduction of the area.\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/grdcut.html#examples",
    "href": "documentation/modules/grdcut.html#examples",
    "title": "grdcut",
    "section": "Examples",
    "text": "Examples\nTo obtain data for an oblique Mercator projection map we need to extract more data that is actually used. This is necessary because the output of grdcut has edges defined by parallels and meridians, while the oblique map in general does not. Hence, to get all the data from the ETOPO2 data needed to make a contour map for the region defined by its lower left and upper right corners and the desired projection, use:\n    G = grdcut(\"@earth_relief_02m\", region_diag=(160,20,220,30), proj=\"oc190/25.5/292/69/1\");\nSuppose you have used surface to grid ship gravity in the region between 148E - 162E and 8N - 32N, and you do not trust the gridding near the edges, so you want to keep only the area between 150E - 160E and 10N - 30N, then:\n    G = grdcut(\"grav_148_162_8_32.nc\", region=(150,160,10,30));\nTo return the subregion of a grid such that any boundary strips where all values are entirely above 0 are excluded, try::\n    G = grdcut(\"bathy.nc\", z_subregion=\"-/0\");\nTo return the subregion of a grid such that any boundary rows or columns that are all NaNs, try:\n    G = grdcut(\"bathy.nc\", z_subregion=\"+N\");\nTo return the subregion of a grid that contains all nodes within a distance of 500 km from the point 45,30 try:\n    G = grdcutgrdcut(\"bathy.nc\", circ_subregion=\"45/30/500k\");\nTo create a topography grid with data only inside France and set it to NaN outside France, based on the 10x10 minute DEM, try:\n\nusing GMT\nD = coast(DCW=:FR, dump=true);\nG = grdcut(\"@earth_relief_10m\", cutline=(polygon=D, crop2cutline=true));\nimshow(G)\n\n\n\n\n\n\n\n\nTo determine what grid region and resolution (in text format) most suitable for a 24 cm wide map that is using an oblique projection to display the remote Earth Relief data grid, try:\n    grdcut(\"@earth_relief\", region_diag=(270,20,305,25), proj=\"Oc280/25.5/22/69/24c\", dryrun=\"+t\")"
  },
  {
    "objectID": "documentation/modules/grdcut.html#notes",
    "href": "documentation/modules/grdcut.html#notes",
    "title": "grdcut",
    "section": "Notes",
    "text": "Notes\nIf the input file is a geotiff with multiple data bands then the output format will depend on your selection (if any) of the bands to keep: If you do not specify any bands (which means we consider all the available bands) or you select more than one band, then the output file can either be another geotiff (if you give a .tif[f] extension) or it can be a multiband netCDF file (if you give a .nc or .grd extension). If you select a single band from the input geotiff then GMT will normally read that in as a single grid layer and thus write a netCDF grid (unless you append another grid format specifier). However, if your output filename has a .tif[f] extension then we will instead write it as a one-band geotiff. All geotiff output operations are done via GDAL’s gdal_translate."
  },
  {
    "objectID": "documentation/modules/grdcut.html#source-code",
    "href": "documentation/modules/grdcut.html#source-code",
    "title": "grdcut",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdcut(; kwargs...) - grdcut.jl:45\ngrdcut(cmd0::String; kwargs...) - grdcut.jl:43\ngrdcut(arg1; kwargs...) - grdcut.jl:44"
  },
  {
    "objectID": "documentation/modules/grdcut.html#see-also",
    "href": "documentation/modules/grdcut.html#see-also",
    "title": "grdcut",
    "section": "See Also",
    "text": "See Also\ngrdclip, grdfill, grdinfo, grdpaste, surface"
  },
  {
    "objectID": "documentation/modules/grdfft.html",
    "href": "documentation/modules/grdfft.html",
    "title": "grdfft",
    "section": "",
    "text": "Mathematical operations on grids in the spectral domain\n(Warning: Manual translate by Claude. Needs revision)"
  },
  {
    "objectID": "documentation/modules/grdfft.html#synopsis",
    "href": "documentation/modules/grdfft.html#synopsis",
    "title": "grdfft",
    "section": "Synopsis",
    "text": "Synopsis\ngrdfft ingrid [ ingrid2 ] [ G | outgrid | save ] [ A | azim | azimuth ] [ C | upward | continue ] [ D | dfdz | differentiate ] [ E | radial_power | spectrum ] [ F | filter ] [ I | integrate ] [ M | mgal45 ] [ N | inquire | fft_params ] [ Q | no_wavenumber ] [ S | scale ] [ V | verbose ] [ f | colinfo ]"
  },
  {
    "objectID": "documentation/modules/grdfft.html#description",
    "href": "documentation/modules/grdfft.html#description",
    "title": "grdfft",
    "section": "Description",
    "text": "Description\ngrdfft will take the 2-D forward Fast Fourier Transform and perform one or more mathematical operations in the frequency domain before transforming back to the space domain. An option is provided to scale the data before writing the new values to an output file. The horizontal dimensions of the grid are assumed to be in meters. Geographical grids may be used by specifying the colinfo option that scales degrees to meters. If you have grids with dimensions in km, you could change this to meters using grdedit."
  },
  {
    "objectID": "documentation/modules/grdfft.html#required-arguments",
    "href": "documentation/modules/grdfft.html#required-arguments",
    "title": "grdfft",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ningrid\n\n2-D binary grid file to be operated on. Can be a file name, a GMTgrid object, or a Matrix.\n\ningrid2\n\nOptional second grid file for cross-spectral estimates (see E | spectrum)."
  },
  {
    "objectID": "documentation/modules/grdfft.html#optional-arguments",
    "href": "documentation/modules/grdfft.html#optional-arguments",
    "title": "grdfft",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nG or outgrid or save : – save=“outfile.grd” | save=“table.txt”\nSpecify the name of the output grid file or the 1-D spectrum table (see radial_power). This is optional for radial_power but mandatory for all other options that require a grid output.\nA or azim : – azim=angle | azim=deg\nTake the directional derivative in the azimuth direction measured in degrees CW from north.\nC or upward : – upward=zlevel\nUpward (for zlevel &gt; 0) or downward (for zlevel &lt; 0) continue the field zlevel meters.\nD or dfdz : – dfdz=true | dfdz=scale | dfdz=“g”\nDifferentiate the field, i.e., take ∂/∂z of the grid z. This is equivalent to multiplying by kr in the frequency domain (kr is radial wave number). Options:\n\nNo argument or true : Multiply by kr [Default].\nscale (Number) : Multiply by kr × scale instead.\n“g” : Indicates that your data are geoid heights in meters and output should be gravity anomalies in mGal. Here, scale is a numerical factor to multiply kr by (e.g., 2π × 6.673e-11 × 5.972e24 / 6371000³ = 6.2638e-7 for Earth). Note that in this case, the whole value must be provided as a string.\n\nRepeatable. [Default is no scale].\nE or radial_power : – radial_power=true | radial_power=:r | radial_power=(dir=:x, modifiers…) | radial_power=“r+w+n”\nEstimate power spectrum in the radial or a horizontal direction. No grid file is created. If one grid is given then f (i.e., frequency or wave number), power[f], and 1 standard deviation in power[f] are written to the file set by save [standard output]. If two grids are given we write f and 8 quantities: Xpower[f], Ypower[f], coherent power[f], noise power[f], phase[f], admittance[f], gain[f], coherency[f]. Each quantity is followed by its own 1-std dev error estimate, hence the output is 17 columns wide. Select your spectrum by choosing one of these directives:\n\ndir=:r : Choose a radial spectrum [Default].\ndir=:x : Compute the spectrum in the x-direction instead.\ndir=:y : Compute the spectrum in the y-direction instead.\n\nTwo modifiers are available to adjust the output further:\n\nwavelength : wavelength=true | wavelength=:k – Write wavelength w instead of frequency f, and if your grid is geographic you may further append :k to scale wavelengths from meter [Default] to km.\nnormalize : normalize=true – Normalize spectrum so that the mean spectral values per frequency are reported [By default the spectrum is obtained by summing over several frequencies].\n\nF or filter : – filter=(lc, lp, hp, hc) | filter=“lc/lp/hp/hc” | filter=(dir=:x, lc=lc, lp=lp, hp=hp, hc=hc) | filter=(dir=:r, lo=lo, hi=hi) | filter=(dir=:y, lo=lo, hi=hi, order=n)\nFilter the data. Place :x or :y immediately after F (or use dir=:x or dir=:y) to filter x or y direction only; default is isotropic [:r]. Choose between a cosine-tapered band-pass, a Gaussian band-pass filter, or a Butterworth band-pass filter:\nCosine-taper: Specify four wavelengths lc/lp/hp/hc in correct units (see colinfo) to design a bandpass filter: wavelengths greater than lc or less than hc will be cut, wavelengths greater than lp and less than hp will be passed, and wavelengths in between will be cosine-tapered. E.g., filter=(1000000, 250000, 50000, 10000), colinfo=:g will bandpass, cutting wavelengths &gt; 1000 km and &lt; 10 km, passing wavelengths between 250 km and 50 km. To make a highpass or lowpass filter, give hyphens (-) or missing for hp/hc or lc/lp. E.g., filter=(dir=:x, lp=missing, hp=50, hc=10) will lowpass x, passing wavelengths &gt; 50 and rejecting wavelengths &lt; 10. filter=(dir=:y, lc=1000, lp=250, hp=missing) will highpass y, passing wavelengths &lt; 250 and rejecting wavelengths &gt; 1000.\nGaussian band-pass: Append lo/hi, the two wavelengths in correct units (see colinfo) to design a bandpass filter. At the given wavelengths the Gaussian filter weights will be 0.5. To make a highpass or lowpass filter, give a hyphen (-) or missing for the hi or lo wavelength, respectively. E.g., filter=(lo=missing, hi=30) will lowpass the data using a Gaussian filter with half-weight at 30, while filter=(lo=400, hi=missing) will highpass the data.\nButterworth band-pass: Append lo/hi/order, the two wavelengths in correct units (see colinfo) and the filter order (an integer) to design a bandpass filter. At the given cut-off wavelengths the Butterworth filter weights will be 0.707 (i.e., the power spectrum will therefore be reduced by 0.5). To make a highpass or lowpass filter, give a hyphen (-) or missing for the hi or lo wavelength, respectively. E.g., filter=(lo=missing, hi=30, order=2) will lowpass the data using a 2nd-order Butterworth filter, with half-weight at 30, while filter=(lo=400, hi=missing, order=2) will highpass the data.\nNote: For filtering in the time (or space) domain instead, see grdfilter.\nI or integrate : – integrate=true | integrate=scale | integrate=“g”\nIntegrate the field, i.e., compute ∫ z(x,y) dz. This is equivalent to divide by kr in the frequency domain (kr is radial wave number). Options:\n\nNo argument or true : Divide by kr [Default].\nscale (Number) : Divide by kr × scale instead.\ng : Indicates that your data set is gravity anomalies in mGal and output should be geoid heights in meters. Note that in this case, the whole value must be provided as a string.\n\nM or mgal45 : – mgal45=value\nSpecify the value of the gravity in mili Gals at 45 degrees latitude (used to convert gravity anomalies to geoid heights). Default is 980619.9203 mGal (Moritz’s 1980 IGF value). This value needs to be changed accordingly when using data from other planets.\nN or inquire : – inquire=true | inquire=:a | inquire=(mode=:f, modifiers…) | inquire=“a+d+e+t50+v+w+z”\nChoose or inquire about suitable grid dimensions for FFT and set optional parameters. Control the FFT dimension via these directives:\n\n:a or mode=:a : Let the FFT select dimensions yielding the most accurate result.\n:f or mode=:f : Force the FFT to use the actual dimensions of the data.\n:m or mode=:m : Let the FFT select dimensions using the least work memory.\n:r or mode=:r : Let the FFT select dimensions yielding the most rapid calculation.\n:s or mode=:s : Just present a list of optional dimensions, then exit.\nnx/ny or size=(nx, ny) : Do FFT on array size nx/ny (must be &gt;= grid file size).\n\nWithout a directive we expect nx/ny which will do FFT on array size nx/ny (must be &gt;= grid file size). Default chooses dimensions &gt;= data which optimize speed and accuracy of FFT. If FFT dimensions &gt; grid file dimensions, data are extended and tapered to zero.\nControl detrending of data by appending a modifier for removing a linear trend. The default action is to remove a best-fitting linear plane (+d):\n\ndetrend or +d : detrend=true – Detrend data, i.e. remove best-fitting linear trend.\nmean or +a : mean=true – Only remove the mean value.\nmid or +h : mid=true – Only remove the mid value, i.e. 0.5 × (max + min).\nleave or +l : leave=true – Leave data alone.\n\nControl extension and tapering of data by appending a modifier to control how the extension and tapering are to be performed:\n\nextend or +e : extend=true – Extend the grid by imposing edge-point symmetry [Default].\nmirror or +m : mirror=true – Extends the grid by imposing edge mirror symmetry.\nno_extend or +n : no_extend=true – Turns off data extension.\n\nTapering is performed from the data edge to the FFT grid edge [100%]. Change this percentage via modifier:\n\ntaper or +t : taper=width – Set taper width as percentage.\n\nWhen +n is in effect, the tapering is applied instead to the data margins as no extension is available [0%].\nControl messages being reported:\n\n+v : verbose_fft=true – Report suitable dimensions during processing.\n\nControl writing of temporary results: For detailed investigation you can write the intermediate grid being passed to the forward FFT; this is likely to have been detrended, extended by point-symmetry along all edges, and tapered. Use these modifiers to save such grids:\n\nwrite or +w : write=“suffix” – Set the suffix from which output file name(s) will be created (i.e., ingrid_suffix.ext) [Default is “tapered”], where ext is your file extension.\nsave_fft or +z : save_fft=true | save_fft=:p – Save the complex grid produced by the forward FFT. By default we write the real and imaginary components to ingrid_real.ext and ingrid_imag.ext. Append :p to instead use the polar form of magnitude and phase to files ingrid_mag.ext and ingrid_phase.ext.\n\nQ or no_wavenumber : – no_wavenumber=true\nSelects no wavenumber operations. Useful in conjunction with inquire modifiers when you wish to write out the 2-D spectrum (or other intermediate grid products) only.\nS or scale : – scale=factor | scale=:d\nMultiply each element by factor in the space domain (after the frequency domain operations). [Default is 1.0]. Alternatively, append :d to convert deflection of vertical to micro-radians.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at"
  },
  {
    "objectID": "documentation/modules/grdfft.html#grid-distance-units",
    "href": "documentation/modules/grdfft.html#grid-distance-units",
    "title": "grdfft",
    "section": "Grid Distance Units",
    "text": "Grid Distance Units\nIf the grid does not have meter as the horizontal unit, append +uunit to the input file name to convert from the specified unit to meter. If your grid is geographic, convert distances to meters by supplying colinfo=:g instead."
  },
  {
    "objectID": "documentation/modules/grdfft.html#considerations",
    "href": "documentation/modules/grdfft.html#considerations",
    "title": "grdfft",
    "section": "Considerations",
    "text": "Considerations\nnetCDF COARDS grids will automatically be recognized as geographic. For other geographical grids where you want to convert degrees into meters, select colinfo=:g. If the data are close to either pole, you should consider projecting the grid file onto a rectangular coordinate system using grdproject."
  },
  {
    "objectID": "documentation/modules/grdfft.html#data-detrending",
    "href": "documentation/modules/grdfft.html#data-detrending",
    "title": "grdfft",
    "section": "Data Detrending",
    "text": "Data Detrending\nThe default detrending mode is to remove a best-fitting linear plane (+d). Consult and use inquire to select other modes."
  },
  {
    "objectID": "documentation/modules/grdfft.html#normalization-of-spectrum",
    "href": "documentation/modules/grdfft.html#normalization-of-spectrum",
    "title": "grdfft",
    "section": "Normalization of Spectrum",
    "text": "Normalization of Spectrum\nBy default, the power spectrum returned by spectrum simply sums the contributions from frequencies that are part of the output frequency. For x- or y-spectra this means summing the power across the other frequency dimension, while for the radial spectrum it means summing up power within each annulus of width delta_q, the radial frequency (q) spacing. A consequence of this summing is that the radial spectrum of a white noise process will give a linear radial power spectrum that is proportional to q. Appending normalize=true will instead compute the mean power per output frequency and in this case the white noise process will have a white radial spectrum as well."
  },
  {
    "objectID": "documentation/modules/grdfft.html#examples",
    "href": "documentation/modules/grdfft.html#examples",
    "title": "grdfft",
    "section": "Examples",
    "text": "Examples\nTo obtain the normalized radial spectrum from the remote data grid @white_noise.nc, after removing the mean, try:\n\nusing GMT\nD = grdfft(\"@white_noise.nc\", radial_power=(dir=:r, normalize=true, wavelength=true));\nviz(D)\n\n\n\n\n\n\n\n\nTo upward continue the sea-level magnetic anomalies in the file mag_0.nc to a level 800 m above sealevel:\nG = grdfft(\"mag_0.nc\", upward=800, verbose=true, save=\"mag_800.nc\")\nTo transform geoid heights in m (geoid.nc) on a geographical grid to free-air gravity anomalies in mGal:\nG = grdfft(\"geoid.nc\", dfdz=:g, verbose=true, save=\"grav.nc\")\nTo transform gravity anomalies in mGal (faa.nc) to deflections of the vertical (in micro-radians) in the 038 direction, we must first integrate gravity to get geoid, then take the directional derivative, and finally scale radians to micro-radians:\nG = grdfft(\"faa.nc\", integrate=:g, azim=38, scale=1e6, verbose=true, save=\"defl_38.nc\")\nSecond vertical derivatives of gravity anomalies are related to the curvature of the field. We can compute these as mGal/m² by:\nG = grdfft(\"gravity.nc\", dfdz=true, dfdz=true, verbose=true, save=\"grav_2nd_derivative.nc\")\nNote: To repeat dfdz twice, you would need to call grdfft twice in sequence or use the monolithic syntax.\nTo compute cross-spectral estimates for co-registered bathymetry and gravity grids, and report result as functions of wavelengths in km, try:\nD = grdfft([\"bathymetry.nc\", \"gravity.grd\"], spectrum=(wavelength=:k,), colinfo=:g, verbose=true)\nOr using two separate grid arguments:\nbathy = gmtread(\"bathymetry.nc\")\ngrav = gmtread(\"gravity.grd\")\nD = grdfft(bathy, grav, spectrum=(wavelength=:k,), colinfo=:g, verbose=true)\nTo examine the pre-FFT grid after detrending, point-symmetry reflection, and tapering has been applied, as well as saving the real and imaginary components of the raw spectrum of the data in topo.nc, try:\ngrdfft(\"topo.nc\", inquire=(write=true, save_fft=true), colinfo=:g, verbose=true, \n       no_wavenumber=true)\nYou can now make plots of the data in topo_taper.nc, topo_real.nc, and topo_imag.nc."
  },
  {
    "objectID": "documentation/modules/grdfft.html#notes",
    "href": "documentation/modules/grdfft.html#notes",
    "title": "grdfft",
    "section": "Notes",
    "text": "Notes\n\nRepeating Operations\nSome operations like dfdz and integrate can be repeated to get higher-order derivatives or multiple integrations. In GMT.jl, you have two options:\n\nChain calls: Call grdfft multiple times in sequence\nMonolithic syntax: Use the GMT command string directly\n\nExample for second derivative:\n# Option 1: Chain calls\nG1 = grdfft(\"gravity.nc\", dfdz=true)\nG2 = grdfft(G1, dfdz=true)\n\n# Option 2: Monolithic syntax  \nG = grdfft(\"gravity.nc\", D=\"-D -D\", save=\"output.nc\")"
  },
  {
    "objectID": "documentation/modules/grdfft.html#source-code",
    "href": "documentation/modules/grdfft.html#source-code",
    "title": "grdfft",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdfft(cmd0::String; ...) - grdfft.jl:48\ngrdfft(; ...) - grdfft.jl:48\ngrdfft(cmd0::String, arg1; ...) - grdfft.jl:48\ngrdfft(arg1, arg2; kw...) - grdfft.jl:72\ngrdfft(arg1; ...) - grdfft.jl:72\ngrdfft(cmd0::String, arg1, arg2; kwargs...) - grdfft.jl:48"
  },
  {
    "objectID": "documentation/modules/grdfft.html#see-also",
    "href": "documentation/modules/grdfft.html#see-also",
    "title": "grdfft",
    "section": "See Also",
    "text": "See Also\ngrdfilter, grdproject"
  },
  {
    "objectID": "documentation/modules/grdfilter.html",
    "href": "documentation/modules/grdfilter.html",
    "title": "grdfilter",
    "section": "",
    "text": "Filter a grid in the space (or time) domain"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#synopsis",
    "href": "documentation/modules/grdfilter.html#synopsis",
    "title": "grdfilter",
    "section": "Synopsis",
    "text": "Synopsis\nG = grdfilter(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#description",
    "href": "documentation/modules/grdfilter.html#description",
    "title": "grdfilter",
    "section": "Description",
    "text": "Description\ngrdfilter filters a grid in the time (or space) domain using one of the selected convolution or non-convolution isotropic or rectangular filters and computes distances using Cartesian or Spherical geometries. The output grid can optionally be generated as a sub-region of the input (via region/R) and/or with new increment (via inc/I) or registration (via toggle/T). In this way, one may have “extra space” in the input data so that the edges will not be used and the output can be within one half-width of the input edges. If the filter is low-pass, then the output may be less frequently sampled than the input.\nNote: For filtering in the frequency (or wavenumber) domain instead, see grdfft."
  },
  {
    "objectID": "documentation/modules/grdfilter.html#required-arguments",
    "href": "documentation/modules/grdfilter.html#required-arguments",
    "title": "grdfilter",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nInput Grid\n\nFirst positional argument or ingrid: Input grid as a file name (String) or a GMTgrid object\n\nOptionally, append =ID for reading a specific file format [Default is =nf]\nAppend ?varname for a specific netCDF variable\nModifiers supported:\n\n+b: Select a band [Default is 0]\n+d: Divide data values by given divisor [Default is 1]\n+n: Replace data values matching invalid with NaN\n+o: Offset data values by given offset [Default is 0]\n+s: Scale data values by given scale [Default is 1]\n\n\n\n\n\ndistance or D\nDistance flag tells how grid (x, y) relates to filter width. Required option.\nSyntax: D=flag or distance=flag where flag is one of: - D=\"p\" or D=:p: Grid (px,py) with width an odd number of pixels; Cartesian distances - D=0 or D=\"0\": Grid (x,y) same units as width, Cartesian distances - D=1 or D=\"1\": Grid (x,y) in degrees, width in km, Cartesian distances - D=2 or D=\"2\": Grid (x,y) in degrees, width in km, dx scaled by cos(middle y), Cartesian distances - D=3 or D=\"3\": Grid (x,y) in degrees, width in km, dx scaled by cos(y), Cartesian distances (slower) - D=4 or D=\"4\": Grid (x,y) in degrees, width in km, Spherical distance calculation (slower) - D=5 or D=\"5\": Grid (x,y) in Mercator -Jm1 img units, width in km, Spherical distance calculation\nNotes: - Flags 0-2 are fastest (weight matrix computed once) - Flags 3-5 are slower (weights recomputed for each latitude)\nExamples:\n# Spherical distance calculation for geographic grid\nG = grdfilter(\"@earth_relief_05m\", filter=\"m600\", D=4)\n\n# Cartesian distances for projected grid\nG = grdfilter(grid, filter=\"g100\", D=0)\n\n\nfilter or F\nSets the filter type and width. Required option.\nSyntax: F=\"xwidth[/width2][+modifiers]\" or filter=\"xwidth[/width2][+modifiers]\"\nWhere x is the filter type code followed by the full diameter width. Append /width2 for a rectangular filter (requires D=\"p\" or D=0).\nConvolution Filters: - b: Boxcar - All weights are equal - c: Cosine Arch - Weights follow a cosine arch curve\n- g: Gaussian - Weights given by Gaussian function (width is 6×sigma) - f: Custom - Weights from filter weight grid file (requires D=0) - o: Operator - Weights from filter weight grid file, sum to zero (requires D=0)\nNon-Convolution Filters: - m: Median - Returns median value [default] - +qquantile: Select another quantile (0-1 range) [default is 0.5] - p: Mode (probability) - Returns modal value - +l: Return lowermost mode if multiple - +u: Return uppermost mode if multiple - h: Histogram Mode - Modal value as center of dominant peak - Append /binwidth to specify binning interval - +c: Center bins on multiples of binwidth - +l: Return lowermost mode if multiple - +u: Return uppermost mode if multiple - l: Lower - Return minimum of all values - L: Lower+ - Return minimum of all positive values only - u: Upper - Return maximum of all values - U: Upper- - Return maximum of all negative values only\nModifiers: - +h: High-pass filtering [default is low-pass] - +c: Center bins (for histogram mode) - +l: Return lowermost value (for mode filters) - +u: Return uppermost value (for mode filters) - +qquantile: Specify quantile for median filter (0-1)\nExamples:\n# Median filter, 600 km width\nG = grdfilter(\"input.nc\", F=\"m600\", D=4)\n\n# Gaussian filter, 100 km width\nG = grdfilter(grid, filter=\"g100\", distance=4)\n\n# High-pass Gaussian filter\nG = grdfilter(grid, F=\"g100+h\", D=4)\n\n# 25th percentile (lower quartile)\nG = grdfilter(grid, filter=\"m600+q0.25\", D=4)\n\n# Rectangular boxcar filter\nG = grdfilter(grid, F=\"b50/20\", D=0)\n\n# Histogram mode with 10-unit bins\nG = grdfilter(grid, filter=\"h600/10\", D=4)"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#optional-arguments",
    "href": "documentation/modules/grdfilter.html#optional-arguments",
    "title": "grdfilter",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\noutgrid or G or save\nOutput grid file name or let the function return a GMTgrid object.\nSyntax: G=\"filename.nc\" or outgrid=\"filename.nc\"\nModifiers: - =ID: Write specific file format - +d: Divide data values by divisor - +n: Replace invalid with NaN\n- +o: Offset data values (or +oa for automatic) - +s: Scale data values (or +sa for automatic)\nExamples:\n# Save to file\ngrdfilter(\"input.nc\", filter=\"m600\", D=4, G=\"filtered.nc\")\n\n# Return GMTgrid object (default)\nG = grdfilter(\"input.nc\", filter=\"m600\", D=4)\n\n\ninc or I or spacing\nSet the output grid spacing.\nSyntax: I=x_inc[/y_inc] or inc=\"x_inc[/y_inc]\" or spacing=x_inc\nGeographic coordinates units: - d: Arc degrees - m: Arc minutes - s: Arc seconds - e, f, k, M, n, u: Length units (converted to degrees)\nModifiers: - +e: Adjust max extent to fit increment exactly - +n: Specify number of nodes instead of increment\nExamples:\n# 0.5 degree spacing\nG = grdfilter(grid, F=\"m600\", D=4, I=0.5)\n\n# Different x and y spacing\nG = grdfilter(grid, filter=\"g100\", D=4, inc=\"1/0.5\")\n\n# 30 arc minutes\nG = grdfilter(grid, F=\"m600\", D=4, I=\"30m\")\n\n# 100 nodes in x, 50 in y\nG = grdfilter(grid, filter=\"g50\", D=4, I=\"100+n/50+n\")\n\n\nnans or N\nDetermine how NaN-values in input grid affect filtered output.\nSyntax: N=\"directive\" or nans=\"directive\"\nDirectives: - i: Ignore all NaNs in calculation [Default] - p: Force output to NaN if any NaN found in filter circle - r: Like i but preserve NaN if input node was NaN (co-registered grids only)\nExamples:\n# Ignore NaNs (default)\nG = grdfilter(grid, F=\"m600\", D=4, N=\"i\")\n\n# Propagate NaNs\nG = grdfilter(grid, filter=\"g100\", D=4, nans=\"p\")\n\n# Preserve input NaNs\nG = grdfilter(grid, F=\"m600\", D=4, N=\"r\")\n\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\n\n\n\nregion or R\nSpecify the output region (sub-region of input).\nSyntax: R=(xmin, xmax, ymin, ymax) or R=\"xmin/xmax/ymin/ymax\" or region=...\nExamples:\n# Tuple format\nG = grdfilter(grid, F=\"m600\", D=4, R=(150, 250, 10, 40))\n\n# String format  \nG = grdfilter(grid, filter=\"g100\", D=4, region=\"150/250/10/40\")\n\n# Extract Pacific region\nG = grdfilter(\"@earth_relief_05m\", F=\"m600\", D=4, R=(150,250,10,40), I=0.5)\n\n\ntoggle or T\nToggle the node registration for output grid (gridline ↔︎ pixel).\nExamples:\n# Toggle registration\nG = grdfilter(grid, F=\"m600\", D=4, T=true)\n\n# Equivalent using toggle keyword\nG = grdfilter(grid, filter=\"g100\", D=4, toggle=true)\n\n\nregistration or r\nSet node registration explicitly.\nSyntax: r=\"g\" (gridline) or r=\"p\" (pixel)\nExamples:\n# Force gridline registration\nG = grdfilter(grid, F=\"m600\", D=4, r=\"g\")\n\n# Force pixel registration\nG = grdfilter(grid, filter=\"g100\", D=4, registration=\"p\")\n\n\nverbose or V\nControl verbosity level.\nSyntax: V=true or V=level or verbose=level\nExamples:\n# Verbose output\nG = grdfilter(grid, F=\"m600\", D=4, V=true)\n\n# Specific verbosity level\nG = grdfilter(grid, filter=\"g100\", D=4, verbose=:w)\n\n\ncolinfo or f\nSpecify data types of input/output columns (time or geographical data).\nExamples:\n# Time/geographic data specification\nG = grdfilter(grid, F=\"m600\", D=4, f=\"0x,1t\")\n\n\ncores or x\nLimit number of cores used in multi-threaded algorithms.\nSyntax: x=n where: - n &gt; 0: Use n cores - n &lt; 0: Use (all - n) cores - x=true: Use all available cores [default]\nExamples:\n# Use 4 cores\nG = grdfilter(grid, F=\"m600\", D=4, x=4)\n\n# Use all but 2 cores\nG = grdfilter(grid, filter=\"g100\", D=4, cores=-2)\n\n# Single-threaded\nG = grdfilter(grid, F=\"m600\", D=4, x=1)"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#examples",
    "href": "documentation/modules/grdfilter.html#examples",
    "title": "grdfilter",
    "section": "Examples",
    "text": "Examples\n\nBasic Filtering\n\nusing GMT\n\n# Load Earth relief data\ngrid = gmtread(\"@earth_relief_05m\", region=(140,260,0,50))\n\n# Apply median filter with 600 km width (spherical distances)\nG = grdfilter(grid, filter=\"m600\", D=4, region=(150,250,10,40), inc=0.5)\n\n61×201 GMTgrid{Float32, 2}:\n -5368.0  -5432.0  -5508.5  -5554.5  …  -3837.0  -3801.0  -3765.0  -3727.5\n -5635.0  -5682.5  -5701.5  -5710.0     -3833.5  -3800.0  -3761.0  -3714.5\n -5734.0  -5767.5  -5792.0  -5805.5     -3834.5  -3802.0  -3765.0  -3721.0\n -5791.0  -5817.0  -5837.0  -5858.0     -3853.0  -3807.5  -3767.0  -3725.0\n -5821.5  -5856.5  -5885.0  -5903.0     -3881.5  -3825.0  -3781.0  -3743.0\n -5850.0  -5885.0  -5912.5  -5939.0  …  -3889.0  -3840.5  -3799.5  -3769.5\n -5871.0  -5898.0  -5925.5  -5953.0     -3889.5  -3842.5  -3803.5  -3777.0\n -5883.5  -5904.5  -5933.5  -5953.5     -3873.0  -3834.5  -3805.0  -3781.5\n -5886.0  -5906.5  -5933.5  -5951.5     -3847.0  -3820.0  -3798.0  -3773.0\n -5860.0  -5885.0  -5918.5  -5940.5     -3799.0  -3780.0  -3766.0  -3747.0\n -5796.5  -5820.5  -5856.0  -5878.0  …  -3733.0  -3711.0  -3703.5  -3699.5\n -5716.0  -5738.0  -5755.0  -5778.5     -3639.0  -3624.0  -3628.0  -3639.0\n -5647.5  -5659.0  -5657.0  -5672.5     -3554.0  -3541.5  -3554.5  -3576.5\n     ⋮                               ⋱                                 ⋮\n -5987.5  -5986.5  -5978.5  -5963.5      1520.0   1623.0   1699.0   1732.0\n -5982.5  -5982.5  -5973.5  -5952.5  …   1595.0   1662.5   1725.0   1784.5\n -5962.5  -5961.0  -5953.0  -5941.0      1651.0   1720.0   1781.0   1835.5\n -5910.0  -5914.5  -5917.5  -5910.5      1695.0   1754.0   1820.0   1875.5\n -5860.5  -5866.5  -5872.0  -5870.5      1726.5   1778.5   1843.0   1906.5\n -5812.5  -5820.5  -5829.5  -5834.5      1745.5   1795.0   1846.5   1914.0\n -5775.0  -5782.5  -5791.0  -5799.5  …   1772.5   1806.0   1850.0   1915.0\n -5734.5  -5744.5  -5753.0  -5764.0      1784.5   1809.0   1855.0   1925.0\n -5686.0  -5704.0  -5716.0  -5727.5      1795.0   1837.0   1890.5   1955.0\n -5631.0  -5655.5  -5672.5  -5682.5      1831.5   1869.0   1925.5   1993.5\n -5527.5  -5573.5  -5595.5  -5609.0      1861.0   1894.0   1957.0   2026.5\n -5444.0  -5471.5  -5507.0  -5537.5  …   1894.0   1933.5   1986.0   2048.0\n\n\n\n\nHigh-Pass Filtering\n# High-pass filter (residuals from low-pass)\nG_residual = grdfilter(\"@earth_relief_05m\", \n    F=\"m600+h\", \n    D=4, \n    R=(150,250,10,40), \n    I=0.5)\n\n\nDifferent Filter Types\n# Gaussian smoothing\nG_gauss = grdfilter(grid, filter=\"g100\", distance=4)\n\n# Boxcar (moving average)\nG_box = grdfilter(grid, F=\"b200\", D=4)\n\n# Cosine arch\nG_cos = grdfilter(grid, filter=\"c150\", D=4)\n\n# Maximum value in window\nG_max = grdfilter(grid, F=\"u500\", D=4)\n\n# Minimum value in window\nG_min = grdfilter(grid, filter=\"l500\", D=4)\n\n\nQuantile Filtering\n# Lower quartile (25th percentile)\nG_q25 = grdfilter(grid, F=\"m600+q0.25\", D=4)\n\n# Upper quartile (75th percentile)\nG_q75 = grdfilter(grid, filter=\"m600+q0.75\", D=4)\n\n# 90th percentile\nG_q90 = grdfilter(grid, F=\"m600+q0.9\", D=4)\n\n\nCustom Filter from Grid\n# Create custom anisotropic Gaussian filter\n# exp(-0.5*r^2) where r^2 = (2x^2 + y^2 - 2xy)/6\nfilter_grid = grdmath(\"-R-10/10/-10/10 -I1 X 2 POW 2 MUL Y 2 POW ADD X Y MUL 2 MUL SUB 6 DIV NEG 2 DIV EXP DUP SUM DIV\")\n\n# Apply custom filter\nG = grdfilter(\"ripples.nc\", F=\"f$(filter_grid)\", D=0, G=\"smooth.nc\")\n\n\nRectangular Filters\n# Rectangular boxcar filter (100 km × 50 km)\nG = grdfilter(grid, F=\"b100/50\", D=0, I=1)\n\n# Rectangular Gaussian\nG = grdfilter(grid, filter=\"g200/100\", D=0)\n\n\nVariable Filter Width\n# Create variable width grid (must match output dimensions)\nwidth_grid = # ... GMTgrid with varying filter widths\n\n# Apply variable width median filter\nG = grdfilter(grid, F=width_grid, D=4, I=0.5)\n\n\nSub-Region Extraction with Filtering\n# Filter and extract Pacific region\nG_pacific = grdfilter(\"@earth_relief_05m\",\n    filter=\"m600\",\n    distance=4,\n    region=(150, 250, 10, 40),\n    inc=0.5)\n\n\nNaN Handling\n# Ignore NaNs (default)\nG1 = grdfilter(grid, F=\"m600\", D=4, N=\"i\")\n\n# Propagate NaNs (conservative)\nG2 = grdfilter(grid, F=\"m600\", D=4, nans=\"p\")\n\n# Preserve input NaNs only\nG3 = grdfilter(grid, F=\"m600\", D=4, N=\"r\")\n\n\nMulti-Threaded Processing\n# Use all available cores (default)\nG = grdfilter(grid, F=\"m600\", D=4)\n\n# Use 8 cores\nG = grdfilter(grid, filter=\"g100\", D=4, x=8)\n\n# Single-threaded\nG = grdfilter(grid, F=\"m600\", D=4, cores=1)\n\n\nComparison of Filter Types\n\nusing GMT\n\n# Original data\ngrid = gmtread(\"@earth_relief_05m\", region=(150,200,10,40))\n\n# Apply different filters\nG_median = grdfilter(grid, F=\"m600\", D=4, I=0.5)\nG_gauss = grdfilter(grid, F=\"g600\", D=4, I=0.5)\nG_boxcar = grdfilter(grid, F=\"b600\", D=4, I=0.5)\nG_mode = grdfilter(grid, F=\"p600\", D=4, I=0.5)\n\n# Visualize differences\nsubplot(grid=(2,2), F=(width=20, height=15))\n    grdimage(G_median, panel=(1,1), title=\"Median\")\n    grdimage(G_gauss, panel=(1,2), title=\"Gaussian\")\n    grdimage(G_boxcar, panel=(2,1), title=\"Boxcar\")\n    grdimage(G_mode, panel=(2,2), title=\"Mode\")\nsubplot(:show)"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#distance-flag-details",
    "href": "documentation/modules/grdfilter.html#distance-flag-details",
    "title": "grdfilter",
    "section": "Distance Flag Details",
    "text": "Distance Flag Details\nThe distance flag (D) determines how grid coordinates relate to filter width:\n\n\n\nFlag\nGrid Units\nWidth Units\nX Scaling\nDistance Calc\nSpeed\n\n\n\n\np\nPixels\nPixels (odd)\nNone\nCartesian\nFast\n\n\n0\nAny\nSame as grid\nNone\nCartesian\nFast\n\n\n1\nDegrees\nKilometers\nNone\nCartesian\nFast\n\n\n2\nDegrees\nKilometers\ncos(mid_y)\nCartesian\nFast\n\n\n3\nDegrees\nKilometers\ncos(y)\nCartesian\nSlow\n\n\n4\nDegrees\nKilometers\ncos(y)\nSpherical\nSlow\n\n\n5\nMercator\nKilometers\ncos(y)\nSpherical\nSlow\n\n\n\nRecommendations: - Use D=4 for accurate geographic filtering (most common) - Use D=0 for Cartesian grids or custom filters - Use D=1 or D=2 for faster approximate geographic filtering - Use D=5 for Mercator projected grids from img2mercgrd"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#filter-type-comparison",
    "href": "documentation/modules/grdfilter.html#filter-type-comparison",
    "title": "grdfilter",
    "section": "Filter Type Comparison",
    "text": "Filter Type Comparison\n\n\n\n\n\n\n\n\n\nFilter\nType\nUse Case\nNotes\n\n\n\n\nBoxcar (b)\nConvolution\nSimple smoothing\nEqual weights, sharp cutoff\n\n\nCosine Arch (c)\nConvolution\nSmooth lowpass\nGradual weight decay\n\n\nGaussian (g)\nConvolution\nStandard smoothing\nWidth = 6σ, smooth decay\n\n\nMedian (m)\nNon-convolution\nOutlier removal\nRobust to spikes\n\n\nMode (p)\nNon-convolution\nPeak detection\nFinds most common value\n\n\nHistogram Mode (h)\nNon-convolution\nPeak detection\nLike mode with binning\n\n\nMin/Max (l/u)\nNon-convolution\nEnvelope detection\nExtract extremes\n\n\nCustom (f)\nConvolution\nSpecialized\nUser-defined weights\n\n\nOperator (o)\nConvolution\nDerivatives\nWeights sum to zero"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#limitations",
    "href": "documentation/modules/grdfilter.html#limitations",
    "title": "grdfilter",
    "section": "Limitations",
    "text": "Limitations\n\nMercator grids (D=5): Input must be created by img2mercgrd with origin at Equator\nPerformance: If output increments are not integer multiples of input increments, filtering is considerably slower\nCustom filters (f/o): Require D=0 and odd dimensions; output spacing must match or be integer multiples of input\nVariable width: Filter width grid must match output grid dimensions and registration"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#tips-for-julia-users",
    "href": "documentation/modules/grdfilter.html#tips-for-julia-users",
    "title": "grdfilter",
    "section": "Tips for Julia Users",
    "text": "Tips for Julia Users\n\nInput formats: GMT.jl accepts:\n\nGMTgrid objects\nFile names as strings\nRemote GMT datasets (e.g., \"@earth_relief_05m\")\n\nOutput options:\n\nOmit G to return GMTgrid object\nSpecify G=\"filename.nc\" to save to file\nUse save= as alias for G=\n\nBoolean options: Use true instead of empty strings:\n\nT=true not T=\"\"\nV=true not V=\"\"\n\nKeyword flexibility: Most options have multiple aliases:\n\nfilter= or F=\ndistance= or D=\nregion= or R=\ninc= or I= or spacing=\n\nPiping workflows: GMTgrid objects can be piped through functions:\nresult = gmtread(\"input.nc\") |&gt;\n         g -&gt; grdfilter(g, F=\"m600\", D=4) |&gt;\n         g -&gt; grdimage(g, proj=:Mercator, show=true)\nPerformance: For large grids, consider:\n\nUsing coarser output increments\nSmaller filter widths\nFaster distance flags (D=0,1,2 vs D=4)\nLimiting cores if memory constrained"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#geographical-and-time-coordinates",
    "href": "documentation/modules/grdfilter.html#geographical-and-time-coordinates",
    "title": "grdfilter",
    "section": "Geographical and Time Coordinates",
    "text": "Geographical and Time Coordinates\nWhen the output grid type is netCDF, coordinates are labeled “longitude”, “latitude”, or “time” based on input attributes or f/R options. Time coordinates are stored as relative time since epoch (specified by TIME_UNIT and TIME_EPOCH)."
  },
  {
    "objectID": "documentation/modules/grdfilter.html#source-code",
    "href": "documentation/modules/grdfilter.html#source-code",
    "title": "grdfilter",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdfilter(cmd0::String; kwargs...) - grdfilter.jl:35\ngrdfilter(arg1; kwargs...) - grdfilter.jl:36"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#see-also",
    "href": "documentation/modules/grdfilter.html#see-also",
    "title": "grdfilter",
    "section": "See Also",
    "text": "See Also\ngrdfft, {{&lt; scatter grdmath &gt;}}, {{&lt; scatter grdproject &gt;}}, {{&lt; scatter grdsample &gt;}}, {{&lt; scatter grdgradient &gt;}}"
  },
  {
    "objectID": "documentation/modules/grdfilter.html#references",
    "href": "documentation/modules/grdfilter.html#references",
    "title": "grdfilter",
    "section": "References",
    "text": "References\n\nGMT Documentation: https://docs.generic-mapping-tools.org/latest/grdfilter.html\nGMT.jl Documentation: https://www.generic-mapping-tools.org/GMTjl_doc/"
  },
  {
    "objectID": "documentation/modules/grdgradient.html",
    "href": "documentation/modules/grdgradient.html",
    "title": "grdgradient",
    "section": "",
    "text": "grdgradient(cmd0::String=\"\", arg1=nothing; kwargs...)\nCompute directional derivative or gradient from a grid"
  },
  {
    "objectID": "documentation/modules/grdgradient.html#description",
    "href": "documentation/modules/grdgradient.html#description",
    "title": "grdgradient",
    "section": "Description",
    "text": "Description\nComputes the directional derivative in a given direction (azim), or to find the direction (slopegrid) [and the magnitude (find_dir)] of the vector gradient of the data.\nEstimated values in the first/last row/column of output depend on boundary conditions (see interp)."
  },
  {
    "objectID": "documentation/modules/grdgradient.html#required-arguments",
    "href": "documentation/modules/grdgradient.html#required-arguments",
    "title": "grdgradient",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe 2-D gridded data set to be contoured."
  },
  {
    "objectID": "documentation/modules/grdgradient.html#optional-arguments",
    "href": "documentation/modules/grdgradient.html#optional-arguments",
    "title": "grdgradient",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or azim or azimuth : – azim=azim | azim=(azim1, azim2)\nAzimuthal direction for a directional derivative; azim is the angle in the x,y plane measured in degrees positive clockwise from north (the +y direction) toward east (the +x direction). The negative of the directional derivative, -[dz/dx sin(azim) + dz/dy cos(azim)], is found; negation yields positive values when the slope of z(x,y) is downhill in the azim direction, the correct sense for shading the illumination of an image (see grdimage and grdview) by a light source above the x,y plane shining from the azim direction. Optionally, supply two azimuths, azim=(azim1, azim2), in which case the gradients in each of these directions are calculated and the one larger in magnitude is retained; this is useful for illuminating data with two directions of lineated structures, e.g., azim=(0,270) illuminates from the north (top) and west (left). Finally, if azim is a file it must be a grid of the same domain, spacing and registration as in_grdfile and we will update the azimuth at each output node when computing the directional derivatives.\nG or save or outgrid or outfile : – save=file_name.grd\nWrite one or more fields directly to grids on disk or return them to the Julia REPL as grid objects. If more than one field is specified via fields then file_name must contain the format flag %s so that we can embed the field code in the file names.\nD or find_dir : – find_dir=true | find_dir=:a | find_dir=:c | find_dir=:o | find_dir=:n | find_dir=acon\nFind the direction of the positive (up-slope) gradient of the data. To instead find the aspect (the down-slope direction), use find_dir=:a. By default, directions are measured clockwise from north, as azim in azim above. Use find_dir=:c to use conventional Cartesian angles measured counterclockwise from the positive x (east) direction. Use find_dir=:o to report orientations (0-180) rather than directions (0-360). Use find_dir=:n to add 90 degrees to all angles (e.g., to give local strikes of the surface). Note, you can combine two or more options by cating the single flgas in a word, (e.g. find_dir=:on)\nE or lambert : – lambert=([simple=true, peucker=true, manip=true,] view=(azim,elev) [,ambient=val, difuse=val, specular=val, shine=val])\nCompute Lambertian radiance appropriate to use with grdimage and grdview. The Lambertian Reflection assumes an ideal surface that reflects all the light that strikes it and the surface appears equally bright from all viewing directions. Here, azim and elev are the azimuth and elevation of the light vector. Optionally, supply ambient [0.55], diffuse [0.6], specular [0.4], or shine [10], which are parameters that control the reflectance properties of the surface. Default values are given in the brackets. Use lambert=(simple=true, view=(azim,elev)) for a simpler Lambertian algorithm. Note that with this form you only have to provide azimuth and elevation. Alternatively, use lambert=(peucker=true,) for the Peucker piecewise linear approximation (simpler but faster algorithm; in this case the azim and elev are hardwired to 315 and 45 degrees. This means that even if you provide other values they will be ignored. The lambert=(manip=true,) uses another algorithm that gives results close to ESRI’s hillshade but faster. In this case the azimuth and elevation are hardwired to 315 and 45 degrees.\nN or norm or normalize : – norm=([laplace=true, cauchy=true,] [amp=val,] [sigma=val, offset=val])\nNormalization. [Default is no normalization.] The actual gradients g are offset and scaled to produce normalized gradients gn with a maximum output magnitude of amp. If amp is not given, default amp = 1. If offset is not given, it is set to the average of g. norm=true yields gn = amp ] (g - offset)/max(abs(g - offset)). norm=(laplace=true,) normalizes using a cumulative Laplace distribution yielding gn* = amp * (1.0 - exp(sqrt(2) * (g - offset)/ sigma)), where sigma is estimated using the L1 norm of (g - offset) if it is not given. norm=(cauchy=true,) normalizes using a cumulative Cauchy distribution yielding gn = (2 * amp / PI) * atan( (g - offset)/ sigma) where sigma is estimated using the L2 norm of (g - offset) if it is not given. To use offset and/or sigma from a previous calculation, leave out the argument to the modifier(s) (e.g. set them to ““) and see save_stats for usage.\nQ or save_stats : – save_stats=:save | save_stats=:read | save_stats=:Read\nControls how normalization via norm is carried out. When multiple grids should be normalized the same way (i.e., with the same offset and/or sigma), we must pass these values via norm. However, this is inconvenient if we compute these values from a grid. Use save_stats=:save to save the results of offset and sigma to a statistics file; if grid output is not needed for this run then specify outgrid=:none. For subsequent runs, just use save_stats=:read to read these values. Using save_stats=:Read will read then delete the statistics file. See TILES for more information. (Warning: this option is available on GMT6 only)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or slopegrid :\nName of output grid file with scalar magnitudes of gradient vectors. Requires find_dir but makes outgrid optional.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)"
  },
  {
    "objectID": "documentation/modules/grdgradient.html#grid-distance-units",
    "href": "documentation/modules/grdgradient.html#grid-distance-units",
    "title": "grdgradient",
    "section": "Grid Distance Units",
    "text": "Grid Distance Units\nIf the grid does not have meter as the horizontal unit, append +u unit to the input file name to convert from the specified unit to meter. If your grid is geographic, convert distances to meters by supplying colinfo=:g instead."
  },
  {
    "objectID": "documentation/modules/grdgradient.html#hints",
    "href": "documentation/modules/grdgradient.html#hints",
    "title": "grdgradient",
    "section": "Hints",
    "text": "Hints\nIf you don’t know what norm options to use to make an intensity file for grdimage and grdview, a good first try is norm=e0.6.\nUsually 255 shades are more than enough for visualization purposes. You can save 75% disk space by appending =nb/a to the output filename outgrid.\nIf you want to make several illuminated maps of subregions of a large data set, and you need the illumination effects to be consistent across all the maps, use the norm option and supply the same value of sigma and offset to grdgradient for each map. A good guess is offset = 0 and sigma found by grdinfo -L2 or -L1 applied to an unnormalized gradient grd.\nIf you simply need the x- or y-derivatives of the grid, use grdmath."
  },
  {
    "objectID": "documentation/modules/grdgradient.html#tiles",
    "href": "documentation/modules/grdgradient.html#tiles",
    "title": "grdgradient",
    "section": "Tiles",
    "text": "Tiles\nFor very large datasets (or very large plots) you may need to break the job into multiple tiles. It is then important that the normalization of the intensities are handled the same way for each tile. By default, offset and sigma are recalculated for each tile. Hence, different tiles of the same large grid will compute different offset and sigma values. Thus, the intensity for the same directional slope will be different across the final map. This inconsistency can lead to visible changes in image appearance across tile seams. The way to ensure compatible results is to specify the same offset and sigma via the modifiers to norm. However, if these need to be estimated from the large grid then the save_stats option can help: Run grdgradient on the full grid (or as large portion of the grid that your computer can handle) and specify save_stats=:save to create a statistics file with the resulting offset and sigma. Then, for each of your grid tile calculations, give norm=(offset=““,) and/or norm=(sigma=““,) without arguments to norm and specify save_stats=:read. This option will read the values from the hidden statistics file and use them in the normalization. If you use save_stats=:Read for the final tile then the statistics file is removed after use."
  },
  {
    "objectID": "documentation/modules/grdgradient.html#examples",
    "href": "documentation/modules/grdgradient.html#examples",
    "title": "grdgradient",
    "section": "Examples",
    "text": "Examples\nTo make a file for illuminating the data in geoid.nc using exp- normalized gradients in the range [-0.6,0.6] imitating light sources in the north and west directions:\n    G = grdgradient(\"geoid.nc\", azim=(0,270), norm=(laplace=true, amp=0.6), Verbose=true)\nTo find the azimuth orientations of seafloor fabric in the file topo.nc:\n    G = grdgradient(\"topo.nc\", find_dir=:no);\nTo determine the offset and sigma suitable for normalizing the intensities from topo.nc, do\n    grdgradient(\"topo.nc\", azim=30, norm=:t0.6, save_stats=:save);\nTo use the previously determined offset and sigma to normalize the intensities in tile_3.nc, do\n    Gtile_3_int = grdgradient(\"tile_3.nc\", azim=30, norm=(cauchy=true,offset=\"\",sigma=\"\"),save_stats=:read)"
  },
  {
    "objectID": "documentation/modules/grdgradient.html#references",
    "href": "documentation/modules/grdgradient.html#references",
    "title": "grdgradient",
    "section": "References",
    "text": "References\nHorn, B.K.P., Hill-Shading and the Reflectance Map, Proceedings of the IEEE, Vol. 69, No. 1, January 1981, pp. 14-47. (http://people.csail.mit.edu/bkph/papers/Hill-Shading.pdf)"
  },
  {
    "objectID": "documentation/modules/grdgradient.html#source-code",
    "href": "documentation/modules/grdgradient.html#source-code",
    "title": "grdgradient",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdgradient(cmd0::String; kwargs...) - grdgradient.jl:41\ngrdgradient(arg1; kwargs...) - grdgradient.jl:46"
  },
  {
    "objectID": "documentation/modules/grdhisteq.html",
    "href": "documentation/modules/grdhisteq.html",
    "title": "grdhisteq",
    "section": "",
    "text": "Not yet"
  },
  {
    "objectID": "documentation/modules/grdhisteq.html#source-code",
    "href": "documentation/modules/grdhisteq.html#source-code",
    "title": "grdhisteq",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdhisteq(cmd0::String; kwargs...) - grdhisteq.jl:33\ngrdhisteq(arg1; kwargs...) - grdhisteq.jl:39"
  },
  {
    "objectID": "documentation/modules/grdinfo.html",
    "href": "documentation/modules/grdinfo.html",
    "title": "grdinfo",
    "section": "",
    "text": "grdinfo(cmd0::String=\"\", arg1=nothing; kwargs...)\nReads a 2-D grid file and reports metadata and various statistics for the (x,y,z) data in the grid file"
  },
  {
    "objectID": "documentation/modules/grdinfo.html#description",
    "href": "documentation/modules/grdinfo.html#description",
    "title": "grdinfo",
    "section": "Description",
    "text": "Description\nReads a 2-D grid file and reports metadata and various statistics for the data (v) and coordinates (x,y) in a grid (or x,y,z for a 3-D cube). The output information may report the minimum/maximum values for v and the coordinates, where the min/max of v occur, the spatial increments, and the number of nodes in each dimension, and [optionally] the mean, standard deviation, and/or the median, median absolute deviation (MAD) of v, and/or the mode (Least Median of Squares; LMS), LMS scale of v, and number of nodes set to NaN. We also report if the grid is pixel- or gridline-registered and if it is a Cartesian or Geographic data set (based on metadata in the file). We can also report information for 3-D netCDF data cubes, but note that data cubes are not compatible with options tiles, extrema, report_ingeog, and nearest=:b."
  },
  {
    "objectID": "documentation/modules/grdinfo.html#required-arguments",
    "href": "documentation/modules/grdinfo.html#required-arguments",
    "title": "grdinfo",
    "section": "Required Arguments",
    "text": "Required Arguments\ningrid : – A grid file name or a GMTgrid"
  },
  {
    "objectID": "documentation/modules/grdinfo.html#optional-arguments",
    "href": "documentation/modules/grdinfo.html#optional-arguments",
    "title": "grdinfo",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or oneliner or numeric: – oneliner=true | | numeric=true | oneliner=:n|:t\nFormats the report using tab-separated fields on a single line. The output is:\n\nname w e s n {b t} v0 v1 dx dy {dz} nx ny {nz} [x0 y0 {z0} x1 y1 {z1}] [med scale] [mean std rms] [n_nan] registration gtype\n\nThe data in brackets are output only if the corresponding options minmax_pos (with no directive), force_scan=1, and force_scan=2 are used, respectively, while the data in braces only apply if used with 3-D data cubes. Use oneliner=:t to place file name at the end of the output record or oneliner=:n, but preferably numeric=true, to only output numerical columns. The registration is either 0 (gridline) or 1 (pixel), while gtype is either 0 (Cartesian) or 1 (geographic). If the nearest option is used, the output format is instead NF w e s n {b t} v0 v1, where NF is the total number of files read and w e s n {b t} are rounded off (see nearest).\nD or tiles : – tiles=xoff | tiles=(xoff,yoff) | tiles=“+i”\nDivide a single grid’s domain (or the region domain, if no grid given) into tiles of size dx times dy (set via nearest). You can specify overlap between tiles by appending xoff[/yoff]. You may use the modifier +i to ignore tiles that have no data within each tile subregion. Default output is text region strings. Use oneliner to instead report four columns with xmin xmax ymin ymax per tile, or use -Ct to also have the region string appended as trailing text.\nE or extrema or extreme : – extrema=[:x|:y][“+l|+L|+u|+U”]\nReport the extreme values found on a per column (extrema=:x) or per row (extrema=:y) basis. By default, we look for the global maxima (+u|+U) for each column. Use extrema=“+l” or extrema=“+L” (or extrema=“x+l”, etc…) to look for minima instead. Upper case +L means we find the minimum of the positive values only, while upper case +U means we find the maximum of the negative values only [use all values]. We only allow one input grid when extrema is selected.\nF or report_ingeog : – report_ingeog=true\nReport grid domain and x/y-increments in world mapping format [Default is generic]. Does not apply to the oneliner option.\nG or download : – download=true\nForce (possible) download of all tiles of tiled global remote grids in order to report the requested information [refuse to give the information for tiled grids].\nI or nearest : – nearest=dx | nearest=(dx,dy) | nearest=:b|:i|:r\nReport the min/max of the region to the nearest multiple of dx and dy, and output this in the form -Rw/e/s/n (unless oneliner is set). To report the actual grid region, select nearest=:r. For a grid produced by the img supplement (a Cartesian Mercator grid), the exact geographic region is given with nearest=:i (if not found then we return the actual grid region instead). If no argument is given then we report the grid increment in the form -Ixinc/yinc. If nearest=:b is given we write each grid’s bounding box polygon instead. Finally, if tiles is in effect then dx and dy are the dimensions of the desired tiles.\nL or force_scan : – force_scan=0|1|2 | force_scan=:p|:a\n\n\nforce_scan=0 Report range of v after actually scanning the data, not just reporting what the header says.\nforce_scan=1 Report median and L1 scale of v (L1 scale = 1.4826 * Median Absolute Deviation (MAD)).\nforce_scan=2 Report mean, standard deviation, and root-mean-square (rms) of v.\nforce_scan=:p Report mode (LMS) and LMS scale of v.\nforce_scan=:a All of the above.\n\nNote: If the grid is geographic then each node represents a physical area that decreases with increasing latitude. We therefore report spherically weighted statistical estimates for such grids.\nM or minmax_pos : – minmax_pos=true | minmax_pos=:c|:f\nFind and report the location of min/max v-values, and count and report the number of nodes set to NaN, if any [Default]. Use minmax_pos=:f to instead force an update of the v-value min/max by reading the matrix, or use :c for conditionally doing so if the header information does not contain a valid v range.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or minmax : – minmax=true | minmax=“[dv][+a[alpha]][+s]”\nDetermine min and max data value. If dv is provided then we first round these values off to multiples of dv. To exclude the two tails of the distribution when determining the min and max you can add +a to set the combined alpha value (in percent [2]): We then sort the values, exclude the data in the 0.5 * alpha and 100 - 0.5 * alpha tails, and revise the min and max. Give alpha in the format alphaL/alphaR to select unequal tail areas. To force a symmetrical range about zero, using minus/plus the max absolute value of the two extremes, append +s. We report the result via the text string -Tvmin/vmax or -Tvmin/vmax/dv (if dv was given) as expected by makecpt.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at"
  },
  {
    "objectID": "documentation/modules/grdinfo.html#examples",
    "href": "documentation/modules/grdinfo.html#examples",
    "title": "grdinfo",
    "section": "Examples",
    "text": "Examples\nTo obtain all the information about the remote data set in file earth_relief_10m:\n    grdinfo(\"@earth_relief_10m\", force_scan=:a, minmax_pos=true)\nGet the grid spacing in earth_relief_10m:\n    dx = grdinfo(\"@earth_relief_10m\", oneliner=:n, outcols=7)\nTo learn about the extreme values and coordinates in the 3-D data cube S362ANI_kmps.nc?vs::\n    grdinfo(\"S362ANI_kmps.nc?vs\", minmax_pos=true)"
  },
  {
    "objectID": "documentation/modules/grdinfo.html#source-code",
    "href": "documentation/modules/grdinfo.html#source-code",
    "title": "grdinfo",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdinfo(cmd0::String; kwargs...) - grdinfo.jl:48\ngrdinfo(arg1; kwargs...) - grdinfo.jl:49"
  },
  {
    "objectID": "documentation/modules/grdinfo.html#see-also",
    "href": "documentation/modules/grdinfo.html#see-also",
    "title": "grdinfo",
    "section": "See Also",
    "text": "See Also\ngrd2cpt, grd2xyz, grdedit"
  },
  {
    "objectID": "documentation/modules/grdmask.html",
    "href": "documentation/modules/grdmask.html",
    "title": "grdmask",
    "section": "",
    "text": "grdmask(cmd0::String=\"\", arg1=nothing, kwargs...)\nCreate mask grid from polygons or point coverage."
  },
  {
    "objectID": "documentation/modules/grdmask.html#description",
    "href": "documentation/modules/grdmask.html#description",
    "title": "grdmask",
    "section": "Description",
    "text": "Description\ngrdmask can operate in two different modes. 1. It reads one or more pathfiles that each define a closed polygon. The nodes defined by the specified region and lattice spacing will be set equal to one of three possible values depending on whether the node is outside, on the polygon perimeter, or inside the polygon, with the assigned z value selected via out_edge_in. If multiple polygons overlap the same nodes then the polygon selected depends on the clobber selection. The resulting mask may be used in subsequent operations involving grdmath to mask out data from polygonal areas. 2. The pathfiles simply represent data point locations and the mask is set to the inside or outside value depending on whether a node is within a maximum distance from the nearest data point. If the distance specified is zero then only the nodes nearest each data point are considered “inside”."
  },
  {
    "objectID": "documentation/modules/grdmask.html#required-arguments",
    "href": "documentation/modules/grdmask.html#required-arguments",
    "title": "grdmask",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/grdmask.html#optional-arguments",
    "href": "documentation/modules/grdmask.html#optional-arguments",
    "title": "grdmask",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or steps : – steps=true | steps=:meridian|:parallel|:x|:y|:r|:theta\nBy default, geographic line segments (as indicated for example by the colinfo option) are drawn as great circle arcs. To draw them as straight lines, use the steps=true. Alternatively, use steps=:meridian to draw the line by first following a meridian, then a parallel. Or append steps=:parallel to start following a parallel, then a meridian. (This can be practical to draw a line along parallels, for example). For Cartesian data, points are simply connected, unless you use steps=:x or steps=:y to draw stair-case curves that whose first move is along x or y, respectively. If your Cartesian data are polar (theta, r), use steps=:t or steps=:r to construct stair-case paths whose first move is along theta or r, respectively.\nC or clobber : – clobber=:f|l|o|u\nClobber mode: Selects the polygon whose z-value will determine the grid nodes. Choose from the following modes: clobber=:f for the first polygon to overlap a node; o for the last polygon to overlap a node; l for the polygon with the lowest z-value, and u for the polygon with the uppermost z-value [Default is o]. Note: Does not apply to search_radius. For polygon z-values, see out_edge_in.\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nN or out_edge_in : – out_edge_in=values | out_edge_in=“z|Z|p|Pvalues”\nSets the out/edge/in that will be assigned to nodes that are outside the polygons, on the edge, or inside. Values can be any number, including the textstring NaN [Default is 0/0/1]. Optionally, use Nz to set polygon insides to the z-value obtained from the data (either segment header Zzval, Lheader or via aZ=name); use NZ to consider the polygon boundary as part of the inside. Alternatively, use Np to use a running number as polygon ID; optionally append start of the sequence [0]. Here, NP includes the polygon perimeter as inside. Note: out_edge_in=“z|Z|p|P” cannot be used in conjunction with seach_radius; they also all optionally accept /out [0].\nS or search_radius : – search_radius=rad | search_radius=(xlim,ylim)\nSet nodes to inside, on edge, or outside depending on their distance to the nearest data point. Nodes within radius [0] from the nearest data point are considered inside; append a distance unit (see [Units]). If radius is given as z then we instead read individual radii from the 3rd input column. Unless Cartesian data, specify the unit of these radii by appending it after -Sz. If search_radius is not set then we consider the input data to define one or more closed polygon(s) instead. For Cartesian data with different units you can instead use search_radius=(xlim,ylim) which will perform a rectangular search where all nodes within ± xlim and ± ylim of a data point will be considered inside. One can also achieve the rectangular selection effect by using the search_radius=n_cellsc form. Here n_cells means the number of cells around each data point. As an example, search_radius=“0c” means that only the cell where point lies is masked, search_radius=“1c” masks one cell beyond that (i.e. makes a 3x3 neighborhood), and so on.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nx or cores : – cores=N\nLimit the number of cores used when making the individual frames. By default we try to use all available cores. Append N to only use n cores (if too large it will be truncated to the maximum cores available). Finally, give a negative N to select (all - N) cores (or at least 1 if N equals or exceeds all). The parallel processing does not depend on OpenMP.\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/grdmask.html#insideoutside-status",
    "href": "documentation/modules/grdmask.html#insideoutside-status",
    "title": "grdmask",
    "section": "Inside/outside Status",
    "text": "Inside/outside Status\nTo determine if a point is inside, outside, or exactly on the boundary of a polygon we need to balance the complexity (and execution time) of the algorithm with the type of data and shape of the polygons. For any Cartesian data we use a non-zero winding algorithm, which is quite fast. For geographic data we will also use this algorithm as long as (1) the polygons do not include a geographic pole, and (2) the longitude extent of the polygons is less than 360. If this is the situation we also carefully adjust the test point longitude for any 360 degree offsets, if appropriate. Otherwise, we employ a full spherical ray-shooting method to determine a points status."
  },
  {
    "objectID": "documentation/modules/grdmask.html#notes",
    "href": "documentation/modules/grdmask.html#notes",
    "title": "grdmask",
    "section": "Notes",
    "text": "Notes\nA grid produced by grdmask is a categorical dataset. As such, one has to be careful not to interpolate it with standard methods, such as splines. However, if you make a map of this grid using a map projection the grid will be reprojected to yield a rectangular matrix in the projected coordinates. This interpolation is done using splines by default and thus may yield artifacts in your map. We recommend you use grdimage interp=:n to instead use a nearest neighbor interpolation for such cases."
  },
  {
    "objectID": "documentation/modules/grdmask.html#save-storage-space",
    "href": "documentation/modules/grdmask.html#save-storage-space",
    "title": "grdmask",
    "section": "Save storage space",
    "text": "Save storage space\nSince most uses of grdmask revolves around creating mask grids that hold just a few integer values (and perhaps NaN), we choose to write them to disk as byte grids by appending the suffix =nb to the desired grid filename. Some situations may store integers that exceed the range available in a byte and for those we specify a short integer grid with =ns. For larger integers you may consider =ni, otherwise use the default float grid format."
  },
  {
    "objectID": "documentation/modules/grdmask.html#examples",
    "href": "documentation/modules/grdmask.html#examples",
    "title": "grdmask",
    "section": "Examples",
    "text": "Examples\nTo set all nodes inside and on the polygons coastline_*.xy to 0, and outside points to 1, do\n    G = grdmask(\"coastline_*.xy\", region=(-60,-40,-40,-30), inc=\"5m\", out_edge_in=(1,0,0))\nTo set nodes within 50 km of data points to 1 and other nodes to NaN, do\n    G = grdmask(\"data.xyz\", region=(-60,-40,-40,-30), inc=\"5m\", out_edge_in=(NaN,1,1), search_radius=\"50k\")\nTo assign polygon IDs to the gridnodes using the insides of the polygons in plates.gmt, based on the attribute POL_ID, do\n    G = grdmask(\"plates.gmt\", region=(-40,-40,-40,-40), inc=\"2m\", out_edge_in=:z, aZ=POL_ID)\nSame exercise, but instead compute running polygon IDs starting at 100, do\n    G = grdmask(\"plates.gmt\", region=(-40,-40,-40,-40), inc=\"2m\", out_edge_in=\"p100\")"
  },
  {
    "objectID": "documentation/modules/grdmask.html#source-code",
    "href": "documentation/modules/grdmask.html#source-code",
    "title": "grdmask",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdmask(cmd0::String; kwargs...) - grdmask.jl:48\ngrdmask(arg1; kwargs...) - grdmask.jl:49"
  },
  {
    "objectID": "documentation/modules/grdmask.html#see-also",
    "href": "documentation/modules/grdmask.html#see-also",
    "title": "grdmask",
    "section": "See Also",
    "text": "See Also\ngrdlandmask, grdclip, mask, clip"
  },
  {
    "objectID": "documentation/modules/grdpaste.html",
    "href": "documentation/modules/grdpaste.html",
    "title": "grdpaste",
    "section": "",
    "text": "grdpaste(cmd0::String=\"\", arg1=nothing, arg2=nothing, kwargs...)\nJoin two grids along their common edge"
  },
  {
    "objectID": "documentation/modules/grdpaste.html#description",
    "href": "documentation/modules/grdpaste.html#description",
    "title": "grdpaste",
    "section": "Description",
    "text": "Description\nCombines ingrid_a and ingrid_b into outgrid by pasting them together along their common edge. Files ingrid_a and ingrid_b must have the same grid spacings and registration, and must have one edge in common. If in doubt, check with grdinfo and use grdcut and/or grdsample if necessary to prepare the edge joint. Note: For geographical grids, you may have to use colinfo to handle periodic longitudes unless the input grids are properly recognized as such via their meta-data. For stitching multiple grids, see grdblend instead."
  },
  {
    "objectID": "documentation/modules/grdpaste.html#required-arguments",
    "href": "documentation/modules/grdpaste.html#required-arguments",
    "title": "grdpaste",
    "section": "Required Arguments",
    "text": "Required Arguments\ningrid_a : – A grid file name or a GMTgrid\ningrid_b : – The other of two grids to be pasted together."
  },
  {
    "objectID": "documentation/modules/grdpaste.html#optional-arguments",
    "href": "documentation/modules/grdpaste.html#optional-arguments",
    "title": "grdpaste",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at"
  },
  {
    "objectID": "documentation/modules/grdpaste.html#examples",
    "href": "documentation/modules/grdpaste.html#examples",
    "title": "grdpaste",
    "section": "Examples",
    "text": "Examples\nSuppose file_a.nc is 150E - 180E and 0 - 30N, and file_b.nc is 150E - 180E, -30S - 0, then you can make outfile.nc which will be 150 - 180 and -30S - 30N by:\n    G = grdpaste(\"file_a.nc\", \"file_b.nc\", colinfo=:g);"
  },
  {
    "objectID": "documentation/modules/grdpaste.html#source-code",
    "href": "documentation/modules/grdpaste.html#source-code",
    "title": "grdpaste",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdpaste(G1::String, G2::String; kwargs...) - grdpaste.jl:54\ngrdpaste(G1::GItype, G2::String; kwargs...) - grdpaste.jl:51\ngrdpaste(G1::String, G2::GItype; kwargs...) - grdpaste.jl:50\ngrdpaste(G1::GItype, G2::GItype; kwargs...) - grdpaste.jl:21"
  },
  {
    "objectID": "documentation/modules/grdpaste.html#see-also",
    "href": "documentation/modules/grdpaste.html#see-also",
    "title": "grdpaste",
    "section": "See Also",
    "text": "See Also\ngrdblend, grdclip, grdcut, grdinfo, grdsample"
  },
  {
    "objectID": "documentation/modules/grdproject.html",
    "href": "documentation/modules/grdproject.html",
    "title": "grdproject",
    "section": "",
    "text": "Forward and inverse map transformation of grids\n(Warning: Manual translate by Claude. Needs revision)"
  },
  {
    "objectID": "documentation/modules/grdproject.html#synopsis",
    "href": "documentation/modules/grdproject.html#synopsis",
    "title": "grdproject",
    "section": "Synopsis",
    "text": "Synopsis\ngrdproject ingrid [ G | outgrid | save ] [ J | proj | projection ] [ C | center | origin ] [ D | inc | increment | spacing ] [ E | dpi ] [ F | scaling | force_scale ] [ I | inverse ] [ M | unit ] [ R | region | limits ] [ V | verbose ] [ j | spherical_dist | spherical ] [ n | interp | interpolation ] [ r | reg | registration ]"
  },
  {
    "objectID": "documentation/modules/grdproject.html#description",
    "href": "documentation/modules/grdproject.html#description",
    "title": "grdproject",
    "section": "Description",
    "text": "Description\ngrdproject will do one of two things depending whether inverse has been set. If set, it will transform a gridded data set from a rectangular coordinate system onto a geographical system by resampling the surface at the new nodes. If not set, it will project a geographical gridded data set onto a rectangular grid. To obtain the value at each new node, its location is inversely projected back onto the input grid after which a value is interpolated between the surrounding input grid values. By default bi-cubic interpolation is used. Aliasing is avoided by also forward projecting the input grid nodes. If two or more nodes are projected onto the same new node, their average will dominate in the calculation of the new node value. Interpolation and aliasing is controlled with the interpolation option. The new node spacing may be determined in one of several ways by specifying the grid spacing, number of nodes, or resolution. Nodes not constrained by input data are set to NaN.\nThe region option can be used to select a map region larger or smaller than that implied by the extent of the grid file."
  },
  {
    "objectID": "documentation/modules/grdproject.html#required-arguments",
    "href": "documentation/modules/grdproject.html#required-arguments",
    "title": "grdproject",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ningrid\n\n2-D binary grid file to be projected. Can be a file name, or GMTgrid object.\n\n\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)"
  },
  {
    "objectID": "documentation/modules/grdproject.html#optional-arguments",
    "href": "documentation/modules/grdproject.html#optional-arguments",
    "title": "grdproject",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nC or center : – center=true | center=(dx, dy) | center=“dx/dy”\nLet projected coordinates be relative to projection center [Default is relative to lower left corner]. Optionally, add offsets in the projected units to be added (or subtracted when inverse is set) to (from) the projected coordinates, such as false eastings and northings for particular projection zones [0/0].\nD or inc : – inc=xinc | inc=(xinc, yinc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSet the grid spacing for the new grid. If neither inc nor dpi are set then we select the same number of output nodes as there are input nodes. Available modifiers:\nGeographical (degrees) coordinates:\n\nAppend m to indicate arc minutes or s to indicate arc seconds.\nIf one of the units e, f, k, M, n or u is appended instead, the increment is assumed to be given in meter, foot, km, Mile, nautical mile or US survey foot, respectively, and will be converted to the equivalent degrees longitude at the middle latitude of the region (the conversion depends on PROJ_ELLIPSOID). If yinc is given but set to 0 it will be reset equal to xinc; otherwise it will be converted to degrees latitude.\n\nAll coordinates:\n\nexact or +e : exact=true – If appended then the corresponding max x (east) or y (north) may be slightly adjusted to fit exactly the given increment [by default the increment may be adjusted slightly to fit the given domain].\nnumber or +n : number=true – Instead of giving an increment you may specify the number of nodes desired; the increment is then recalculated from the number of nodes and the domain. The resulting increment value depends on whether you have selected a gridline-registered or pixel-registered grid.\n\nNote: If region is set from a grid file then the grid spacing (and registration) have already been initialized; use inc (and registration) to override the values.\nE or dpi : – dpi=value\nSet the resolution for the new grid in dots per inch.\nF or one2one : – scaling=:e | one2one=:f | one2one=“c|i|p|e|f|k|M|n|u”\nForce 1:1 scaling, i.e., output (or input, see inverse) data are in actual projected meters [:e]. To specify other units, use:\n\n:f : foot\n:k : km\n:M : statute mile\n:n : nautical mile\n:u : US survey foot\n:i : inch\n:c : cm\n:p : point\n\nWithout scaling, the output (or input, see inverse) are in the units specified by PROJ_LENGTH_UNIT (but see unit).\nI or inverse : – inverse=true\nDo the inverse transformation, from rectangular to geographical.\nM or projected_unit : – projected_unit=:c | projected_unit=:i | projected_unit=:p\nAppend :c, :i, or :p to indicate that cm, inch, or point should be the projected measure unit [Default is set by PROJ_LENGTH_UNIT in gmt.conf]. Cannot be used with scaling.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)"
  },
  {
    "objectID": "documentation/modules/grdproject.html#output-region-issues",
    "href": "documentation/modules/grdproject.html#output-region-issues",
    "title": "grdproject",
    "section": "Output Region Issues",
    "text": "Output Region Issues\nThe boundaries of a projected (rectangular) data set will not necessarily give rectangular geographical boundaries (Mercator is one exception). In those cases some nodes may be unconstrained (set to NaN). To get a full grid back, your input grid may have to cover a larger area than you are interested in."
  },
  {
    "objectID": "documentation/modules/grdproject.html#select-ellipsoidal-versus-spherical-solution",
    "href": "documentation/modules/grdproject.html#select-ellipsoidal-versus-spherical-solution",
    "title": "grdproject",
    "section": "Select Ellipsoidal versus Spherical Solution",
    "text": "Select Ellipsoidal versus Spherical Solution\nGMT will use ellipsoidal formulae if they are implemented and the user have selected an ellipsoid as the reference shape (see PROJ_ELLIPSOID). The user needs to be aware of a few potential pitfalls:\n\nProjection-dependent switching: For some projections, such as Transverse Mercator, Albers, and Lambert’s conformal conic we use the ellipsoidal expressions when the areas mapped are small, and switch to the spherical expressions (and substituting the appropriate auxiliary latitudes) for larger maps. The ellipsoidal formulae are used as follows:\n\nTransverse Mercator: When all points are within 10 degrees of central meridian\nConic projections: When longitudinal range is less than 90 degrees\nCassini projection: When all points are within 4 degrees of central meridian\n\nHistorical data matching: When you are trying to match some historical data (e.g., coordinates obtained with a certain projection and a certain reference ellipsoid) you may find that GMT gives results that are slightly different. One likely source of this mismatch is that older calculations often used less significant digits. For instance, Snyder’s examples often use the Clarke 1866 ellipsoid (defined by him as having a flattening f = 1/294.98). From f we get the eccentricity squared to be 0.00676862818 (this is what GMT uses), while Snyder rounds off and uses 0.00676866. This difference can give discrepancies of several tens of cm. If you need to reproduce coordinates projected with this slightly different eccentricity, you should specify your own ellipsoid with the same parameters as Clarke 1866, but with f = 1/294.97861076. Also, be aware that older data may be referenced to different datums, and unless you know which datum was used and convert all data to a common datum you may experience mismatches of tens to hundreds of meters.\nScale factors: Be aware that PROJ_SCALE_FACTOR have certain default values for some projections so you may have to override the setting in order to match results produced with other settings.\n\nThe decision of ellipsoidal (if available) versus spherical is taken in this order: - The user specifies spherical=:e which forces the ellipsoidal solution. - The user specifies spherical=:g which forces the spherical solution. - A specific region is set via region which implies that portions of that region will be more than stated limit of longitude from the specific (or implied if not set) central meridian.\nWhen a spherical solution is requested or implied, we consider the currently selected ellipsoid and substitute the relevant auxiliary latitude as latitude in the exact equation. Finally, coordinate conversion may also be affected by the selected PROJ_SCALE_FACTOR which is typically 0.9996 but is 1 for a sphere.\nNote: For some projection, a spherical solution may be used despite the user having selected an ellipsoid. This occurs when the user’s region setting implies a region that exceeds the domain in which the ellipsoidal series expansions are valid. These are the conditions: 1. Lambert Conformal Conic (:LambertConic) and Albers Equal-Area (:AlbersEqualArea) will use the spherical solution when the map scale exceeds 1.0E7. 2. Transverse Mercator (:TransverseMercator) and UTM (:UTM) will use the spherical solution when either the west or east boundary given in region is more than 10 degrees from the central meridian. 3. Same for Cassini (:Cassini) but with a limit of only 4 degrees."
  },
  {
    "objectID": "documentation/modules/grdproject.html#source-code",
    "href": "documentation/modules/grdproject.html#source-code",
    "title": "grdproject",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdproject(cmd0::String; kwargs...) - grdproject.jl:41\ngrdproject(arg1; kwargs...) - grdproject.jl:42"
  },
  {
    "objectID": "documentation/modules/grdproject.html#see-also",
    "href": "documentation/modules/grdproject.html#see-also",
    "title": "grdproject",
    "section": "See Also",
    "text": "See Also\nmapproject"
  },
  {
    "objectID": "documentation/modules/grdrotater.html",
    "href": "documentation/modules/grdrotater.html",
    "title": "grdrotater",
    "section": "",
    "text": "grdrotater(cmd0::String=\"\", arg1=nothing; kwargs...)\nTakes a geographical grid and reconstructs it given total reconstruction rotations.\nSee full GMT docs at grdrotater"
  },
  {
    "objectID": "documentation/modules/grdrotater.html#parameters",
    "href": "documentation/modules/grdrotater.html#parameters",
    "title": "grdrotater",
    "section": "Parameters",
    "text": "Parameters\n\nA | rot_region :: [Type =&gt; Str | Tuple | Vec]\nSpecify directly the region of the rotated grid.\nD | rot_outline :: [Type =&gt; Bool or Str] \\(Arg = true | filename\\)\nName of the grid polygon outline file. This represents the outline of the grid reconstructed to the specified time.\nF | rot_polyg | rot_polygon :: [Type =&gt; Str | GMTdaset | Mx2 array] \\(Arg = filename | dataset)\\)\nSpecify a multisegment closed polygon file that describes the inside area of the grid that should be rotated.\nG | save | outgrid | outfile :: [Type =&gt; Str]\nOutput grid file name. Note that this is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = grdrotater(….) form.\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nT | ages :: [Type =&gt; Str | Tuple]\nSets the desired reconstruction times. For a single time append the desired time. (http://docs.generic-mapping-tools.org/latest/grdrotater.html#t)\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr.\nb | binary :: [Type =&gt; Str]\nd | nodata :: [Type =&gt; Str or Number] \\(Arg = [i|o]nodata\\)\nControl how user-coded missing data values are translated to official NaN values in GMT.\nf | geog | colinfo | coltypes | coltype :: [Type =&gt; Str] \\(Arg = [i|o]colinfo\\)\nSpecify the data types of input and/or output columns (time or geographical data).\ng | gap :: [Type =&gt; Str] \\(Arg = [a]x|y|d|X|Y|D|[col]z[+|-]gap[u]\\)\nExamine the spacing between consecutive data points in order to impose breaks in the line.\nh | header :: [Type =&gt; Str] \\(Arg = [i|o][n][+c][+d][+rremark][+ttitle]\\)\nPrimary input file(s) has header record(s).\nn | interp | interpolation :: [Type =&gt; Str] \\(Arg = [b|c|l|n][+a][+bBC][+c][+tthreshold]\\)\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation, l for bilinear interpolation, or n for nearest-neighbor value.\no | outcols | outcol :: [Type =&gt; Str] \\(Arg = cols[,…]\\)\nSelect specific data columns for primary output, in arbitrary order.\n\n\nExample\n\nusing GMT\n\nG = grdmath(\"-R-5/5/-5/5 -I0.1 -fg X Y HYPOT\");\ntri = [-2.411 -1.629; -0.124 2.601; 2.201 -1.629; -2.410 -1.629];\nGr, tri_rot = grdrotater(G, rotation=\"-40.8/32.8/-12.9\", rot_outline=true, rot_polygon=tri);\nimshow(Gr, plot=(data=tri_rot,))"
  },
  {
    "objectID": "documentation/modules/grdrotater.html#source-code",
    "href": "documentation/modules/grdrotater.html#source-code",
    "title": "grdrotater",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdrotater(cmd0::String; ...) - grdrotater.jl:47\ngrdrotater(; ...) - grdrotater.jl:47\ngrdrotater(cmd0::String, arg1; kwargs...) - grdrotater.jl:47\ngrdrotater(arg1; kw...) - grdrotater.jl:46"
  },
  {
    "objectID": "documentation/modules/grdrotater.html#see-also",
    "href": "documentation/modules/grdrotater.html#see-also",
    "title": "grdrotater",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/grdspotter.html",
    "href": "documentation/modules/grdspotter.html",
    "title": "grdspotter",
    "section": "",
    "text": "Create CVA grid from a gravity or topography grid.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/grdtrend.html",
    "href": "documentation/modules/grdtrend.html",
    "title": "grdtrend",
    "section": "",
    "text": "grdtrend(cmd0::String=\"\", arg1=nothing, arg2=nothing; kwargs...)\nFit trend surface to grids and compute residuals"
  },
  {
    "objectID": "documentation/modules/grdtrend.html#description",
    "href": "documentation/modules/grdtrend.html#description",
    "title": "grdtrend",
    "section": "Description",
    "text": "Description\ngrdtrend reads a 2-D grid and fits a low-order polynomial trend to these data by [optionally weighted] least-squares. The trend surface is defined by:\n\\[m_1 + m_2x + m_3y + m_4xy + m_5x^2 + m_6y^2 + m_7x^3 + m_8x^2y + m_9xy^2 + m_{10}y^3\\]\nThe user must specify -N n_model, the number of model parameters to use; thus, -N 3 fits a bilinear trend, -N 6 a quadratic surface, and so on. Optionally, append +r to the |-N| option to perform a robust fit. In this case, the program will iteratively reweight the data based on a robust scale estimate, in order to converge to a solution insensitive to outliers. This may be handy when separating a “regional” field from a “residual” which should have non-zero mean, such as a local mountain on a regional surface. Optionally, you may choose to fit a trend that varies only along the x or y axis, in which case you select an n_model from 1 (constant) to 4 (cubic).\nIf data file has values set to NaN, these will be ignored during fitting; if output files are written, these will also have NaN in the same locations."
  },
  {
    "objectID": "documentation/modules/grdtrend.html#required-arguments",
    "href": "documentation/modules/grdtrend.html#required-arguments",
    "title": "grdtrend",
    "section": "Required Arguments",
    "text": "Required Arguments\nThe 2-D gridded data set.\n-N or model : – model=n_model | model=(n=?, robust=true, xonly=true, yonly=true)\nn_model sets the ID of the highest model parameters to fit. Use model=(n=n_model, robust=true for robust fit. As an option, add either xonly=true or yonly=true to only fit a model that depends on x or y terms, respectively. This means we either fit \\(m_1 + m_2x + m_3x^2 + m_4x^3\\) or \\(m_1 + m_2y + m_3y^2 + m_4y^3\\). Note that n_model may only be 1-4 for the one-dimensional fits but may be 1-10 for the two-dimensional surface fits."
  },
  {
    "objectID": "documentation/modules/grdtrend.html#optional-arguments",
    "href": "documentation/modules/grdtrend.html#optional-arguments",
    "title": "grdtrend",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nD or diff : – diff=true | diff=“diff.grd”\nCompute and return the difference (input data - trend). The form diff=“diff.grd” writes the resul to to the file diff.grd.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or trend : – trend=true | trend=“trend.grd”\nCompute and return the fitted trend. The form trend=“trend.grd” writes the resul to to the file trend.grd.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\n\n-W or weights : – weights=“weight.grd[+s]”\nIf weight.grd exists, it will be read and used to solve a weighted least-squares problem. [Default: Ordinary least-squares fit]. Append +s to instead read data uncertainties (one sigma) and create weights as 1/sigma^2. If the robust option has been selected, the weights used in the robust fit will be written to weight.nc."
  },
  {
    "objectID": "documentation/modules/grdtrend.html#remarks",
    "href": "documentation/modules/grdtrend.html#remarks",
    "title": "grdtrend",
    "section": "Remarks",
    "text": "Remarks\nThe domain of x and y will be shifted and scaled to [-1, 1] and the basis functions are built from Legendre polynomials. These have a numerical advantage in the form of the matrix which must be inverted and allow more accurate solutions. NOTE: The model parameters listed with verbose are Legendre polynomial coefficients; they are not numerically equivalent to the \\(m_j\\) in the equation described above. The description above is to allow the user to match model with the order of the polynomial surface. See grdmath if you need to evaluate the trend using the reported coefficients."
  },
  {
    "objectID": "documentation/modules/grdtrend.html#examples",
    "href": "documentation/modules/grdtrend.html#examples",
    "title": "grdtrend",
    "section": "Examples",
    "text": "Examples\nTo remove a planar trend from the remote grid earth_relief_05m for the region around Hawaii:\n    G = grdtrend(\"@earth_relief_05m\", region=(180,240,10,40), model=3, diff=true)\nTo do a robust fit of a bicubic surface to hawaii_topo.nc, writing the result in hawaii_trend.nc and the weights used in hawaii_weight.nc, and reporting the progress:\n    grdtrend(\"hawaii_topo.nc\", model=(n=10, robust=true), trend=\"hawaii_trend.nc\",\n             weights=\"hawaii_weight.nc\", verbose=true)"
  },
  {
    "objectID": "documentation/modules/grdtrend.html#source-code",
    "href": "documentation/modules/grdtrend.html#source-code",
    "title": "grdtrend",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdtrend(cmd0::String; ...) - grdtrend.jl:27\ngrdtrend(; ...) - grdtrend.jl:27\ngrdtrend(cmd0::String, arg1; ...) - grdtrend.jl:27\ngrdtrend(arg1, arg2; kw...) - grdtrend.jl:72\ngrdtrend(arg1; ...) - grdtrend.jl:72\ngrdtrend(cmd0::String, arg1, arg2; kwargs...) - grdtrend.jl:27"
  },
  {
    "objectID": "documentation/modules/grdtrend.html#see-also",
    "href": "documentation/modules/grdtrend.html#see-also",
    "title": "grdtrend",
    "section": "See Also",
    "text": "See Also\ngrdfft, grdfilter, grdmath"
  },
  {
    "objectID": "documentation/modules/grdview.html",
    "href": "documentation/modules/grdview.html",
    "title": "grdview",
    "section": "",
    "text": "grdview(cmd0::String=\"\"; kwargs...)\nCreate 3-D perspective image or surface mesh from a grid"
  },
  {
    "objectID": "documentation/modules/grdview.html#description",
    "href": "documentation/modules/grdview.html#description",
    "title": "grdview",
    "section": "Description",
    "text": "Description\nReads a 2-D grid and produces a a 3-D perspective plot by drawing a mesh, painting a colored/grayshaded surface made up of polygons, or by scanline conversion of these polygons to a raster image. Options include draping a data set on top of a surface, plotting of contours on top of the surface, and apply artificial illumination based on intensities provided in a separate grid.\nThe region option can be used to select a map region larger or smaller than that implied by the extent of the grid."
  },
  {
    "objectID": "documentation/modules/grdview.html#required-arguments",
    "href": "documentation/modules/grdview.html#required-arguments",
    "title": "grdview",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nJz or JZ or zscale or zsize : zscale=scale | zsize=size\nSet z-axis scaling or or z-axis size. zsize=size sets the size to the fixed value size (for example zsize=10 or zsize=4i). zscale=scale sets the vertical scale to UNIT/z-unit."
  },
  {
    "objectID": "documentation/modules/grdview.html#optional-arguments",
    "href": "documentation/modules/grdview.html#optional-arguments",
    "title": "grdview",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name. Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=\"color1,color2[,color3 ,...]\" or color=((r1,g1,b1),(r2,g2,b2),...) to build a linear continuous CPT from those colors automatically (see [Setting color]). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map. Must be present if you want (1) mesh plot with contours (surftype=(mesh=true,)), or (2) shaded/colored perspective image (surftype=(surface=true,) or surftype=(img=true,)). For surftype=(surface=true,) you can specify that you want to skip a z-slice by setting the red r/g/b component to -.\nG or drape : – drape=grid | drape=(grid_r, grid_g, grid_b) | drape=image\nDrape the image in drapegrid on top of the relief provided by reliefgrid. [Default determines colors from reliefgrid]. Note that zsize and plane always refers to the reliefgrid. The drapegrid only provides the information pertaining to colors, which (if drape is a grid) will be looked-up via the CPT (see color). Instead, you may give three grid files via separate drape options in the specified order. These files must contain the red, green, and blue colors directly (in 0-255 range) and no CPT is needed. The drapegrid may be of a different resolution than the reliefgrid. Finally, drapegrid may be an image to be draped over the surface, in which case the color option is not required. For the drape image case it is important that both reliefgrid and drapeimage carry referencing information. In that case, the reliefgrid can be in geograpgic coordinates and drapeimage in any projection system. Otherwise, we try to figure out what to do but things may ofc go wrong.\nisgeog : – isgeog=true\nWhen drapping an image that has a projection info, over a grid that is in geographics but does not carry any information about this fact we may need to use this option to help the program finding the common BoundingBox. Used only together with drape\nclim : – clim=(z_min,z_max)\nWhen doing an automatic colorization (i.e., when a colormap is not provided explicitly), limit the automatic color map to be computed between z_min,z_max. Grid values below z_min and above z_max will be painted with the same color as those.\nequalize : – equalize=true | equalize=ncolors\nWith automatic colorization, map data values to colors through the data’s cumulative distribution function (CDF), so that the colors are histogram equalized. Default (with equalize=true) chooses arbitrary values by a crazy scheme based on equidistant values for a Gaussian CDF. Use equalize=ncolors to specify the desire number of colors.\npercent : – percent=pct\nExclude the two tails of the distribution (in percentage). Grid values are sorted and we exclude data in 0.5pct and 100 - 0.5pct from the automatic colormap determination. This option is specially useful when the grid has outliers.\nI or shade or intensity : – shade=grid | shade=azim | shade=(azimuth=az, norm=params, auto=true)\nGives the name of a grid with intensities in the (-1,+1) range, or a constant intensity to apply everywhere (affects the ambient light). Alternatively, derive an intensity grid from the input data grid grd_z via a call to grdgradient; use shade=(azimuth=az,) or shade=(azimuth=az, norm=params) to specify azimuth and intensity arguments for that module or just give shade=(auto=true,) to select the default arguments (azim=-45,norm=:t1). If you want a more specific intensity scenario then run grdgradient separately first.\nN or plane : – plane=lev | plane=(lev, fill)\nDraws a plane at this z-level. If the optional color is provided via plane=(lev, fill), and the projection is not oblique, the frontal facade between the plane and the data perimeter is colored. See -Wf for setting the pen used for the outline.\nQ or surf or surftype : – surftype=(mesh=true, waterfall=(:rows | :cols [,fill]), surface=true, image=true, nan_alpha=true, monochrome=true)\nSelect one of following settings. For any of these choices, you may force a monochrome image by setting monochrome=true. Colors are then converted to shades of gray using the (monochrome television) YIQ transformation. Note: pay attention to always use a tuple, even when only one option is used. This is correct: surf=(img=true,) but this is wrong: surf=(img=true)\n\nSpecify mesh=true for mesh plot [Default], and optionally set a color (see [Setting color]), with mesh=color, for a different mesh paint.\nSpecify waterfall=:rows or :cols for waterfall plots (row or column profiles). Specify fill color or patterns with a second argument. For example waterfall=(:rows, :red)\nSpecify surface=true for surface plot, and optionally add mesh=true to have mesh lines drawn on top of surface.\nSpecify image=true for image plot. Optionally use image=dpi to set the effective dpi resolution for the rasterization [100].\nSpecify nan\\_alpha=true, same as image=true but will make nodes with z = NaN transparent, using the colormasking feature in PostScript Level 3.\n\nR or region or limits : – limits=(xmin, xmax, ymin, ymax, zmin, zmax) | limits=(BB=(xmin, xmax, ymin, ymax, zmin, zmax),) | …more\nSpecify the region of interest. Default limits are computed from data extents. More at [limits](../common_opts/opt_R.html)\nS or smooth : – smooth=smoothfactor\nUsed to resample the contour lines at roughly every (gridbox_size/smoothfactor) interval.\nT or no_interp : – no_interp=(skip=true, outlines=true)\nPlot image without any interpolation. This involves converting each node-centered bin into a polygon which is then painted separately. Use skip=true to skip nodes with z = NaN. This option is useful for categorical data where interpolating between values is meaningless. Optionally, add outlines=true to draw the tile outlines. If the default pen is not to your liking, use outlines=pen (see [Pen attributes]). As this option produces a flat surface it cannot be combined with -JZ or -Jz.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen or pens\n\n\npens=(contour=true,)\nDraw contour lines on top of surface or mesh (not image). Use pens=(contour=true, pen) to set pen attributes used for the contours. [Default: width = 0.75p, color = black, style = solid].\npens=(mesh=true, pen)\nSets the pen attributes used for the mesh. [Default: width = 0.25p, color = black, style = solid]. You must also select surftype=(mesh=true,) or surftype=(surface=true, mesh=true) for meshlines to be drawn.\npens=(facade=true, pen)\nSets the pen attributes used for the facade. [Default: width = 0.25p, color = black, style = solid]. You must also select plane for the facade outline to be drawn.\n\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/grdview.html#examples",
    "href": "documentation/modules/grdview.html#examples",
    "title": "grdview",
    "section": "Examples",
    "text": "Examples\nSee the Example 04 at the Historical Collection gallery.\nMake a low resolution image plot with texture draping. Use a dpi=50 to make it lighter to load the man page. The drape option is used to overlay an image texture (from a cork tree trunk) on the grid data from the Gulf of Guinea zone. (Note, the viz function calls grdview when it detects the view option)\n\nusing GMT\n\nG = grdcut(\"@earth_relief_01m\", region=(0,10,0,10));\nviz(G, shade=\"+nt0.5\", proj=:merc, view=(145,35), drape=\"@wood_texture.jpg\", zsize=5, surftype=(image=50,))\n\n\n\n\n\n\n\n\nThis example imagines that a OVNI (UFO) ship is pointing a spot light with a radius of 100 km over Denver.\n\nusing GMT\n\nG = grdcut(\"@earth_relief_30s\", region=(-108,-103,35,40));\n\n# Compute the distances to Denver (here we need to use the terse syntax)\nGr = grdmath(\"-R? -104.9903 39.7392 SDIST\", G);\n\n# Mask distances &gt; 100 km\nGinside = Gr &lt; 100;\n\n# Compute gradients along two directions to use in shading.\nGint1 = grdgradient(G, azim=90, norm=(cauchy=true, amp=1));\nGint2 = grdgradient(G, azim=45, norm=(cauchy=true, amp=1));\n\n# Combine the gradients\nGint = Gint2 * 0.5 + Gint1 + Ginside - 0.5;\n\n# View the result\nC = makecpt(range=(1000,4000));\ngrdview(G, shade=Gint, proj=:merc, zsize=1, view=(155,25), colormap=C, surftype=:image, show=true)"
  },
  {
    "objectID": "documentation/modules/grdview.html#source-code",
    "href": "documentation/modules/grdview.html#source-code",
    "title": "grdview",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdview(cmd0::String; kwargs...) - grdview.jl:46\ngrdview(arg1; kwargs...) - grdview.jl:47"
  },
  {
    "objectID": "documentation/modules/greenspline.html",
    "href": "documentation/modules/greenspline.html",
    "title": "greenspline",
    "section": "",
    "text": "Interpolate using Green’s functions for splines in 1-3 dimensions\n(Warning: Manual translate by Claude. Needs revision)"
  },
  {
    "objectID": "documentation/modules/greenspline.html#synopsis",
    "href": "documentation/modules/greenspline.html#synopsis",
    "title": "greenspline",
    "section": "Synopsis",
    "text": "Synopsis\ngreenspline table [ A | gradient] [ C | approx| approximate ] [ D | metadata | metadata] [ E | misfit] [ G | outgrid | save ] [ I | inc | increment | spacing ] [ L | leave_trend ] [ N | nodes] [ Q | dir_derivative] [ R | region | limits ] [ S | splines ] [ T | mask] [ V | verbose ] [ W | uncertainties] [ Z | mode | distmode ] [ b | binary ] [ d | nodata ] [ e | pattern ] [ f | colinfo ] [ h | header ] [ i | incol | incols ] [ o | outcol | outcols ] [ r | reg | registration ] [ x | cores ] [ : | yx ]"
  },
  {
    "objectID": "documentation/modules/greenspline.html#description",
    "href": "documentation/modules/greenspline.html#description",
    "title": "greenspline",
    "section": "Description",
    "text": "Description\ngreenspline uses the Green’s function for the chosen spline and geometry to interpolate data at regular or arbitrary output locations. Choose between minimum curvature, regularized, or continuous curvature splines in tension for either 1-D, 2-D, or 3-D Cartesian coordinates or spherical surface coordinates. Mathematically, the solution is composed as a sum of Green’s functions and a trend function. The unknown coefficients are determined by requiring the solution to fit the observed data points exactly or approximately (via SVD)."
  },
  {
    "objectID": "documentation/modules/greenspline.html#required-arguments",
    "href": "documentation/modules/greenspline.html#required-arguments",
    "title": "greenspline",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nThe name of one or more data files (or a GMTdataset or Matrix) holding the x, w data points. If no input is given then standard input is read."
  },
  {
    "objectID": "documentation/modules/greenspline.html#optional-arguments",
    "href": "documentation/modules/greenspline.html#optional-arguments",
    "title": "greenspline",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or gradient : – gradient=gradfile | gradient=“gradfile+f1”\nAppend name of file with surface gradients to partly constrain the solution. Use modifier +f to select one of these input formats:\n\n0: For 1-D data, gradient magnitude (slope) only: x, v\n1: Records contain x, y, azimuth, v (azimuth in degrees clockwise from north) [Default for 2-D]\n2: Records contain x, y, v, azimuth\n\n3: Records contain x, direction(s), v (directions counter-clockwise from horizontal)\n4: Records contain x, gradient components (2-D or 3-D)\n5: Records contain x, unit vector, v (2-D or 3-D)\n\nC or approx or approximate : – approx=cutoff | approx=(n=:, mode=:r, cutoff=0.01, file=“eigen.txt”, cumulative=true, incremental=true, dryrun=true)\nFind an approximate surface fit using singular value decomposition (SVD) and eliminate contribution from smaller eigenvalues [Default uses Gauss-Jordan elimination for exact fit]. Append a directive:\n\nn: Retain only the specified number of largest eigenvalues (e.g., C=(n=100,))\nr: Retain eigenvalues whose ratio to largest eigenvalue is less than value [Default]\nv: Retain eigenvalues needed to ensure model prediction variance fraction is at least value\n\nOptional modifiers (use as named tuple members):\n\ncumulative=true: Produce cumulative sum of contributions, one grid per eigenvalue (2-D only)\nincremental=true: Produce incremental sum of contributions, one grid per eigenvalue (2-D only)\nfile=“filename”: Save eigenvalues to specified file\ndryrun=true: Save eigenvalues and exit without surface output (requires file)\n\nD or meta or metadata: – meta=(xname=“…”, yname=“…”, zname=“…”, vname=“…”, …)\nControl netCDF grid metadata. Use named tuple with these optional members:\n\nxname, yname, zname: Dimension names (with optional units in brackets)\nvname: Variable name for data\nscale, offset: Scale factor and offset for data values\ninvalid: Value used for NaN or missing data\ntitle, remark: Title and remark strings\n\nE or misfit : – misfit=true | misfit=“misfitfile” | misfit=(misfitfile=“…”, reportfile=“…”)\nEvaluate spline exactly at input data locations and report misfit statistics. If E=true, statistics are written to stderr. If a filename is given, write data table augmented by spline estimate and misfit columns. If C is used with history modifiers, write eigenvalue analysis table instead. Use named tuple for multiple outputs: julia     E=(misfitfile=\"misfit.txt\", reportfile=\"report.txt\")\nG or outgrid or save : – save=“outfile.grd” | save=“table.txt”\nSpecify output filename. For 2-D grids, a grid file is required. For 3-D, can be a cube file, a template for multiple 2-D grids (with floating-point format like \"layer_%g.grd\"), or omitted for ASCII/binary table output. For arbitrary output locations (with N), this specifies the output table name. Ignored if C is specified.\nI or inc or increment or spacing : – inc=xinc | inc=(xinc,yinc) | inc=(xinc,yinc,zinc)\nSpecify equidistant sampling intervals. For 1-D, give xinc; for 2-D, give xinc and yinc; for 3-D, give xinc, yinc, and zinc.\nL or leave_trend : – leave_trend=true | leave_trend=:t | leave_trend=:r | leave_trend=:tr\nControl detrending and normalization of data prior to solving. Append directives:\n\n:t: Remove and restore linear least-squares trend\n:r: Normalize and restore data by maximum absolute residual value\n\nDefault applies both detrending and normalization when geometrically permissible.\nN or nodes : – nodes=“nodefile”\nASCII file with coordinates of desired output locations in the first column(s). The resulting values are appended to each record and written to the file given in G (or stdout).\nQ or dir_derivative : – dir_derivative=az | dir_derivative=(x,y,z)\nTake directional derivative instead of evaluating solution. For 1-D, give nothing (uses derivative). For 2-D, give azimuth in degrees. For 3-D, give three components of desired vector direction as a tuple; the vector will be normalized.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS oe splines : – splines=:c | splines=:t | splines=(:t, tension) | splines=(:q, tension, params…)\nSelect spline type. Append directive for spline selection:\n\n:c: Minimum curvature spline (1-D, 2-D, or 3-D Cartesian)\n:l: Linear or bilinear spline (1-D or 2-D Cartesian)\n:p: Minimum curvature spline for spherical surface (Parker, 1994)\n:q: Continuous curvature spline in tension for spherical surface (Wessel & Becker, 2008); append tension\n:r: Regularized spline in tension (Mitasova & Mitas, 1993); append tension and optional scale\n:t: Continuous curvature spline in tension (Wessel & Bercovici, 1998); append tension and optional scale\n\nFor :q, optional modifiers as named tuple:\n\nlimit: Truncation error for Legendre sum [1e-6]\nn: Number of points in spline setup [10001] (must be odd)\n\nExample: julia   S=(:t, 0.7)                           # Tension 0.7   S=(:r, 0.95, 50)                      # Tension 0.95, scale 50   S=(:q, 0.85, limit=1e-8, n=15001)     # Spherical with custom parameters\nT or mask : – mask=“maskgrid”\nFor 2-D interpolation only. Evaluate solution only at nodes in maskgrid that are not NaN. This option eliminates the need for R, I, and r.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or uncertainties : – uncertainties=true | uncertainties=:w\nData one-sigma uncertainties are in the last column. Compute weights inversely proportional to uncertainties squared. Append :w if weights are given directly instead of uncertainties (no squaring). Results in weighted least squares fit. Only has effect with C.\nZ or mode or distmode : – distmode=mode\nSet distance mode for calculating distances between data points:\n\n0: (x) in user units, Cartesian distances (1-D)\n1: (x,y) in user units, Cartesian distances (2-D)\n2: (x,y) in degrees, Flat Earth distances (2-D)\n3: (x,y) in degrees, Spherical distances in km (2-D)\n4: (x,y) in degrees, cosine of great circle arcs (spherical surface; requires S=:p or S=:q)\n5: (x,y,z) in user units, Cartesian distances (3-D)\n\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/greenspline.html#examples",
    "href": "documentation/modules/greenspline.html#examples",
    "title": "greenspline",
    "section": "Examples",
    "text": "Examples\n\n1-D Spline\nResample 1-D data using minimum curvature spline:\n\nusing GMT\n\n# Create sample data\ndata = [1.0 2.0; 3.0 4.5; 5.0 3.0; 7.0 5.5; 9.0 6.0];\n\n# Minimum curvature spline\nresult = greenspline(data, region=\"0/10\", inc=0.1, S=:c);\nplot(data)\nplot!(result, lc=:blue, show=true)\n\n\n\n\n\n\n\n\nSpline in tension (tension = 0.7):\nresult = greenspline(data, region=\"0/10\", inc=0.1, S=(:t, 0.7))\n\n\n2-D Cartesian Grid\nCreate uniform grid using minimum curvature spline:\n# Load data\ndata = gmtread(\"@Table_5_11.txt\")\n\n# Minimum curvature spline\nG = greenspline(data, region=(0,6.5,-0.2,6.5), inc=0.1, S=:c, Z=1)\nSpline in tension with mask:\n# Only evaluate where mask is not NaN\nG = greenspline(data, T=\"mask.nc\", S=(:t, 0.5), Z=1, save=\"result.nc\")\nRegularized spline in tension:\n# Return directional derivative (NW direction, -45°)\nG = greenspline(data, region=(0,6.5,-0.2,6.5), inc=0.1, S=(:r, 0.95), \n                Z=1, Q=-45, save=\"slopes.nc\")\n\n\nApproximate Fit with SVD\nCartesian cubic spline retaining 100 largest eigenvalues:\nG = greenspline(data, region=(0,6.5,-0.2,6.5), inc=0.1, S=:c, Z=1, \n                C=(n=100,), save=\"approx.nc\")\nEvaluate cumulative contributions:\n# Creates files contribution_cum_000.nc, contribution_cum_001.nc, etc.\ngreenspline(data, region=(0,6.5,-0.2,6.5), inc=0.1, S=:c, Z=1,\n            C=(cumulative=true,), save=\"contribution.nc\")\n\n\nSurface with Gradient Constraints\nRecover surface from single point value and gradient constraints:\n# Point data in pt.txt, gradients in slopes.txt  \nG = greenspline(\"pt.txt\", region=(-3.2,3.2,-3.2,3.2), inc=0.1, S=:c, Z=1,\n                A=\"slopes.txt+f1\", save=\"surface.nc\")\n\n\n3-D Cartesian Interpolation\nCreate 3-D grid from (x,y,z,w) data:\n# ASCII table output\nresult = greenspline(\"@Table_5_23.txt\", region=(5,40,-5,10,5,16), \n                     inc=0.25, S=(:r, 0.85), Z=5)\n\n# Multiple 2-D layer grids\ngreenspline(\"@Table_5_23.txt\", region=(5,40,-5,10,5,16), inc=0.25,\n            S=(:r, 0.85), Z=5, save=\"layer_%g.grd\")\n\n# Single 3-D netCDF cube\ngreenspline(\"@Table_5_23.txt\", region=(5,40,-5,10,5,16), inc=0.25,\n            S=(:r, 0.85), Z=5, save=\"cube3d.nc\")\n\n\nSpherical Surface Interpolation\nGlobal grid using Parker spline:\n# Minimum curvature on sphere\nG = greenspline(\"@mag_obs_1990.txt\", region=:global, inc=1, S=:p, Z=3);\nWith tension:\n# Continuous curvature in tension (tension = 0.85)\nG = greenspline(\"@mag_obs_1990.txt\", region=:global, inc=1, S=(:q, 0.85), Z=3)\n\n\nArbitrary Output Locations\nOutput at specific coordinates:\n# Nodes specified in nodefile.txt\ngreenspline(data, N=\"nodefile.txt\", S=:c, Z=1, save=\"output.txt\")\n\n\nMisfit Evaluation\nEvaluate fit quality:\n# Statistics to stderr\ngreenspline(data, region=(0,6.5,-0.2,6.5), inc=0.1, S=:c, Z=1, \n            E=true, save=\"grid.nc\")\n\n# Write augmented data table with estimates and misfits\ngreenspline(data, region=(0,6.5,-0.2,6.5), inc=0.1, S=:c, Z=1,\n            E=\"misfits.txt\", save=\"grid.nc\")"
  },
  {
    "objectID": "documentation/modules/greenspline.html#notes",
    "href": "documentation/modules/greenspline.html#notes",
    "title": "greenspline",
    "section": "Notes",
    "text": "Notes\n\nMemory Requirements\nThe solution requires inverting an n × n double precision matrix, where n is the number of data constraints. Memory usage scales as n²: - n = 1,024: ~8 MB - n = 10,240: ~800 MB\nPre-process data with blockmean, blockmedian, or blockmode to avoid aliasing and control n. For spherical data, use gmtspatial nearest neighbor reduction.\n\n\nBoundary Conditions\nFor Cartesian cases, free-space Green functions are used, so no boundary conditions apply at domain edges. For specific boundary conditions, consider using surface instead.\n\n\nNumerical Stability\nThe inversion can become unstable when data neighbors are very close compared to the overall data span. Remedies: - Pre-process data by averaging closely spaced neighbors - Use SVD solution (C) and discard smallest eigenvalues\n\n\nTension Parameter\nTension suppresses spurious oscillations from minimum curvature requirement, especially with rapid gradient changes: - Smooth data (e.g., potential fields): Little or no tension needed - Rough data (e.g., topography): Moderate tension typically better\nExperiment with a range of values. For regularized spline (S=:r), the scale value has limited stable range—experiment to find valid settings.\n\n\n1-D Splines\nUnlike sample1d (which offers traditional splines with standard boundary conditions like natural cubic spline), greenspline’s 1-D spline does not specify boundary conditions at domain ends.\n\n\nEigenvalue Selection\nFor approximate fits (C), it may be difficult to determine how many eigenvalues to retain. The cumulative and incremental modifiers create solutions for all cutoff selections, allowing animation to explore changes and select appropriate C values. See GMT animations for examples.\n\n\nSpherical Splines\nThe series solution for S=:q (Wessel & Becker, 2008) is slower to compute, so values are pre-calculated and cubic spline interpolation lookup is used. Optional modifiers limit and n control accuracy and performance."
  },
  {
    "objectID": "documentation/modules/greenspline.html#references",
    "href": "documentation/modules/greenspline.html#references",
    "title": "greenspline",
    "section": "References",
    "text": "References\n\nDavis, J. C., 1986, Statistics and Data Analysis in Geology, 2nd Edition, 646 pp., Wiley, New York.\nMitasova, H., and L. Mitas, 1993, Interpolation by regularized spline with tension: I. Theory and implementation, Math. Geol., 25, 641-655.\nParker, R. L., 1994, Geophysical Inverse Theory, 386 pp., Princeton Univ. Press, Princeton, N.J.\nSandwell, D. T., 1987, Biharmonic spline interpolation of Geos-3 and Seasat altimeter data, Geophys. Res. Lett., 14, 139-142.\nWessel, P., and D. Bercovici, 1998, Interpolation with splines in tension: a Green’s function approach, Math. Geol., 30, 77-93, https://doi.org/10.1023/A:1021713421882.\nWessel, P., and J. M. Becker, 2008, Interpolation using a generalized Green’s function for a spherical surface spline in tension, Geophys. J. Int, 174, 21-28, https://doi.org/10.1111/j.1365-246X.2008.03829.x.\nWessel, P., 2009, A general-purpose Green’s function interpolator, Computers & Geosciences, 35, 1247-1254, https://doi.org/10.1016/j.cageo.2008.08.012."
  },
  {
    "objectID": "documentation/modules/greenspline.html#source-code",
    "href": "documentation/modules/greenspline.html#source-code",
    "title": "greenspline",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngreenspline(cmd0::String; kwargs...) - greenspline.jl:76\ngreenspline(arg1; kwargs...) - greenspline.jl:77"
  },
  {
    "objectID": "documentation/modules/greenspline.html#see-also",
    "href": "documentation/modules/greenspline.html#see-also",
    "title": "greenspline",
    "section": "See Also",
    "text": "See Also\nblockmean, blockmedian, blockmode, nearneighbor, sample1d, surface, triangulate"
  },
  {
    "objectID": "documentation/modules/histogram.html",
    "href": "documentation/modules/histogram.html",
    "title": "histogram",
    "section": "",
    "text": "histogram(cmd0::String=\"\", arg1=nothing; kwargs...)\nCalculate and plot histograms"
  },
  {
    "objectID": "documentation/modules/histogram.html#description",
    "href": "documentation/modules/histogram.html#description",
    "title": "histogram",
    "section": "Description",
    "text": "Description\nReads file, MxN matrix, GMTdataset or GMTimage and examines the first data column (or one set by incol) to calculate histogram parameters based on the bin-width provided. Using these parameters, scaling, and optional range parameters it will plot the histogram. A cumulative histogram may also be specified."
  },
  {
    "objectID": "documentation/modules/histogram.html#optional-arguments",
    "href": "documentation/modules/histogram.html#optional-arguments",
    "title": "histogram",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or horizontal : – horizontal=true\nPlot the histogram horizontally from x = 0 [Default is vertically from y = 0]. The plot dimensions remain the same, but the two axes are flipped.\nauto : – auto=true\nWhen input is a GMTimage of UInt16 type this option will compute the histogram as well as good bounds to use in contrast enhancement, which will be plotted as two vertical lines.\nbg or background : – bg=imagename | bg=funname|img|grd | bg=(…, colormap)\nFills the plotting canvas with a backround image. That image may come from a file (e.g. bg=“cute.png”) or from a predefined function name. Possible names are: akley, eggs, circle, parabola, rosenbrok, sombrero, x, y, xy, x+y. For further details consult the same option in the plot manual.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at frame\nC or color or cmap : – color=cpt\nGive a CPT or specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. The mid x-value for each bar is used to look-up the bar color. If no argument is given then we select the current CPT.\nD or annot or annotate or count : – annot=true | annot=(beneath=|font=|offset=|vertical=,)\nAnnotate each bar with the count it represents. Add any of the following options: Use annot=(beneath=true,) to place the labels beneath the bars instead of above; use annot=(font=“font”,) to change to another font than the default annotation font; use annot=(offset=val,) to change the offset between bar and label [6p]; use annot=(vertical=true,) to rotate the labels from horizontal to vertical.\nE or width : – width=val | width=(width=val, offset=val)\nUse an alternative histogram bar width than the default set via bin, and optionally shift all bars by an offset. Here width is either an alternative width in data units, or the user may append a valid plot dimension unit (“c|i|p”) for a fixed dimension instead. Optionally, all bins may be shifted along the axis by offset. As for width, it may be given in data units of plot dimension units by appending the relevant unit.\nbinmethod or BinMethod : – binmethod=mthod\nUse a binning algorithm. For decimal data: “scott”, optimal for data is close to being normally distributed. Also appropriate for most other distributions. Uses a bin width of 3.5*std(X(:))*numel(X)^(-1/3); “fd”, uses a bin width of 2*IQR(X(:))*numel(X)^(-1/3), where IQR is the interquartile range of X; “sturges”, chooses the number of bins to be ceil(1 + log2(numel(X))). “sqrt”, chooses the number of bins to be ceil(sqrt(numel(X))).\nFor DateTime data: “second”, “minute”, “hour”, “day”, “week”, “month” or “year”\nF or center : – center=true\nCenter bin on each value. [Default is left edge].\nfull_histo : – full_histo=true\nWhen input is a GMTimage of UInt16 type histograms are often (e.g. Landsat images) characterized by a very high number of countings at x=0 followed by bins with zero countings. By default we check for that case and if found we set the zero bin countings to zero. This is crucial for the auto or thresholds to work. If, however, that is not wished use full_histo=true\nG or fill : fill=color\nSelect filling of bars [Default is a type of blue].\nI or inquire or bins : – inquire=:all | inquire=:no_zero | inquire=:bins\nInquire about min/max x and y after binning. The xmin xmax ymin ymax is output; no plotting is done. Use inquire=:no_zero to output a table of the resulting x,y data instead. inquire=:all will output all x,y bin data even when y == 0. inquire=:bins outputs the binned array (the histogram).\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or out_range : – out_range=:first | out_range=:last | out_range=:both\nThe modifiers specify the handling of extreme values that fall outside the range set by bin. By default these values are ignored. Use out_range=:both to let these values be included in the first or last bins. To only include extreme values below first bin into the first bin, use out_range=:first, and to only include extreme values above the last bin into that last bin, use out_range=:last.\nN or distribution : – distribution=mode | distribution=(mode=mode, pen=(pen))\nDraw the equivalent normal distribution; append desired pen [0.5p,black]. The mode selects which central location and scale to use:\n0 = mean and standard deviation [Default];\n1 = median and L1 scale (1.4826 * median absolute deviation; MAD);\n2 = LMS (least median of squares) mode and scale.\nThis option may be repeated to draw several of these curves. To do that use a tuple of tuples. Example: N=((mode=1,pen=(1,:red)), (mode=0,pen=(1,:blue)))\nQ or cumulative : – cumulative=true | cumulative=“r”\nDraw a cumulative histogram. Append r to instead compute the reverse cumulative histogram.\nS or stairs : – stairs=true\nDraws a stairs-step diagram which does not include the internal bars of the default histogram. Uses pen.\nT or range or bin : – range=(min,max,inc[,:number,:log2,:log10]) | range=[list] | range=file\nDefines the range of the new CPT by giving the lowest and highest z-value (and optionally an interval). If range is not given, the existing range in the master CPT will be used intact. The values produces defines the color slice boundaries. If :number is added as a fourth element then inc is meant to indicate the number of equidistant coordinates instead. Use :log2 if we should take log2 of min and max, get their nearest integers, build an equidistant log2-array using inc integer increments in log2, then undo the log2 conversion. Same for :log10. For details on array creation, see Generate 1D Array.\nthresholds : – thresholds=(low,high)\nWhen input is a GMTimage of UInt16 type this option will compute the histogram as well as good bounds to use in contrast enhancement. The alghoritm used checks from right and left when the countings are &gt;= low && &lt;= high percentage of the maximum histogram countings. The defaul values (which are used by auto and zoom) are thresholds=(0.1,0.4)\ngetauto or getthresholds : – getthresholds=true\nGet the automatically determined thresholds to use in contrast enhancement. No plotting is done.\nZ or kind : – kind=type | kind=(counts=, | freq=, | frequency=, | log_count=, | log_freq=, | log10_count=, | log10_freq=, weights=)\nChoose between 6 types of histograms:\n0 = counts [Default]\n1 = frequency_percent\n2 = log (1.0 + count)\n3 = log (1.0 + frequency_percent)\n4 = log10 (1.0 + count)\n5 = log10 (1.0 + frequency_percent).\nTo use weights provided as a second data column instead of pure counts, use a tuple. e.g. kind=(counts=true, weights=true). If no weights are used then we may use the simpler form kind=?? where ?? is the name of any of the 6 types. e.g. kind=frequency\nzoom : – zoom=true\nWhen input is a GMTimage of UInt16 type this option will set auto=true and show histogram only on the region of interest."
  },
  {
    "objectID": "documentation/modules/histogram.html#examples",
    "href": "documentation/modules/histogram.html#examples",
    "title": "histogram",
    "section": "Examples",
    "text": "Examples\nTo draw a histogram of the data v3206_06.txt containing seafloor depths, using a 250 meter bin width, center bars, and draw bar outline, use:\n\nusing GMT\nhistogram(\"@v3206_06.txt\", bin=250, center=true, pen=\"0.5p\", show=true)\n\n\n\n\n\n\n\n\nIf you know the distribution of your data, you may explicitly specify range and scales. E.g., to plot a histogram of the y-values (2nd column) in the file errors.xy using a 1 meter bin width, plot from -10 to +10 meters @ 0.75 cm/m, annotate every 2 m and 100 counts, and use black bars, run:\n    histogram(\"errors.xy\", bin=1, region=(-10,10,0,0), J=\"xc/0.01c\",\n              xaxis=(annot=2,label=:Error), yaxis=(annot=100, label=:Counts), fill=:black, incol=1) \nSince no y-range was specified, histogram will calculate ymax in even increments of 100.\nTo plot the histogram of a Landsat image, pick good bounds for contrast enhancement and show them\nI = gmtread(\"landsat.tif\")\nhistogram(I, zoom=true, show=true);"
  },
  {
    "objectID": "documentation/modules/histogram.html#source-code",
    "href": "documentation/modules/histogram.html#source-code",
    "title": "histogram",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nhistogram(cmd0::String; kwargs...) - pshistogram.jl:73\nhistogram(arg1; kwargs...) - pshistogram.jl:74"
  },
  {
    "objectID": "documentation/modules/histogram.html#see-also",
    "href": "documentation/modules/histogram.html#see-also",
    "title": "histogram",
    "section": "See also",
    "text": "See also"
  },
  {
    "objectID": "documentation/modules/image.html",
    "href": "documentation/modules/image.html",
    "title": "image",
    "section": "",
    "text": "image(cmd0::String=\"\", arg1=nothing; kwargs...)\nPlot raster or EPS images"
  },
  {
    "objectID": "documentation/modules/image.html#description",
    "href": "documentation/modules/image.html#description",
    "title": "image",
    "section": "Description",
    "text": "Description\nimage reads an Encapsulated PostScript file or a raster image file and plots it on a map. The image can be scaled arbitrarily, and 1-bit raster images can be (1) inverted, i.e., black pixels (on) becomes white (off) and vice versa, or (2) colorized, by assigning different foreground and background colors, and (3) made transparent where one of back- or foreground is painted only. As an option, the user may choose to convert colored raster images to grayscale using TV’s YIQ-transformation. For raster files, the user can select which color to be made transparent. The user may also choose to replicate the image which, when preceded by appropriate clip paths, may allow larger custom-designed fill patterns to be implemented (the pattern mechanism offered in most GMT programs is limited to rasters smaller than 146 by 146)."
  },
  {
    "objectID": "documentation/modules/image.html#required-arguments",
    "href": "documentation/modules/image.html#required-arguments",
    "title": "image",
    "section": "Required Arguments",
    "text": "Required Arguments\nimagefile This must be an Encapsulated PostScript (EPS) file or a raster image. An EPS file must contain an appropriate BoundingBox. A raster file can have a depth of 1, 8, 24, or 32 bits and is read via GDAL."
  },
  {
    "objectID": "documentation/modules/image.html#optional-arguments",
    "href": "documentation/modules/image.html#optional-arguments",
    "title": "image",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nD or pos or position : – pos=(map=true, inside=true, outside=true, norm=true, paper=true, anchor=XX, dpi=XX, width=XX, justify=code, repeat=n, offset=XX)\nSets reference point on the map for the image using one of four coordinate systems:\n\n\nUse map=true for map (user) coordinates,\n\n\nuse inside=true or outside=true (the default) for setting anchor via a 2-char justification code that refers to the (invisible) map domain rectangle,\n\n\nuse norm=true for normalized (0-1) coordinates, or\n\n\nuse paper=true for plot coordinates (inches, cm, etc.). All but paper=true requires both region and proj to be specified.\n\n\nBy default, the anchor point on the scale is assumed to be the bottom left corner (BL), but this can be changed by adding justify=:code where :code is a 2-char justification code (see text). Note: If inside is used (the default) then justify defaults to the same as refpoint, if outside is used then justify defaults to the mirror opposite of refpoint. Specify image size in one of two ways: Use dpi=val to set the dpi of the image in val dots per inch, or use width=width or width=(width,height) to set the width (and height) of the image in plot coordinates (inches, cm, etc.). If height is not given, the original aspect ratio of the image is maintained. If width is negative we use the absolute value and interpolate image to the device resolution using the PostScript image operator. If neither size nor dpi is set then we revert to the default dpi [GMT_GRAPHICS_DPU]. Optionally, use replicate=nx or replicate=(nx,ny) to replicate the image nx times horizontally and ny times vertically. If ny is omitted, it will be identical to nx [Default is 1/1].\nF or box : – box=(clearance=gap, pen=pen, fill=fill, inner=(gap,pen), rounded=xx, shaded=(dx,dy[,shade]))\nWithout further options, draws a rectangular border around the map scale or rose using MAP_FRAME_PEN; specify a different pen with pen=new_pen. Add fill=fill_value to fill the logo box [no fill]. Append clearance=gap where gap is either a scalar, or tuples with (xgap, ygap), or (lgap,rgap,bgap,tgap) where these items are uniform, separate in x- and y-direction, or individual side spacings between logo and border. Append inner to draw a secondary, inner border as well. We use a uniform gap between borders of 2p and the MAP_DEFAULT_PEN unless other values are specified. Append rounded=6 to draw rounded rectangular borders instead, with a 6p corner radius. You can override this radius by appending another value. Finally, append shaded=(dx,dy[,shade]) to draw an offset background shaded region. Here, dx,dy indicates the shift relative to the foreground frame [4p,4p] and shade sets the fill style to use for shading [gray50]. Requires map_scale or rose. If both map_scale or rose, you may repeat box after each of these but remember to put repeated settings inside a tuple of tuples.\nG or bitcolor or bit_color or bit_bg|fg|alpha : – bit_bg=color | bit_fg=color | bit_alpha=color | bitcolor=color[+b|+f|+t]\nChange certain pixel values to another color or make them transparent. For 1-bit images you can specify an alternate color for the background (bit_bg=color) or the foreground (bit_bf=color) pixels, or give no color to make those pixels transparent. Alternatively, for color images you can select a single color that should be made transparent instead (bit_alpha=color). The last form, G or bit_color, allows using the plain GMT syntax, but does not let set more than one of the bg, fg or alpha settings.\nI or invert : – invert=true\nInvert 1-bit image before plotting. This is what is done when you use G=:P to invert patterns in other GMT plotting programs. Ignored if used with color images.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nM or monochrome : – monochrome=true\nConvert color image to monochrome grayshades using the (television) YIQ-transformation.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\n\nFor perspective view, optionally append zmin,zmax.\n\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats."
  },
  {
    "objectID": "documentation/modules/image.html#notes",
    "href": "documentation/modules/image.html#notes",
    "title": "image",
    "section": "Notes",
    "text": "Notes\nThe bit_color and invert options are for raster images only. They have no effect when placing Encapsulated PostScript files."
  },
  {
    "objectID": "documentation/modules/image.html#examples",
    "href": "documentation/modules/image.html#examples",
    "title": "image",
    "section": "Examples",
    "text": "Examples\nTo plot the remote image needle.jpg, scaling it be 7 cm wide (height is scaled accordingly), use:\n\nusing GMT\nimage(\"@needle.jpg\", pos=(paper=true, anchor=(0,0), width=7), show=1)\n\n\n\n\n\n\n\n\nTo plot the same file but reversing the bands, use:\n\nusing GMT\nimage(\"@needle.jpg+b2,1,0\", pos=(paper=true, anchor=(0,0), width=7), show=1)\n\n\n\n\n\n\n\n\nTo only plot its red band as gray shade, use:\n\nusing GMT\nimage(\"@needle.jpg+b0\", pos=(paper=true, anchor=(0,0), width=7), show=1)\n\n\n\n\n\n\n\n\nTo include an Encapsulated PostScript file gallo.eps with its upper right corner 5 cm to the right and 2.5 cm up from the current location, and have its width scaled to 4 cm, while keeping the aspect ratio, use:\n\nusing GMT\nimage(\"@gallo.eps\", pos=(paper=true, anchor=(5,2.5), justify=:TR, width=4), show=1)\n\n\n\n\n\n\n\n\nTo replicate the 1-bit remote raster image vader1.png, colorize it (dark gray background and yellow foreground), and setting each of 6 by 12 tiles to be 2.5 cm wide, use:\n\nusing GMT\nimage(\"@vader1.png\", bit_bg=:darkgray, bit_fg=:yellow,\n      pos=(paper=true, anchor=(0,0), width=5, repeat=(6,12)), show=1)"
  },
  {
    "objectID": "documentation/modules/image.html#source-code",
    "href": "documentation/modules/image.html#source-code",
    "title": "image",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimage(cmd0::String; kwargs...) - psimage.jl:38\nimage(arg1; kwargs...) - psimage.jl:39"
  },
  {
    "objectID": "documentation/modules/image.html#see-also",
    "href": "documentation/modules/image.html#see-also",
    "title": "image",
    "section": "See Also",
    "text": "See Also\nlegend, colorbar, plot, [psconvert]"
  },
  {
    "objectID": "documentation/modules/inset.html",
    "href": "documentation/modules/inset.html",
    "title": "inset",
    "section": "",
    "text": "inset(kwargs...)\nManage figure inset setup and completion\nThe inset module is used to carve out a sub-region of the current plot canvas and restrict further plotting to that section of the canvas. The inset setup is started with the inset(…) directive that defines the placement and size of the inset. Subsequent plot commands will be directed to that window. The inset is completed via the inset(:end) directive, which reverts operations to the full canvas and restores the plot region and map projection that was in effect prior to the setup of the inset."
  },
  {
    "objectID": "documentation/modules/inset.html#description",
    "href": "documentation/modules/inset.html#description",
    "title": "inset",
    "section": "Description",
    "text": "Description\nThe inset(…) defines the dimension and placement of the inset canvas. It records the current region and projection so that we may return to the initial plot environment when the inset is completed. The user may select any plot region and projection once plotting in the inset, but if the first command uses a projection that leaves off the scale or width then we supply a scale or width to fill the inset as best as possible, given the inset size and margins (if selected). Note: If you wish to let the inset dimensions be determined by the region and projection that will be used to draw in the inset, then give these arguments in the inset() command."
  },
  {
    "objectID": "documentation/modules/inset.html#required-arguments",
    "href": "documentation/modules/inset.html#required-arguments",
    "title": "inset",
    "section": "Required Arguments",
    "text": "Required Arguments\n\nD or pos or positionor inset_box or insetbox : – position=(map=true, inside=true, outside=true, norm=true, paper=true, anchor=XX, size=XX, width=XX, justify=code, offset=XX)\nDefine the map inset rectangle on the map. Specify the rectangle in one of three ways:\n\nUse map=(lon,lat) for map coordinates. Requires both region and proj to be set.\nUse inside=code or outside=code for setting the refpoint via a 2-char justification code that refers to the (invisible) projected map bounding box. Requires both region and proj to be set.\nUse norm=(x,y) for normalized bounding box coordinates (0-1). Requires both region and proj to be set.\nUse paper=(x,y) for plot coordinates (append cm, inch, or point).\n\nUse size=(length,width) (or width) of bounding rectangle or box in plot coordinates (inches, cm, etc.). By default, the anchor point on the scale is assumed to be the bottom left corner (BL), but this can be changed by using justify=?? where ?? stands for a 2-char justification code justify (see text). Note: with the default outside=true, the justify defaults to the same as anchor, if inside=true is used then justify defaults to the mirror opposite of anchor. Specify inset box attributes via the box option [outline only].\nAlternatively, use position=“west/east/south/north” of geographic rectangle bounded by parallels and meridians; append +r if the coordinates instead are the lower left and upper right corners of the desired rectangle. (Or, give xmin/xmax/ymin/ymax of bounding rectangle in projected coordinates and optionally append +uunit [Default coordinate unit is meter (e)]. NOTE that this form requires passing the options as a string and it uses the terse pure GMT syntax."
  },
  {
    "objectID": "documentation/modules/inset.html#optional-arguments",
    "href": "documentation/modules/inset.html#optional-arguments",
    "title": "inset",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or clearance : – clearance=val | clearance=(left=val, right=val, bott=val, bottom=val, top=val))\nReserve a space of dimension clearance between the actual inset plot area and the given inset box on the specified side, using side values from left=val, right=val, bottom=val, or top=val, or lr=val for both left and right or tb=val for both top and bott. No side means all sides. Alternatively, if all sides are to be set you can also give a pair of values separated by slashes (for setting separate horizontal and vertical margins), or the full set of four separate margins. Such space will be left untouched by the inset map plotting. Append units as desired (cm, inch, or point) [Default is set by PROJ_LENGTH_UNIT].\nF or box : – box=(clearance=val, fill=color, inner=true, pen=pen, rounded=true, shaded=XX)\nWithout further options, draws a rectangular border around the map inset using MAP_FRAME_PEN. The following modifiers can be appended to |-F|, with additional explanation and examples provided in the The background panel cookbook section:\n\nclearance=val where val is either gap or (xgap,ygap), or (lgap,rgap,bgap,tgap) where these items are uniform, separate in x- and y-direction, or individual side spacings between the map embellishment and the border for each side.\nfill=color, where color is any valid color setting (see Setting color), to fill the scale panel [no fill].\ninner=true to draw a secondary, inner border as well. We use a uniform gap between borders of 2p and the MAP_DEFAULTS_PEN unless other values are specified (like inner=“gap/pen”).\npen=pen, to specify different Pen attributes attributes.\nrounded=true to draw rounded rectangular borders instead, with a 6p corner radius. You can override this radius by using another value instead of true.\nshadded=true or shadded=(dx,dy) or shadded=shade to draw an offset background shaded region. Here, dx/dy indicates the shift relative to the foreground frame [4p/-4p]and shade sets the fill style to use for shading (“gray50”).\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nN or noclip or no_clip : noclip=true\nDo not clip features extruding outside map inset boundaries [Default will clip].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)"
  },
  {
    "objectID": "documentation/modules/inset.html#synopsis-end-mode",
    "href": "documentation/modules/inset.html#synopsis-end-mode",
    "title": "inset",
    "section": "Synopsis (end mode)",
    "text": "Synopsis (end mode)\nThe inset(:end) command finalizes the current inset, which returns the plotting environment to the state prior to the start of the inset. The previous region and map projection will be in effect going forward."
  },
  {
    "objectID": "documentation/modules/inset.html#the-nested-call-mode",
    "href": "documentation/modules/inset.html#the-nested-call-mode",
    "title": "inset",
    "section": "The nested call mode",
    "text": "The nested call mode\nThe options described above respect the pure use of inset as a modern mode function. But we can also use it in a mix mode in one-liners commands. It is mixed because the functioning relies in mixing the classic and modern modes (in a way transparent to the user). And, as just said, this mix mode consists in calling the inset function as an option to the plot, basemap and grdimage functions. Since we are doing a nested call, we need to pass all options as argument to inset and this ofc reduces the number of possibilities but still, it offers quite nice features that allow creating elaborated figures with very short commands. The [Figure insets] shows several examples of this usage.\nThe inset windows are located according to an algorithm that tries to avoid overlapping lines in line plots (with a moderate success), or in some corner position for insets with images. Inset windows sizes are also automatically estimated from image sizes and projections (when they are geographical). However, user can manually control this wth position option explained above.\n\ninset – inset=(data, zoom=(…), coast=(…), position=(…), box=(…), clearance=(…))\n\n\ndata An image, a grid a table (GMTdataset) or a file name that can be automatically read by gmtread. Depending on the data type an x,y plot or an image is displayed inside the inset window.\nzoom This refers to an area of the main window that we wish to make a zoom of. Its arguments depend on whether we are zooming an x,y plot or an image. In the first case we pass an x location and a half-width. For example zoom=(10,2) means that the zoom window covers the abscissa [8 12] range. The y extent is whatever the line has between those x limits. But for the case of images we need one more argument because now we have 2 dimensions. The syntax now is zoom=(x0,y0,delta), an extension of the previous concept, which requires that the units of x and y are the same and we get a square zoom window. The alternative is to use the usual way of GMT specifying region limits. That is zoom=(x_min, x_max, y_min, y_max)\npzoom When adding insets to images we can provide an external image (or file name) that will be displayed in the inset. But since in this case the inset does not have to share the same coordinates with main figure, we only provide here the point coordinates of the interesting area. The syntax is hence pzoom=(x0,y0).\ncoast With this argument we can call the coast command with all of its normal arguments. And furthermore, we can even call the plot (or any of its avatars) to add line/symbol plots over the inset map. A further option to this form of calling coast is the option rect=?. If ? is true, it will plot a 0.75 pt blue rectangle showing the main window limits. Alternatives is rect=number, rect=color or rect=(number, color), where color is a color name and number is the rectangle line thickness in points\nposition, box, clearance Have the same meaning/usage as explained above."
  },
  {
    "objectID": "documentation/modules/inset.html#examples",
    "href": "documentation/modules/inset.html#examples",
    "title": "inset",
    "section": "Examples",
    "text": "Examples\nTo make a simple basemap plot that demonstrates the inset module, try\n\nusing GMT\ngmtbegin()\n    basemap(region=(0,40,20,60), proj=:merc, frame=(annot=:afg, fill=:lightgreen))\n    inset(position=(anchor=:TR, width=6.4, offset=0.5), box=(fill=:pink, pen=0.5), margins=0.6)\n        basemap(region=:global360, proj=(name=:laea, center=[20,20]), figsize=5, frame=:afg)\n        text(text=\"INSET\", font=18, region_justify=:TR, offset=(away=true, shift=-0.4), noclip=true)\n    inset(:end)\n    text(text=\"MAP\", font=18, region_justify=:BL, offset=(away=true, shift=0.5))\ngmtend(:show)\n\n\n\n\n\n\n\n\nMake a zoom over a region of a synthetic plot.\n\nusing GMT\n\nt = 0:0.01:2pi;\nplot(t, cos.(t).+rand(length(t))*0.1, inset=(zoom=(pi,pi/4), box=(fill=:lightblue,)), show=true)\n\n\n\n\n\n\n\n\nAdd an inset to basemap image with a rectangle in the inset taken from main image limits.\n\nusing GMT\n\nbasemap(region=(-48,-43,-26,-20), proj=:merc,\n        inset=(coast, R=\"-80/-28/-43/10\", proj=:merc, shore=true, rect=(2,:red)), show=true)"
  },
  {
    "objectID": "documentation/modules/inset.html#source-code",
    "href": "documentation/modules/inset.html#source-code",
    "title": "inset",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ninset(; ...) - gmtbegin.jl:65\ninset(fim::Union{AbstractString, Symbol}; stop, kwargs...) - gmtbegin.jl:65"
  },
  {
    "objectID": "documentation/modules/lines.html",
    "href": "documentation/modules/lines.html",
    "title": "lines",
    "section": "",
    "text": "lines(cmd0::String=\"\", arg1=[]; kwargs...)\nReads (x,y) pairs and plot lines with different levels of decoration. The input can either be a file name of a file with at least two columns (x,y), but optionally more, a GMTdatset object with also two or more columns.\nThis module plots a large variety of lines and polygons. It goes from simple lines and polygons (color/pattern filled or not) to the so called decorated lines. That is, lines decorated with symbols and text patterns.\nThis module is a subset of plot to make it simpler to draw line plots. So not all (fine) controlling parameters are not listed here. For the finest control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/lines.html#parameters",
    "href": "documentation/modules/lines.html#parameters",
    "title": "lines",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\ndecorated\nFor all types of line decorations: symbols [Decorated lines], fronts [Front lines], text [Quoted lines], etc… see [Line decorations]\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/lines.html#examples",
    "href": "documentation/modules/lines.html#examples",
    "title": "lines",
    "section": "Examples",
    "text": "Examples\nDecorated curve with blue stars\n\nusing GMT\nxy = gmt(\"gmtmath -T0/180/1 T SIND 4.5 ADD\");\nlines(xy, axes=:af, pen=(1,:red), decorated=(dist=(2.5,0.25), marker=:star,\n      ms=1, pen=(0.5,:green), fill=:blue, dec2=true), aspect=\"4:2\", show=true)"
  },
  {
    "objectID": "documentation/modules/lines.html#source-code",
    "href": "documentation/modules/lines.html#source-code",
    "title": "lines",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlines(cmd0::String; ...) - plot.jl:632\nlines(cmd0::String, arg1; first, kwargs...) - plot.jl:632\nlines(f::Function; ...) - plot.jl:635\nlines(f1::Function, f2::Function; ...) - plot.jl:641\nlines(f::Function, rang; first, kw...) - plot.jl:635\nlines(f1::Function, f2::Function, rang; first, kw...) - plot.jl:641\nlines(; ...) - plot.jl:632\nlines(arg; kw...) - plot.jl:648\nlines(arg1, arg2; kw...) - plot.jl:646"
  },
  {
    "objectID": "documentation/modules/makecpt.html",
    "href": "documentation/modules/makecpt.html",
    "title": "makecpt",
    "section": "",
    "text": "makecpt(cmd0::String=\"\", arg1=nothing; kwargs...)\nor\nor\nMake static color palette tables (CPTs) from master CPTs."
  },
  {
    "objectID": "documentation/modules/makecpt.html#description",
    "href": "documentation/modules/makecpt.html#description",
    "title": "makecpt",
    "section": "Description",
    "text": "Description\nMake static color palette tables (CPTs). You define an equidistant set of contour intervals or pass your own z-table or list, and create a new CPT based on an existing master (dynamic) CPT. The resulting CPT can be reversed relative to the master cpt, and can be made continuous or discrete.\nThe CPT includes three additional colors beyond the range of z-values. These are the background color (B) assigned to values lower than the lowest z-value, the foreground color (F) assigned to values higher than the highest z-value, and the NaN color (N) painted wherever values are undefined.\nIf the master CPT includes B, F, and N entries, these will be copied into the new master file. If not, the parameters COLOR_BACKGROUND, COLOR_FOREGROUND, and COLOR_NAN from the gmt.conf file or the command line will be used. This default behavior can be overruled using the options bg, overrule_bg or no_bg.\nThe color model (RGB, HSV or CMYK) of the palette created by makecpt will be the same as specified in the header of the master CPT. When there is no COLOR_MODEL entry in the master CPT, the COLOR_MODEL specified in the gmt.conf file or on the command line will be used.\nThe second form is a quick way of generating CPT objects for use in the imshow/viz functions. Here name (as a symbol) is the name of any of the GM default palettes. It can also be the name of CPT file living in current directory. With it, you don’t specify the color=cptname as it is already implied by the fact that first argin is a symbol. As mentioned, its primary usage is to quickly show a CPT with the imshow command. e.g imshow(:gray)\nThe third form created the colormap from z_min, z_max limits of the grid G. The options for this form are the same as for the other two, plus the equalize option that actually call grd2cpt and call a histgram equalized cmap."
  },
  {
    "objectID": "documentation/modules/makecpt.html#optional-arguments",
    "href": "documentation/modules/makecpt.html#optional-arguments",
    "title": "makecpt",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or alpha or transparency : – alpha=xx | alpha=“xx+a”\nSets a constant level of transparency (0-100) for all color slices. Append +a to also affect the fore-, back-, and nan-colors\nC or color or cmap or colormap or colorscale : – cmap=[[section/]master_cpt[+h[hinge]][+u|+Uunit]|local_cpt|color1,color2[,color3,…]]\nName of an input CPT file. Generally, the input is one of the GMT master_cpt files (see Of Colors and Color Legends) and can be either addressed by master_cpt or section/master_cpt (without the .cpt extension). If given a master CPT with soft-hinges then you can enable the hinge at data value hinge via +h, whereas for hard-hinge CPTs you can adjust the location of the hinge. For any other master_cpt, you may convert their z-values from meter to another distance unit (append +Uunit) or from another unit to meter (append +uunit), with unit taken from e|f|k|M|n|u. One can also supply the file name of already custom made local_cpt file. Alternatively, give color1,color2[,color3,…] to build a linear continuous CPT from those colors automatically, where z starts at 0 and is incremented by one for each color. In this case colorn can be a r/g/b triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc). See also [Setting color](../common_features/color.html)\nD or bg or background : – bg=true | bg=:i\nSelect the back- and foreground colors to match the colors for lowest and highest z-values in the output CPT [Default uses the colors specified in the master file, or those defined by the parameters COLOR_BACKGROUND, COLOR_FOREGROUND, and COLOR_NAN]. Append i to match the colors for the lowest and highest values in the input (instead of the output) CPT.\nE or nlevels : – nlevels=true | nlevels=nlevels\nImplies reading data table(s) (from an array or file). We use the last data column to determine the data range; use incol to select another column, and use binary_in if your data table is native binary. This z-range information is used instead of providing the range option. We create a linear color table by dividing the table data z-range into nlevels equidistant slices. If nlevels is not given it defaults to the number of levels in the chosen CPT.\nequalize – equalize=true | equalize=nlevels\nCreate an histgram equalized CPT. If nlevels is not given it defaults to the number guessed by grd2cpt. Note that when using this option and, by consequence, the form that takes a grid as input, the other options are those of the grd2cpt function.\nF or color_model : – color_model=true|:r|:h|:c[“+c”[label]] | color_model=“+kkeys”\nForce output CPT to be written with r/g/b codes, gray-scale values or color name (the default) or r/g/b codes only (r), or h-s-v codes (h), or c/m/y/k codes (c). Optionally or alternatively, append +c to write discrete palettes in categorical format. If label is appended then we create labels for each category to be used when the CPT is plotted. The label may be a comma-separated list of category names (you can skip a category by not giving a name), or give start[-], where we automatically build monotonically increasing labels from start (a single letter or an integer). Append - to build ranges start-start+1 instead. If the categorical CPT should have string keys instead of numerical entries then use color_model=“+kkeys”, where keys is either a file with one key per record or a single letter (e.g., D), then we build sequential letter keys (e.g., D, E, F, …) starting at that point. For comma-separated lists of keys, use range instead. Note: If +cM is given and the number of categories is 12, then we automatically create a list of month names. Likewise, if +cD is given and the number of categories is 7 then we make a list of weekday names. The format of these labels will depend on the FORMAT_TIME_PRIMARY_MAP, GMT_LANGUAGE and possibly TIME_WEEK_START settings.\nG or truncate : – truncate=(zlo,zhi)\nTruncate the incoming CPT so that the lowest and highest z-levels are to zlo and zhi. If one of these equal NaN then we leave that end of the CPT alone. The truncation takes place before any resampling. See also Manipulating CPTs\nI or inverse or reverse : – inverse=true | inverse=:z\nReverse the sense of color progression in the master CPT. Also exchanges the foreground and background colors, including those specified by the parameters COLOR_BACKGROUND and COLOR_FOREGROUND. Use inverse=:z to reverse the sign of z-values in the color table. Note that this change of z-direction happens before truncate and range values are used so the latter much be compatible with the changed z-range. See also Manipulating CPTs\nM or overrule_bg : – overrule_bg=true\nOverrule background, foreground, and NaN colors specified in the master CPT with the values of the parameters COLOR_BACKGROUND, COLOR_FOREGROUND, and COLOR_NAN specified in the gmt.conf file or on the command line. When combined with bg, only COLOR_NAN is considered.\nN or no_bg or nobg : – no_bg=true\nMake all the background, foreground, and NaN-color fields be white (since we can’t remove them like in plain GMT).\nQ or log : – log=true\nFor logarithmic interpolation scheme with input given as logarithms. Expects input z-values provided via range to be log10(z), assigns colors, and writes out z.\nS or auto : – auto=str\nDetermine a suitable range for the range option from the input table. Choose from several types of range determinations: auto=:r will use the data range min/max, auto=inc[“+d”] will use the data min/max but rounded to nearest inc (append “+d” to resample to a discrete CPT), auto=“ascl” will make a symmetric range around the average (i.e., mean) and ±scl * sigma, auto=“mscl” will make a symmetric range around the median and ±scl * L1_scale, auto=“pscl” will make symmetric range around mode (i.e., LMS; least median of squares) and ±scl * LMS_scale, while auto=“qlow/high” sets the range from low quartile to high quartile (in percentages). We use the last data column for this calculation; use input_col if you need to adjust the column orders.\nT or range : – range=(min,max,inc[,:number,:log2,:log10]) | range=[list] | range=file\nDefines the range of the new CPT by giving the lowest and highest z-value (and optionally an interval). If range is not given, the existing range in the master CPT will be used intact. The values produces defines the color slice boundaries. If :number is added as a fourth element then inc is meant to indicate the number of equidistant coordinates instead. Use :log2 if we should take log2 of min and max, get their nearest integers, build an equidistant log2-array using inc integer increments in log2, then undo the log2 conversion. Same for :log10. For details on array creation, see Generate 1D Array.\nA quick, in the sense of more limited, replacement for this option, however, is to provide the start, stop and optionally the increment via input positional arguments. E.g. for example makecpt(1,5,0.1, kw...) or even makecpt(1,5, kw...).\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or wrap or categorical : – wrap=true | wrap=:w\nDo not interpolate the input color table but pick the output colors starting at the beginning of the color table, until colors for all intervals are assigned. This is particularly useful in combination with a categorical color table, like “categorical”. Alternatively, use wrap=:w to produce a wrapped (cyclic) color table that endlessly repeats its range.\nZ or continuous : – continuous=true\nForce a continuous CPT when building from a list of colors and a list of z-values [discrete].\nname or save : – save=“name.cpt”\nSave the color map with the save=“name.cpt”. When in modern mode this also automatically sets a required GMT option (-H)."
  },
  {
    "objectID": "documentation/modules/makecpt.html#notes-on-transparency",
    "href": "documentation/modules/makecpt.html#notes-on-transparency",
    "title": "makecpt",
    "section": "Notes on Transparency",
    "text": "Notes on Transparency\nThe PostScript language originally had no accommodation for transparency. However, Adobe added an extension that allows developers to encode some forms of transparency using the PostScript language model but it is only realized when converting the PostScript to PDF (and via PDF to any raster image format). GMT uses this model but there are some limitations: Transparency can only be controlled on a per-object or per-layer basis. This means that a color specifications (such as those in CPTs of given via command-line options) only apply to vector graphic items (i.e., text, lines, polygon fills) or to an entire layer (which could include items such as PostScript images). This limitation rules out any mechanism of controlling transparency in such images on a pixel level."
  },
  {
    "objectID": "documentation/modules/makecpt.html#color-hinges",
    "href": "documentation/modules/makecpt.html#color-hinges",
    "title": "makecpt",
    "section": "Color Hinges",
    "text": "Color Hinges\nSome of the GMT master dynamic CPTs are actually two separate CPTs meeting at a hinge. Usually, colors may change dramatically across the hinge, which is used to separate two different domains (e.g., land and ocean across the shoreline, for instance). CPTs with a hinge will have their two parts stretched to the required range separately, i.e., the bottom part up to the hinge will be stretched independently of the part from the hinge to the top, according to the prescribed new range. Hinges are either hard or soft. Soft hinges must be activated by appending hinge=val to the CPT name. If the selected range does not include an activated soft or hard hinge then we only resample colors from the half of the CPT that pertains to the range. See Of Colors and Color Legends for more information."
  },
  {
    "objectID": "documentation/modules/makecpt.html#discrete-versus-continuous-cpt",
    "href": "documentation/modules/makecpt.html#discrete-versus-continuous-cpt",
    "title": "makecpt",
    "section": "Discrete versus Continuous CPT",
    "text": "Discrete versus Continuous CPT\nAll CPTs can be stretched, but only continuous CPTs can be sampled at new nodes (i.e., by given an increment in range). We impose this limitation to avoid aliasing the original CPT."
  },
  {
    "objectID": "documentation/modules/makecpt.html#examples",
    "href": "documentation/modules/makecpt.html#examples",
    "title": "makecpt",
    "section": "Examples",
    "text": "Examples\nTo make a CPT with z-values from -200 to 200, with discrete color changes every 25, and using a polar blue-white-red colortable:\n\nusing GMT\nC = makecpt(cmap=:polar, range=(-200,200,25))\nimshow(C, horizontal=true)\n\n\n\n\n\n\n\n\nTo make an equidistant CPT from z = -2 to 6 using the continuous default turbo rainbow of colors:\n    C = makecpt(range=(2,6))\nTo use the GEBCO look-alike CPT with its default range for bathymetry and save the file on disk, run\n    makecpt(cmap=:gebco, write=\"my_gebco.cpt\")\nor simply use -Cgebco directly in the application that needs the color table. To create a 24-level color table suitable for plotting the depths in the remote data table v3206_06.txt (with lon, lat, depths), run\n\nusing GMT\nC = makecpt(\"@v3206_06.txt\", cmap=:gebco, nlevels=24)\nimshow(C, horizontal=true)\n\n\n\n\n\n\n\n\nTo use the gebco color table but reverse the z-values so it can be used for positive depth values, try\n    makecpt(cmap=:gebco, reverse=:z)\nTo make a custom discrete color table for depth of seismicity, using red color for hypocenters between 0 and 100 km, green for 100-300 km, and blue for deep (300-1000 km) earthquakes, use\n\nusing GMT\nimshow(makecpt(cmap=(:red,:green,:blue), range=[0,100,300,1000], no_bg=true), horizontal=true)\n\n\n\n\n\n\n\n\nTo make a discrete CPT from white to blue as z goes from 3 to 10, try\n\nusing GMT\nimshow(makecpt(cmap=\"white,blue\", range=(3,10)), horizontal=true)\n\n\n\n\n\n\n\n\nAnd to get a continuous CPT, use the option continuous=true.\n\nusing GMT\nimshow(makecpt(cmap=\"white,blue\", range=(3,10), continuous=true), horizontal=true)\n\n\n\n\n\n\n\n\nTo make a wrapped (cyclic) CPT from the turbo table over the interval 0 to 500, i.e., the color will be wrapped every 500 z-units so that we always get a color regardless of the z value, try\n\nusing GMT\nimshow(makecpt(cmap=:turbo, range=(0,500), wrap=:w), horizontal=true)\n\n\n\n\n\n\n\n\nTo show the turbo color table.\n\nusing GMT\nimshow(:turbo, horizontal=true)\n\n\n\n\n\n\n\n\nTo make a categorical CPT with string keys instead of numerical lookup values, try:\n\nusing GMT\nC = makecpt(cmap=:categorical, range=\"wood,water,gold\")\nimshow(C, B=:none, horizontal=true)"
  },
  {
    "objectID": "documentation/modules/makecpt.html#bugs",
    "href": "documentation/modules/makecpt.html#bugs",
    "title": "makecpt",
    "section": "Bugs",
    "text": "Bugs\nSince makecpt will also interpolate from any existing CPT you may have in your directory, you should not use one of the listed cpt names as an output filename; hence the my_gebco.cpt in the example. If you do create a CPT of such a name, e.g., rainbow.cpt, then makecpt will read that file first and not look for the master CPT in the shared GMT directory."
  },
  {
    "objectID": "documentation/modules/makecpt.html#source-code",
    "href": "documentation/modules/makecpt.html#source-code",
    "title": "makecpt",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmakecpt(cmd0::Symbol; kwargs...) - makecpt.jl:59\nmakecpt(cmd0::String; ...) - makecpt.jl:60\nmakecpt(cmd0::String, arg1; kwargs...) - makecpt.jl:60\nmakecpt(cmd0::String, arg1, d::Dict) - makecpt.jl:64\nmakecpt(G::GMTgrid; equalize, kw...) - makecpt.jl:92\nmakecpt(; ...) - makecpt.jl:60\nmakecpt(b, e, inc; kw...) - makecpt.jl:174\nmakecpt(b, e; ...) - makecpt.jl:174\nmakecpt(arg1; kw...) - makecpt.jl:173"
  },
  {
    "objectID": "documentation/modules/makecpt.html#see-also",
    "href": "documentation/modules/makecpt.html#see-also",
    "title": "makecpt",
    "section": "See Also",
    "text": "See Also\ngrd2cpt"
  },
  {
    "objectID": "documentation/modules/makecpt.html#references",
    "href": "documentation/modules/makecpt.html#references",
    "title": "makecpt",
    "section": "References",
    "text": "References\nCrameri, F., (2018). Scientific colour-maps. Zenodo. http://doi.org/10.5281/zenodo.1243862\nCrameri, F. (2018), Geodynamic diagnostics, scientific visualisation and StagLab 3.0, Geosci. Model Dev., 11, 2541-2562, doi:10.5194/gmd-11-2541-2018."
  },
  {
    "objectID": "documentation/modules/marginalhist.html",
    "href": "documentation/modules/marginalhist.html",
    "title": "marginalhist",
    "section": "",
    "text": "marginalhist(data; kwargs...)\nTakes a Mx2 array, and make a scatter plot of first vs second column. The default is to do a scatter3 plot if number of points &lt;= 200 and bihex plot otherwise, but this is configurable. Input data can be a MxN matrix, a GMTdataset or a file name that upon reading with gmtread returns a GMTdataset.\nThe plot consists of histograms of each column along the diagonal and scatter or hexagonal bining plots for the inter-variable relations, depending on if the the number of samples is &lt;= 2000. But this can be changed with options in kwargs.\nmarginalhist(..., gap=xx) Set the gap in centimeters between the fig and the marginal plots.\nmarginalhist(..., scatter=true) Force scatter plots even when number of points &gt; 2000. Symbol type (black little circles by default) parameters, fill color and size, are controllabe via normal plot options.\nmarginalhist(...,xvar,yvar) plots the variables xvar and yvar from the table D. You can specify one or multiple variables for yvar and one only for xvar."
  },
  {
    "objectID": "documentation/modules/marginalhist.html#examples",
    "href": "documentation/modules/marginalhist.html#examples",
    "title": "marginalhist",
    "section": "Examples",
    "text": "Examples\nCreate a simple scatter plot with annotated (count numbers in histograms)\n\nusing GMT\nmarginalhist(randn(2500,2), scatter=true, histkw=(annot=true,), show=true)\n\n\n\n\n\n\n\n\nChange mrker type and histogram’s default color.\n\nusing GMT\nmarginalhist(randn(2000,2), histkw=(frame=\"none\", fill=:tomato, W=\"0@100\"),\n             marker=:cross, ms=\"4p\", show=true)\n\n\n\n\n\n\n\n\nAn hexbin scater plot with marginal density plots. Note that we must set aspect=:equal to have that hexbin plot.\n\nusing GMT\nmarginalhist(randn(2500,2), cmap=:lisbon, density=true, histkw=(fill=\"darkgreen@60\",),\n             aspect=:equal, show=true)"
  },
  {
    "objectID": "documentation/modules/marginalhist.html#source-code",
    "href": "documentation/modules/marginalhist.html#source-code",
    "title": "marginalhist",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmarginalhist(fname::String; first, kw...) - statplots.jl:1418\nmarginalhist(arg1::Union{GDtype, Matrix{&lt;:Real}}; first, kwargs...) - statplots.jl:1419"
  },
  {
    "objectID": "documentation/modules/marginalhist.html#see-also",
    "href": "documentation/modules/marginalhist.html#see-also",
    "title": "marginalhist",
    "section": "See Also",
    "text": "See Also\ncornerplot, plot, [binstats], histogram"
  },
  {
    "objectID": "documentation/modules/meca.html",
    "href": "documentation/modules/meca.html",
    "title": "meca",
    "section": "",
    "text": "meca(cmd0::String=\"\", arg1=nothing; kwargs...)\nmeca - Plot focal mechanisms"
  },
  {
    "objectID": "documentation/modules/meca.html#description",
    "href": "documentation/modules/meca.html#description",
    "title": "meca",
    "section": "Description",
    "text": "Description\nReads data values from tables or input arguments and plots focal mechanisms (beachballs). The module reads focal mechanism parameters and plots the corresponding beachballs on a map. Several input format conventions are supported: Aki & Richards, Global CMT, moment tensor, partial focal mechanism, and principal axis."
  },
  {
    "objectID": "documentation/modules/meca.html#focal-mechanism-conventions",
    "href": "documentation/modules/meca.html#focal-mechanism-conventions",
    "title": "meca",
    "section": "Focal Mechanism Conventions",
    "text": "Focal Mechanism Conventions\n\nAki & Richards (aki= or Sa)\nColumns: lon, lat, depth, strike, dip, rake, magnitude, newlon, newlat, text\n\n\nGlobal CMT (CMT= or Sc)\nColumns: lon, lat, depth, strike1, dip1, rake1, strike2, dip2, rake2, mantissa, exponent, newlon, newlat, text\n\n\nMoment Tensor (moment_tensor= or Sm/Sz/Sd)\nColumns: lon, lat, depth, mrr, mtt, mff, mrt, mrf, mtf, exponent, newlon, newlat, text\n\n\nPartial (partial= or Sp)\nColumns: lon, lat, depth, strike1, dip1, strike2, fault_type, magnitude, newlon, newlat, text\n\n\nPrincipal Axis (principal_axis= or Sx/Sy)\nColumns: lon, lat, depth, T_value, T_azim, T_plunge, N_value, N_azim, N_plunge, P_value, P_azim, P_plunge, exponent, newlon, newlat, text"
  },
  {
    "objectID": "documentation/modules/meca.html#required-arguments",
    "href": "documentation/modules/meca.html#required-arguments",
    "title": "meca",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nA data table (or matrices/datasets) containing focal mechanism parameters. The format depends on the convention specified.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or convention : Convention-specific options\nSelects the input convention and symbol size. Choose from:\n\naki or Sa : Aki & Richards convention\nCMT or Sc : Global CMT convention\n\nmoment_tensor or mt or Sm : Seismic moment tensor (full)\ndev or Sz : Deviatoric moment tensor (zero trace)\ndc or Sd : Double couple from moment tensor (zero trace and determinant)\npartial or Sp : Partial focal mechanism\naxis or principal_axis or Sx : Principal axis\nprincipal or Sy : Best double couple from principal axis\n\nAppend scale to set the symbol size. Use tuple form to add modifiers:\n\naki=(scale=val, ...) or CMT=(scale=val, ...) etc.\n\nAvailable modifiers (as named tuple elements):\n\nangle : Rotate text angle\nfont : Set text font\n\njustify : Text justification\nradius_moment : Radius will be proportional to the seismic moment\nsame_size : Plot the same size for any magnitude\noffset : Offset text by dx/dy\nrefmag : Reference magnitude for scaling"
  },
  {
    "objectID": "documentation/modules/meca.html#optional-arguments",
    "href": "documentation/modules/meca.html#optional-arguments",
    "title": "meca",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or offset : – offset=true | offset=(fill=…, offset=.., pen=…, size=…)\nOffsets beachballs to the longitude, latitude specified in the last two columns of the input. A line connects the original and relocated positions. Available modifiers:\n\nfill : Symbol fill color\noffset : Interpret the contents of the two columns as plot offsets instead, or append fixed offset dx[/dy] for all events.\npen : Line pen attributes\nsize : Set the size of the symbol. Prepend any of a|c|d|g|h|i|n|p|s|t|x to change the symbol fron the default [c]\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap : – cmap=cpt\nGive a CPT to determine compressive quadrant fill based on depth (3rd column).\nD or depth_range : – depth_range=(depmin,depmax)\nPlot only events with depths between depmin and depmax.\nE or extensionfill : – extensionfill=fill\nSelects filling of extensive quadrants [Default is white].\nF : – Fa=true | Fa=[size[/Psymbol[Tsymbol]]] , Fe|Fg|Fr=fill , Fp|Ft|Fz=pen , Fo=true\nAliases:\n\nFa or PT_axes : Computes and plots P and T axes with symbols. Optionally specify size and (separate) P and T axis symbols from the following: (c) circle, (d) diamond, (h) hexagon, (i) inverse triangle, (p) point, (s) square, (t) triangle, (x) cross. [Default: 6p/cc]\nFe or T_axis_color : Sets the color or fill pattern for the T axis symbol. [Default as set by extensionfill]\nFo or psvelo : Old psvelomeca format (no depth in 3rd column)\nFg or P_axis_color : Sets the color or fill pattern for the P axis symbol. [Default as set by extensionfill]\nFr or label_box : Draw a box behind the label (if any). [Default fill is white]\nFp or P_axis_pen : Draws the P axis outline using default pen (see W), or sets pen attributes.\nFt or T_axis_pen : Draws the T axis outline using default pen (see W), or sets pen attributes.\nFz or zero_trace : Overlay zero trace moment tensor using default pen (see W), or sets pen attributes.\n\nG or fill or extensionfill : – fill=color\nSelects filling of compressive quadrants [Default is black].\nH or scale : – scale=true | scale=scale\nScale symbol sizes and pen widths on a per-record basis using the scale read from the data file. The symbol size is either provided by convention or via the input size column. Alternatively, append a constant scale that should be used instead of reading a scale column.\nI or intens or intensity : – intens=val | intens=:a\nUse the supplied intens value (nominally in the ±1 range) to modulate the compressional fill color by simulating illumination [none]. If no intensity is provided we will instead read intens from an extra data column after the required input columns determined by convention.\nL or pen_outline : – pen_outline=pen\nDraws the “beach ball” outline using specified pen attributes.\nM or same_size or samesize : – same_size=true\nUse the same size for all beachballs. Size is set from the magnitude columns, but the same size is used regardless of magnitude.\nN or no_clip or noclip : – no_clip=true\nDo NOT skip symbols that fall outside the map border [Default clips symbols].\nT or nodal : – nodal=plane | nodal=(plane=val, pen=…)\nPlot nodal planes and circumference only. Specify which plane(s) to draw:\n\n0 : Both planes\n1 : Only first nodal plane\n\n2 : Only second nodal plane\n\nUse tuple form to set pen: nodal=(plane=0, pen=pen_spec)\nFor double couple mechanisms, the nodal option renders the beach ball transparent by drawing only the nodal planes and the circumference. For non-double couple mechanisms, nodal=0 option overlays best double couple transparently.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen : – pen=pen\nSet pen attributes for features [Default pen is 0.25p,black,solid]. This setting applies to A, L, T, Fp, Ft, and Fz, unless overruled by options to those arguments. See also [Pen attributes]\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/meca.html#examples",
    "href": "documentation/modules/meca.html#examples",
    "title": "meca",
    "section": "Examples",
    "text": "Examples\nPlot focal mechanisms using Aki-Richards convention:\n\nusing GMT\n\n# Create focal mechanism data  \nD = mat2ds([0.0 5.0 0.0 0 90 0 5 0 0], [\"Right Strike Slip\"])\n\n# Plot with fixed size beachballs\nmeca(D, region=(-1,4,1,6), proj=:Mercator, aki=2.5, fill=:black, show=true)\n\n\n\n\n\n\n\n\nPlot using Global CMT convention with depth-based coloring:\n# Background map\ngrdimage(\"@earth_relief\", region=[-74,-59,5,15], proj=:guess, figsize=10, shade=true)\ncoast!(shorelines=true, borders=((type=1, pen=0.8),(type=2, pen=0.1)))\n\n# Focal mechanisms with offsets\nmeca!(\"focal_data.txt\", CMT=(scale=0.4, font=6), offset=true, fill=:black, show=true)\nPlot multiple mechanisms with varying types:\n\nusing GMT\n\n# Right lateral strike slip\nD1 = mat2ds([0.0 5.0 0.0 0 90 0 5 0 0], [\"Right Strike Slip\"])\nmeca(D1, region=(-1,4,1,6), proj=:Mercator, aki=2.5, fill=:black)\n\n# Thrust fault\nD2 = mat2ds([0.0 3.5 0.0 0 45 90 5 0 0], [\"Thrust\"])\nmeca!(D2, aki=2.5, fill=:black)\n\n# Normal fault\nD3 = mat2ds([0.0 2.0 0.0 0 45 -90 5 0 0], [\"Normal\"])  \nmeca!(D3, aki=2.5, fill=:black, show=true)\n\n\n\n\n\n\n\n\n\nusing GMT\n\npsmeca([0.0 3.0 0.0 0 45 90 5 0 0], aki=true, fill=:black, region=(-1,4,0,6), proj=:Merc, show=1)\n\n\n\n\n\n\n\n\nThe same but add a Label\n\npsmeca(mat2ds([0.0 3.0 0.0 0 45 90 5 0 0], [\"Thrust\"]), aki=true, fill=:black, region=(-1,4,0,6), proj=:Merc, show=1)"
  },
  {
    "objectID": "documentation/modules/meca.html#references",
    "href": "documentation/modules/meca.html#references",
    "title": "meca",
    "section": "References",
    "text": "References\nAki, K., & Richards, P. G. (1980). Quantitative seismology: theory and methods. San Francisco: W. H. Freeman.\nDahlen, F. A., & Tromp, J. (1998). Theoretical global seismology. Princeton, N.J: Princeton University Press.\nFrohlich, C. (1996). Cliff’s Nodes Concerning Plotting Nodal Lines for P, SH and SV. Seismological Research Letters, 67(1), 16–24, https://doi.org/10.1785/gssrl.67.1.16.\nLay, T., & Wallace, T. C. (1995). Modern global seismology. San Diego: Academic Press."
  },
  {
    "objectID": "documentation/modules/meca.html#source-code",
    "href": "documentation/modules/meca.html#source-code",
    "title": "meca",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmeca(cmd0::String; kwargs...) - psmeca.jl:77\nmeca(arg1; kwargs...) - psmeca.jl:78"
  },
  {
    "objectID": "documentation/modules/meca.html#see-also",
    "href": "documentation/modules/meca.html#see-also",
    "title": "meca",
    "section": "See Also",
    "text": "See Also\ncoupe, polar, velo\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/mgd77track.html",
    "href": "documentation/modules/mgd77track.html",
    "title": "mgd77track",
    "section": "",
    "text": "Plot track-lines of MGD77 cruises.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/nearneighbor.html",
    "href": "documentation/modules/nearneighbor.html",
    "title": "nearneighbor",
    "section": "",
    "text": "nearneighbor(cmd0::String=\"\", arg1=nothing; kwargs...)\nGrid table data using a “Nearest neighbor” algorithm"
  },
  {
    "objectID": "documentation/modules/nearneighbor.html#description",
    "href": "documentation/modules/nearneighbor.html#description",
    "title": "nearneighbor",
    "section": "Description",
    "text": "Description\nReads randomly-spaced (x,y,z[,w]) triples [quadruplets] from file or table and uses a nearest neighbor algorithm to assign a weighted average value to each node that has one or more data points within a search radius (R) centered on the node with adequate coverage across a subset of the chosen sectors. The node value is computed as a weighted mean of the nearest point from each sector inside the search radius. The weighting function and the averaging used is given by\n\\[ w(r_i) = \\frac{w_i}{1 + d(r_i) ^ 2}, \\quad d(r) = \\frac {3r}{R}, \\quad \\bar{z} = \\frac{\\sum_i^n w(r_i) z_i}{\\sum_i^n w(r_i)} \\]\nwhere n is the number of data points that satisfy the selection criteria and \\(r_i\\) is the distance from the node to the i’th data point. If no data weights are supplied then \\(w_i = 1\\).\n\nusing GMT\n\nplot([0.75 1.25], region=(0,2,0,2), figscale=4, marker=:circ, ms=5, pen=:thick, fill=\"lightgreen@70\", frame=(grid=0.25,))\nd = [0.04 1.8; 0.3 0.3; 0.31 0.7; 0.65 1.88; 0.9 0.44; 0.88 0.2; 1.3 0.8; 1.72 1.1; 1.33 1.59; 1.8 1.9; 1.82 0.5; 1.6 1.3;\n# inside but not close enough\n0.5 0.9; 0.3 1.3; 0.8 1.7; 0.6 1.65]\nplot!(d, marker=:circ, ms=0.25, fill=:black)\nplot!([0.52 1.52; 0.6 1.2; 1.15 1.3; 1 0.88], marker=:circ, ms=0.25, fill=:red)\nd = [0.75 1.25; 0.5 0.9; NaN NaN; 0.75 1.25; 0.52 1.52; NaN NaN; 0.75 1.25; 0.6 1.2; NaN NaN; 0.75 1.25; 1.15 1.3; NaN NaN; 0.75 1.25; 1 0.88]\nplot!(d, pen=:thinnest)\nplot!([0.25 1.25; 1.25 1.25; NaN NaN; 0.75 0.75; 0.75 1.75], pen=:thicker)\nplot!([0.75 1.25; 1.10355 1.60355], pen=(1,:dash))\ntext!(mat2ds([1 1.4; 1.03 0.93],[\"R\", \"r@-i@-\"]), font=(16,\"Times-Italic\"), justify=:BL)\nshowfig()\n\n\n\n\n\n\n\n\nSearch geometry includes the search radius (R) which limits the points considered and the number of sectors (here 4), which restricts how points inside the search radius contribute to the value at the node. Only the closest point in each sector (red circles) contribute to the weighted estimate."
  },
  {
    "objectID": "documentation/modules/nearneighbor.html#required-arguments",
    "href": "documentation/modules/nearneighbor.html#required-arguments",
    "title": "nearneighbor",
    "section": "Required Arguments",
    "text": "Required Arguments\ntable 3 [or 4, see weights] column data from file or GMTdataset holding (x,y,z[,w]) data values. If no file is specified, nearneighbor will read from standard input.\n\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or search_radius : – search_radius=rad\nSets the search_radius that determines which data points are considered close to a node. Append the distance unit (see [Units])."
  },
  {
    "objectID": "documentation/modules/nearneighbor.html#optional-arguments",
    "href": "documentation/modules/nearneighbor.html#optional-arguments",
    "title": "nearneighbor",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nE or empty : – empty=??\nSet the value assigned to empty nodes [NaN].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nN or sectors or nn or nearest : – sectors=n_sectors | sectors=(n=n_sectors, min_sectors=n_min)\nThe circular search area centered on each node is divided into n_sectors sectors. Average values will only be computed if there is at least one value inside each of at least n_min of the sectors for a given node. Nodes that fail this test are assigned the value NaN (but see empty). If min_sectors is omitted then n_min is set to be at least 50% of n_sectors (i.e., rounded up to next integer) [Default is a quadrant search with 100% coverage, i.e., n_sectors = n_min = 4]. Note that only the nearest value per sector enters into the averaging; the more distant points are ignored. Alternatively, use sectors:nn or sectors=:nearest to call GDALʻs nearest neighbor algorithm instead.\nW or weights : – weights=true\nInput data have a 4th column containing observation point weights. These are multiplied with the geometrical weight factor to determine the actual weights used in the calculations.\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nn or interp or interpol : – interp=params\nSelect interpolation mode for grids. More at [interp](../common_opts/opt_n.html)\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/nearneighbor.html#examples",
    "href": "documentation/modules/nearneighbor.html#examples",
    "title": "nearneighbor",
    "section": "Examples",
    "text": "Examples\nTo grid the data in the remote file @ship_15.txt at 5x5 arc minutes using a search radius of 15 arch minutes, and plot the resulting grid using default projection and colors, do\n\nusing GMT\nG = nearneighbor(\"@ship_15.txt\", region=(245,255,20,30), inc=\"5m\", S=\"15m\")\nimshow(G)\n\n\n\n\n\n\n\n\nTo create a gridded data set from the file seaMARCII_bathy.lon_lat_z using a 0.5 min grid, a 5 km search radius, using an octant search with 100% sector coverage, and set empty nodes to -9999:\n    G = nearneighbor(\"seaMARCII_bathy.lon_lat_z\", region=(242,244,-22,-20), inc=\"0.5m\",\n                     empty=-9999, search_radius=\"5k\", sectors=(n=8, min_sectors=8))\nTo make a global grid file from the data in geoid.xyz using a 1 degree grid, a 200 km search radius, spherical distances, using an quadrant search, and set nodes to NaN only when fewer than two quadrants contain at least one value:\n    G = nearneighbor(\"geoid.xyz\", region=(0,360,-90,90), inc=1, -Lg search_radius=\"200k\", sectors=4)"
  },
  {
    "objectID": "documentation/modules/nearneighbor.html#source-code",
    "href": "documentation/modules/nearneighbor.html#source-code",
    "title": "nearneighbor",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nnearneighbor(; kwargs...) - nearneighbor.jl:48\nnearneighbor(cmd0::String; kwargs...) - nearneighbor.jl:46\nnearneighbor(arg1; kwargs...) - nearneighbor.jl:47"
  },
  {
    "objectID": "documentation/modules/nearneighbor.html#see-also",
    "href": "documentation/modules/nearneighbor.html#see-also",
    "title": "nearneighbor",
    "section": "See Also",
    "text": "See Also\nblockmean, blockmedian, blockmode, greenspline, sphtriangulate, surface, triangulate"
  },
  {
    "objectID": "documentation/modules/parallelplot.html",
    "href": "documentation/modules/parallelplot.html",
    "title": "parallelplot",
    "section": "",
    "text": "parallelplot(cmd0::String=\"\", arg1=nothing; labels|axeslabels=String[], group=Vector{String},\n             groupvar=\"\", normalize=\"range\", kwargs...)\nCreates a parallel coordinates plot from the table (Matrix or GMTdataset). Each line in the plot represents a row in the table, and each coordinate variable in the plot corresponds to a column in the table. By default, table columns are plotted.\nThis module is a subset of plot to make it simpler to draw stair plots. So not all (fine) controlling parameters are not listed here. For the finest control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/parallelplot.html#parameters",
    "href": "documentation/modules/parallelplot.html#parameters",
    "title": "parallelplot",
    "section": "Parameters",
    "text": "Parameters\n\naxeslabels or labels : – axeslabels=[“??”,“??”,…] | labels=[“??”,“??”,…]\nString vector with the names of each variable axis. Plots a default “Label?” if not provided..\ngroup : – group=[“??”,“??”,…] | group=Int(…)\nA string vector or vector of integers used to group the lines in the plot.\ngroupvar : – groupvar=“text | groupvar=Int | groupvar=:ColName\nUses the table variable specified by groupvar to group the lines in the plot. groupvar can be a column number, or a column name passed in as a Symbol. e.g. groupvar=:Male if a column with that name exists. When arg1 is GMTdatset or cmd0 is the name of a file with one and it has the text field filled, use groupvar=\"text\" to use that text field as the grouping vector.\nnomalize : – nomalize=“range” | nomalize=“none” | nomalize=“score” | nomalize=“scale”\n\n\nrange: (Default) Display raw data along coordinate rulers that have independent minimum and maximum limits.\nnone or \"\": Display raw data along coordinate rulers that have the same minimum and maximum limits.\nzscore: Display z-scores (with a mean of 0 and a standard deviation of 1) along each coordinate ruler.\nscale: Display values scaled by standard deviation along each coordinate ruler.\n\nquantile : – quantile=0.25\nGive a quantile in the [0-1] interval to plot the median +- quantile as dashed lines.\nstd : – std=1\nInstead of median plus quantile lines, draw the mean +- one standard deviation. This is achieved with both std=true or std=1. For other number od standard deviations use, e.g. std=2, or std=1.5.\nband : – band=true\nIf used, instead of the dashed lines referred above, plot a band centered in the median. The band colors are assigned automatically but this can be overriden by the fill option. If set and quantile not given, set a default of quantile = 0.25.\nfill : – fill=true | fill=[“color1”, “color2”, …]*  When band option is used and want to control the bands colors, give a list of colors to paint them.\nfillalpha : – fillalpha=[0.5, 0.7, …]\nWhen fill option is used, we can set the bands transparency with this option that takes in an array (vec or 1-row matrix) with numeric values between [0-1] or ]1-100], where 100 (or 1) means full transparency.\nFor fine the lines settings use the same options as in the plot module. Nemely lw or lt for controling the line thickness, lc for line color, ls for line styles, etc…\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/parallelplot.html#examples",
    "href": "documentation/modules/parallelplot.html#examples",
    "title": "parallelplot",
    "section": "Examples",
    "text": "Examples\nCreate a parallel plot using the measurement data in iris.dat. Use a different color for each group as identified in species, and label the horizontal axis using the variable names.\n\nusing GMT\nparallelplot(GMT.TESTSDIR * \"iris.dat\", groupvar=\"text\", normalize=\"none\", legend=true, show=true)\n\n\n\n\n\n\n\n\nPlot only the median, 25 percent, and 75 percent quartile values for each group identified in species. Label the horizontal axis using the variable names.\n\nusing GMT\nparallelplot(GMT.TESTSDIR * \"iris.dat\", groupvar=\"text\", quantile=0.25, legend=true, show=true)\n\n\n\n\n\n\n\n\nPlot bands enveloping the +- 25% percentil arround the median.\n\nusing GMT\nparallelplot(GMT.TESTSDIR * \"iris.dat\", groupvar=\"text\", band=true, legend=true, show=true)"
  },
  {
    "objectID": "documentation/modules/parallelplot.html#source-code",
    "href": "documentation/modules/parallelplot.html#source-code",
    "title": "parallelplot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nparallelplot(cmd0::String; axeslabels, labels, group, groupvar, normalize, kw...) - statplots.jl:1097\nparallelplot(arg1; axeslabels, labels, group, groupvar, normalize, kw...) - statplots.jl:1094"
  },
  {
    "objectID": "documentation/modules/plot.html",
    "href": "documentation/modules/plot.html",
    "title": "plot",
    "section": "",
    "text": "plot(cmd0::String=\"\", arg1=[]; kwargs...)\nReads (x,y) pairs and plot lines, polygons, or symbols with different levels of decoration. The input can either be a file name of a file with at least two columns (x,y),but optionally more, a GMTdatset object with also two or more columns. If a symbol is selected and no symbol size given, then it will interpret the third column of the input data as symbol size. Symbols whose size is &lt;= 0 are skipped. If no symbols are specified then the symbol code (see symbol below) must be present as last column in the input. If symbol is not used, a line connecting the data points will be drawn instead. To explicitly close polygons, use close. Select a fill with fill. If fill is set, pen will control whether the polygon outline is drawn or not. If a symbol is selected, fill and pen determines the fill and outline/no outline, respectively.\nSince many options imply further data, to control symbol size and/or color for example, columns beyond 2 for plot or 3 for plot3d cannot be used to plot multiple lines at once (like Matlab does). However, that is stil possible if one uses the form plot(x, y, ...) where x is the coordinates vector or a matrix with only one column or row and y is a matrix with N columns representing the individual lines and M rows, as many as elements in x. This case, off course, looses the possibility of having extra columns with options auxiliary data. Still, another possibility to achieve this when arg1 is a MxN matrix is to use the key/val multicol=true. Automatic legends are obtained by using legend=true.\nSelecting both a symbol and a pen plots a line and add the sybols at the vertex."
  },
  {
    "objectID": "documentation/modules/plot.html#parameters",
    "href": "documentation/modules/plot.html#parameters",
    "title": "plot",
    "section": "Parameters",
    "text": "Parameters\n\nA or steps : – steps=true | steps=:meridian|:parallel|:x|:y|:r|:theta\nBy default, geographic line segments (as indicated for example by the colinfo option) are drawn as great circle arcs. To draw them as straight lines, use the steps=true. Alternatively, use steps=:meridian to draw the line by first following a meridian, then a parallel. Or append steps=:parallel to start following a parallel, then a meridian. (This can be practical to draw a line along parallels, for example). For Cartesian data, points are simply connected, unless you use steps=:x or steps=:y to draw stair-case curves that whose first move is along x or y, respectively. If your Cartesian data are polar (theta, r), use steps=:t or steps=:r to construct stair-case paths whose first move is along theta or r, respectively.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nbg or background : – bg=imagename | bg=funname|img|grd | bg=(…, colormap)\nFills the plotting canvas with a backround image. That image may come from a file (e.g. bg=“cute.png”) or from a predefined function name. Possible names are: akley, eggs, circle, parabola, rosenbrok, sombrero, x, y, xy, x+y (see also [Plot surfaces]). In the forms bg=img and bg=grd, the img and grd stand for a GMTimage and a GMTgrid object respectively. Image types can have associated a color map (if they do not, see the [image_cpt!] on how to assign one) but a grid type do not so we need to provide that information in case the turbo default is not intended. To assign a colormap the bg argument must be a two elements tuple, where first element is any of funname|img|grd and the second a colormap name (a CPT) or a GMTcpt object (see also makecpt). To revert the sense of the color progression prefix the colormap name or of the predefined function with a ‘-’. Example: plot(rand(8,2), bg=(:sombrero, \"-magma\")). Note that the images, either generated or read from file, will normally be deformed to fill the entire area selected with the region option. If that is not wished or if the image coordinates are intended to be used, then this is not the right option but instead you should grdimage followed plot call(s). Another point to notice is that the [frame] option also has a fill or bg|background option that also fills the canvas but it does it using a constant color by replicating a pattern (that can be an image too) and this has a quite different result. The example [Subplots] shows applications of this option.\nC or color or cmap : – color=cpt\nGive a CPT or specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically, where z starts at 0 and is incremented by one for each color. In this case color_n can be a [r g b] triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ). If symbol is set, let symbol fill color be determined by the z-value in the third column. Additional fields are shifted over by one column (optional size would be 4th rather than 3rd field, etc.). If symbol is not set, then it expects the user to supply a multisegment file where each segment header contains a Zval string. The val will control the color of the line or polygon (if close is set) via the CPT.\nD or shift or offset : – offset=(dx,dy) | offset=dx\nOffset the plot symbol or line locations by the given amounts dx,dy [Default is no offset]. If dy is not given it is set equal to dx.\nE or error or errorbars : – error=(x|y|X|Y=true, notch=true, cap=width, pen=pen, colored=true, cline=true, csymbol=true)\nDraw symmetrical error bars. Use error=(x=true) and/or error=(y=true) to indicate which bars you want to draw (Default is both x and y). The x and/or y errors must be stored in the columns after the (x,y) pair [or (x,y,z) triplet]. If asym=true is appended then we will draw asymmetrical error bars; these requires two rather than one extra data column, with the low and high value. If upper case error=(X=true) and/or Y are used we will instead draw “box-and-whisker” (or “stem-and-leaf”) symbols. The x (or y) coordinate is then taken as the median value, and four more columns are expected to contain the minimum (0% quantile), the 25% quantile, the 75% quantile, and the maximum (100% quantile) values. The 25-75% box may be filled by using fill. If notch=true is appended the we draw a notched “box-and-whisker” symbol where the notch width reflects the uncertainty in the median. This symbol requires a 5th extra data column to contain the number of points in the distribution. The cap=width modifier sets the cap width that indicates the length of the end-cap on the error bars [7p]. Pen attributes for error bars may also be set via pen=pen. [Defaults: width = default, color = black, style = solid]. When color is used we can control how the look-up color is applied to our symbol. Add cline=true to use it to fill the symbol, while csymbol=true will just set the error pen color and turn off symbol fill. Giving colored=true will set both color items.\nF or conn or connection : – conn=(continuous=true, net|network=true, refpoint=true, ignore_hdr=true, single_group=true, segments=true, anchor=(x,y))\nAlter the way points are connected (by specifying a scheme) and data are grouped (by specifying a method). Use one of three line connection schemes:\n\ncontinuous=true : Draw continuous line segments for each group [Default].\nrefpoint=true : Draw line segments from a reference point reset for each group.\nnetwork=true : Draw networks of line segments between all points in each group. Optionally, use one of four segmentation methods to define the group:\nignore_hdr=true : Ignore all segment headers, i.e., let all points belong to a single group, and set group reference point to the very first point of the first file.\nsingle_group=true : Consider all data in each file to be a single separate group and reset the group reference point to the first point of each group.\nsegments=true : Segment headers are honored so each segment is a group; the group reference point is reset to the first point of each incoming segment [Default].\nsegments_reset=true : Same as segments=true, but the group reference point is reset after each record to the previous point (this method is only available with the refpoint=true scheme). Instead of the codes ignore_hdr, single_group, segments, segments_reset you may append the coordinates of a anchor=(x,y) which will serve as a fixed external reference point for all groups.\n\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nJz or JZ or zscale or zsize (for plot3d only) : – zscale=scale | zsize=size\nSet z-axis scaling or or z-axis size. zsize=size sets the size to the fixed value size (for example zsize=10 or zsize=4i). zscale=scale sets the vertical scale to UNIT/z-unit.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nhexbin : – hexbin=true\nMake a 2D hexagonal binning plot of points xy that have been processed by binstats(xy, tiling=:hex, stats=...). Note thatb for this we rely in keeping a correct trac of the figure size and plot limis, which is not obvious because those are often given as strings and we must parse them back to numeric. In case it fails, it’s users responsability to provide a correct size to the marker=hexagon, markersize=??? options.\nI or shade : – shade=intens\nUse the supplied intens value (nominally in the -1 to +1 range) to modulate the fill color by simulating illumination [none]. If no intensity is provided (e.g. shade=““) we will instead read intens from the first data column after the symbol parameters (if given).\nL or close or polygon : – close=(sym=true, asym=true, envelope=true, left=true, right=true, x0=x0, top=true, bot=true, y0=y0, pen=pen)\nForce closed polygons. Alternatively, add modifiers to build a polygon from a line segment.\n\nsym=true to build symmetrical envelope around y(x) using deviations dy(x) given in extra column 3.\nasym=true to build asymmetrical envelope around y(x) using deviations dy1(x) and dy2(x) from extra columns 3-4.\nenvelope=true to build asymmetrical envelope around y(x) using bounds yl(x) and yh(x) from extra columns 3-4.\nleft=true or right=true or x0=x0 to connect first and last point to anchor points at either xmin, xmax, or x0, or\nbot=true or top=true or y0=y0 to connect first and last point to anchor points at either ymin, ymax, or y0. Polygon may be painted (fill) and optionally outlined by adding pen=pen. See also the ribbon option further down.\n\nN or noclip or no_clip : noclip=true | noclip=:r | noclip=:c\nDo NOT clip symbols that fall outside map border [Default plots points whose coordinates are strictly inside the map border only]. This option does not apply to lines and polygons which are always clipped to the map region. For periodic (360-longitude) maps we must plot all symbols twice in case they are clipped by the repeating boundary. The noclip will turn off clipping and not plot repeating symbols. Use noclip=:r to turn off clipping but retain the plotting of such repeating symbols, or use noclip=:c to retain clipping but turn off plotting of repeating symbols.\nS or symbol or marker : – symbol=(symb=name, size=val, unit=unity) or marker|Marker|shape=name, markersize|MarkerSize|ms|size=val\nPlot symbols (including vectors, pie slices, fronts, decorated or quoted lines). If present, size is symbol size in the unit set in gmt.conf (unless c, i, or p is appended to markersize or synonym or cm, inch, point as unity when using the symbol=(symb=name,size=val,unit=unity) form). If the symbol name is not given it will be read from the last column in the input data (must come from a file name or a GMTdataset); this cannot be used in conjunction with binary input (data from file). Optionally, append c, i,or p to indicate that the size information in the input data is in units of cm, inch, or point, respectively [Default is PROJ_LENGTH_UNIT]. Note: if you provide both size and symbol via the input file you must use PROJ_LENGTH_UNIT to indicate the unit used for the symbol size or append the units to the sizes in the file. If symbol sizes are expected via the third data column then you may convert those values to suitable symbol sizes via the incol mechanism.\nYou can change symbols by adding the required -S option to any of your multisegment headers (GMTdataset only). Choose between these symbol codes:\n\n- or x-dash size is the length of a short horizontal (x-dir) line segment.\n+ or plus size is diameter of circumscribing circle.\na or * or star size is diameter of circumscribing circle.\nc or circle size is diameter of circle.\nd or diamond size is diameter of circumscribing circle.\ne or ellipse Direction (in degrees counter-clockwise from horizontal), major_axis, and minor_axis must be found in columns 3, 4, and 5.\nE or Ellipse Same as ellipse, except azimuth (in degrees east of north) should be given instead of direction. The azimuth will be mapped into an angle based on the chosen map projection (ellipse leaves the directions unchanged.) Furthermore, the axes lengths must be given in geographical instead of plot-distance units. An exception occurs for a linear projection in which we assume the ellipse axes are given in the same units as region. For degenerate ellipses (circles) with just the diameter given, use Ellipse-. The diameter is excepted to be given in column 3. Alternatively, append the desired diameter to E- and this fixed diameter is used instead (e.g. symbol=“E-500”). For allowable geographical units, see UNITS.\nfront Draw a front. See [Front lines]\ng or octagon size is diameter of circumscribing circle.\nh or hexagon size is diameter of circumscribing circle.\ni or inverted_tri size is diameter of circumscribing circle.\nj or rotated_rec Rotated rectangle. Direction (in degrees counter-clockwise from horizontal), x-dimension, and y-dimension must be found in columns 3, 4, and 5.\nJ or Rotated_rec Same as rotated_rec, except azimuth (in degrees east of north) should be given instead of direction. The azimuth will be mapped into an angle based on the chosen map projection (rotated_rec leaves the directions unchanged.) Furthermore, the dimensions must be given in geographical instead of plot-distance units. For a degenerate rectangle (square) with one dimension given, use J-. The dimension is excepted to be given in column 3. Alternatively, append the dimension diameter to J- and this fixed dimension is used instead. An exception occurs for a linear projection in which we assume the dimensions are given in the same units as region. For allowable geographical units, see UNITS.\nm or matang math angle arc, optionally with one or two arrow heads [Default is no arrow heads]. The size is the length of the vector head. Arc width is set by pen, with vector head outlines defaulting to half of arc width. The radius of the arc and its start and stop directions (in degrees counter-clockwise from horizontal) must be given in columns 3-5. See [Vector Attributes] for specifying other attributes.\nM or Matang Same as matang but switches to straight angle symbol if angles subtend 90 degrees exactly.\nn or pentagon size is diameter of circumscribing circle.\np or point No size needs to be specified (1 pixel is used).\nquoted lines i.e., lines with annotations such as contours. See [Quoted lines]\nr or rectangle No size needs to be specified, but the x- and y-dimensions must be found in columns 3 and 4.\nR or roundrect Rounded rectangle. No size needs to be specified, but the x- and y-dimensions and corner radius must be found in columns 3, 4, and 5.\ns or square size is diameter of circumscribing circle.\nt or ^ or triangle size is diameter of circumscribing circle.\nw or wedge or web or pie size is diameter of circumscribing circle. Data is x,y (center) startdir and stopdir\nW or Wedge or Web or Pie Same as wedge, except azimuths (in degrees east of north) should be given instead of the two directions.\nx or cross size is diameter of circumscribing circle.\ny or y-dash (|). size is the length of a short vertical (y-dir) line segment.\ndecorated i.e., lines with symbols along them. See [Decorated lines]\n\ncsymbol or cmarker or custom_symbol or custom_marker : – csymbol=(name=symbname, size=val, unit=unity)\nUse one the GMT’s custom symbols where symbname is the lowercase name of any of those in the table, plus arrow or ski_alpine (these are from GMT.jl).\nW or pen=pen\nSet pen attributes for lines or the outline of symbols [Defaults: width = default, color = black, style = solid]. See [Pen attributes]. If the modifier pen=(cline=true) is appended then the color of the line are taken from the CPT (see cmap). If instead modifier pen=(csymbol=true) is appended then the color from the cpt file is applied to symbol fill. Use pen=(colored=true) for both effects. You can also append one or more additional line attribute modifiers: offset=val will start and stop drawing the line the given distance offsets from the end point. Append unit u from c | i | p to indicate plot distance on the map or append map distance units instead (see below); bezier=true will draw the line using a Bezier spline; vspecs will place a vector head at the ends of the lines. You can use vec_start and vec_stop to specify separate vector specs at each end [shared specs]. See the [Vector Attributes] for more information. If level is set, then pen=(zlevels=true) assign pen color via cmap and the z-values obtained. Finally, if pen color = :auto then we will cycle through the pen colors implied by COLOR_SET and change on a per-segmentbasis. The width, style, or transparency settings are unchanged.\ndecimate : – decimate=true | decimate=decfactor\nFor very large datasets it may be convenient to decimate data before plotting. The decimate option decimates the input data using a clever algorithm (see MS-thesis). The decfactor (default is 10) is used such that the decimated size is 1÷decfactor of initial size.\ngroupvar or hue : – groupvar=“text” | groupvar=Int | groupvar=:ColName\nUses the table variable specified by groupvar to group the points in the plot. groupvar can be a column number, or a column name passed in as a Symbol. e.g. groupvar=:Male if a column with that name exists. When arg1 is GMTdatset or cmd0 is the name of a file with one and it has the text field filled, use groupvar=\"text\" or groupvar=*text_col_name* to use that text field as the grouping vector.\nlegend and label : – legend=“thelabel” | label=thelabel | legend=(label=“thelabel”, pos=position, box=??, fontsise=?, font=?)\nAdd a legend to the plot. In its simple form just provide legend=\"thelabel\", which plots the legend at the default UpperRight position. To control the legend position and other parameters one must use the tuple form where label=\"thelabel\" is the same as above; pos=position where position is a 2 char code (or its expanded form) like in the text. For a full featured positioning option in legend=(label=\"thelabel\", pos=(...)) see the pos option in legend that allows also to plot the legend outside of the figure space. The box option may take two forms (refer to legend for more details): (1) use box=:none to not plot the legend box or,\n\nbox=(clearance=?, fill=?, inner=?, pen=?, rounded=?, shade=?). For example, box=(pen=1, fill=\"gray95\", shade=true) to plot a light gray box with a shade. When using the groupvar option we can just set legend=true to create a legend containing an entry for each of the groups. Controling the position of that legend is done by omitting the label keyword in the legend=(...) form. e.g. legend=(pos=:TL,). Use fontsise=?, where ? is the size in points, controls the legend text size and font=? to change the default font. Example: label=(fontsize=8, font=\"Helvetica,blue\")\n\nlinefit or regress : – linefit=true\nPlot a regression fit over a scatter plot. Input can either be a GMTdataset obtained from the linearfitxy function or a Mx2 matrix. Preferably use the first form that provides more user control. See the linearfitxy documentation for extra options usable in this case.\nribbon or band : – ribbon=dy | ribbon=(dy1,dy2) | *ribbon=mat | ribbon=(vec1,vec2)\nSimilar to the polygon** option above but where the data to build envelope around y(x) is passed directly via this option instead of extra columns in the input data. In the above dy, dy1, dy2 are scalars, mat is a Mx2 matrix and vec1,vec2 are vectors with the same length as number of rows in input data.\nzcolor or markerz or mz : – zcolor=xx | zcolor=true\nTake the vector xx (same size as number os points in data) and interpolate the current color scale to paint the symbols based on that colr scale. The form zcolor=true is equivant to zcolor=1:npoints\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nZ or level : level=vec | level=(data=vec, outline=true, nofill=true) | level=“att=???”\nInstead of specifying a symbol or polygon fill and outline color via markercolor and pen, give both a value via level and a color lookup table via color. Alternatively, give a vector with one z-value for each polygon in the input data. To apply it to the pen color, use level=(data=vec, outline=true). This results in filled polygons and outline color chosen from the vec and the active cmap. Use level=(data=vec, nofill=true) to only paint outlines but not fill. Instead of a numeric vec, one can pass an attribute name of the attrib holding the numeric data in the GMTdaset. For example, this is legal too: level=(data=“att=FROMAGE”, nofill=true). Here, the contents of the FROMAGE attribute will be used to color lines or polygons. The default is to fill and draw outlines with default color (black). This option is particularly useful to make choropleth maps. Note, options fill and pen may overlap with this option.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/plot.html#units",
    "href": "documentation/modules/plot.html#units",
    "title": "plot",
    "section": "Units",
    "text": "Units\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (spheric_dist=:g). You can use spheric_dist=:f to perform “Flat Earth” calculations (quicker but less accurate) or spheric_dist=:e to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/plot.html#examples",
    "href": "documentation/modules/plot.html#examples",
    "title": "plot",
    "section": "Examples",
    "text": "Examples\nDecorated curve with blue stars\n\nxy = gmt(\"gmtmath -T0/180/1 T SIND 4.5 ADD\");\nlines(xy, axes=:af, pen=(1,:red), decorated=(dist=(2.5,0.25), symbol=:star,\n      symbsize=1, pen=(0.5,:green), fill=:blue, dec2=true), show=true)\n\n\nUndefVarError: `gmt` not defined\n\nStacktrace:\n [1] top-level scope\n   @ In[2]:1"
  },
  {
    "objectID": "documentation/modules/plot.html#source-code",
    "href": "documentation/modules/plot.html#source-code",
    "title": "plot",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nplot(cmd0::String; ...) - plot.jl:140\nplot(cmd0::String, arg1; kw...) - plot.jl:140\nplot(arg1::Number, arg2::Number; kw...) - plot.jl:144\nplot(f::Function; ...) - plot.jl:129\nplot(f1::Function, f2::Function; ...) - plot.jl:135\nplot(f::Function, range_x; first, kw...) - plot.jl:129\nplot(f1::Function, f2::Function, range_t; first, kw...) - plot.jl:135\nplot(; ...) - plot.jl:140\nplot(arg1, arg2; kw...) - plot.jl:142\nplot(arg1; first, kw...) - plot.jl:101"
  },
  {
    "objectID": "documentation/modules/plot.html#see-also",
    "href": "documentation/modules/plot.html#see-also",
    "title": "plot",
    "section": "See Also",
    "text": "See Also\nplot3, scatter, lines, bar\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/polar.html",
    "href": "documentation/modules/polar.html",
    "title": "polar",
    "section": "",
    "text": "Plot polarities on the lower hemisphere of the focal sphere.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/project.html",
    "href": "documentation/modules/project.html",
    "title": "project",
    "section": "",
    "text": "project(cmd0::String=\"\", arg1=nothing, kwargs...)\nProject data onto lines or great circles, or generate tracks"
  },
  {
    "objectID": "documentation/modules/project.html#description",
    "href": "documentation/modules/project.html#description",
    "title": "project",
    "section": "Description",
    "text": "Description\nReads arbitrary (\\(x\\), \\(y\\) [, z]) data and writes any combination of (\\(x, y\\), z, \\(p, q, r, s\\)), where (\\(p, q\\)) are the coordinates in the projection, (\\(r, s\\)) is the position in the (\\(x, y\\)) coordinate system of the point on the profile (\\(q = 0\\) path) closest to (\\(x, y\\)), and z is all remaining columns in the input (beyond the required \\(x\\) and \\(y\\) columns).\nAlternatively, project may be used to generate (\\(r,s,p\\)) triples at equal increments dist along a profile using step. In this case, no input is read.\nProjections are defined in one of three ways:\n\nBy a center (cx,cy) using origin and an azimuth in degrees clockwise from North using azim.\nBy a center (cx,cy) using origin and end point (bx,by) of the projection path using endpoint.\nBy a center (cx,cy) using origin and a rotation pole position (px,py) using pole (not allowed when a Cartesian transformation is set by flat_earth).\n\nTo spherically project data along a great circle path, an oblique coordinate system is created which has its equator along that path, and the zero meridian through (cx,cy). Then the oblique longitude (\\(p\\)) corresponds to the distance from (cx,cy) along the great circle, and the oblique latitude (q) corresponds to the distance perpendicular to the great circle path. When moving in the increasing (\\(p\\)) direction, (in the direction set by azim azimuth ), the positive (\\(q\\)) direction is to the left. If a pole has been specified by pole, then the positive (q) direction is toward the pole.\nTo specify an oblique projection, use the pole option to set the pole. Then the equator of the projection is already determined and the origin option is used to locate the \\(p = 0\\) meridian. The center (cx,cy) will be taken as a point through which the \\(p = 0\\) meridian passes. If you do not care to choose a particular point, use the South pole (cx = 0, cy = -90).\nData can be selectively windowed by using the length and width options. If width is used, the projection width is set to use only points with \\(w_{min} &lt; q &lt; w_{max}\\). If length is set, then the length is set to use only those points with \\(l_{min} &lt; p &lt; l_{max}\\). If the endpoint option has been used to define the projection, then length w may be selected to window the length of the projection to exactly the span from the center (origin) to to the endpoint (endpoint).\nFlat Earth (Cartesian) coordinate transformations can also be made. Set flat_earth and remember that azimuth is clockwise from North (the \\(y\\) axis), NOT the usual cartesian theta, which is counterclockwise from the \\(x\\) axis. (i.e., \\(azimuth = 90 - theta\\)).\nNo assumptions are made regarding the units for \\(x, y, r, s, p, q\\), dist, \\(l_{min}, l_{max}, w_{min}, w_{max}\\). However, if km is selected, map units are assumed and \\(x, y, r, s\\), must be in degrees and \\(p, q\\), dist, \\(l_{min}, l_{max}, w_{min}, w_{max}\\) will be in km.\nCalculations of specific great-circle and geodesic distances or for back-azimuths or azimuths are better done using mapproject as project is strictly spherical.\n\nusing GMT\n\na = atand(4 / 2.5)\nX = project([0 0], origin=(0,-1), endpoint=(2.5,3), flat_earth=true)\nplot([-1.5 -1.0625; 0 -2; 2 1.2; 0.5 2.1375], region=(-3.5,4,-2.7,2.6), fill=:lightgray,\n     xlabel=\"@%7%x@%% or @%7%r@%%\", ylabel=\"@%7%y@%% or @%7%s@%%\", figsize=\"12/0\")\nplot!([0 -1; 2 2.2], marker=:circ, ms=0.3, fill=:orange, frame=(grid=10,))\narrows!([0 -1 2 2.2; 0 -1 -2.5 0.5625], arrow=(len=\"16p\", stop=true, shape=1),\n        endpoint=true, lw=2, fill=:black)\nplot!([0 0], marker=:circ, ms=0.3, fill=:red)\n# Get coordinates of the (0,q) point as well so we can dash the line \nx = -X[4] * sind(a)\ny =  X[4] * cosd(a) - 1\nplot!([X[5] X[6]], marker=:circ, ms=0.2, fill=:blue)\nT = mat2ds([ 0   -1      0;\n             2    2.2    0;\n             1.9  1.9    a;\n            -2.3  0.4    a;\n             2    1.2    a;\n             0   -2      a;\n             0   -2      a;\n            -1.5 -1.0625 a;\n            0.45  0.8   -16],\n           [\"TL @%7%C@%%\", \"BR @%7%E@%%\", \"TC p\", \"RM q\", \"TC L@-max@-\",\n            \"TC L@-min@-\", \"RB W@-min@-\", \"RM W@-max@-\", \"TC @~a@~\"])\ntext!(T, font=(12, \"Times-Italic\"), angle=\"\", justify=\"\", offset=(away=true, shift=0.15))\nplot!([0 0; X[5] X[6]], pen=(0.25, :red, :dash))\nplot!([0 0; x y], pen=(0.25, :red, :dash))\nplot!([0.0 -1], marker=(:matangle, [2.54 a 90], (length=\"9p\", start=true)), ml=0.5, fill=:black)\nshowfig()\n\n\n\n\n\n\n\n\nExplanation of the coordinate system utilized by project. The input point (red circle) is given in the original x-y (or lon-lat) coordinate system and is projected to the p-q coordinate system, defined by the center (center) and either the end-point (outvars) or azimuth (\\(\\alpha\\)), or for geographic data a rotation pole pole (not shown). The blue point has projected coordinates (p,0) and is reported as (r,s) in the original coordinate system. Options length (limit range of p) and width (limit range of q) can be used to exclude data outside the specified limits (light gray area)."
  },
  {
    "objectID": "documentation/modules/project.html#required-arguments",
    "href": "documentation/modules/project.html#required-arguments",
    "title": "project",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nC or origin or start_point : – origin=(cx, cy)\nSet the origin cx,cy of the projection when used with azim or endpoint or set the coordinates cx,cy of a point through which the oblique zero meridian (\\(p = 0\\)) should pass when used with pole. cx,cy is not required to be 90 degrees from the pole set by pole."
  },
  {
    "objectID": "documentation/modules/project.html#optional-arguments",
    "href": "documentation/modules/project.html#optional-arguments",
    "title": "project",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or azim or azimuth : – azim=az\nSet the azimuth of the projection. The azimuth is clockwise from North (the \\(y\\) axis) regardless of whether spherical or Cartesian coordinate transformation is applied.\nE or endpoint or end_pt : – endpoint=(bx,by)\nSet the end point bx,by of the projection path.\nF or outvars : – outvars=flags\nSpecify the desired output using any combination of xyzpqrs in any order, where (\\(p, q\\)) are the coordinates in the projection, (\\(r, s\\)) is the position in the (\\(x, y\\)) coordinate system of the point on the profile (\\(q = 0\\) path) closest to (\\(x, y\\)), and z is all remaining columns in the input (beyond the required \\(x\\) and \\(y\\) columns). [Default is xyzpqrs]. If output format is ASCII then z also includes any trailing text (which is placed at the end of the record regardless of the order of z in flags). Use lower case and do not add spaces between the letters. Note: If step is selected, then the output order is set to be rsp and outvars is not allowed.\nG or step or generate : – step=“dist[unit][/colat][+c][+h][+n]”\nCreate (r, s, p) output points every dist units of p, assuming all units are the same unless \\(x, y, r, s\\) are set to degrees using km. No input is read when step is used. See Units for selecting geographic distance units [km]. The following directives and modifiers are supported:\n\nOptionally, append /colat for a small circle instead [Default is a colatitude of 90, i.e., a great circle]. Note, when using origin and endpoint to generate a circle that goes through the center and end point, the center and end point cannot be farther apart than \\(2|colat|\\).\nOptionally, append +c when using pole to calculate the colatitude that will lead to the small circle going through the center cx/cy.\nOptionally, append +h to report the position of the pole as part of the segment header when using pole [Default is no header].\nOptionally, append +n to indicate a desired number of points rather than an increment. Requires origin and endpoint or |-Z| so that a length can be computed.\n\nL or length : – length=(lmin,lmax) | length=:w\nSpecify length controls for the projected points. Project only those points whose p coordinate is within \\(l_{min} &lt; p &lt; l_{max}\\). If endpoint has been set, then you may alternatively use length=:w to stay within the distance from cx,cy to bx,by.\nN or flat_earth : – flat_earth=true\nSpecify the Flat Earth case (i.e., Cartesian coordinate transformation in the plane). [Default uses spherical trigonometry.]\nQ or km : – km=true\nSpecify that x, y, r, s are in degrees while p, q, dist, lmin, lmax, wmin, wmax are in km. If km is not set, then all these are assumed to be in the same units.\nS or sort : – sort=true\nSort the output into increasing p order. Useful when projecting random data into a sequential profile.\nT or pole : – pole=(px,py)\nSet the position of the rotation pole of the projection as px,py.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or width : – width=(wmin,wmax)\nSpecify width controls for the projected points. Project only those points whose q coordinate is within \\(w_{min} &lt; q &lt; w_{max}\\).\nZ or ellipse : – ellipse=“major[unit][/minor/azimuth][+e]”\nCreate the coordinates of an ellipse with major and minor axes given in km (unless flat_earth is given for a Cartesian ellipse) and the azimuth of the major axis in degrees; used in conjunction with origin (sets its center) and step (sets the distance increment). Note: For the Cartesian ellipse (which requires flat_earth), we expect direction counter-clockwise from the horizontal instead of an azimuth. A geographic major may be specified in any desired unit [Default is km] by appending the unit (e.g., 3d for degrees); if so we assume the minor axis and the increment are also given in the same unit (see Units). For degenerate ellipses you can just supply a single diameter instead. The following modifiers are supported:\n\nAppend +e to adjust the increment set via step so that the ellipse has equal distance increments [Default uses the given increment and closes the ellipse].\n\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/project.html#examples",
    "href": "documentation/modules/project.html#examples",
    "title": "project",
    "section": "Examples",
    "text": "Examples\nTo project the remote data sets ship_03.txt (lon,lat,depth) onto a great circle specified by the two points (330,-18) and (53,21) and sort the records on the projected distances along that circle and only output the distance and the depths, try\n\nusing GMT\nD = project(\"@ship_03.txt\", origin=(330,-18), pole=(53,21), sort=true, outvars=:pz, km=true)\nimshow(D)\n\n\n\n\n\n\n\n\nTo generate points every 10 km along a great circle from 10N,50W to 30N,10W:\n\nusing GMT\nDgc = project(origin=(-50,10), endpoint=(-10,30), step=10, km=true)\nimshow(Dgc, marker=:point, lw=0.5, coast=true)\n\n\n\n\n\n\n\n\n(Note that Dgc could now be used as input for grdtrack, etc. ).\nTo generate points every 1 degree along a great circle from 30N,10W with azimuth 30 and covering a full 360, try:\nD = project(origin=(\"10W\",\"30N\"), azim=30, step=1, length=(-180,180))\nimshow(D, coast=true)\nTo generate points every 10 km along a small circle of colatitude 60 from 10N,50W to 30N,10W:\n\nusing GMT\nDsc = project(origin=(-50,10), endpoint=(-10,30), step=(10,60), km=true)\nimshow(Dsc, marker=:point, lw=0.5, coast=true)\n\n\n\n\n\n\n\n\nTo create a partial small circle of colatitude 80 about a pole at 40E,85N, with extent of 45 degrees to either side of the meridian defined by the great circle from the pole to a point 15E,15N, try\n    D = project(origin=(15,15), pole=(40,85), step=(1,80), length(-45,45))\nTo generate points approximately every 10 km along an ellipse centered on (30W,70N) with major axis of 1500 km with azimuth of 30 degree and a minor axis of 600 km, try\n\nusing GMT\nDellip = project(origin=(-30,70), step=10, ellipse=\"1500/600/30+e\", km=true)\nimshow(Dellip, coast=true)\n\n\n\n\n\n\n\n\nTo project the shiptrack gravity, magnetics, and bathymetry in c2610.xygmb along a great circle through an origin at 30S, 30W, the great circle having an azimuth of N20W at the origin, keeping only the data from NE of the profile and within ± 500 km of the origin, run:\n    Dprj = project(\"c2610.xygmb\", origin=(-30,-30), azim=-20, width=(-10000,0),\n                length=(-500,500), outvars=:pz, km=true)\n(Note in this example that width=(-10000,0) is used to admit any value with a large negative q coordinate. This will take those points which are on our right as we walk along the great circle path, or to the NE in this example.)\nTo make a Cartesian coordinate transformation of mydata.xy so that the new origin is at 5,3 and the new x axis (p) makes an angle of 20 degrees with the old x axis, use:\n    D = project(\"mydata.xy\", origin=(5,3), azimuth=70, outvars=:pq)\nTo take data in the file pacific.lonlat and transform it into oblique coordinates using a pole from the hotspot reference frame and placing the oblique zero meridian (p = 0 line) through Tahiti, run:\n    D = project(\"pacific.lonlat\", pole=(-75,68), origin=(\"-149:26\",\"-17:37\"), outvars=:pq)\nSuppose that pacific_topo.nc is a grid file of bathymetry, and you want to make a file of flowlines in the hotspot reference frame. If you run:\n    G = grd2xyz(\"pacific_topo.nc\");\n    D = project(pole=(-75,68), oigin=(0,-90), outvars=:xyq);\n    Gflow = xyz2grd(region=etc, inc=etc);\nthen Gflow is a grid in the same area as pacific_topo.nc, but flow contains the latitudes about the pole of the projection. You now can use grdcontour on Gflow to draw lines of constant oblique latitude, which are flow lines in the hotspot frame.\nIf you have an arbitrarily rotation pole px,py and you would like to draw an oblique small circle on a map, you will first need to make a file with the oblique coordinates for the small circle (i.e., lon = 0-360, lat is constant), then create a file with two records: the north pole (0/90) and the origin (0/0), and find what their oblique coordinates are using your rotation pole. Now, use the projected North pole and origin coordinates as the rotation pole and center, respectively, and project your file as in the pacific example above. This gives coordinates for an oblique small circle."
  },
  {
    "objectID": "documentation/modules/project.html#source-code",
    "href": "documentation/modules/project.html#source-code",
    "title": "project",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nproject(cmd0::String; ...) - project.jl:66\nproject(; ...) - project.jl:66\nproject(arg1; kw...) - project.jl:80\nproject(cmd0::String, arg1; kwargs...) - project.jl:66"
  },
  {
    "objectID": "documentation/modules/project.html#see-also",
    "href": "documentation/modules/project.html#see-also",
    "title": "project",
    "section": "See Also",
    "text": "See Also\nfitcircle, gmtvector, grdtrack, mapproject, grdproject, grdtrack"
  },
  {
    "objectID": "documentation/modules/quiver.html",
    "href": "documentation/modules/quiver.html",
    "title": "quiver",
    "section": "",
    "text": "quiver(compx, compy; kwargs...)\nor \n    quiver(X, Y, U, V; kwargs...)\nPlot vector field from two component grids"
  },
  {
    "objectID": "documentation/modules/quiver.html#description",
    "href": "documentation/modules/quiver.html#description",
    "title": "quiver",
    "section": "Description",
    "text": "Description\nReads two 2-D grid files which represents the x and y components of a vector field and produces a vector field plot by drawing vectors with orientation and length according to the information in the files. Alternatively, polar coordinate r, theta grids may be given instead. To replicate the Matlab functioning one can also pass four arrays in input: X, Y -&gt; arrays of coordinates as produced by meshgrid; U, V horizontal and vertical components."
  },
  {
    "objectID": "documentation/modules/quiver.html#required-arguments",
    "href": "documentation/modules/quiver.html#required-arguments",
    "title": "quiver",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ncompx Contains the x-components of the vector field.\ncompy Contains the y-components of the vector field."
  },
  {
    "objectID": "documentation/modules/quiver.html#optional-arguments",
    "href": "documentation/modules/quiver.html#optional-arguments",
    "title": "quiver",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or polar : – polar=true\nThe grid files contain polar (r, theta) components instead of Cartesian (x, y) [Default is Cartesian components].\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap or colorap or colorscale : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name (for grd_z only). Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. In this case color1 etc can be a (r,g,b) triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ) (see [Setting color](../common_features/color.html)). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map.\nG or fill : – fill=fill\nSets color or shade for vector interiors (see Fill color/pattern) [Default is no fill]. Alternatively, the fill may be set via |-Q|.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“x”“multx”[“/multy”]\nOnly plot vectors at nodes every x_inc, y_inc apart (must be multiples of original grid spacing). Append m for arc minutes or s for arc seconds. Alternatively, use inc=“x” to specify the multiples multx[/multy] directly [Default plots every node]. Example inc=“x10/5” to select every other 10 nodes in x and 5 nodes in y. NOTE: by default we estimate good values so that the arrows do no overlap so you may start by jumping this option unless some fine control is desired.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nN or noclip or no_clip : noclip=true\nDo NOT clip vectors at map boundaries [Default will clip].\nQ or vec or vector or arrow : – vector=parameters\nModify vector parameters. For vector heads, append vector head size [Default is 0, i.e., stick-plot]. See Vector Attributes for specifying additional attributes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or vscale or vec_scale : – vscale=(inverse=len, length=len, scale=xx, scale_at_lat=??, refsize=size)\nSets scale for vector plot lengths in data units per plot distance measurement unit. Append c, i, or p to indicate the desired plot distance measurement (then xx must be a string) unit (cm, inch, or point); if no unit is given we use the default value that is controlled by PROJ\\_LENGTH\\_UNIT. Vector lengths converted via plot unit scaling will plot as straight Cartesian vectors and their lengths are not affected by map projections and coordinate locations. For geographic data you may alternatively give scale in data units per map distance unit (see Units). Then, your vector magnitudes (in data units) are scaled to map distances in the given distance unit, and finally projected onto the Earth to give plot dimensions. These are geo-vectors that follow great circle paths and their lengths may be affected by the map projection and their coordinates. Finally, use vscale=(inverse=len,…) if it is simpler to give the reciprocal scale in plot length or distance units per data unit. Alternatively, use vscale=(length=len,…) to set a fixed plot len for all vectors. To report the minimum, maximum, and mean data and plot vector lengths of all vectors plotted, use verbose option. If an automatic legend entry is desired via label, or or two modifiers will be required:\n\nscale_at_lat=slon or scale_at_lat=(slon,slat) or scale_at_lat=true controls where on a geographic map a geovector’s refsize length applies. The modifier is neither needed nor available when plotting Cartesian vectors. The length is calculated for latitude slat (optionally supply longitude slon for oblique projections [default is central meridian]). If scale_at_lat=true then we select the reference length origin to be the middle of the map.\nrefsize=size sets the desired reference vector magnitude in data units. E.g., for a reference length of 25 mm/yr for plate motions, use modifier refsize=25 with a corresponding option label=“Velocity (25 mm/yr)”. If refsize is not specified we default to the scale given above.\n\nT or sign_scale : – sign_scale=true\nMeans the azimuths of Cartesian data sets should be adjusted according to the signs of the scales in the x- and y-directions [Leave alone]. This option can be used to convert vector azimuths in cases when a negative scale is used in one of both directions (e.g., positive down).\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format.\nZ or azimuth : – azimuth=true\nThe theta grid provided contains azimuths rather than directions (implies polar=true).\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nl or legend : – legend=params\nAdd a map legend entry to the session legend information file for the current plot (modern mode only). While this option is not expanded, see params at The -l option\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/quiver.html#examples",
    "href": "documentation/modules/quiver.html#examples",
    "title": "quiver",
    "section": "Examples",
    "text": "Examples\nA nice arrow field\n\nusing GMT\n\nX,Y = meshgrid(-pi:pi/8:pi,-pi:pi/8:pi);\nU = sin.(Y);\nV = cos.(X);\nquiver(X, Y, U, V, region=(-3.6,3.6,-3.6,3.6), fill=:black, lc=:red, show=true)\n\n\n\n\n\n\n\n\nFor simplicity let’s create a grid using grdmath and compute its horizontal derivatives. Then we plot them as an arrow field.\n\nG = gmt(\"grdmath -R-2/2/-2/2 -I0.1 X Y R2 NEG EXP X MUL\");\ndzdy = gmt(\"grdmath ? DDY\", G);\ndzdx = gmt(\"grdmath ? DDX\", G);\ngrdcontour(G, annot=:none, pen=:gray80)\nquiver!(dzdx, dzdy, cmap=:turbo, lw=1, show=true)"
  },
  {
    "objectID": "documentation/modules/quiver.html#vector-scaling-and-unit-effects",
    "href": "documentation/modules/quiver.html#vector-scaling-and-unit-effects",
    "title": "quiver",
    "section": "Vector scaling and unit effects",
    "text": "Vector scaling and unit effects\nThe scale given via vscale may require some consideration. As explained in vscale, it is specified in data-units per plot or distance unit. The plot or distance unit chosen will affect the type of vector you select. In all cases, we first compute the magnitude r of the user’s data vectors at each selected node from the x and y components (unless you are passing r, theta grids directly with polar). These magnitudes are given in whatever data units they come with. Let us pretend our data grids record secular changes in the Earth’s magnetic horizontal vector field in units of nTesla/year, and that at a particular node the magnitude is 28 nTesla/year (in some direction). If you specify the scale using plot distance units (c | i | p) then you are selecting Cartesian vectors. Let us further pretend that you selected vscale=“10c” as your scale option. That means you want 10 nTesla/year to equate to a 1 cm plot length. Internally, we convert this scale to a plot scale of 1/10 = 0.1 cm per nTesla/year. Given our vector magnitude of 28 nTesla/year, we multiply it by our plot scale and finally obtain a vector length of 2.8 cm, which is then plotted. The user’s data units do not enter of course, i.e., they always cancel [Likewise, if we had used vscale=“25i” (25 nTesla/year per inch) the plot scale would be (1/25) = 0.04 inch per nTesla/year and the vector plot lengths would be 28 * 0.04 inch = 1.12 inch]. If we now wished to plot a 10 nTesla/year reference vector in the map legend we would plot one that is 10 times 0.1 cm = 1 cm long since the scale length is constant regardless of map projection and location. A 10 nTesla/year vector will be 1 cm anywhere.\nLet us contrast this behavior with what happens if we use a geographic distance unit instead, say vscale=“0.5k” (0.5 nTesla/year per km). Internally, this becomes a map scale of 2 km per nTesta/year. Given our node magnitude of 28 nTesla/year, the vector length will be 28 x 2 km = 56 km. Again, the user’s data unit do not enter. Now, that vector length of 56 km must be projected onto the Earth, and because of map distortions, a 56 km vector will be mapped to a length on the plot that is a function of the user’s map projection, the map scale, and possibly the location on the map. E.g., a 56 km vector due east at Equator on a Mercator map would seem to equal ~0.5 degree longitude but at 60 north it would be more like ~1 degree longitude. A consequence of this effect is that a user who wants to add a 10 nTesla/year reference vector to a legend faces the same problem we do when we wish to draw a 100 km map scale on a map: the plotted length usually will depend on latitude and hence that reference scale is only useful around that latitude.\nThis brings us to the inverse scale option, vscale=(inverse=len,…). This variant is useful when providing the inverse of the scale is simpler. In the Cartesian case above, we could instead give vscale=(inverse=“0.1c”) which would directly imply a plot scale of 0.1 cm per nTesla/year. Likewise, for geographic distances we could give vscale=(inverse=“2k”) for 2 km per nTesla/year scale as well. As the inverse argument increases, the plotted vector length increases as well, while for plain vscale the plot length decreases with increasing scale."
  },
  {
    "objectID": "documentation/modules/quiver.html#notes",
    "href": "documentation/modules/quiver.html#notes",
    "title": "quiver",
    "section": "Notes",
    "text": "Notes\nBe aware that using inc may lead to aliasing unless your grid is smoothly varying over the new length increments. It is generally better to filter your grids and resample at a larger grid increment and use these grids instead of the originals."
  },
  {
    "objectID": "documentation/modules/quiver.html#source-code",
    "href": "documentation/modules/quiver.html#source-code",
    "title": "quiver",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdvector(arg1::Matrix{&lt;:Real}, arg2::Matrix{&lt;:Real}; kw...) - grdvector.jl:186\ngrdvector(arg1, arg2; first, kwargs...) - grdvector.jl:58\ngrdvector(arg1::Matrix{&lt;:Real}, arg2::Matrix{&lt;:Real}, arg3::Matrix{&lt;:Real}, arg4::Matrix{&lt;:Real}; kw...) - grdvector.jl:188"
  },
  {
    "objectID": "documentation/modules/quiver.html#see-also",
    "href": "documentation/modules/quiver.html#see-also",
    "title": "quiver",
    "section": "See Also",
    "text": "See Also\ngrdcontour, plot\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/modules/rose.html",
    "href": "documentation/modules/rose.html",
    "title": "rose",
    "section": "",
    "text": "rose(cmd0::String=\"\", arg1=nothing; kwargs...)\nPlot a polar histogram (rose, sector, windrose diagrams)"
  },
  {
    "objectID": "documentation/modules/rose.html#description",
    "href": "documentation/modules/rose.html#description",
    "title": "rose",
    "section": "Description",
    "text": "Description\nReads (length, azimuth) pairs from matrix or file and plot a windrose diagram. Add incols=0 if your data only has azimuth values. Optionally (with sector), polar histograms may be drawn (sector diagram or rose diagram). Options include full circle and half circle plots. The outline of the windrose is drawn with the same color as MAP_DEFAULT_PEN."
  },
  {
    "objectID": "documentation/modules/rose.html#required-arguments",
    "href": "documentation/modules/rose.html#required-arguments",
    "title": "rose",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nA data table holding length, azimuth or just azimuths values. If only azimuths are given, use incols=0 to indicate a single column; then all lengths are set to unity (see scale=:u to set actual lengths to unity as well)."
  },
  {
    "objectID": "documentation/modules/rose.html#optional-arguments",
    "href": "documentation/modules/rose.html#optional-arguments",
    "title": "rose",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or sector or sectors : – sector=width | sector=“width+r”\nGives the sector width in degrees for sector and rose diagram. [Default 0 means windrose diagram]. Append +r (an forcedly give argument as a string) to draw rose diagram instead of sector diagram.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nRemember that “x” here is radial distance and “y” is azimuth. The ylabel may be used to plot a figure caption. The scale bar length is determined by the radial gridline spacing.\nC or color or cmap : – color=cpt\nGive a CPT or specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. The r-value for each sector is used to look-up the sector color. Cannot be used with a rose diagram.\nD or shift : – shift=true\nShift sectors so that they are centered on the bin interval (e.g., first sector is centered on 0 degrees).\nE or vectors : – vectors=:m | vectors=mode_file | vectors=“+wmode_file”\nPlot vectors showing the principal directions given in the mode_file file (a file name or else a matrix). Alternatively, specify vectors=:m to compute and plot mean direction. See vector_params to control the vector attributes. Finally, to instead save the computed mean direction and other statistics, use vectors=“[m]+wmode_file”. The eight items saved to a single record are: mean_az, mean_r, mean_resultant, max_r, scaled_mean_r, length_sum, n, sign@alpha, where the last term is 0 or 1 depending on whether the mean resultant is significant at the level of confidence set via alpha.\nF or no_scale : – no_scale=true\nDo not draw the scale length bar [Default plots scale bar in lower right corner provided frame is used. We use MAP_TICK_PEN_PRIMARY to draw the scale and label it with FONT_ANNOT_PRIMARY.\nG or fill\nSelects shade, color or pattern for filling the sectors [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color] for extend color selection (including color map generation).\nI or inquire : – inquire=true\nComputes statistics needed to specify a useful region. No plot is generated. The following statistics are computed: n, mean az, mean r, mean resultant length, max bin sum, scaled mean, and linear length sum. Note: You may use outcol to select a subset from this record.\nL or labels : – labels=true | labels=(wlabel,elabel,slabel,nlabel)\nSpecify labels for the 0, 90, 180, and 270 degree marks. For full-circle plot the default is WEST,EAST,SOUTH,NORTH and for half-circle the default is 90W,90E,-,0. A - in any entry disables that label. Use labels=true to disable all four labels. Note that the GMT_LANGUAGE setting will affect the words used.\nM or vector_params : – vector_params=parameters\nUsed with vectors to modify vector parameters. For vector heads, append vector head size [Default is 0, i.e., a line]. See VECTOR ATTRIBUTES for specifying additional attributes. If vectors is not given and the current plot mode is to draw a windrose diagram then using this option will add vector heads to all individual directions using the supplied attributes.\nN or vonmises : – vonmises=mode | vonmises=“mode+ppen”\nDraw the equivalent circular normal distribution, i.e., the von Mises distribution; append desired pen [Default is “0.25p,black”]. The mode selects which central location and scale to use:\n\n0 = mean and standard deviation;\n1 = median and L1 scale (1.4826 * median absolute deviation; MAD);\n2 = LMS (least median of squares) mode and scale.\n\nNote: At the present time, only mode = 0 is supported.\nQ or alpha : – alpha=true | alpha=alpha\nSets the confidence level used to determine if the mean resultant is significant (i.e., Lord Rayleigh test for uniformity) [0.05]. Note: The critical values are approximated [Berens, 2009] and requires at least 10 points; the critical resultants are accurate to at least 3 significant digits. For smaller data sets you should consult exact statistical tables.\nR or region or limits : – region=(r0,r1,az0,az1)\nSpecifies the region of interest in (r, azimuth) space. Here, r0 is 0, r1 is max length in units. For azimuth, specify either -90/90 or 0/180 for half circle plot or 0/360 for full circle.\nS or norm or normalize : – norm=true | norm=“+a”\nNormalize input radii (or bin counts if |-A| is used) by the largest value so all radii (or bin counts) range from 0 to 1. Optionally, further normalize rose plots for area (i.e., take sqrt(r) before plotting [Default is no normalizations].\nT or orientation : – orientation=true\nSpecifies that the input data are orientation data (i.e., have a 180 degree ambiguity) instead of true 0-360 degree directions [Default]. We compensate by counting each record twice: First as azimuth and second as azimuth + 180. Ignored if range is given as -90/90 or 0/180.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for sector outline or rose plot [Default is no outline]. Use pen=“’v’pen” to change pen used to draw vector (requires vectors) [Default is same as sector outline].\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nZ or scale : – scale=:u | scale=scale\nMultiply the data radii by scale. E.g., use scale=0.001 to convert your data from m to km. To exclude the radii from consideration, set them all to unity with scale=:u [Default is no scaling].\nyx : – yx=true\nInput file has (azimuth,radius) pairs rather than the expected (radius,azimuth).\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\no or outcol : – outcol=??\nSelect specific data columns for primary output, in arbitrary order. More at\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at"
  },
  {
    "objectID": "documentation/modules/rose.html#examples",
    "href": "documentation/modules/rose.html#examples",
    "title": "rose",
    "section": "Examples",
    "text": "Examples\nTo plot a half circle rose diagram of the data in the remote data file azimuth_lengths.txt (containing pairs of (azimuth, length in meters)), using a 5 degree bin sector width, on a circle of diameter = 10 cm, using a light blue shading, try:\n\nusing GMT\n    rose(\"@azimuth_lengths.txt\", yx=true, sectors=5, no_scale=true, labels=true,\n         fill=:lightblue, region=(0,1,0,180), xaxis=(annot=true, ticks=true, label=\"Fault length\"),\n         yaxis=(grid=30,), norm=true, show=true)\n\n\n\n\n\n\n\n\nTo plot a full circle wind rose diagram of the data in the file lines.r_az, on a circle of diameter = 10 cm, grid going out to radius = 500 units in steps of 100 with a 45 degree sector interval, using a solid pen width = 0.5 point, and shown in landscape [Default] orientation, use:\n    rose(\"lines.az_r\", region=(0,500,0,360), xaxis=(grid=100,), yaxis=(grid=45,),\n         title=\"Windrose diagram\", pen=0.5, show=true)\nRedo the same plot but this time add orange vector heads to each direction (with nominal head size 0.5 cm but this will be reduced linearly for lengths less than 1 cm) and save the plot, use:\n    rose(\"lines.az_r\", region=(0,500,0,360), xaxis=(grid=100,), yaxis=(grid=45,),\n         title=\"Windrose diagram\", pen=0.5, vector_params=\"0.5c+e+gorange+n1c\", show=true)"
  },
  {
    "objectID": "documentation/modules/rose.html#bugs",
    "href": "documentation/modules/rose.html#bugs",
    "title": "rose",
    "section": "Bugs",
    "text": "Bugs\nNo default radial scale and grid settings for polar histograms. Users must run the module with inquire to find max length in binned data set."
  },
  {
    "objectID": "documentation/modules/rose.html#references",
    "href": "documentation/modules/rose.html#references",
    "title": "rose",
    "section": "References",
    "text": "References\nBerens, P., 2009, CircStat: A MATLAB Toolbox for Circular Statistics, J. Stat. Software, 31(10) , 1-21."
  },
  {
    "objectID": "documentation/modules/rose.html#source-code",
    "href": "documentation/modules/rose.html#source-code",
    "title": "rose",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nrose(cmd0::String; kwargs...) - psrose.jl:75\nrose(arg1; kwargs...) - psrose.jl:76"
  },
  {
    "objectID": "documentation/modules/rose.html#see-also",
    "href": "documentation/modules/rose.html#see-also",
    "title": "rose",
    "section": "See Also",
    "text": "See Also\nhistogram"
  },
  {
    "objectID": "documentation/modules/sac.html",
    "href": "documentation/modules/sac.html",
    "title": "sac",
    "section": "",
    "text": "Plot seismograms in SAC format.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/scatter.html",
    "href": "documentation/modules/scatter.html",
    "title": "scatter",
    "section": "",
    "text": "scatter(cmd0::String=\"\", arg1=nothing; kwargs...)\nReads (x,y) pairs and plot symbols at those locations on a map/figure. The input can either be a file name of a file with at least two columns (x,y), but optionally more, a GMTdatset object with also two or more columns.\nThis module is a subset of plot to make it simpler to draw scatter plots. So many (fine) controlling parameters are not listed here. For a finer control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/scatter.html#required-arguments",
    "href": "documentation/modules/scatter.html#required-arguments",
    "title": "scatter",
    "section": "Required Arguments",
    "text": "Required Arguments\nThere are no required arguments but"
  },
  {
    "objectID": "documentation/modules/scatter.html#optional-arguments",
    "href": "documentation/modules/scatter.html#optional-arguments",
    "title": "scatter",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nG or markerfacecolor or MarkerFaceColor or markercolor or mc or fill\nSelect color or pattern for filling of symbols [Default is no fill]. Note that plot will search for fill and pen settings in all the segment headers (when passing a GMTdaset or file of a multi-segment dataset) and let any values thus found over-ride the command line settings (but those must be provided in the terse GMT syntax). See [Setting color](../common_features/color.html) for extend color selection (including color map generation).\nzcolor or markerz or mz : – zcolor=xx | zcolor=true\nTake the vector xx (same size as number os points in data) and interpolate the current color scale to paint the symbols based on that color scale. The form zcolor=true is equivant to zcolor=1:npoints\nS or symbol or marker or Marker or shape : – Default is circle with a diameter of 7 points\n\nsymbol=symbol string\nA full GMT compact string.\nsymbol=(symb=??, size=??, unit=??)\nWhere symb is one [Symbols] like :circle, size is symbol size in cm, unless unit is specified i.e. :points\n\nIn alternative to the symbol keyword, user can select the symbol name with either marker or shape and symbol size with markersize or ms. The value of these keywords can be either numeric (symb meaning size in cm) or string if an unit is appended, e.g. markersize=\"5p\" This form of symbol selection allows also to specify a variable symbol size. All it’s need for this is that the keyword’s value be an array with the same number of elements as the number of data points.\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/scatter.html#examples",
    "href": "documentation/modules/scatter.html#examples",
    "title": "scatter",
    "section": "Examples",
    "text": "Examples\nA simple scatter of ten points plotted as red circles of 7 points size\n\nusing GMT\nscatter(1:10,rand(10), fill=:red, show=true)\n\n\n\n\n\n\n\n\nA plot where symbol’s size grows linearly\n\nusing GMT\nsizevec = [s for s = 1:10] ./ 10;\nscatter(1:10, 1:10, markersize = sizevec, marker=:square, fill=:green, show=1)"
  },
  {
    "objectID": "documentation/modules/scatter.html#see-also",
    "href": "documentation/modules/scatter.html#see-also",
    "title": "scatter",
    "section": "See also",
    "text": "See also\nThe GMT man page"
  },
  {
    "objectID": "documentation/modules/scatter.html#source-code",
    "href": "documentation/modules/scatter.html#source-code",
    "title": "scatter",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nscatter(cmd0::String; ...) - plot.jl:387\nscatter(cmd0::String, arg1; kw...) - plot.jl:387\nscatter(D::Vector{&lt;:GMTdataset{Float64, 2}}; first, kw...) - plot.jl:399\nscatter(f::Function; ...) - plot.jl:376\nscatter(f1::Function, f2::Function; ...) - plot.jl:382\nscatter(f::Function, range_x; first, kw...) - plot.jl:376\nscatter(f1::Function, f2::Function, range_t; first, kw...) - plot.jl:382\nscatter(; ...) - plot.jl:387\nscatter(arg1, arg2; kw...) - plot.jl:393\nscatter(arg; kw...) - plot.jl:390"
  },
  {
    "objectID": "documentation/modules/segy2grd.html",
    "href": "documentation/modules/segy2grd.html",
    "title": "segy2grd",
    "section": "",
    "text": "Converting SEGY data to a grid.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/segy.html",
    "href": "documentation/modules/segy.html",
    "title": "segy",
    "section": "",
    "text": "Plot a SEGY file in 2-D.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/solar.html",
    "href": "documentation/modules/solar.html",
    "title": "solar",
    "section": "",
    "text": "solar(cmd0::String=\"\", arg1=[]; kwargs...)\nCalculate and plot the day-night terminator and the civil, nautical and astronomical twilights."
  },
  {
    "objectID": "documentation/modules/solar.html#required-arguments",
    "href": "documentation/modules/solar.html#required-arguments",
    "title": "solar",
    "section": "Required Arguments",
    "text": "Required Arguments\nThere are no required arguments but either sun or terminators must be selected."
  },
  {
    "objectID": "documentation/modules/solar.html#optional-arguments",
    "href": "documentation/modules/solar.html#optional-arguments",
    "title": "solar",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or format : format=true\nFormats the report selected by sun=?? using tab-separated fields on a single line. The output is Sun Lon Lat Azimuth Elevation in degrees, Sunrise Sunset Noon in decimal days, day length in minutes, SolarElevationCorrected corrected for the effect of refraction index and Equation of time in minutes. Note that if no position is provided in sun=(lon,lat) the data after Elevation refers to the point (0,0).\ncoast : coast=true | coast=(full coast options list)\nWhen plotting a mapp this option calls the coast module to plot coastlines, rivers, etc… The simple form coast=true will plot the coastlines with a black, 0.5 points thickness, pen. Note, however, that with this option the coastlines are plotted on top of the terminators. If the other way arround is needed, then you must do the usual two calls: coast + solar!\nG or fill : fill=color | G=:c\nSelect color or pattern for filling of terminators; or use G=:c for clipping [Default is no fill]. Deactivate clipping by appending the output of clip C.\nI or sun : sun=true | sun=(lon,lat) | sun=(pos=(lon,lat), date=date) | sun=(pos=(lon,lat), date=date, TZ=tzone)\nPrint current sun position as well as Azimuth and Elevation. Use sun=(lon,lat) to print also the times of Sunrise, Sunset, Noon and length of the day. To add a date, use a NamedTuple instead and add the element date=date in ISO format, e.g, date=“2000-04-25” to compute sun parameters for this date. If necessary, add another element with the time zone via TZ=tzone.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nM or dump : dump=true\nWrite terminator(s) as a multisegment file to standard output. No plotting occurs.\nN or invert : invert=true\nInvert the sense of what is inside and outside the terminator. Only used with clipping (G=:c) and cannot be used together with axes.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or terminators : terminators=“d|c|n|a” | terminators=(term=“d|c|n|a”, date=date) | terminators=(term=“d|c|n|a”, date=date), TZ=tzone)\nPlot (or dump; see dump) one or more terminators defined via the dcna flags. Where: d means day/night terminator; c means civil twilight; n means nautical twilight; a means astronomical twilight. To add a date, use a NamedTuple instead and add the element date=date in ISO format, e.g, date=“2000-04-25” to know where the day-night was at that date. If necessary, add another element with the time zone via TZ=tzone.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen : pen=pen\nSet pen attributes for lines or the outline of symbols [Defaults: width = default, color = black, style = solid].\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/solar.html#examples",
    "href": "documentation/modules/solar.html#examples",
    "title": "solar",
    "section": "Examples",
    "text": "Examples\nPrint current Sun position and Sunrise, Sunset times at:\nsolar(sun=(pos=(-7.93,37.079), date=\"2016-02-04T10:01:00\"))\nPlot the day-night and civil twilight\n\nusing GMT\ncoast(region=:d, shore=0.1, proj=\"Q0/14c\", axes=(annot=:auto, axes=\"WSen\"),\n      resolution=:low, area=1000)\nsolar!(pen=1, terminators=\"dc\", show=true)\n\n\n\n\n\n\n\n\nBut it is much nicer if we paint the terminators\n\nusing GMT\ncoast(region=:d, proj=\"Ks0/12\", resolution=:low, area=5000, borders=\"1/0.5p,gray\",\n      water=(175,210,255), axes=(annot=:a,ticks=:a,grid=:a), shore=0.5) \nsolar!(terminators=(term=:d, date=\"2016-02-09T16:00:00\"), fill=\"navy@95\")\nsolar!(terminators=(term=:c, date=\"2016-02-09T16:00:00\"), fill=\"navy@85\")\nsolar!(terminators=(term=:n, date=\"2016-02-09T16:00:00\"), fill=\"navy@80\")\nsolar!(terminators=(term=:a, date=\"2016-02-09T16:00:00\"), fill=\"navy@80\", show=true)"
  },
  {
    "objectID": "documentation/modules/solar.html#see-also",
    "href": "documentation/modules/solar.html#see-also",
    "title": "solar",
    "section": "See also",
    "text": "See also\nThe GMT man page"
  },
  {
    "objectID": "documentation/modules/solar.html#source-code",
    "href": "documentation/modules/solar.html#source-code",
    "title": "solar",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsolar(cmd0::String; ...) - pssolar.jl:42\nsolar(; ...) - pssolar.jl:42\nsolar(cmd0::String, arg1; first, kwargs...) - pssolar.jl:42"
  },
  {
    "objectID": "documentation/modules/sphdistance.html",
    "href": "documentation/modules/sphdistance.html",
    "title": "sphdistance",
    "section": "",
    "text": "sphdistance(cmd0::String=\"\", arg1=nothing; kwargs...)\nsphdistance - Create Voronoi distance, node, or natural nearest-neighbor grid on a sphere"
  },
  {
    "objectID": "documentation/modules/sphdistance.html#description",
    "href": "documentation/modules/sphdistance.html#description",
    "title": "sphdistance",
    "section": "Description",
    "text": "Description\nReads one or more data files (or standard input) containing lon, lat coordinates and performs the construction of Voronoi polygons. These polygons are then processed to calculate the nearest distance to each node of the lattice and written to the specified grid. The Voronoi algorithm used is STRIPACK [Renka, 1997]. As an option, you may provide pre-calculated Voronoi polygon information, thus bypassing the memory- and time-consuming triangularization."
  },
  {
    "objectID": "documentation/modules/sphdistance.html#required-arguments",
    "href": "documentation/modules/sphdistance.html#required-arguments",
    "title": "sphdistance",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nA GMTdataset (or matrix) or a data file name containing lon, lat coordinates.\nG or save or outgrid or outfile : – outgrid=name\nOutput grid file name. Note that this is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = sphdistance(...) form.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes."
  },
  {
    "objectID": "documentation/modules/sphdistance.html#optional-arguments",
    "href": "documentation/modules/sphdistance.html#optional-arguments",
    "title": "sphdistance",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or save_mem : – save_mem=true\nFor large data sets you can save some memory (at the expense of more processing) by only storing one form of location coordinates (geographic or Cartesian) at the time [Default keeps both arrays in memory].\nD or duplicates : – duplicates=true\nDelete any duplicate points [Default assumes there are no duplicates]. Note: The STRIPACK algorithm and implementation expect that there are no duplicate points in the input. It is best that the user ensures this is the case. This option provides a brute-force yet exact comparison that is very slow for large data sets.\nE or quantity : – quantity=:d | quantity=:n | quantity=“z[dist]”\nSpecify the quantity to assign to the grid nodes:\n\n:d : Distance to the nearest data point (default).\n:n : Node ID of the nearest data point.\n:z : Compute the natural nearest-neighbor gridding. Append dist (in same units as the grid spacing) to set the distance threshold beyond which we do not assign a value [Default is infinity, but typically using twice the node spacing yields good results].\n\nL or dist_unit : – dist_unit=:letter\nSpecify distance unit for output grid. Choose among e|f|k|M|n|u for meter, foot, km, Miles, nautical miles, or survey foot. Requires that the input data are lon, lat coordinates.\nN or nodes : – nodes=nodetable\nRead a multisegment file with node information from sphtriangulate. This bypasses the construction of the Voronoi polygons. The table may be a file name, a GMTdataset, or a matrix.\nQ or voronoi : – voronoi=file\nAppend the name of a file with pre-calculated Voronoi polygons in the format written by sphtriangulate. This bypasses the memory- and time-consuming triangularization [Default performs Delaunay triangulation on input data to set up the Voronoi polygons].\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\n\n\n\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/sphdistance.html#notes",
    "href": "documentation/modules/sphdistance.html#notes",
    "title": "sphdistance",
    "section": "Notes",
    "text": "Notes\nThe STRIPACK algorithm and implementation expect that there are no duplicate points in the input. It is best that the user ensures that this is the case. GMT has tools, such as blockmean and others, to combine close points into single entries. Also, sphdistance has the duplicates option to determine and exclude duplicates, but it is a very brute-force yet exact comparison that is very slow for large data sets."
  },
  {
    "objectID": "documentation/modules/sphdistance.html#examples",
    "href": "documentation/modules/sphdistance.html#examples",
    "title": "sphdistance",
    "section": "Examples",
    "text": "Examples\nTo generate a grid with distances (in km) to the nearest points in the hotspots file:\n# Using sphtriangulate to pre-compute the Voronoi polygons\nV = sphtriangulate(\"@hotspots.txt\", voronoi=true, skip=true)\nG = sphdistance(voronoi=V, region=:global, inc=1, outgrid=\"globedist.nc\", dist_unit=:k)\nTo construct Voronoi polygons from the points in testdata.txt and then calculate distances from the data to a global 1×1 degree grid:\nD = gmtread(\"testdata.txt\")\nG = sphdistance(D, region=:global, inc=1)\nTo generate the same grid in two steps using sphtriangulate separately:\n# First create the Voronoi polygon information\nV = sphtriangulate(\"testdata.txt\", voronoi=true)\n\n# Then compute the distances\nG = sphdistance(voronoi=V, region=:global, inc=1)\nTo create a natural nearest-neighbor grid from hotspots.txt with max interpolation distance of 2 degrees:\nG = sphdistance(\"@hotspots.txt\", quantity=\"z2\", region=:global, inc=1)"
  },
  {
    "objectID": "documentation/modules/sphdistance.html#references",
    "href": "documentation/modules/sphdistance.html#references",
    "title": "sphdistance",
    "section": "References",
    "text": "References\nRenka, R. J., 1997, Algorithm 772: STRIPACK: Delaunay Triangulation and Voronoi Diagram on the Surface of a Sphere, ACM Trans. Math. Software, 23(3), 416-434, https://doi.org/10.1145/275323.275329."
  },
  {
    "objectID": "documentation/modules/sphdistance.html#source-code",
    "href": "documentation/modules/sphdistance.html#source-code",
    "title": "sphdistance",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsphdistance(cmd0::String; ...) - sphdistance.jl:47\nsphdistance(; ...) - sphdistance.jl:47\nsphdistance(arg1; kw...) - sphdistance.jl:78\nsphdistance(cmd0::String, arg1, arg2; kwargs...) - sphdistance.jl:47\nsphdistance(cmd0::String, arg1; ...) - sphdistance.jl:47"
  },
  {
    "objectID": "documentation/modules/sphdistance.html#see-also",
    "href": "documentation/modules/sphdistance.html#see-also",
    "title": "sphdistance",
    "section": "See Also",
    "text": "See Also\nsphtriangulate, triangulate"
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html",
    "href": "documentation/modules/sphtriangulate.html",
    "title": "sphtriangulate",
    "section": "",
    "text": "sphtriangulate(cmd0::String=\"\", arg1=nothing, kwargs...)\nDelaunay or Voronoi construction of spherical data."
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#description",
    "href": "documentation/modules/sphtriangulate.html#description",
    "title": "sphtriangulate",
    "section": "Description",
    "text": "Description\nReads lon, lat from file or table and performs a spherical Delaunay triangulation, i.e., it determines how the points should be connected to give the most equilateral triangulation possible on the sphere. Optionally, you may choose voronoi=:v which will do further processing to obtain the Voronoi polygons. Normally, either set of polygons will be written as closed fillable segment output; use arcs=true to write unique arcs instead. As an option, compute the area of each triangle or polygon. The algorithm used is STRIPACK."
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#required-arguments",
    "href": "documentation/modules/sphtriangulate.html#required-arguments",
    "title": "sphtriangulate",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns."
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#optional-arguments",
    "href": "documentation/modules/sphtriangulate.html#optional-arguments",
    "title": "sphtriangulate",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or area : – area=true\nCompute the area of the spherical triangles (voronoi=:d) or polygons (voronoi=:v) and write the areas (in chosen units; see unit) in the output segment headers [no areas calculated].\nC or save_mem : – save_mem=true\nFor large data set you can save some memory (at the expense of more processing) by only storing one form of location coordinates (geographic or Cartesian 3-D vectors) at any given time, translating from one form to the other when necessary [Default keeps both arrays in memory].\nD or skipdup : skipdup=true\nUsed to skip the last (repeated) input vertex at the end of a closed segment if it equals the first point in the segment. [Default uses all points].\nL or unit : – unit=??\nSpecify the unit used for distance and area calculations. Choose among unit=:e (m), f (foot), k (km), M (mile), n (nautical mile), u (survey foot), or d (spherical degree). A spherical approximation is used unless spherical_dist=:ellipsoidal is set, in which case we convert latitudes to authalic latitudes before calculating areas. When degree is selected the areas are given in steradians.\nN or nodes : – nodes=“file”\nWrite the information pertaining to each polygon. For Delaunay: the three node number and the triangle area (if area was set); for Voronoi the unique node lon, lat and polygon area (if area was set)) to a separate file. This information is also encoded in the segment headers of ASCII output files (or dataset types). Required if binary output is needed.\nQ or voronoi : – voronoi=:d|v\nUse voronoi=:d for Delaunay triangles or voronoi=:v for Voronoi polygons [Delaunay]. If binary_out is used then nodes may be used to specify a separate file where the polygon information normally is written.\nT or arcs : – arcs=true\nWrite the unique arcs of the construction [Default writes fillable triangles or polygons]. When used with area we store arc length in the segment header in chosen unit (see unit).\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\nj or metric or spherical_dist or spherical : – metric=greatcirc or spherical=:flat or spherical=:ellipsoidal\nDetermine how spherical distances are calculated in modules that support this [Default is spherical=:greatcirc]. GMT has different ways to compute distances on planetary bodies:\n\nspherical=:greatcirc to perform great circle distance calculations, with parameters such as distance increments or radii compared against calculated great circle distances [Default is spherical=:greatcirc].\nspherical=:flat to select Flat Earth mode, which gives a more approximate but faster result.\nspherical=:ellipsoidal to select ellipsoidal (or geodesic) mode for the highest precision and slowest calculation time.\n\nNote: All spherical distance calculations depend on the current ellipsoid (PROJ_ELLIPSOID), the definition of the mean radius (PROJ_MEAN_RADIUS), and the specification of latitude type (PROJ_AUX_LATITUDE). Geodesic distance calculations is also controlled by method (PROJ_GEODESIC).\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at"
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#examples",
    "href": "documentation/modules/sphtriangulate.html#examples",
    "title": "sphtriangulate",
    "section": "Examples",
    "text": "Examples\nTo create a spherical triangulation from the remote data set hotspots.txt and then plot it on a sphere, try:\n\nusing GMT\nD = sphtriangulate(\"@hotspots.txt\", voronoi=:d, arcs=true)\nimshow(D, region=:global, proj=:guess, frame=:afg, pen=3)\n\n\n\n\n\n\n\n\nTo triangulate the points in the file testdata.txt, and make a Voronoi diagram via plot, use\n    D = sphtriangulate(\"testdata.txt\", voronoi=:v)\n    plot(D, region=:global, proj=(name=:ortho, center=(30,30)), pen=1, frame=:ag, show=true)\nTo compute the optimal Delaunay triangulation network based on the multiple segment file globalnodes.txt and save the area of each triangle in the header record, try\n    D = sphtriangulate(\"globalnodes.txt\", voronoi=:d, area=true)"
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#notes",
    "href": "documentation/modules/sphtriangulate.html#notes",
    "title": "sphtriangulate",
    "section": "Notes",
    "text": "Notes\nThe STRIPACK algorithm and implementation expect that there are no duplicate points in the input. It is best that the user ensures that this is the case. GMT has tools, such as blockmean and others, to combine close points into single entries. Also, sphtriangulate has a skipdup option to determine and exclude duplicates, but it is a very brute-force yet exact comparison that is very slow for large data sets. Detection of duplicates in the STRIPACK library will exit the module."
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#source-code",
    "href": "documentation/modules/sphtriangulate.html#source-code",
    "title": "sphtriangulate",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsphtriangulate(cmd0::String; ...) - sphtriangulate.jl:43\nsphtriangulate(; ...) - sphtriangulate.jl:43\nsphtriangulate(arg1; kw...) - sphtriangulate.jl:52\nsphtriangulate(cmd0::String, arg1; kwargs...) - sphtriangulate.jl:43"
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#see-also",
    "href": "documentation/modules/sphtriangulate.html#see-also",
    "title": "sphtriangulate",
    "section": "See Also",
    "text": "See Also\ntriangulate, sphdistance"
  },
  {
    "objectID": "documentation/modules/sphtriangulate.html#references",
    "href": "documentation/modules/sphtriangulate.html#references",
    "title": "sphtriangulate",
    "section": "References",
    "text": "References\nRenka, R, J., 1997, Algorithm 772: STRIPACK: Delaunay Triangulation and Voronoi Diagram on the Surface of a Sphere, AMC Trans. Math. Software, 23 (3), 416-434."
  },
  {
    "objectID": "documentation/modules/stem.html",
    "href": "documentation/modules/stem.html",
    "title": "stem",
    "section": "",
    "text": "stem(cmd0::String=\"\", arg1=nothing; kwargs...)\nReads (x,y) pairs and plot the data sequence, y, as stems that extend from a baseline along the x-axis. The data values are indicated by circles terminating each stem. The input can either be a file name of a file with at least two columns (x,y), but optionally more, a GMTdatset object with also two or more columns, or direct x,y inputs\nstem(D::GMTdatset,xvar,yvar) plots the variables xvar and yvar from the table D. You can specify one or multiple variables for yvar and one only for xvar."
  },
  {
    "objectID": "documentation/modules/stem.html#examples",
    "href": "documentation/modules/stem.html#examples",
    "title": "stem",
    "section": "Examples",
    "text": "Examples\nCreate a stem plot of 50 data values between −2π and 2π.\n\nusing GMT\n\nY = linspace(-2*pi,2*pi,50);\nstem(Y, show=true)\n\n\n\n\n\n\n\n\nThe same but now specify the set of x values for the stem plot.\n\nusing GMT\n\nY = linspace(-2*pi,2*pi,50);\nstem([Y Y], show=true)\n\n\n\n\n\n\n\n\nTwo of them and with some variations.\n\nusing GMT\n\nY = linspace(-2*pi,2*pi,50);\nstem(Y,[Y -Y], multicol=true, fill=true, ms=\"10p\", nobaseline=true, ls=:DashDot, show=true)"
  },
  {
    "objectID": "documentation/modules/stem.html#source-code",
    "href": "documentation/modules/stem.html#source-code",
    "title": "stem",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nstem(cmd0::String; ...) - plot.jl:910\nstem(; ...) - plot.jl:910\nstem(cmd0::String, arg1; first, kwargs...) - plot.jl:910\nstem(arg1, arg2; kw...) - plot.jl:966\nstem(arg; kw...) - plot.jl:964"
  },
  {
    "objectID": "documentation/modules/surface.html",
    "href": "documentation/modules/surface.html",
    "title": "surface",
    "section": "",
    "text": "surface(cmd0::String=\"\", arg1=nothing; kwargs...)"
  },
  {
    "objectID": "documentation/modules/surface.html#description",
    "href": "documentation/modules/surface.html#description",
    "title": "surface",
    "section": "Description",
    "text": "Description\nReads randomly-spaced (x,y,z) triples from file or table and produces a binary file of gridded values z(x,y) by solving the differential equation (away from data points)\n$$ (1 - t) \\nabla ^2(z) + t \\nabla (z) = 0 $$\nwhere t is a tension factor between 0 and 1, and \\(\\nabla\\) indicates the Laplacian operator. Here, t = 0 gives the “minimum curvature” solution. Minimum curvature can cause undesired oscillations and false local maxima or minima (See Smith and Wessel, 1990), and you may wish to use t &gt; 0 to suppress these effects. Experience suggests t ~ 0.25 usually looks good for potential field data and t should be larger (t ~ 0.35) for steep topography data. t = 1 gives a harmonic surface (no maxima or minima are possible except at control data points). It is recommended that the user preprocess the data with blockmean, blockmedian, or blockmode to avoid spatial aliasing and eliminate redundant data. You may impose lower and/or upper bounds on the solution. These may be entered in the form of a fixed value, a grid with values, or simply be the minimum/maximum input data values. Natural boundary conditions are applied at the edges, except for geographic data with 360-degree range where we apply periodic boundary conditions in the longitude direction."
  },
  {
    "objectID": "documentation/modules/surface.html#required-arguments",
    "href": "documentation/modules/surface.html#required-arguments",
    "title": "surface",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nOne or more data tables holding a number of data columns.\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“xinc[+e|n][/yinc[+e|n]]”\nSpecify the grid increments or the block sizes. More at [spacing](../common_opts/opt_I.html)"
  },
  {
    "objectID": "documentation/modules/surface.html#optional-arguments",
    "href": "documentation/modules/surface.html#optional-arguments",
    "title": "surface",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or aspect_ratio : – aspect_ratio=ar | aspect_ratio=:m\nAspect ratio. If desired, grid anisotropy can be added to the equations. Enter ar, where dy = dx / ar relates the grid dimensions. For geographic data, you may use aspect_ratio=:m to set the aspect ratio to the cosine of the mean latitude [Default = 1 assumes isotropic grid.]\nC or convergence : – convergence=clim | convergence=“clim%”\nConvergence limit. Iteration is assumed to have converged when the maximum absolute change in any grid value is less than clim. (Units same as data z units). Alternatively, give limit in percentage of rms deviation by appending %. [Default is scaled to \\(10^{-4}\\) of the root-mean-square deviation of the data from a best-fit (least-squares) plane.]. This is the final convergence limit at the desired grid spacing; for intermediate (coarser) grids the effective convergence limit is divided by the grid spacing multiplier.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nSelect the data map projection. This projection is only used to add a referencing info to the grid formats that support it. E.g., netCDF, GeoTIFF, and others supported by GDAL.\nD or breakline : – breakline=“bfile” | breakline=“bfile+z[level]”\nUse x, y, z data in the bfile file (or a GMTdataset) as a soft breakline. A soft breakline is a line whose vertices will be used to constrain the nearest grid nodes without any further interpolation. A coastline or a lake shore are good examples of soft breaklines. Multi-segments files are accepted. If your lines do not have z-values or you wish to override those with a constant z-value, then append +zlevel to the filename. If no value is given then we default to 0.\nG or save or outgrid or outfile : – outgrid=[=ID][+ddivisor][+ninvalid][+ooffset|a][+sscale|a][:driver[dataType][+coptions]]\nGive the name of the output grid file. Optionally, append =ID for writing a specific file format (See full description). The following modifiers are supported:\n\n+d - Divide data values by given divisor [Default is 1].\n+n - Replace data values matching invalid with a NaN.\n+o - Offset data values by the given offset, or append a for automatic range offset to preserve precision for integer grids [Default is 0].\n+s - Scale data values by the given scale, or append a for automatic scaling to preserve precision for integer grids [Default is 1].\n\nNote1: Any offset is added before any scaling. +sa also sets +oa (unless overridden). To write specific formats via GDAL, use =gd and supply driver (and optionally dataType) and/or one or more concatenated GDAL -co options using +c. See the “Writing grids and images” cookbook section for more details.\nNote2: This is optional and to be used only when saving the result directly on disk. Otherwise, just use the G = modulename(...) form.\nLl or lower and Lu or upper : – lower=?? | upper=??\nImpose limits on the output solution. ?? in lower=?? sets the lower bound. It can be the name of a grid file with lower bound values, a fixed value, d to set to minimum input value, or u for unconstrained [Default]. upper sets the upper bound and can be the name of a grid file with upper bound values, a fixed value, d to set to maximum input value, or u for unconstrained [Default]. Grid files used to set the limits may contain NaNs. In the presence of NaNs, the limit of a node masked with NaN is unconstrained. Note: Grids given via L must be compatible with the desired output domain and increments.\nM or mask : – mask=max_radius\nAfter solving for the surface, apply a mask so that nodes farther than max_radius away from a data constraint are set to NaN. Append a distance unit (see [Units]) if needed. One can also select the nodes to mask by using the mask=“c” form. Here n_cells means the number of cells around the node controlled by a data point. As an example mask=“0c” means that only the cell where the point lies is filled, mask=“1c” keeps one cell beyond that (i.e. makes a 3x3 square neighborhood), and so on.\nN or iterations or max_iterations : – iterations=n_iter\nNumber of iterations. Iteration will cease when convergence is reached or when number of iterations reaches n_iter. This is the final iteration limit at the desired grid spacing; for intermediate (coarser) grids the effective iteration limit is scaled by the grid spacing multiplier [Default is 500].\nQ or suggest : – suggest=true | suggest=:r\nSuggest grid dimensions which have a highly composite greatest common factor. This allows surface to use several intermediate steps in the solution, yielding faster run times and better results. The sizes suggested by suggest can be achieved by altering region and/or inc. You can recover the region and inc you want later by using grdsample or grdcut on the output of surface. Alternatively, append r to have surface use the specified region setting exactly as given in the calculations [Default automatically seeks a slightly larger region if that allows for more intermediate steps to ensure the best possible convergence; the region is then trimmed back to what was requested in region upon output].\nS or search_radius : – search_radius=?? | search_radius=“??m|s”\nSearch radius. Enter search_radius in same units as x,y data; append m to indicate arc minutes or s for arc seconds. This is used to initialize the grid before the first iteration; it is not worth the time unless the grid lattice is prime and cannot have regional stages. [Default = 0.0 and no search is made.]\nT or tension : – tension=factor | search_radius=“i|b_factor”\nTension factor[s]. These must be between 0 and 1. Tension may be used in the interior solution (above equation, where it suppresses spurious oscillations) and in the boundary conditions (where it tends to flatten the solution approaching the edges). Using zero for both values results in a minimum curvature surface with free edges, i.e., a natural bicubic spline. Use tension=i…, where … is the tension_factor to set interior tension, and tension=b… to set boundary tension. If you do not prepend i or b, both will be set to the same value. [Default = 0 for both gives minimum curvature solution.]\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or log : – log=true | log=logfile\nWrite convergence information to logfile [Default is surface_log.txt].\nZ or over_relaxation : – over_relaxation=factor\nOver-relaxation factor. This parameter is used to accelerate the convergence; it is a number between 1 and 2. A value of 1 iterates the equations exactly, and will always assure stable convergence. Larger values overestimate the incremental changes during convergence, and will reach a solution more rapidly but may become unstable. If you use a large value for this factor, it is a good idea to monitor each iteration with the verbose=:i option. [Default = 1.4 converges quickly and is almost always stable.]\npreproc : – preproc=true | preproc=“blockmedian|blockmode”\n\nThis option means that the data is previously passed through one of block* modules to decimate the data in each cell as strongly advised. preproc=true will use blockmean. To use any of the other two, pass its name as value. e.g. preproc=\"blockmedian\".\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\nr or reg or registration : – reg=:p | reg=:g\nSelect gridline or pixel node registration. Used only when output is a grid. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at\n\nUnits\nFor map distance unit, append unit d for arc degree, m for arc minute, and s for arc second, or e for meter [Default unless stated otherwise], f for foot, k for km, M for statute mile, n for nautical mile, and u for US survey foot. By default we compute such distances using a spherical approximation with great circles (-jg) using the authalic radius (see PROJ_MEAN_RADIUS). You can use -jf to perform “Flat Earth” calculations (quicker but less accurate) or -je to perform exact geodesic calculations (slower but more accurate; see PROJ_GEODESIC for method used)."
  },
  {
    "objectID": "documentation/modules/surface.html#examples",
    "href": "documentation/modules/surface.html#examples",
    "title": "surface",
    "section": "Examples",
    "text": "Examples\nTo grid 5 by 5 minute gravity block means from the ASCII data in hawaii_5x5.xyg, using a tension_factor = 0.25, a convergence_limit = 0.1 mGal, and monitoring each iteration, try:\n    G = surface(\"hawaii_5x5.xyg\", region=(198,208,18,25), inc=\"5m\", tension=0.25, convergence=0.1)"
  },
  {
    "objectID": "documentation/modules/surface.html#notes",
    "href": "documentation/modules/surface.html#notes",
    "title": "surface",
    "section": "Notes",
    "text": "Notes\nWhile the region specified by region determines your final output grid, internally we may use a slightly larger region that will allow for more intermediate grids (i.e., more common factors between n_columns - 1 and n_rows - 1). This should allow for better convergence in the final solution."
  },
  {
    "objectID": "documentation/modules/surface.html#gridding-geographic-data-boundary-conditions",
    "href": "documentation/modules/surface.html#gridding-geographic-data-boundary-conditions",
    "title": "surface",
    "section": "Gridding Geographic Data: Boundary Conditions",
    "text": "Gridding Geographic Data: Boundary Conditions\nThe surface finite difference algorithm is Cartesian at heart, hence the ad hoc option to change the aspect ratio for a suitable mean latitude (aspect_ratio). When geographic data are supplied and the output grid has a 360 degree longitude range we will impose periodic boundary conditions in longitude. However, no equivalent geographic boundary condition can be applied at the poles since the finite difference solution will not be valid there (actual spacing between the nodes at the poles is zero). If you attempt this type of gridding you will be severely warned but the calculations will continue. Because the result is a geographic grid, the GMT i/o machinery will interfere and detect inconsistencies at the pole points and replace all values along a pole with their mean value. This will introduce further distortion into the grid near the poles. We recommend you instead consider spherical gridding for global data sets; see greenspline (for modest data sets) or sphinterpolate, or project your data using a stereographic projection and grid the projected Cartesian data."
  },
  {
    "objectID": "documentation/modules/surface.html#gridding-geographic-data-setting-increments",
    "href": "documentation/modules/surface.html#gridding-geographic-data-setting-increments",
    "title": "surface",
    "section": "Gridding Geographic Data: Setting Increments",
    "text": "Gridding Geographic Data: Setting Increments\nSpecifying grid increments in distance units (meters, km, etc.) for geographic (lon, lat) grids triggers a conversion from the given increment to the equivalent increment in degrees. This is done differently for longitude and latitude and also depends on chosen ellipsoid, but ultimately is a great-circle approximation. For latitude we divide your y-increment with the number of you chosen unit per degree latitude, while for longitude we divide your x-increment by the number of such units per degree along the mid-parallel in your region. The resulting degree increments may therefore not exactly match the increments you entered explicitly. Hence, there may be rounding off in ways you don’t want and cannot easily control, resulting in prime grid dimensions. You can handle the situation via suggest but with the never-ending decimals in some increments that is still a challenge. Another approach is to not grid geographic data using length units as increments, due to the above conversion. It may be cleaner to specify grid intervals in spherical degrees, minutes or seconds. That way you can control the grid dimensions directly and avoid the round-off. Alternatively, if your region is far from Equator and your are concerned about the difference in longitude and latitude increments in degrees you could project all data to a local projection (e.g., UTM) to yield units of meters, and then grid the projected data using meters as the final grid increment. Either approach avoids “ugly” increments like 0.161697s and will let you specify intervals that are easily divisible into the range. If increment choice is dictated by a need for a desired increment in meters then the projection route will yield better results."
  },
  {
    "objectID": "documentation/modules/surface.html#bugs",
    "href": "documentation/modules/surface.html#bugs",
    "title": "surface",
    "section": "Bugs",
    "text": "Bugs\nsurface will complain when more than one data point is found for any node and suggest that you run blockmean, blockmedian, or blockmode first. If you did run these decimators and still get this message it usually means that your grid spacing is so small that you need more decimals in the output format used. You may specify more decimal places by editing the parameter FORMAT_FLOAT_OUT in your gmt.conf file prior to running the decimators or choose binary input and/or output using single or double precision storage."
  },
  {
    "objectID": "documentation/modules/surface.html#source-code",
    "href": "documentation/modules/surface.html#source-code",
    "title": "surface",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsurface(cmd0::String; ...) - surface.jl:78\nsurface(; ...) - surface.jl:78\nsurface(arg1::Union{GMT.Gdal.AbstractDataset, GDtype, Matrix{&lt;:AbstractFloat}}; kw...) - surface.jl:107\nsurface(cmd0::String, arg1::Union{Nothing, GMT.Gdal.AbstractDataset, GDtype, Matrix{&lt;:AbstractFloat}}; kwargs...) - surface.jl:78"
  },
  {
    "objectID": "documentation/modules/surface.html#see-also",
    "href": "documentation/modules/surface.html#see-also",
    "title": "surface",
    "section": "See Also",
    "text": "See Also\nblockmean, blockmedian, blockmode, grdcut, grdsample, greenspline, nearneighbor, triangulate, sphinterpolate"
  },
  {
    "objectID": "documentation/modules/surface.html#references",
    "href": "documentation/modules/surface.html#references",
    "title": "surface",
    "section": "References",
    "text": "References\nSmith, W. H. F, and P. Wessel, 1990, Gridding with continuous curvature splines in tension, Geophysics, 55, 293-305, https://doi.org/10.1190/1.1442837."
  },
  {
    "objectID": "documentation/modules/talwani3d.html",
    "href": "documentation/modules/talwani3d.html",
    "title": "talwani3d",
    "section": "",
    "text": "Compute geopotential anomalies over 3-D bodies by the method of Talwani.\n\n\n\n\n\n\nWarning\n\n\n\nThis GMT supplements module has not yet been ported to the long verbose syntax. To use it, you will need to use the Monolithic mode.\n\n\nPlease open a Feature Request if you would like to see this module ported to the long verbose syntax, or better yet, consider contributing the port yourself!"
  },
  {
    "objectID": "documentation/modules/text.html",
    "href": "documentation/modules/text.html",
    "title": "text",
    "section": "",
    "text": "text(cmd0::String=\"\", arg1=nothing; kwargs...)\nPlot or typeset text on maps"
  },
  {
    "objectID": "documentation/modules/text.html#description",
    "href": "documentation/modules/text.html#description",
    "title": "text",
    "section": "Description",
    "text": "Description\ntext plots text strings of variable size, font type, and orientation. Various map projections are provided, with the option to draw and annotate the map boundaries. Greek characters, subscript, superscript, and small caps are supported as follows: The sequence @~ toggles between the selected font and Greek (Symbol). @% no % sets the font to no; @%% resets the font to the starting font, @- toggles subscripts on/off, @+ toggles superscript on/off, @# toggles small caps on/off, @; color; changes the font color (@;; resets it), @: size: changes the font size (@:: resets it), and @_ toggles underline on/off. @@ prints the @ sign. @e, @o, @a, @E, @O, @A give the accented Scandinavian characters. Composite characters (overstrike) may be indicated with the @! sequence, which will print the two characters on top of each other. To learn the octal codes for symbols not available on the keyboard and some accented European characters, see Section Char-esc-seq and Appendix Chart-Octal-Codes-for-Chars in the GMT Technical Reference and Cookbook. Note that PS_CHAR_ENCODING must be set to an extended character set in your gmt.conf file in order to use the accented characters. Using the fill or pen options, a rectangle underlying the text may be plotted (does not work for strings with sub/super scripts, symbols, or composite characters, except in paragraph mode (paragraph))."
  },
  {
    "objectID": "documentation/modules/text.html#required-arguments",
    "href": "documentation/modules/text.html#required-arguments",
    "title": "text",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntextfile\nA file containing 1 or more records with (x, y[, font, angle, justify], text). The attributes in brackets can alternatively be set directly via attrib. font is a font specification with format [size,][font,][color] where size is text size in points, font is the font to use, and color sets the font color. To draw outline fonts you append =pen to the font specification. The angle is measured in degrees counter-clockwise from horizontal, and justify sets the alignment. If font is not an integer, then it is taken to be a text string with the desired font name (see list for available fonts). The alignment refers to the part of the text string that will be mapped onto the (x,y) point. Choose a 2 character combination of L, C, R (for left, center, or right) and T, M, B for top, middle, or bottom. e.g., BL for lower left.\ntextrecord\nA GMTdataset type that can be obtained with the mat2ds(mat, txt) function, where mat is a MxN with the x,y(,z) coordinates and txt a string vector with the desired text.\nrich()\nThe rich() function is a convenient function to plot text whose parts have different colors, fonts, font sizes, subscripts, superscripts, greek letters, underline, small caps and LaTeX equations. Text generated with this functions can also be used in titles, labels, legends, etc… Se example at the end of this page.\n(text, x=?, y=?)\nAs a third alternative, provide the input data in a form of a string vector and x and y vector coordinates, or just a x=mat where mat is MxN matix. In the particular case where the text is a single string one may use the (text=“txt”, x=?, y=?) form."
  },
  {
    "objectID": "documentation/modules/text.html#optional-arguments",
    "href": "documentation/modules/text.html#optional-arguments",
    "title": "text",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or azimuth or azim : – azimuth=true\nAngles are given as azimuths; convert them to directions using the current projection.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or clearance : – clearance=true | clearance=(margin=(dx,dy), round=true, concave=true, convex=true)\nAdjust the clearance between the text and the surrounding box [15%]. Only used if pen or fill are specified. Append the unit you want (cm, inch, or point); if not given we consult PROJ_LENGTH_UNIT) or % for a percentage of the font size. Optionally, use options round (rounded rectangle) or, for paragraph mode only, concave or convex to set the shape of the textbox when using fill and/or pen. Default gets a straight rectangle.\nD or offset : – offset=([away=true, corners=true,] shift=(dx,dy) [,line=pen])\nOffsets the text from the projected (x, y) point by shift=(dx, dy). If dy is not specified then it is set equal to dx. Use offset=(away=true,) to offset the text away from the point instead (i.e., the text justification will determine the direction of the shift). Using offset=(corners=true,) will shorten diagonal offsets at corners by sqrt(2). Optionally, use offset=(line=true,) which will draw a line from the original point to the shifted point; use offset=(line=pen,) to change the pen attributes for this line.\nF or attrib : – attrib=(angle=val, font=font, justify=code, region_justify=code, header=true, label=true, rec_number=first, text=text, zvalues=format)\nBy default, text will be placed horizontally, using the primary annotation font attributes (FONT_ANNOT_PRIMARY), and centered on the data point. Use this option to override these defaults by specifying up to three text attributes (font, angle, and justification). Use font=font to set the font (size,fontname,color). For example font=18 or font=(18, “Helvetica-Bold”, :red); if no font info is given then the input file must have this information in one of its columns. Use angle=val to set the angle; if no angle is given then the input file must have this as a column. Alternatively, use Angle=val to force text-baselines to convert into the -90/+90 range. Use justify=code to set the justification; if no justification is given then the input file must have this as a column. Items read from the data should be in the same order as specified with the F option. Example: font=(18, “Helvetica-Bold”, :red), justify=““, angle=”“ selects a 12p red Helvetica-Bold font and expects to read the justification and angle from the file, in that order, after x, y and before text. In addition, the region_justify justification lets us use x,y coordinates extracted from the region string instead of providing them in the input file. For example region_justify=:TL gets the x_min, y_max from the region string and plots the text at the Upper Left corner of the map. Normally,the text to be plotted comes from the data record. Instead, use header=true or label=true to select the text as the most recent segment header or segment label, respectively in a multisegment input file, rec_number=first to use the record number (counting up from first), text=text to set a fixed text string, or zvalues to format incoming z values to a string using the supplied format (zvalues=““ uses FORMAT_FLOAT_MAP). Note: If threeD is in effect then the z value used for formatting is in the 4th, not 3rd column. Exceptionally, this option can be broken up in its individual pieces by dropping the attrib keyword.\noutline : – outline=true | outline=“thk,color”\nPlots an outline arround the text. By setting outline=true we plot a 1 point white outline around the text. To control the outline pen use the form “thickness,color”. For example outline=“3p,red” adds a 3 points thickness red outline.\nG or fill : – fill=color | fill=:c\nSets the shade or color used for filling the text box [Default is no fill]. Alternatively, use fill=:c to plot the text and then use the text dimensions (and clearance) to build clip paths and turn clipping on. This clipping can then be turned off later with clip C. To not plot the text but activate clipping, use fill=:C instead.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nL or list : – list=true\nLists the font-numbers and font-names available, then exits.\nM or paragraph : – paragraph=true\nParagraph mode. Files must be multiple segment files. Segments are separated by a special record whose first character must be flag [Default is &gt;]. Starting in the 3rd column, we expect to find information pertaining to the typesetting of a text paragraph (the remaining lines until next segment header). The information expected is (x y [font angle justify ] linespace parwidth parjust), where x y font angle justify are defined above (font, angle, and justify can be set via F), while linespace and parwidth are the linespacing and paragraph width, respectively. The justification of the text paragraph is governed by parjust which may be l (eft), c (enter), r (ight), or j (ustified). The segment header is followed by one or more lines with paragraph text. Text may contain the escape sequences discussed above. Separate paragraphs with a blank line. Note that here, the justification set via justify applies to the box alignment since the text justification is set by parjust.\nN or noclip or no_clip : noclip=true\nDo NOT clip text at map boundaries [Default will clip].\nQ or change_case : – change_case=:lower | change_case=:upper\nChange all text to either change_case=:lower or change_case=:upper case [Default leaves all text as is].\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nS or shade : shade=true | shade=(dx,dy) | shade=shade\nPlot an offset background shaded region beneath the text box. Here, (dx,dy) indicates the shift relative to the text box in points [4p, 4p] and shade sets the fill color to use for shading [gray50]. Requires the fill option.\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen : – pen=pen\nSets the pen used to draw a rectangle around the text string (see clearance) [Default is width = default, color = black, style = solid].\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nZ or threeD : – threeD=true\nFor 3-D projections: expect each item to have its own level given in the 3rd column, and noclip is implicitly set. (Not implemented for paragraph mode).\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format.\na or aspatial : – aspatial=??\nControl how aspatial data are handled in GMT during input and output. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at"
  },
  {
    "objectID": "documentation/modules/text.html#notes-on-transparency",
    "href": "documentation/modules/text.html#notes-on-transparency",
    "title": "text",
    "section": "Notes on Transparency",
    "text": "Notes on Transparency\nThe PostScript language originally had no accommodation for transparency. However, Adobe added an extension that allows developers to encode some forms of transparency using the PostScript language model but it is only realized when converting the PostScript to PDF (and via PDF to any raster image format). GMT uses this model but there are some limitations: Transparency can only be controlled on a per-object or per-layer basis. This means that a color specifications (such as those in CPTs of given via command-line options) only apply to vector graphic items (i.e., text, lines, polygon fills) or to an entire layer (which could include items such as PostScript images). This limitation rules out any mechanism of controlling transparency in such images on a pixel level.\n\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/text.html#limitations",
    "href": "documentation/modules/text.html#limitations",
    "title": "text",
    "section": "Limitations",
    "text": "Limitations\nIn paragraph mode, the presence of composite characters and other escape sequences may lead to unfortunate word splitting. Also, if a font is requested with an outline pen it will not be used in paragraph mode. Note if any single word is wider than your chosen paragraph width then the paragraph width is automatically enlarged to fit the widest word."
  },
  {
    "objectID": "documentation/modules/text.html#examples",
    "href": "documentation/modules/text.html#examples",
    "title": "text",
    "section": "Examples",
    "text": "Examples\nTo plot just the red outlines of the (lon lat text strings) stored in the file text.txt on a Mercator plot with the given specifications, use\ntext(\"text.txt\", region=(-30,30,-10,20), proj=:merc, figscale=0.25, font=(18,:Helvetica,\"-=0.5p\",:red), frame=(annot=5,), show=true)\nTo plot just the “Hello World” and let the program estimate the region, do\n\nusing GMT\ntext([\"Hello World\"], x=2.0, y=2.0, show=true)\n\n\n\n\n\n\n\n\nA similar example but using the outline option to plot a 3 points green outline.\n\nusing GMT\ntext([\"Hello World\"], x=2.0, y=2.0, outline=\"3p,red\", font=40, show=true)\n\n\n\n\n\n\n\n\nExample using the rich function (reproduces the original example in Makie).\n\nusing GMT\ntext(rich(\"H\", subscript(\"2\"), greek(\"O\"),\" is the \", smallcaps(\"formula\"),\" for \",\n     rich(underline(\"water\"), color=:red, font=\"Helvetica\", size=16)), x=1, y=1, frame=:none)\n\nstr = \"A BEAUTIFUL RAINBOW\";\nC = makecpt(range=(1,length(str)+1,1));\nfontsizes = 20 .+ 10 .* sin.(range(0, 3pi, length = length(str)));\nrainbow_chars = map(enumerate(str)) do (i, c)\n    rich(\"$c\", color = GMT.arg2str(Tuple(round.(Int,C.colormap[i,:].*255))), size = fontsizes[i]);\nend\ntext!(join(rainbow_chars), x=1, y=0.99, font=\"Helvetica-Bold\", show=1)"
  },
  {
    "objectID": "documentation/modules/text.html#source-code",
    "href": "documentation/modules/text.html#source-code",
    "title": "text",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntext(txt::Vector{String}; x, y, first, kwargs...) - pstext.jl:182\ntext(cmd0::String; ...) - pstext.jl:59\ntext(; ...) - pstext.jl:59\ntext(arg1; kw...) - pstext.jl:178\ntext(cmd0::String, arg1; first, kwargs...) - pstext.jl:59"
  },
  {
    "objectID": "documentation/modules/trend2d.html",
    "href": "documentation/modules/trend2d.html",
    "title": "trend2d",
    "section": "",
    "text": "trend2d(cmd0::String=\"\", arg1=nothing, kwargs...)\nFit [weighted] [robust] polynomial for z = f(x,y) to xyz[w] data."
  },
  {
    "objectID": "documentation/modules/trend2d.html#description",
    "href": "documentation/modules/trend2d.html#description",
    "title": "trend2d",
    "section": "Description",
    "text": "Description\ntrend2d reads x,y,z [and w] values from the first three [four] columns [or xyz[w]file] and fits a regression model z = f(x,y) + e by [weighted] least squares. The fit may be made robust by iterative reweighting of the data. The user may also search for the number of terms in f(x,y) which significantly reduce the variance in z. n_model may be in [1,10] to fit a model of the following form (similar to grdtrend):\n\\[z(x,y) = m_1 + m_{2}x + m_{3}y + m_{4}xy + m_{5}x^2 + m_{6}y^2 + m_{7}x^3 +\n  m_{8}x^{2}y + m_{9}xy^2 + m_{10}y^3\\]\nThe user must specify model=n, the number of model parameters to use; thus, fits a bilinear trend, model=6 a quadratic surface, and so on. Optionally, append +r to perform a robust fit. In this case, the program will iteratively reweight the data based on a robust scale estimate, in order to converge to a solution insensitive to outliers. This may be handy when separating a “regional” field from a “residual” which should have non-zero mean, such as a local mountain on a regional surface."
  },
  {
    "objectID": "documentation/modules/trend2d.html#required-arguments",
    "href": "documentation/modules/trend2d.html#required-arguments",
    "title": "trend2d",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ntable\nData table(s) containing x,y,z [w] values in the first 3 [4] columns.\nF or out or output : – out=:xyzmrw | out=:p\nSpecify up to six letters from the set {x y z m r w} in any order to create columns of output. x = x, y = y, z = z, m = model f(x,y), r = residual z - m, w = weight used in fitting. Alternatively, to just report the model parameters, use out=:p.\nN or model : – model=n | model=“n+r”\nSpecify the number of terms in the model, n_model, and use model=“n_model+r” to do a robust fit. E.g., a robust bilinear model is model=“4+r”."
  },
  {
    "objectID": "documentation/modules/trend2d.html#optional-arguments",
    "href": "documentation/modules/trend2d.html#optional-arguments",
    "title": "trend2d",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nC or condition_number : – condition_number=number\nSet the maximum allowed condition number for the matrix solution. trend2d fits a damped least squares model, retaining only that part of the eigenvalue spectrum such that the ratio of the largest eigenvalue to the smallest eigenvalue is condition_#. [Default: condition_# = 1.0e06].\nI or conf_level : – conf_level=true | conf_level=level\nIteratively increase the number of model parameters, starting at one, until n_model is reached or the reduction in variance of the model is not significant at the confidence_level level. You may set conf_level=true only, without an attached number; in this case the fit will be iterative with a default confidence level of 0.51. Or choose your own level between 0 and 1. See remarks section.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or weights : – weights=true | weights=“+s|+w”\nWeights are supplied in input column 4. Do a weighted least squares fit [or start with these weights when doing the iterative robust fit]. Append +s to instead read data uncertainties (one sigma) and create weights as 1/sigma^2, or use the weights as read (+w) [Default reads only the first 2 columns].\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nbo or binary_out : – binary_out=??\nSelect native binary format for table output. More at\ndi or nodata_in : – nodata_in=??\nSubstitute specific values with NaN. More at\ne or pattern : – pattern=??\nOnly accept ASCII data records that contain the specified pattern. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\ng or gap : – gap=??\nExamine the spacing between consecutive data points in order to impose breaks in the line. More at\nh or header : – header=??\nSpecify that input and/or output file(s) have n header records. More at\ni or incol or incols : – incol=col_num | incol=“opts”\nSelect input columns and transformations (0 is first column, t is trailing text, append word to read one word only). More at incol\nq or inrows : – inrows=??\nSelect specific data rows to be read and/or written. More at\ns or skiprows or skip_NaN : – skip_NaN=true | skip_NaN=“&lt;cols[+a][+r]&gt;”\nSuppress output of data records whose z-value(s) equal NaN. More at\nw or wrap or cyclic : – wrap=??\nConvert input records to a cyclical coordinate. More at\nyx : – yx=true\nSwap 1st and 2nd column on input and/or output. More at"
  },
  {
    "objectID": "documentation/modules/trend2d.html#remarks",
    "href": "documentation/modules/trend2d.html#remarks",
    "title": "trend2d",
    "section": "Remarks",
    "text": "Remarks\nThe domain of x and y will be shifted and scaled to [-1, 1] and the basis functions are built from Chebyshev polynomials. These have a numerical advantage in the form of the matrix which must be inverted and allow more accurate solutions. In many applications of trend2d the user has data located approximately along a line in the x,y plane which makes an angle with the x axis (such as data collected along a road or ship track). In this case the accuracy could be improved by a rotation of the x,y axes. trend2d does not search for such a rotation; instead, it may find that the matrix problem has deficient rank. However, the solution is computed using the generalized inverse and should still work out OK. The user should check the results graphically if trend2d shows deficient rank. NOTE: The model parameters listed with verbose are Chebyshev coefficients; they are not numerically equivalent to the m#s in the equation described above. The description above is to allow the user to match model with the order of the polynomial surface. For evaluating Chebyshev polynomials, see grdmath.\nThe model=“n_model+r” (robust) and conf_level (iterative) options evaluate the significance of the improvement in model misfit Chi-Squared by an F test. The default confidence limit is set at 0.51; it can be changed with the conf_level option. The user may be surprised to find that in most cases the reduction in variance achieved by increasing the number of terms in a model is not significant at a very high degree of confidence. For example, with 120 degrees of freedom, Chi-Squared must decrease by 26% or more to be significant at the 95% confidence level. If you want to keep iterating as long as Chi-Squared is decreasing, set conf_level to zero.\nA low confidence limit (such as the default value of 0.51) is needed to make the robust method work. This method iteratively reweights the data to reduce the influence of outliers. The weight is based on the Median Absolute Deviation and a formula from Huber [1964], and is 95% efficient when the model residuals have an outlier-free normal distribution. This means that the influence of outliers is reduced only slightly at each iteration; consequently the reduction in Chi-Squared is not very significant. If the procedure needs a few iterations to successfully attenuate their effect, the significance level of the F test must be kept low."
  },
  {
    "objectID": "documentation/modules/trend2d.html#examples",
    "href": "documentation/modules/trend2d.html#examples",
    "title": "trend2d",
    "section": "Examples",
    "text": "Examples\nTo remove a planar trend from data.xyz by ordinary least squares, use\n    D = trend2d(\"data.xyz\", out=:xyr, model=3)\nTo simply report the three coefficients, use\n    trend2d(\"data.xyz\", out=:p, model=3)\nTo make the above planar trend robust with respect to outliers, use\n    D = trend2d(\"data.xyz\", out=:xyr, model=\"3+r\")\nTo find out how many terms (up to 10 in a robust interpolant are significant in fitting data.xyz, use\n    trend2d(\"data.xyz\", model=\"10+r\", conf_level=true, verbose=true)"
  },
  {
    "objectID": "documentation/modules/trend2d.html#source-code",
    "href": "documentation/modules/trend2d.html#source-code",
    "title": "trend2d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntrend2d(cmd0::String; ...) - trend2d.jl:41\ntrend2d(; ...) - trend2d.jl:41\ntrend2d(arg1; kw...) - trend2d.jl:52\ntrend2d(cmd0::String, arg1; kwargs...) - trend2d.jl:41"
  },
  {
    "objectID": "documentation/modules/trend2d.html#see-also",
    "href": "documentation/modules/trend2d.html#see-also",
    "title": "trend2d",
    "section": "See Also",
    "text": "See Also\ngrdtrend, trend1d"
  },
  {
    "objectID": "documentation/modules/trend2d.html#references",
    "href": "documentation/modules/trend2d.html#references",
    "title": "trend2d",
    "section": "References",
    "text": "References\nHuber, P. J., 1964, Robust estimation of a location parameter, Ann. Math. Stat., 35, 73-101.\nMenke, W., 1989, Geophysical Data Analysis: Discrete Inverse Theory, Revised Edition, Academic Press, San Diego."
  },
  {
    "objectID": "documentation/modules/triplot.html",
    "href": "documentation/modules/triplot.html",
    "title": "triplot",
    "section": "",
    "text": "triplot(in::Matrix; onlyedges::Bool=false, noplot::Bool=false, kw...)\nPlots the 2-D triangulation or Voronoi polygons defined by the points in a matrix."
  },
  {
    "objectID": "documentation/modules/triplot.html#returns",
    "href": "documentation/modules/triplot.html#returns",
    "title": "triplot",
    "section": "Returns",
    "text": "Returns\nA GMTdataset if noplot=true or nothing otherwise."
  },
  {
    "objectID": "documentation/modules/triplot.html#examples",
    "href": "documentation/modules/triplot.html#examples",
    "title": "triplot",
    "section": "Examples",
    "text": "Examples\nUsing a grid\n\nusing GMT\ntriplot(rand(5,2), voronoi=true, show=true)\n\n\n\n\n\n\n\n\n\nusing GMT\ntriplot(rand(5,3), lc=:red, show=true)"
  },
  {
    "objectID": "documentation/modules/triplot.html#source-code",
    "href": "documentation/modules/triplot.html#source-code",
    "title": "triplot",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/triplot.html#see-also",
    "href": "documentation/modules/triplot.html#see-also",
    "title": "triplot",
    "section": "See Also",
    "text": "See Also\nsphtriangulate, triangulate, trisurf, plot"
  },
  {
    "objectID": "documentation/modules/vband.html",
    "href": "documentation/modules/vband.html",
    "title": "vband",
    "section": "",
    "text": "vband(mat::Matrix; region=(...), width=false,  percent=false, fill=nothing, fillalpha=nothing)\n\nhband(mat::Matrix; region=(...), height=false, percent=false, fill=nothing, fillalpha=nothing)\nReads a MxN array where 2 &lt;= N &lt;= 4 and plot a vertical (vband or vspan) or horizontal (hband or hspan) bands across the xy plot. If N == 2 the bands are plotted from ymin to ymax (vband) and from xmin to xmax (hband). The optional 1 or 2 extra columns control the begin/end of each band (see examples). The third (optional) column specifies the base of a vertical band or the left of the horizontal one. Use a NaN to indicate that base|left = y|x_min. The 4rth column controls the top of vertical bands or the right of the horizontals. Also here a NaN means top|right = y|x_max.\nThe bands width (or height in hband) are controlled by two alternative mechanisms. By default the input mat array has rows with x1 x2 (data) coordinates for the start and end of each vband and y1 y2 for each hband. But alternatively we may specify width=true (for vbands) or percent=true in which case the second column is interpreted as the band width (or height in hband) or the percentage of the plot’s width (height) in data units.\nA small annoyance in using these functions in a first call is that we must specify the plot limits. To minimize this constrain, we can call them from with a plot call as a nested call (see example at the bottom). But even here we have a lower order annoyance. When called nested in plot the bands will be plotted over the lines/symbols and not under as it would be desirable. Mechanics of GMT make this difficult to achieve.\nFor syntax compatibility with other Julia plotting packages vband and hband have aliases vspan and hspan."
  },
  {
    "objectID": "documentation/modules/vband.html#parameters",
    "href": "documentation/modules/vband.html#parameters",
    "title": "vband",
    "section": "Parameters",
    "text": "Parameters\n\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nfill or color\nSelect color or pattern for filling of symbols [Default is lightblue]. It can take the form of a string, a vector or a tuple of colors. See Setting color for extend color selection (including color map generation). When more than one band is requested the bands colors are assigned by cycling through the colors given in this option. This means that a 3 bands and a fill=[:red, :blue] will plot first and third band in red and second in blue.\nOptionally the fill can be done with patterns (which includes the possibility of using images).\nfillalpha or alpha or transparency : – alpha=0.5 | alpha=(50, 75)\nControl the transparency level. Numbers can be floats &lt;= 1.0 or integers in 0-100 range. Default is 75. It can take the form of a number, a vector or a tuple of numbers. When more than one band is requested the bands transparencies are assigned by cycling through the values given in this option. This means that the number of bands and of transparencies may be different.\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/modules/vband.html#examples",
    "href": "documentation/modules/vband.html#examples",
    "title": "vband",
    "section": "Examples",
    "text": "Examples\nA vertical bands with 2 colors and 3 transparencies\n\nusing GMT\nvband([1 2; 2.5 3; 4 5], fill=(:red, :blue), alpha=(0.75, 0.5, 0.3), region=(0,5,-1,5), show=true)\n\n\n\n\n\n\n\n\nNow with variable heights.\n\nusing GMT\nvband([1 2 0 NaN; 2.5 3 NaN 4; 4 5 1 3], fill=[:red, :blue], alpha=(0.75, 0.5, 0.3),\n      region=(0,5,-1,5), show=true)\n\n\n\n\n\n\n\n\nA horizontal band plot with variable lengths and colors and constant transparency.\n\nusing GMT\nhband([-0.5 0.5 0 3; 1 2 1 NaN; 3 4 NaN NaN], fill=(:red, :blue, :green), region=(0,5,-1,5), show=1)\n\n\n\n\n\n\n\n\nWe can fill with patterns as well. And use an image as one of the patterns.\n\nusing GMT\nvband([1 2; 2.5 4], fill=((pattern=TESTSDIR * \"assets/tiling2.jpg\", dpi=200), (pattern=27, dpi=200)),\n      region=(0,5,-1,5), show=true)\n\n\n\n\n\n\n\n\nDo a nested call in which one is not forced to specify the plot limits but let it be computed from input data\n\nusing GMT\nplot(0:0.5:5, rand(11), vband=(data=[1 2; 2.5 3; 4 4.2], fill=[:red, :blue, :green]), show=true)"
  },
  {
    "objectID": "documentation/modules/vband.html#see-also",
    "href": "documentation/modules/vband.html#see-also",
    "title": "vband",
    "section": "See also",
    "text": "See also\nvlines, hlines"
  },
  {
    "objectID": "documentation/modules/vband.html#source-code",
    "href": "documentation/modules/vband.html#source-code",
    "title": "vband",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/modules/violins.html",
    "href": "documentation/modules/violins.html",
    "title": "violin",
    "section": "",
    "text": "violin(data, grp=[]; pos=nothing, kwargs...)\nDraw a violin plot that is similar to a box plot, with the addition of a kernel density plot on each side. The input data can take several different forms.\nviolin(data::AbstractVector{&lt;:Real}; kwargs…)\nDraws a single violin. Options in kwargs provide fine settings for the violin\nviolin(data::AbstractVector{&lt;:Real}, grp::AbstractVector, …) Use the categorical vector (made of integers or text strings) grp break down a the data column vector in cathegories (groups).\nviolin(data::AbstractMatrix{&lt;:Real}; pos=Vector{&lt;:Real}, …) where pos is a coordinate vector (or a single location when data is a vector) where to plot the boxes. Default plots them at 1:n_boxes or 1:n_groups.\nviolin(data::GMTdatset{&lt;:Real}; pos=Vector{Real}(), …) Like the above case but the input data is stored in a GMTdataset\nviolin(data::Vector{Vector{&lt;:Real}}; pos=Vector{Real}(), …) Similar to the Matrix case but here each data vector used to compute the statistics can have a different number of points. There will be as many boxplots as length(data)\nviolin(data::Array{T&lt;:Real,3}; pos=Vector{Real}(), groupwidth=0.75, ccolor=false, …) Draws G groups of violins of N columns boxes. - groupWidth: Specify the proportion of the x-axis interval across which each x-group of boxes should be spread. The default is 0.75. - ccolor: Logical value indicating whether the groups have constant color (when fill=true is used) or have variable color (the default). - fill: If fill=true paint the boxes with a pre-defined color scheme. Otherwise, give a list of colors to paint the boxes. - fillalpha: When the fill option is used, we can set the transparency of filled violins with this option that takes in an array (vec or 1-row matrix) with numeric values between [0-1] or ]1-100], where 100 (or 1) means full transparency. - pos: a coordinate vector where to plot the boxes. Default plots them at 1:n_boxes or 1:n_groups. - split: If true, the groups that have two elements will be plotted with the left-side of one and the right side of the other. For groups that have other number of elements this option is ignored. - ticks or xticks or yticks: A tuple with annotations interval and labels. E.g. xticks=(1:5, [“a”, “b”, “c”, “d”]) where first element is an AbstractArray and second an array or tuple of strings or symbols. - separator: If = true plot a black line separating the groups. Otherwise provide the pen settings of those lines.\nviolin(data::Vector{Vector{Vector{&lt;:Real}}}, …) Like the above but here the groups (length(data)) can have a variable number of elements and each have its own size.\nThis module is a subset of plot. So not all (fine) controlling parameters are not listed here. For the finest control, user should consult the plot module."
  },
  {
    "objectID": "documentation/modules/violins.html#examples",
    "href": "documentation/modules/violins.html#examples",
    "title": "violin",
    "section": "Examples",
    "text": "Examples\nCreate a plot with 8 violins colored with the default colors.\n\nusing GMT\nviolin(randn(100,8), fill=true, show=true)\n\n\n\n\n\n\n\n\nNow add boxplot, scatter and outliers to a plot similar to above. The outliers show as black stars.\n\nusing GMT\nviolin(randn(100,8), fill=true, boxplot=true, scatter=true, outliers=true, show=true)\n\n\n\n\n\n\n\n\nAnd a group example with red dashed separator lines.\n\nusing GMT\nvvv = [[randn(50), randn(30)], [randn(40), randn(48), randn(45)], [randn(35), randn(43)]];\nviolin(vvv, fill=true, boxplot=true, separator=(:red, :dash), scatter=true, outliers=true, show=true)"
  },
  {
    "objectID": "documentation/modules/violins.html#source-code",
    "href": "documentation/modules/violins.html#source-code",
    "title": "violin",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nviolin(data::Array{Array{Vector{T}, 1}, 1}; pos, nbins, first, bins, bandwidth, kernel, groupwidth, ccolor, kwargs...) where T - statplots.jl:608\nviolin(data::Array{&lt;:Real, 3}; pos, nbins, first, bins, bandwidth, kernel, groupwidth, ccolor, kwargs...) - statplots.jl:582\nviolin(data::GMTdataset; pos, first, kwargs...) - statplots.jl:555\nviolin(data::Union{AbstractMatrix{T}, Array{Vector{T}, 1}}; first, pos, nbins, bins, bandwidth, groupwidth, kernel, kwargs...) where T - statplots.jl:570\nviolin(data::Vector{&lt;:Real}, grp::AbstractVector; first, pos, nbins, bins, bandwidth, groupwidth, kernel, kwargs...) - statplots.jl:559\nviolin(data::Vector{&lt;:Real}; ...) - statplots.jl:559"
  },
  {
    "objectID": "documentation/modules/windbarbs.html",
    "href": "documentation/modules/windbarbs.html",
    "title": "windbarbs",
    "section": "",
    "text": "windbarbs(u, v; kwargs...)\nPlot wind barb field from two component grids with the x and y components of the wind field.\nRead two 2-D grid files which represents the x- and y-components of a wind field and produces a wind field plot by drawing wind barbs with orientation and barbs according to the information in the files. Alternatively, polar coordinate r, theta grids may be given instead. Alternatively, a data table with the x and y components of the wind field may be given."
  },
  {
    "objectID": "documentation/modules/windbarbs.html#required-arguments",
    "href": "documentation/modules/windbarbs.html#required-arguments",
    "title": "windbarbs",
    "section": "Required Arguments",
    "text": "Required Arguments\n\ncompx Contains the x-components of the wind field.\ncompy Contains the y-components of the wind field."
  },
  {
    "objectID": "documentation/modules/windbarbs.html#optional-arguments",
    "href": "documentation/modules/windbarbs.html#optional-arguments",
    "title": "windbarbs",
    "section": "Optional Arguments",
    "text": "Optional Arguments\n\nA or polar : – polar=true\nThe grid files contain polar (r, theta) components instead of Cartesian (x, y) [Default is Cartesian components]. This option is valid only when the input files are 2-D grids.\nB or axes or frame\nSet map boundary frame and axes attributes. Default is to draw and annotate left, bottom and vertical axes and just draw left and top axes. More at [frame](../common_opts/opt_B.html)\nC or color or cmap or colorap or colorscale : – color=cpt\nWhere cpt is a GMTcpt type or a cpt file name (for grd_z only). Alternatively, supply the name of a GMT color master dynamic CPT [turbo] to automatically determine a continuous CPT from the grid’s z-range; you may round up/down the z-range by adding +i zinc. Yet another option is to specify color=“color1,color2 [,color3 ,…]” or color=((r1,g1,b1),(r2,g2,b2),…) to build a linear continuous CPT from those colors automatically. In this case color1 etc can be a (r,g,b) triplet, a color name, or an HTML hexadecimal color (e.g. #aabbcc ) (see [Setting color](../common_features/color.html)). When not explicitly set, but a color map is needed, we will either use the current color map, if available (set by a previous call to makecpt), or the default turbo color map.\nG or fill : – fill=fill\nSets color or shade for wind barb interiors (see Fill color/pattern) [Default is no fill].\nI or inc or increment or spacing : – inc=x_inc | inc=(x_inc, y_inc) | inc=“x”“multx”[“/multy”]\nOnly plot wind barbs at nodes every x_inc, y_inc apart (must be multiples of original grid spacing). Append m for arc minutes or s for arc seconds. Alternatively, use inc=“x” to specify the multiples multx[/multy] directly [Default plots every node]. Example inc=“x10/5” to select every other 10 nodes in x and 5 nodes in y. NOTE: by default we estimate good values so that the arrows do no overlap so you may start by jumping this option unless some fine control is desired.\nJ or proj or projection : – proj=\nSelect map projection. More at [proj](../common_opts/opt_J.html)\nN or noclip or no_clip : noclip=true\nDo NOT clip wind barbs at map boundaries [Default will clip].\nQ or barbs : – barbs=(length=length, angle=angle, fill=fill, pen=pen, justify=“b|e|c”, speed=speed, width=width)\nModify wind barb parameters. Append wind barb length [Default is 0.5c]. Several modifiers may be appended to specify the placement of barbs, their shapes, and the justification of the wind barb. Below, left and right refers to the side of the wind barb line when viewed from the start point to the end point of the segment. Chose among these modifiers:\n\nangle - Set the angle of the wind barb [120].\nfill - Turn off fill (if -) or set the wind barb fill [Default fill is used, which may be no fill].\npen - Sets the wind barb pen attributes. If pen has a leading - then the outline is not drawn [Default pen is used, and outline is drawn].\njustify - Determines how the input x, y point relates to the wind barb. Choose from beginning [default], end, or center.\nspeed - Set the wind speed which corresponds to a long barb [default 5].\nwidth - Set the width of wind barbs.\n\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nT or sign_scale : – sign_scale=true\nMeans the azimuths of Cartesian data sets should be adjusted according to the signs of the scales in the x- and y-directions [Leave alone]. This option can be used to convert vector azimuths in cases when a negative scale is used in one of both directions (e.g., positive down).\nU or time_stamp : – time_stamp=true | time_stamp=(just=“code”, pos=(dx,dy), label=“label”, com=true)\nDraw GMT time stamp logo on plot. More at [timestamp](../common_opts/opt_U.html)\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nW or pen=pen\nSet pen attributes for the arrow stem [Defaults: width = default, color = black, style = solid]. See [Pen attributes](../common_features/pens.html) and [Vector attributes](../common_features/arrows_control.html) for arrow line terminations.\nX or xshift or x_offset : xshift=true | xshift=x-shift | xshift=(shift=x-shift, mov=“a|c|f|r”)\nShift plot origin. More at [xshift](../common_opts/opt_X.html)\nY or yshift or y_offset : yshift=true | yshift=y-shift | yshift=(shift=y-shift, mov=“a|c|f|r”)\nShift plot origin. More at [yshift](../common_opts/opt_Y.html)\nZ or azimuth : – azimuth=true\nThe theta grid provided contains azimuths rather than directions (implies polar=true). This option is valid only when the input files are 2-D grids.\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at\np or view or perspective : – view=(azim, elev)\nDefault is viewpoint from an azimuth of 200 and elevation of 30 degrees.\nSpecify the viewpoint in terms of azimuth and elevation. The azimuth is the horizontal rotation about the z-axis as measured in degrees from the positive y-axis. That is, from North. This option is not yet fully expanded. Current alternatives are:\n\nview=??\nA full GMT compact string with the full set of options.\nview=(azim,elev)\nA two elements tuple with azimuth and elevation\nview=true\nTo propagate the viewpoint used in a previous module (makes sense only in bar3!) More at [perspective](../common_opts/opt_p.html)\n\nt or transparency or alpha: – alpha=50\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]. Works only for the PDF and PNG formats."
  },
  {
    "objectID": "documentation/modules/windbarbs.html#examples",
    "href": "documentation/modules/windbarbs.html#examples",
    "title": "windbarbs",
    "section": "Examples",
    "text": "Examples\nTo draw the wind field given by the files r.nc and theta.nc on a barb plot with 0.25 cm length and centered on the node locations, run:\nwindbarb(\"r.nc\", \"theta.nc\", polar=true, barbs=(len=0.25, justify=:c), show=true)\nTo plot a geographic data sets given the files comp_x.nc and comp_y.nc, and only plot every 3rd node in either direction, try:\nwindbarb(\"comp_x.nc\", \"comp_y.nc\", inc=\"x3\", proj=:guess, barbs=(len=0.25, justify=:c), show=true)\n\nusing GMT\n\necmwf(:forecast, var=[\"10u\", \"10v\"], R=\"IHO23\", prefix=\"vel\")\nwindbarbs(\"vel_10u.grd\", \"vel_10v.grd\", barbs=(length=0.25, width=0.15),\n          inc=\"x10\", coast=true, proj=:guess, show=true)\n\n\nRequestError: HTTP/1.1 404 Not Found while requesting https://data.ecmwf.int/forecasts/20251205/12z/ifs/0p25/oper/20251205120000-0h-oper-fc.index\n\nStacktrace:\n  [1] #3\n    @ C:\\programs\\Julia-1.10\\share\\julia\\stdlib\\v1.10\\Downloads\\src\\Downloads.jl:271 [inlined]\n  [2] open(f::Downloads.var\"#3#4\"{Nothing, Vector{Pair{String, String}}, Float64, Nothing, Bool, Nothing, Nothing, String}, args::String; kwargs::@Kwargs{write::Bool, lock::Bool})\n    @ Base .\\io.jl:396\n  [3] open_nolock\n    @ C:\\programs\\Julia-1.10\\share\\julia\\stdlib\\v1.10\\ArgTools\\src\\ArgTools.jl:35 [inlined]\n  [4] arg_write(f::Function, arg::String)\n    @ ArgTools C:\\programs\\Julia-1.10\\share\\julia\\stdlib\\v1.10\\ArgTools\\src\\ArgTools.jl:103\n  [5] #download#2\n    @ C:\\programs\\Julia-1.10\\share\\julia\\stdlib\\v1.10\\Downloads\\src\\Downloads.jl:258 [inlined]\n  [6] download\n    @ C:\\programs\\Julia-1.10\\share\\julia\\stdlib\\v1.10\\Downloads\\src\\Downloads.jl:247 [inlined]\n  [7] ecmwf_fc(; filename::String, levlist::String, kw::@Kwargs{dryrun::Bool, var::Vector{String}, R::String, prefix::String})\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\extras\\weather.jl:423\n  [8] ecmwf_fc\n    @ C:\\Users\\j\\.julia\\dev\\GMT\\src\\extras\\weather.jl:315 [inlined]\n  [9] ecmwf(source::Symbol; filename::String, cb::Bool, dataset::String, params::String, key::String, url::String, wait::Float64, levlist::String, region::String, format::String, dryrun::Bool, verbose::Bool, kw::@Kwargs{var::Vector{String}, R::String, prefix::String})\n    @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\extras\\weather.jl:189\n [10] top-level scope\n    @ In[2]:3"
  },
  {
    "objectID": "documentation/modules/windbarbs.html#source-code",
    "href": "documentation/modules/windbarbs.html#source-code",
    "title": "windbarbs",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nwindbarbs(cmd0::String; first, kwargs...) - windbarbs.jl:25\nwindbarbs(; ...) - windbarbs.jl:25\nwindbarbs(arg1; first, kwargs...) - windbarbs.jl:26\nwindbarbs(arg1::Union{String, GMTgrid}, arg2::Union{String, GMTgrid}; first, kwargs...) - windbarbs.jl:50"
  },
  {
    "objectID": "documentation/modules/windbarbs.html#see-also",
    "href": "documentation/modules/windbarbs.html#see-also",
    "title": "windbarbs",
    "section": "See Also",
    "text": "See Also\ngrdcontour, grdvector\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/ablines.html",
    "href": "documentation/utilities/ablines.html",
    "title": "ablines",
    "section": "",
    "text": "ablines(a, b; kw...)\nor\nablines([a1, a2, ..., an], [b1, b2, ..., bn]; kw...)\nor\nablines(D::GMTdataset; kw...)\nCreates a straight line(s) defined by Y = a + b * X. Input can be a pair of a,b parameters or a vector of them, case in which multiple straight lines are plotted. Plot limits are passed through the usual region option in kw or, if missing, we plot lines in the x = [0 10] interval. The third form, when input is a GMTdataset.html) type implies that this was computed with the linearfitxy function, which embeds the linear fit parameters in the data type attributes. All plot options are available via the kw arguments."
  },
  {
    "objectID": "documentation/utilities/ablines.html#examples",
    "href": "documentation/utilities/ablines.html#examples",
    "title": "ablines",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nablines([1, 2, 3], [1, 1.5, 2], linecolor=[:red, :orange, :pink], linestyle=:dash, linewidth=2, show=true)\n\n\n\n\n\n\n\n\n\nusing GMT\n\nD = linearfitxy([0.0, 0.9, 1.8, 2.6, 3.3, 4.4, 5.2, 6.1, 6.5, 7.4], [5.9, 5.4, 4.4, 4.6, 3.5, 3.7, 2.8, 2.8, 2.4, 1.5],\n                 sx = 1 ./ sqrt.([1000., 1000, 500, 800, 200, 80,  60, 20, 1.8, 1]), sy=1 ./\n                 sqrt.([1., 1.8, 4, 8, 20, 20, 70, 70, 100, 500]));\nplot(D, linefit=true, band_ab=true, band_CI=true, ellipses=true, show=true)"
  },
  {
    "objectID": "documentation/utilities/ablines.html#see-also",
    "href": "documentation/utilities/ablines.html#see-also",
    "title": "ablines",
    "section": "See Also",
    "text": "See Also\nplotlinefit, linearfitxy, plot"
  },
  {
    "objectID": "documentation/utilities/ablines.html#source-code",
    "href": "documentation/utilities/ablines.html#source-code",
    "title": "ablines",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nablines(a::Vector{&lt;:Real}, b::Vector{&lt;:Real}; first, kw...) - linefit.jl:419\nablines(a, b; first, kw...) - linefit.jl:418\nablines(D::GMTdataset; first, kw...) - linefit.jl:410"
  },
  {
    "objectID": "documentation/utilities/append2fig.html",
    "href": "documentation/utilities/append2fig.html",
    "title": "append2fig",
    "section": "",
    "text": "append2fig(fname::String)\nMove the file fname to the default name and location (GMT_user.ps in tmp). The fname should be a PS file that has NOT been closed. Posterior calls to plotting methods will append to this file. Useful when creating figures that use a common base map that may be heavy (slow) to compute."
  },
  {
    "objectID": "documentation/utilities/append2fig.html#source-code",
    "href": "documentation/utilities/append2fig.html#source-code",
    "title": "append2fig",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/cart2pol.html",
    "href": "documentation/utilities/cart2pol.html",
    "title": "cart2pol",
    "section": "",
    "text": "theta, rho = cart2pol(x, y; deg=false)\nTransform Cartesian to polar coordinates. Angles are returned in radians by default. Use deg=true to return the angles in degrees. Input can be scalar, vectors or matrices."
  },
  {
    "objectID": "documentation/utilities/cart2pol.html#source-code",
    "href": "documentation/utilities/cart2pol.html#source-code",
    "title": "cart2pol",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/coastlinesproj.html",
    "href": "documentation/utilities/coastlinesproj.html",
    "title": "coastlinesproj",
    "section": "",
    "text": "cl = coastlinesproj(proj=\"?\", res=\"crude\", coastlines=nothing, limits=Float64[])\nExtract the coastlines from GMT’s GSHHG database and project them using PROJ (NOT the GMT projection machinery). This allows the use of many of the PROJ projections that are not available from pure GMT."
  },
  {
    "objectID": "documentation/utilities/coastlinesproj.html#returns",
    "href": "documentation/utilities/coastlinesproj.html#returns",
    "title": "coastlinesproj",
    "section": "Returns",
    "text": "Returns\nA Vector of GMTdataset containing the projected world GSHHG coastlines at resolution res."
  },
  {
    "objectID": "documentation/utilities/coastlinesproj.html#example",
    "href": "documentation/utilities/coastlinesproj.html#example",
    "title": "coastlinesproj",
    "section": "Example",
    "text": "Example\n\nusing GMT\ncl = coastlinesproj(proj=\"+proj=ob_tran +o_proj=moll +o_lon_p=40 +o_lat_p=50 +lon_0=60\");"
  },
  {
    "objectID": "documentation/utilities/coastlinesproj.html#see-also",
    "href": "documentation/utilities/coastlinesproj.html#see-also",
    "title": "coastlinesproj",
    "section": "See Also",
    "text": "See Also\ngraticules, [plotgrid!], worldrectangular, worldrectgrid, worldrectcoast, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/coastlinesproj.html#source-code",
    "href": "documentation/utilities/coastlinesproj.html#source-code",
    "title": "coastlinesproj",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/cpt4dcw.html",
    "href": "documentation/utilities/cpt4dcw.html",
    "title": "cpt4dcw",
    "section": "",
    "text": "C = cpt4dcw(codes::String, vals::Vector{&lt;:Real}; kwargs...) --&gt; GMTcpt.html)\nCreate a categorical CPT to use with the output of coast(dcw=...) to make Choropleth maps.\nOptionally provide a CPT in the kwarg cmap=CPT with a range sufficient to transform the vals in colors. As an alternative to the above, provide a makecpt type range numeric vector to create a CPT. If none of these are provided a default CPT = makecpt(range=(0,255,1)) will be used."
  },
  {
    "objectID": "documentation/utilities/cpt4dcw.html#returns",
    "href": "documentation/utilities/cpt4dcw.html#returns",
    "title": "cpt4dcw",
    "section": "Returns",
    "text": "Returns\nA GMTcpt color map."
  },
  {
    "objectID": "documentation/utilities/cpt4dcw.html#examples",
    "href": "documentation/utilities/cpt4dcw.html#examples",
    "title": "cpt4dcw",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nC = cpt4dcw(\"PT,ES,FR\", [3., 5, 8], range=[3,9,1])\n\nExtract of a GMTcpt exposed as a GMTdataset for display.\nCATEGORICAL palette.\nModel: rgb\nColor depth: 24\n\n\n\n\n\n\n3×5 GMTdataset{Float64, 2}\n Row │   z      r      g      b  alpha  Labels\n─────┼─────────────────────────────────────────\n   1 │ 3.0   67.0   79.0  187.0    0.0      PT\n   2 │ 5.0   86.0  250.0  117.0    0.0      ES\n   3 │ 7.0  186.0   30.0    2.0    0.0      FR"
  },
  {
    "objectID": "documentation/utilities/cpt4dcw.html#see-also",
    "href": "documentation/utilities/cpt4dcw.html#see-also",
    "title": "cpt4dcw",
    "section": "See Also",
    "text": "See Also\nmakecpt"
  },
  {
    "objectID": "documentation/utilities/cpt4dcw.html#source-code",
    "href": "documentation/utilities/cpt4dcw.html#source-code",
    "title": "cpt4dcw",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncpt4dcw(continent::String; ...) - choropleth_utils.jl:54\ncpt4dcw(codes::String, vals::Vector{&lt;:Real}; kwargs...) - choropleth_utils.jl:11\ncpt4dcw(continent::String, vals; kwargs...) - choropleth_utils.jl:54\ncpt4dcw(codes::Vector{&lt;:AbstractString}, vals::Vector{&lt;:Real}; kwargs...) - choropleth_utils.jl:12"
  },
  {
    "objectID": "documentation/utilities/cube.html",
    "href": "documentation/utilities/cube.html",
    "title": "cube",
    "section": "",
    "text": "FV = cube(r=1.0; radius=1.0, origin=(0.0, 0.0, 0.0))::GMTfv\nCreate a cube mesh with radius r."
  },
  {
    "objectID": "documentation/utilities/cube.html#example",
    "href": "documentation/utilities/cube.html#example",
    "title": "cube",
    "section": "Example",
    "text": "Example\nCreate a cube using the default values.\n\nusing GMT\n\nFV = cube();\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/cube.html#see-also",
    "href": "documentation/utilities/cube.html#see-also",
    "title": "cube",
    "section": "See Also",
    "text": "See Also\ndodecahedron, icosahedron, octahedron, replicant, sphere, tetrahedron, torus,"
  },
  {
    "objectID": "documentation/utilities/cube.html#source-code",
    "href": "documentation/utilities/cube.html#source-code",
    "title": "cube",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncube(; ...) - solids.jl:211\ncube(r; radius, origin) - solids.jl:211"
  },
  {
    "objectID": "documentation/utilities/cylinder.html",
    "href": "documentation/utilities/cylinder.html",
    "title": "cylinder",
    "section": "",
    "text": "FV = cylinder(r, h; base=0.0, center=(0.0, 0.0, 0.0), geog=false, unit=\"m\", np=36)::GMTfv\nCreate a cylinder with radius r and height h."
  },
  {
    "objectID": "documentation/utilities/cylinder.html#example",
    "href": "documentation/utilities/cylinder.html#example",
    "title": "cylinder",
    "section": "Example",
    "text": "Example\nCreate a cylinder of radius 50 and height 100.\n\nusing GMT\n\nFV = cylinder(50, 100)\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/cylinder.html#see-also",
    "href": "documentation/utilities/cylinder.html#see-also",
    "title": "cylinder",
    "section": "See Also",
    "text": "See Also\ncube, dodecahedron, icosahedron, octahedron, replicant, sphere, tetrahedron, torus,"
  },
  {
    "objectID": "documentation/utilities/cylinder.html#source-code",
    "href": "documentation/utilities/cylinder.html#source-code",
    "title": "cylinder",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/delrows.html",
    "href": "documentation/utilities/delrows.html",
    "title": "delrows!",
    "section": "",
    "text": "delrows!(A::Matrix, rows::VecOrMat)\nDelete the rows of Matrix A listed in the vector rows"
  },
  {
    "objectID": "documentation/utilities/dodecahedron.html",
    "href": "documentation/utilities/dodecahedron.html",
    "title": "dodecahedron",
    "section": "",
    "text": "FV = dodecahedron(r=1.0; radius=1.0, origin=(0.0, 0.0, 0.0))::GMTfv\nCreate an dodecahedron mesh with radius r."
  },
  {
    "objectID": "documentation/utilities/dodecahedron.html#example",
    "href": "documentation/utilities/dodecahedron.html#example",
    "title": "dodecahedron",
    "section": "Example",
    "text": "Example\nCreate a dodecahedron using the default values.\n\nusing GMT\n\nFV = dodecahedron();\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/dodecahedron.html#see-also",
    "href": "documentation/utilities/dodecahedron.html#see-also",
    "title": "dodecahedron",
    "section": "See Also",
    "text": "See Also\ncube, cylinder, icosahedron, octahedron, sphere, tetrahedron, torus,"
  },
  {
    "objectID": "documentation/utilities/dodecahedron.html#source-code",
    "href": "documentation/utilities/dodecahedron.html#source-code",
    "title": "dodecahedron",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndodecahedron(; ...) - solids.jl:114\ndodecahedron(r; radius, origin) - solids.jl:114"
  },
  {
    "objectID": "documentation/utilities/ecmwf.html",
    "href": "documentation/utilities/ecmwf.html",
    "title": "ecmwf",
    "section": "",
    "text": "ecmwf(; filename=\"\", cb::Bool=false, dataset=\"\", params::AbstractString=\"\", key::String=\"\",\n          url::String=\"\", region=\"\", format=\"netcdf\", dryrun::Bool=false, verbose::Bool=true)\nRetrieves data from the Climate Data Store CDS service.\nDownload forecast datasets or just some variables from the ECMWF. (see man after that of first mode)\nGet ERA5 data from the Copernicus Climate Change Service (C3S) Climate Data Store (CDS) using the CDS API."
  },
  {
    "objectID": "documentation/utilities/ecmwf.html#examples",
    "href": "documentation/utilities/ecmwf.html#examples",
    "title": "ecmwf",
    "section": "Examples",
    "text": "Examples\n# Copy the following code by selecting it and pressing Ctrl-C\n\n{\"product_type\": [\"reanalysis\"],\n    \"variable\": [\n        \"10m_u_component_of_wind\",\n        \"10m_v_component_of_wind\"\n    ],\n    \"year\": [\"2024\"],\n    \"month\": [\"12\"],\n    \"day\": [\"06\"],\n    \"time\": [\"16:00\"],\n    \"data_format\": \"netcdf\",\n    \"download_format\": \"unarchived\",\n    \"area\": [58, 6, 55, 9]\n}\n\n# Now call the function but WARNING: DO NOT COPY_PASTE it as it would replace the clipboard contents\necmwf(dataset=\"reanalysis-era5-single-levels\", cb=true)\n\nLet’s dare and build the request ourselves\nvar = era5vars([\"t2m\", \"skt\"])          # \"t2m\" is the 2m temperature and \"skt\" is the skin temperature\ndatetime = era5time(hour=10:14);\necmwf(dataset=\"reanalysis-era5-land\", params=[var, datetime], region=(-10, 0, 30, 45))\n\n\n\n\n\n\necmwf(:forecast; levlist=““, kw…)\n\n\nDownload forecast data\n\n\n### Kwargs - cube: If true [the default], when downloading pressure levels variables, save them data as a netCDF 3D cubes instead of one file per layer (when cube=false).\n\n\n- date: The date to select. It can be a string to select a unique date, a DateTime object, or a Int. Where the Int is the number of days to go back from today. If the Int is greater than 3, an error is raised. If the date is a string, it must be in the form YYYYMMDD or YYYY-MM-DD.\n\n\n- dryrun: Print the URL of the requested data and return without trying to download anything.\n\n\n- format: The format in which to save the downloaded data. It can be “grib” or “netcdf”. Default is “netcdf”.\n\n\n- levlist: The pressure levels to select. It can be a string to select a unique pressure level, or a vector of strings or Ints to select multiple pressure levels.\n\n\n- model: A string with the model to select. Either “ifs” or “aifs”. Default is “ifs”.\n\n\n- param, variable, var, vars: The variable(s) to select. It can be a string to select a unique variable, or a vector of strings or Ints to select multiple variables. When variable(s) is requested, we download only those variables as separate files. The names of those files are the same as the variable names with the .grib2 extension. NOTE: Not specifying a variable will download the entire forecast grib file for each forecast step selected with the step option.\n\n\n- R or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\n\n\n- root: The root URL of the CDS ERA5 dataset. Default is “https://data.ecmwf.int/forecasts”.\n\n\n- step: An Int with the forecast step to select.\n\n\n- stream: The stream to select. It can be one of: “oper”, “enfo”, “waef”, “wave”, “scda”, “scwv”, “mmsf”. Default is “oper”.\n\n\n- time: The time in hours to select. It can be a string a Time object, or a Int. What ever it is, it will floored to 0, 6, 12 or 18. The default is the current hour.\n\n\n- stream: A string with the stream to select, it must be one of: “oper”, “enfo”, “waef”, “wave”, “scda”, “scwv”, “mmsf”. Default is “oper”.\n\n\n- type: A string with the type of forecast to select, it must be one of: “fc”, “ef”, “ep”, “tf”. Default is “fc”.\n\n\nExample\n\n\n\nGet the latest 10m wind and 2m temperature forecast for the region of North Atlantic.\necmwf(:forecast, var=[\"10u\", \"10v\", \"2t\"], R=\"IHO23\")\nGet the 1000, 925 and 850 hPa temperature forecast for the Portugal region. Result is saved in a 3D netCDF file.\necmwf(:forecast, var=\"t\", R=\"PTC\", levlist=[\"1000\", \"925\", \"850\"])\nThe same as above but now we request 5 time steps of the Temperature at the 1000 hPa level.\necmwf(:forecast, var=\"t\", R=\"PTC\", steps=0:3:12)"
  },
  {
    "objectID": "documentation/utilities/ecmwf.html#see-also",
    "href": "documentation/utilities/ecmwf.html#see-also",
    "title": "ecmwf",
    "section": "See Also",
    "text": "See Also\nweather, era5vars, era5time, listecmwfvars"
  },
  {
    "objectID": "documentation/utilities/ecmwf.html#source-code",
    "href": "documentation/utilities/ecmwf.html#source-code",
    "title": "ecmwf",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\necmwf(source::Symbol; filename, cb, dataset, params, key, url, wait, levlist, region, format, dryrun, verbose, kw...) - weather.jl:187\necmwf(; ...) - weather.jl:187"
  },
  {
    "objectID": "documentation/utilities/era5time.html",
    "href": "documentation/utilities/era5time.html",
    "title": "era5time",
    "section": "",
    "text": "era5time(; year=\"\", month=\"\", day=\"\", hour=\"\") -&gt; String\nSelect one or more date-times from a CDS ERA5 dataset.\nThis function returns a JSON formatted string that can be used as an input to the ecmwf function params option."
  },
  {
    "objectID": "documentation/utilities/era5time.html#examples",
    "href": "documentation/utilities/era5time.html#examples",
    "title": "era5time",
    "section": "Examples",
    "text": "Examples\n# All times in 2023\nvar = era5time(year=\"2023\")\n\"\\\"year\\\": [\\\"2023\\\"],\\n\\\"month\\\": [\\\"5\\\"],\\n\\\"day\\\": [\\\"13\\\"],\\n\\\"time\\\": [\\\"2\\\"],\\n\""
  },
  {
    "objectID": "documentation/utilities/era5time.html#see-also",
    "href": "documentation/utilities/era5time.html#see-also",
    "title": "era5time",
    "section": "See Also",
    "text": "See Also\necmwf, era5vars, listecmwfvars"
  },
  {
    "objectID": "documentation/utilities/era5time.html#source-code",
    "href": "documentation/utilities/era5time.html#source-code",
    "title": "era5time",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/extrude.html",
    "href": "documentation/utilities/extrude.html",
    "title": "extrude",
    "section": "",
    "text": "FV = extrude(shape::Matrix{&lt;:AbstractFloat}, h; base=0.0, closed=true)::GMTfv\nCreate an extruded 2D/3D shape."
  },
  {
    "objectID": "documentation/utilities/extrude.html#example",
    "href": "documentation/utilities/extrude.html#example",
    "title": "extrude",
    "section": "Example",
    "text": "Example\nExtrude the Swisserland.\n\nusing GMT\n\nDsw = coast(dump=true, DCW=(country=:CH, file=:ODS));   # Get the Swiss border\nFV = extrude(Dsw, 0.2)\nviz(FV, zsize=1)\n\n\n\n\n\n\n\n\nAnd a much nicer example combining extrusion and painting top surface with flatfv.\n\nusing GMT\n\n# Low resolution country polygons\nDit = coast(M=true, DCW=(country=:IT, file=:ODS));\n\n# Extrude and paint the quadrangulated mesh\nFV = flatfv(\"@earth_day_01m\", shape=Dit, thickness=0.5);\n\nviz(FV, zsize=0.5, frame=:none, view=(200, 45))"
  },
  {
    "objectID": "documentation/utilities/extrude.html#see-also",
    "href": "documentation/utilities/extrude.html#see-also",
    "title": "extrude",
    "section": "See Also",
    "text": "See Also\nflatfv, fv2fv, loft, grid2tri, revolve, surf2fv"
  },
  {
    "objectID": "documentation/utilities/extrude.html#source-code",
    "href": "documentation/utilities/extrude.html#source-code",
    "title": "extrude",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimshow(arg1::Symbol; horizontal, kw...) - imshow.jl:235\nimshow(arg1::GMTcpt; horizontal, kw...) - imshow.jl:236\nimshow(arg1::GMT.Gdal.AbstractDataset; kw...) - imshow.jl:241\nimshow(x::AbstractVector{Float64}, f::String; kw...) - imshow.jl:270\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::String; kw...) - imshow.jl:269\nimshow(x::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:266\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:246\nimshow(f::Function, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:268\nimshow(f::Function, x::AbstractVector{Float64}; kw...) - imshow.jl:267\nimshow(arg1::GItype; kw...) - imshow.jl:124\nimshow(arg1; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:36"
  },
  {
    "objectID": "documentation/utilities/flatfv.html",
    "href": "documentation/utilities/flatfv.html",
    "title": "flatfv",
    "section": "",
    "text": "FV = flatfv(I::Union{GMTimage, AbstractString}; shape=nothing, level=0.0)::GMTfv\nCreate a flat 3D surface from an image and a set of xyz or xy coordinates.\nThis function creates a face for each pixel in the image that is inside the shape and assigns the face’s color from that of the image. So be careful that the image is not too large. As explained below, this function creates flat surfaces in any of the xy, xz or yz planes. While this may seam a big limitation, it can be circumvented by a posterior rotation of the image with the help of a rotation matrix created with the eulermat function."
  },
  {
    "objectID": "documentation/utilities/flatfv.html#example",
    "href": "documentation/utilities/flatfv.html#example",
    "title": "flatfv",
    "section": "Example",
    "text": "Example\n\nusing GMT\n    \nFV = flatfv(TESTSDIR * \"/assets/table_flowers.jpg\", shape=:circle, level=1.0);\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/flatfv.html#see-also",
    "href": "documentation/utilities/flatfv.html#see-also",
    "title": "flatfv",
    "section": "See Also",
    "text": "See Also\nextrude, fv2fv, loft, grid2tri, revolve, surf2fv"
  },
  {
    "objectID": "documentation/utilities/flatfv.html#source-code",
    "href": "documentation/utilities/flatfv.html#source-code",
    "title": "flatfv",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/gadm.html",
    "href": "documentation/utilities/gadm.html",
    "title": "gadm",
    "section": "",
    "text": "gadm(country, subregions...; children=false, names=false, children_raw=false, reportlevels=false)\nReturns a GMTdataset for the requested country, or country subregion(s)"
  },
  {
    "objectID": "documentation/utilities/gadm.html#credits",
    "href": "documentation/utilities/gadm.html#credits",
    "title": "gadm",
    "section": "Credits",
    "text": "Credits\nAddapted from the original GADM (MIT Licensed) and stripped from all of it’s dependencies (ArchGDAL repaced by the GMT GDAL functions). Expanded to also return all subregions of a particular administrative entity."
  },
  {
    "objectID": "documentation/utilities/gadm.html#examples",
    "href": "documentation/utilities/gadm.html#examples",
    "title": "gadm",
    "section": "Examples",
    "text": "Examples\n# data of India's borders\ndata = gadm(\"IND\")\n\n# uttar -&gt; the limits of the Uttar Pradesh state\nuttar = gadm(\"IND\", \"Uttar Pradesh\")\n\n# uttar -&gt; limits of all districts of the  Uttar Pradesh state\nuttar = gadm(\"IND\", \"Uttar Pradesh\", children=true)\n\n# Names of all states of India\ngadm(\"IND\", names=true)"
  },
  {
    "objectID": "documentation/utilities/gadm.html#source-code",
    "href": "documentation/utilities/gadm.html#source-code",
    "title": "gadm",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/geodetic2enu.html",
    "href": "documentation/utilities/geodetic2enu.html",
    "title": "geodetic2enu",
    "section": "",
    "text": "xEast, yNorth, zUp = geodetic2enu(lon, lat, h, lon0, lat0, h0)\nConvert from geodetic coordinates to local East, North, Up (ENU) coordinates."
  },
  {
    "objectID": "documentation/utilities/geodetic2enu.html#returns",
    "href": "documentation/utilities/geodetic2enu.html#returns",
    "title": "geodetic2enu",
    "section": "Returns",
    "text": "Returns\nThree Float64 scalars or thre vectors with the cartesian ENU components"
  },
  {
    "objectID": "documentation/utilities/geodetic2enu.html#source-code",
    "href": "documentation/utilities/geodetic2enu.html#source-code",
    "title": "geodetic2enu",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/gmtread.html",
    "href": "documentation/utilities/gmtread.html",
    "title": "gmtread",
    "section": "",
    "text": "gmtread(fname::String; kwargs...)\nRead GMT object from file. The object is one of “grid” or “grd”, “image” or “img”, “data” or “table”, “cmap” or “cpt” and “ps” (for postscript), and OGR formats (shp, kml, json, gpkg). Use a type specificatin to force a certain reading path (e.g. grd=true to read grids) or take the chance of letting the data type be guessed via the file extension. Known extensions are:"
  },
  {
    "objectID": "documentation/utilities/gmtread.html#parameters",
    "href": "documentation/utilities/gmtread.html#parameters",
    "title": "gmtread",
    "section": "Parameters",
    "text": "Parameters\nSpecify data type (with type=true, e.g. img=true). Choose among: - grd | grid: Load a grid\n\nimg | image: Load a image.\ncpt | cmap: Load a GMT color palette.\ndata | dataset | table: Load a dataset (a table of numbers).\nogr: Load a dataset via GDAL OGR (a table of numbers). Many things can happen here.\nps: Load a PostScript file\ngdal: Force reading the file via GDAL. Should only be used to read grids.\nvarname: When netCDF files have more than one 2D (or higher) variables use varname to pick the wished variable. e.g. varname=:slp to read the variable named ‘slp’. This option defaults data type to ‘grid’.This option can be used both with and without the gdal option. Former case uses GMT lib to read the cube and outputs and 3D array in column major order, later case (the one with gdal) uses GDAL to read the cube and outputs and 3D array in row major order. Remember that the layout member of the GMTgrid type informs about memory layout.\ninrows: Select specific data rows to be read. Valid args include ranges or a string with an hard core GMT -q option.\nnodata: When reading table data via GMT (but not GDAL), this option allows user-coded missing data values to be translated to NaN values. By default examine all input columns after the first two. Use the +c modifier to override the starting column used for the examinations. e.g. nodata=-99999+c1 to replace all -99999 values in second column with NaNs.\nstride: When reading table data via GMT (but not GDAL), this option allows subsampling the data. Provide a number to be used as stride for the rows. A stride=2 will read every other row.\nlayer| layers | band | bands: When files are multiband or nc files with 3D or 4D arrays, we access them via these keywords. layer=4 reads the fourth layer (or band) of the file. But the file can be a grid or an image. If it is a grid, layer can be a scalar (to read 3D arrays) or an array of two elements (to read a 4D array). This option should not be used with the gdal option.\nIf file is an image layer can be a 1 or a 1x3 array (to read a RGB image). Not that in this later case bands do not need to be contiguous. A band=[1,5,2] composes an RGB out of those bands. See more at Modifiers for COARDS-compliant netCDF files but note that we use 1 based indexing here.\nUse layers=:all to read all levels of a 3D cube netCDF file.\nR | region | limits: A numeric vector (or a Tuple) or a string defining the region of interest. If numeric, it must have four elements: [xmin, xmax, ymin, ymax]. If string, it must be in the form xmin/xmax/ymin/ymax. Default is to read entire file extent.\nWhen reading remote files via the ‘@’ mechanism, the region can be given in projected coordinates, provided that the proj option is also given and describing system used in R.\nJ | proj | projection: When region is given in projected coordinates, this option must be provided, otherwise it is ignored. The syntax is the same as in all modules that use the proj option.\nconvert: In case that both the region and proj options are used, this option (any value will do) can be used to request that the grid be converted to the new projection defined by proj.\nR or region or limits : – limits=(xmin, xmax, ymin, ymax) | limits=(BB=(xmin, xmax, ymin, ymax),) | limits=(LLUR=(xmin, xmax, ymin, ymax),units=“unit”) | …more\nSpecify the region of interest. More at [limits](../common_opts/opt_R.html). For perspective view view, optionally add zmin,zmax. This option may be used to indicate the range used for the 3-D axes. You may ask for a larger w/e/s/n region to have more room between the image and the axes.\nV or verbose : – verbose=true | verbose=level\nSelect verbosity level. More at [verbose](../common_opts/opt_V.html)\nbi or binary_in : – binary_in=??\nSelect native binary format for primary table input. More at\nf or colinfo : – colinfo=??\nSpecify the data types of input and/or output columns (time or geographical data). More at"
  },
  {
    "objectID": "documentation/utilities/gmtread.html#examples",
    "href": "documentation/utilities/gmtread.html#examples",
    "title": "gmtread",
    "section": "Examples",
    "text": "Examples\nTo read a nc called ‘lixo.grd’\nG = gmtread(\"lixo.grd\");\nto read a jpg image with the bands reversed\nI = gmtread(\"image.jpg\", band=[2,1,0]);\nto read a zip comtressed shape file\nI = gmtread(\"fileshapes.zip.shp\");\nto read remote dataset at 3 arc sec resolution with the region given in UTM and projection conversion\nG = gmtread(\"@earth_relief_03s\", R=[420000, 470000, 4510000, 4535000], J=\"+proj=utm +zone=33\", convert=true);"
  },
  {
    "objectID": "documentation/utilities/gmtread.html#see-also",
    "href": "documentation/utilities/gmtread.html#see-also",
    "title": "gmtread",
    "section": "See Also",
    "text": "See Also\ngmtwrite, gdalread"
  },
  {
    "objectID": "documentation/utilities/gmtread.html#source-code",
    "href": "documentation/utilities/gmtread.html#source-code",
    "title": "gmtread",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/graticules.html",
    "href": "documentation/utilities/graticules.html",
    "title": "graticules",
    "section": "",
    "text": "grat = graticules(D, width=(30,20), grid=nothing, annot_x=nothing)\n\nor\n\ngrat = graticules(; proj=\"projection\", width=(30,20), pm=0, grid=nothing, annot_x=nothing)\nCreate a projected graticule GMTdataset with meridians and parallels at width intervals."
  },
  {
    "objectID": "documentation/utilities/graticules.html#returns",
    "href": "documentation/utilities/graticules.html#returns",
    "title": "graticules",
    "section": "Returns",
    "text": "Returns\nA Vector of GMTdataset containing the projected meridians and parallels. grat[i] attributes store information about that element lon,lat."
  },
  {
    "objectID": "documentation/utilities/graticules.html#example",
    "href": "documentation/utilities/graticules.html#example",
    "title": "graticules",
    "section": "Example",
    "text": "Example\n\nusing GMT\ngrat = graticules(proj=\"+proj=ob_tran +o_proj=moll +o_lon_p=40 +o_lat_p=50 +lon_0=60\");"
  },
  {
    "objectID": "documentation/utilities/graticules.html#see-also",
    "href": "documentation/utilities/graticules.html#see-also",
    "title": "graticules",
    "section": "See Also",
    "text": "See Also\ncoastlinesproj, [plotgrid!], worldrectangular, worldrectgrid, worldrectcoast, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/graticules.html#source-code",
    "href": "documentation/utilities/graticules.html#source-code",
    "title": "graticules",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngraticules(; proj, width, grid, pm, annot_x) - utils_project.jl:305\ngraticules(G_I::GItype; width, grid, annot_x) - utils_project.jl:301\ngraticules(D::GDtype; width, grid, annot_x) - utils_project.jl:297"
  },
  {
    "objectID": "documentation/utilities/gridit.html",
    "href": "documentation/utilities/gridit.html",
    "title": "gridit",
    "section": "",
    "text": "G = gridit(fname=\"\", indata=nothing; method=\"surface\", gdopts=\"\", proj=\"\", epsg=0, kw...)\nWrapper function to interpolate scattered data into a grid. Interpolation methods may be those of GMT and GDAL (gdal_grid)."
  },
  {
    "objectID": "documentation/utilities/gridit.html#returns",
    "href": "documentation/utilities/gridit.html#returns",
    "title": "gridit",
    "section": "Returns",
    "text": "Returns\nA GMTgrid or nothing if file was writen on disk."
  },
  {
    "objectID": "documentation/utilities/gridit.html#examples",
    "href": "documentation/utilities/gridit.html#examples",
    "title": "gridit",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\n# Interpolate cashed data ship_15.txt\nG = gridit(\"@ship_15.txt\", method=:surface, mask=0.3, preproc=true, V=:q);\n\n# Make a base image from gridded data\ngrdimage(G, shade=true, coast=(land=:gray, shore=0.5))\n\n# Add automatic contours\ngrdcontour!(G, show=true)"
  },
  {
    "objectID": "documentation/utilities/gridit.html#see-also",
    "href": "documentation/utilities/gridit.html#see-also",
    "title": "gridit",
    "section": "See Also",
    "text": "See Also\nblockmean, blockmedian, surface, triangulate, nearneighbor"
  },
  {
    "objectID": "documentation/utilities/gridit.html#source-code",
    "href": "documentation/utilities/gridit.html#source-code",
    "title": "gridit",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngridit(fname::String; ...) - gridit.jl:46\ngridit(; ...) - gridit.jl:46\ngridit(arg1::Union{GMT.Gdal.AbstractDataset, GDtype, Matrix{&lt;:AbstractFloat}}; method, proj, epsg, kw...) - gridit.jl:90\ngridit(fname::String, arg1::Union{Nothing, GMT.Gdal.AbstractDataset, GDtype, Matrix{&lt;:AbstractFloat}}; method, gdopts, proj, epsg, kw...) - gridit.jl:46"
  },
  {
    "objectID": "documentation/utilities/hampel.html",
    "href": "documentation/utilities/hampel.html",
    "title": "hampel",
    "section": "",
    "text": "hampel(x; spread=mad(x), threshold=2)\nIdentify outliers using the Hampel criterion.\nGiven vector x, identify elements xₖ such that\nwhere m is the median of the elements, the dispersion scale S is provided by the function spread, and the parameter t is given by threshold. The return value is a Bool vector.\nBy default, spread is [mad] and threshold is 2.\nApply a windowed Hampel filter to a time series.\nGiven vector x and half-width K, apply a Hampel criterion within a sliding window of width 2K+1. The median m of the window replaces the element xₖ at the center of the window if it satisfies\nwhere the dispersion scale S is provided by the function spread and the parameter t is given by threshold. The window shortens near the beginning and end of the vector to avoid referencing fictitious elements. Larger values of t make the filter less agressive, while t=0 is the standard median filter.\nFor recursive filtering, see hampel!\nThe value of boundary determines how the filter handles the boundaries of the vector:\nApply a weighted Hampel filter to a time series.\nGiven vector x and a vector weights of positive intgers, before computing the criterion each element in the window is repeated by the number of times given by its corresponding weight. This is typically used to make the central element more influential than the others."
  },
  {
    "objectID": "documentation/utilities/hampel.html#source-code",
    "href": "documentation/utilities/hampel.html#source-code",
    "title": "hampel",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nhampel(x::AbstractVector, weights::Vector{&lt;:Integer}; kwargs...) - hampel_outliers.jl:90\nhampel(x, K::Integer; kwargs...) - hampel_outliers.jl:89\nhampel(x::AbstractVector; kwargs...) - hampel_outliers.jl:26"
  },
  {
    "objectID": "documentation/utilities/hampel.html#see-also",
    "href": "documentation/utilities/hampel.html#see-also",
    "title": "hampel",
    "section": "See Also",
    "text": "See Also\nlowess, whittaker\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/icosahedron.html",
    "href": "documentation/utilities/icosahedron.html",
    "title": "icosahedron",
    "section": "",
    "text": "FV = icosahedron(r=1.0; radius=1.0, origin=(0.0, 0.0, 0.0))::GMTfv\nCreate an icosahedron mesh with radius r."
  },
  {
    "objectID": "documentation/utilities/icosahedron.html#example",
    "href": "documentation/utilities/icosahedron.html#example",
    "title": "icosahedron",
    "section": "Example",
    "text": "Example\nCreate a icosahedron using the default values.\n\nusing GMT\n\nFV = icosahedron();\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/icosahedron.html#see-also",
    "href": "documentation/utilities/icosahedron.html#see-also",
    "title": "icosahedron",
    "section": "See Also",
    "text": "See Also\ncube, cylinder, dodecahedron, octahedron, replicant, sphere, tetrahedron, torus,"
  },
  {
    "objectID": "documentation/utilities/icosahedron.html#source-code",
    "href": "documentation/utilities/icosahedron.html#source-code",
    "title": "icosahedron",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nicosahedron(; ...) - solids.jl:15\nicosahedron(r; radius, origin) - solids.jl:15"
  },
  {
    "objectID": "documentation/utilities/image_cpt.html",
    "href": "documentation/utilities/image_cpt.html",
    "title": "image_cpt!",
    "section": "",
    "text": "image_cpt!(img::GMTimage, cpt::GMTcpt, clear=false)\n\nor\n\nimage_cpt!(img::GMTimage, cpt::String, clear=false)\nAdd (or replace) a colormap to a GMTimage object from the colors in the cpt. This should have effect only if img is indexed. Use image_cpt!(img, clear=true) to remove a previously existant colormap field in img"
  },
  {
    "objectID": "documentation/utilities/image_cpt.html#see-also",
    "href": "documentation/utilities/image_cpt.html#see-also",
    "title": "image_cpt!",
    "section": "See Also",
    "text": "See Also\n[image_alpha!], ind2rgb"
  },
  {
    "objectID": "documentation/utilities/image_cpt.html#source-code",
    "href": "documentation/utilities/image_cpt.html#source-code",
    "title": "image_cpt!",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimage_cpt!(img::GMTimage; clear) - utils_types.jl:2103\nimage_cpt!(I::GMTimage, cpt::GMTcpt) - utils_types.jl:2096\nimage_cpt!(I::GMTimage, cpt::String) - utils_types.jl:2095"
  },
  {
    "objectID": "documentation/utilities/imshow.html",
    "href": "documentation/utilities/imshow.html",
    "title": "imshow",
    "section": "",
    "text": "imshow(arg1; kw...)\n\nor\n\nviz(arg1; kw...)\nkeywords: GMT, Julia, automatic visualization\nThe second form shown above means that viz is an alias of imshow.\nimshow, or viz, is a front end to the grdimage, grdview, plot and [plot3] programs that accepts GMTgrid, GMTimage, GMTdataset as well as plain matrices or strings with file names of grids or images. The normal options of the grdimage and grdview programs also apply here but some clever guessing of suitable necessary parameters is done if they are not provided. Contrary to other image producing modules the “show’ keyword is not necessary to display the image. Here it is set by default. If user wants to use imshow to create layers of a more complex fig he can use show=false for the intermediate layers.\nThis module uses an internal logic to decide whether use grdimage, grdview or plot. Namely, when the view option is used grdview is choosed and a default vertical scale is assigned. However, sometimes we want a rotated plot, optionally tilted, but not 3D view. In that case use the option flat=true, which forces the use of grdimage.\nThe kw keyword/values are used to pass options to grdimage, etc…, modules. But other than this, we can also use them to call a subset of GMT.jl modules. For example viz(..., coast=true, colorbar=true), or a full set of of coast options like imshow(..., coast=(land=:tomato, ocean=:blue, shore=0.5))."
  },
  {
    "objectID": "documentation/utilities/imshow.html#examples",
    "href": "documentation/utilities/imshow.html#examples",
    "title": "imshow",
    "section": "Examples",
    "text": "Examples\nPlot vertical shaded illuminated view of the Mexican hat\n\nusing GMT\n\nG = gmt(\"grdmath -R-15/15/-15/15 -I0.3 X Y HYPOT DUP 2 MUL PI MUL 8 DIV COS EXCH NEG 10 DIV EXP MUL =\");\nimshow(G, shade=\"+a45\")\n\n\n\n\n\n\n\n\nSame as above but add automatic contours\n\nusing GMT   # Hide\nG = gmt(\"grdmath -R-15/15/-15/15 -I0.3 X Y HYPOT DUP 2 MUL PI MUL 8 DIV COS EXCH NEG 10 DIV EXP MUL =\");    # Hide\n\nimshow(G, shade=\"+a45\", contour=true)"
  },
  {
    "objectID": "documentation/utilities/imshow.html#see-also",
    "href": "documentation/utilities/imshow.html#see-also",
    "title": "imshow",
    "section": "See Also",
    "text": "See Also\ngrdimage, grdview, plot, [plot3]"
  },
  {
    "objectID": "documentation/utilities/imshow.html#source-code",
    "href": "documentation/utilities/imshow.html#source-code",
    "title": "imshow",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimshow(arg1::Symbol; horizontal, kw...) - imshow.jl:235\nimshow(arg1::GMTcpt; horizontal, kw...) - imshow.jl:236\nimshow(arg1::GMT.Gdal.AbstractDataset; kw...) - imshow.jl:241\nimshow(x::AbstractVector{Float64}, f::String; kw...) - imshow.jl:270\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::String; kw...) - imshow.jl:269\nimshow(x::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:266\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:246\nimshow(f::Function, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:268\nimshow(f::Function, x::AbstractVector{Float64}; kw...) - imshow.jl:267\nimshow(arg1::GItype; kw...) - imshow.jl:124\nimshow(arg1; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:36"
  },
  {
    "objectID": "documentation/utilities/info.html",
    "href": "documentation/utilities/info.html",
    "title": "info",
    "section": "",
    "text": "info(GI, showdata::Bool=true; crs::Bool=false)\nShows information about the GI GMTgrid or GMTimage that includes dimensional and, if exists, referencing data.\nShows information about the D GMTdataset (or vector of them).\nRuns show(stdout, \"text/plain\", any) which prints all elements of any. Good for printing the entire vector or matrix."
  },
  {
    "objectID": "documentation/utilities/info.html#source-code",
    "href": "documentation/utilities/info.html#source-code",
    "title": "info",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ninfo(C::GMTcpt) - gmt_main.jl:1708\ninfo(D::GDtype; crs, attribs, att) - gmt_main.jl:1609\ninfo(GI::GItype; ...) - gmt_main.jl:1584\ninfo(any) - gmt_main.jl:1640\ninfo(GI::GItype, showdata::Bool; data, full, crs) - gmt_main.jl:1584"
  },
  {
    "objectID": "documentation/utilities/inwhichpolygon.html",
    "href": "documentation/utilities/inwhichpolygon.html",
    "title": "inwhichpolygon",
    "section": "",
    "text": "inwhichpolygon(D::Vector{GMTdataset}, point::Matrix{Real}; on_is_in=false)\n\nor\n\ninwhichpolygon(D::Vector{GMTdataset}, x, y; on_is_in=false)\nFinds the IDs of the polygons enclosing the query points in point. Each row in the matrix point contains the coordinates of a query point. Query points that don’t fall in any polygon get an ID = 0. Returns either an Int or a Vector{Int} depending on the number of input query points."
  },
  {
    "objectID": "documentation/utilities/inwhichpolygon.html#examples",
    "href": "documentation/utilities/inwhichpolygon.html#examples",
    "title": "inwhichpolygon",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\npts = [[1 2 3;1 2 3;1 2 3][:] [1 1 1;2 2 2; 3 3 3][:]];\nD = triplot(pts, noplot=true);\npoints = [2.4 1.2; 1.4 1.4];\nids = inwhichpolygon(points, D);\n\n# Plot the triangulation and the query points.\nplot(D)\nplot!(D[ids[1]], fill=:grey)\nplot!(D[ids[2]], fill=:green)\nplot!(points, marker=:star, ms=\"12p\", fill=:blue, show=true)"
  },
  {
    "objectID": "documentation/utilities/inwhichpolygon.html#see-also",
    "href": "documentation/utilities/inwhichpolygon.html#see-also",
    "title": "inwhichpolygon",
    "section": "See Also",
    "text": "See Also\ninpolygon, getbyattrib, plot, triplot"
  },
  {
    "objectID": "documentation/utilities/inwhichpolygon.html#source-code",
    "href": "documentation/utilities/inwhichpolygon.html#source-code",
    "title": "inwhichpolygon",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ninwhichpolygon(Dpt::Vector{&lt;:GMTdataset}, Dpol::Vector{&lt;:GMTdataset}; on_is_in, pack) - spatial_funs.jl:484\ninwhichpolygon(point::VecOrMat{&lt;:Real}, D::Vector{&lt;:GMTdataset}; on_is_in, pack) - spatial_funs.jl:462\ninwhichpolygon(D::Vector{&lt;:GMTdataset}, point::VecOrMat{&lt;:Real}; on_is_in, pack) - spatial_funs.jl:458\ninwhichpolygon(point::Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}, D::Vector{&lt;:GMTdataset}; on_is_in, pack) - spatial_funs.jl:460\ninwhichpolygon(x::Union{Real, Vector{&lt;:Real}}, y::Union{Real, Vector{&lt;:Real}}, D::Vector{&lt;:GMTdataset}; on_is_in, pack) - spatial_funs.jl:457\ninwhichpolygon(D::Vector{&lt;:GMTdataset}, x, y; on_is_in, pack) - spatial_funs.jl:456"
  },
  {
    "objectID": "documentation/utilities/isoutlier.html",
    "href": "documentation/utilities/isoutlier.html",
    "title": "isoutlier",
    "section": "",
    "text": "bv = isoutlier(x; critic=3.0, method::Symbol=:median, threshold=nothing, width=0.0) -&gt; Union{BitVector, BitMatrix}\nReturn a logical array whose elements are true when an outlier is detected in the corresponding element of x.\nIf x is a matrix, and width is not used, then isoutlier operates on each column of x separately. By default, an outlier is a value that is more than three median absolute deviations (MAD) from the median. But that can be changed via the critic option."
  },
  {
    "objectID": "documentation/utilities/isoutlier.html#examples",
    "href": "documentation/utilities/isoutlier.html#examples",
    "title": "isoutlier",
    "section": "Examples",
    "text": "Examples\nx = [57, 59, 60, 100, 59, 58, 57, 58, 300, 61, 62, 60, 62, 58, 57];\nfindall(isoutlier(x))\n2-element Vector{Int64}:\n 4\n 9\nx = -50.0:50;   y = x / 50 .+ 3 .+ 0.25 * rand(length(x));\ny[[30,50,60]] = [4,-3,6];   # Add 3 outliers\nfindall(isoutlier([x y], width=9))"
  },
  {
    "objectID": "documentation/utilities/isoutlier.html#source-code",
    "href": "documentation/utilities/isoutlier.html#source-code",
    "title": "isoutlier",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfindall(path::String, idx::LibGit2.GitIndex) - index.jl:191\nfindall(S::SparseArrays.AbstractSparseMatrixCSC) - sparsematrix.jl:1895\nfindall(D::Vector{&lt;:GMTdataset}; kw...) - spatial_funs.jl:367\nfindall(interval_d::Base.Fix2{typeof(in), &lt;:IntervalSets.Interval}, x::AbstractRange) - findall.jl:37\nfindall(p::Base.Fix2{typeof(in)}, x::SparseArrays.AbstractSparseMatrixCSC) - sparsematrix.jl:1919\nfindall(p::Base.Fix2{typeof(in)}, x::Union{SparseArrays.AbstractCompressedVector{Tv, Ti}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}}, false}} where {Tv, Ti}) - sparsevector.jl:840\nfindall(p::Function, S::SparseArrays.AbstractSparseMatrixCSC) - sparsematrix.jl:1899\nfindall(p::F, x::Union{SparseArrays.AbstractCompressedVector{Tv, Ti}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}}, false}} where {Tv, Ti}) where F&lt;:Function - sparsevector.jl:815\nfindall(x::Union{SparseArrays.AbstractCompressedVector{Tv, Ti}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}}, false}} where {Tv, Ti}) - sparsevector.jl:811"
  },
  {
    "objectID": "documentation/utilities/lazwrite.html",
    "href": "documentation/utilities/lazwrite.html",
    "title": "lazwrite",
    "section": "",
    "text": "lazwrite(FileName::AbstractString, xyz; grd_hdr=[], scaleX=nothing, scaleY=nothing, scaleZ=nothing, offX=nothing, offY=nothing, offZ=nothing)\nor\nWrite XYZ data to a LIDAR laz (laszip compressed) or las format file. The second form is used to write a GMTgrid to a laz file. This is a rather more compressed format that waht is achieved with netCDF, but slightly lossy. Use lazread or gmtread to read the laz file back into a GMTgrid."
  },
  {
    "objectID": "documentation/utilities/lazwrite.html#see-also",
    "href": "documentation/utilities/lazwrite.html#see-also",
    "title": "lazwrite",
    "section": "See Also",
    "text": "See Also\nlazread, gmtread"
  },
  {
    "objectID": "documentation/utilities/lazwrite.html#source-code",
    "href": "documentation/utilities/lazwrite.html#source-code",
    "title": "lazwrite",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlazwrite(fname::AbstractString, G::GMTgrid{Float32, 2}; scaleX, scaleY, scaleZ, offX, offY, offZ) - lazwrite.jl:24\nlazwrite(fname::AbstractString, xyz; grd_hdr, scaleX, scaleY, scaleZ, offX, offY, offZ, layout) - lazwrite.jl:30"
  },
  {
    "objectID": "documentation/utilities/lelandshade.html",
    "href": "documentation/utilities/lelandshade.html",
    "title": "lelandshade",
    "section": "",
    "text": "[I = ] lelandshade(G::GMTgrid; detail=1.0, contrast=2.0, intensity=false, zfactor=3, transparency=0.6,\n                   show=false, color=false, opts=String[], cmap=\"\", kw...)\nCompute a grayscale or color shaded illumination image using the thechnique developed by Leland Brown’s “texture shading”\nReturns a GMTimage object (8 or 16 bits depending on the intensity option) if show == false, or nothing otherwise."
  },
  {
    "objectID": "documentation/utilities/lelandshade.html#examples",
    "href": "documentation/utilities/lelandshade.html#examples",
    "title": "lelandshade",
    "section": "Examples",
    "text": "Examples\nTo make a texture shaded from a SRTM1 arc sec grid that will be downloaded from the GMT server and uses the defaults indicated above, do (it may take a little while):\n\nusing GMT\nlelandshade(gmtread(\"@earth_relief_01s\", region=(-114,-113,35,36)), color=true, colorbar=true, show=true)"
  },
  {
    "objectID": "documentation/utilities/lelandshade.html#see-also",
    "href": "documentation/utilities/lelandshade.html#see-also",
    "title": "lelandshade",
    "section": "See Also",
    "text": "See Also\n[gdaldem], makecpt, grd2cpt,"
  },
  {
    "objectID": "documentation/utilities/lelandshade.html#source-code",
    "href": "documentation/utilities/lelandshade.html#source-code",
    "title": "lelandshade",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlelandshade(G::String; detail, contrast, uint16, intensity, zfactor, transparency, color, equalize, opts, cmap, colorbar, show, kw...) - blendimg.jl:325\nlelandshade(G::GMTgrid; detail, contrast, uint16, intensity, zfactor, transparency, color, equalize, opts, cmap, colorbar, show, kw...) - blendimg.jl:330"
  },
  {
    "objectID": "documentation/utilities/listecmwfvars.html",
    "href": "documentation/utilities/listecmwfvars.html",
    "title": "listecmwfvars",
    "section": "",
    "text": "listecmwfvars(source::Symbol=:reanalysis; single::Bool=true, levlist::Bool=false, contain::AbstractString=\"\")\nPrint a list of CDS ERA5 variables."
  },
  {
    "objectID": "documentation/utilities/listecmwfvars.html#examples",
    "href": "documentation/utilities/listecmwfvars.html#examples",
    "title": "listecmwfvars",
    "section": "Examples",
    "text": "Examples\nPrint all pressure-level variables.\nlistecmwfvars(pressure=true)\nPrint only single-level variables containing “Temperature” in their name from the foorecast datasets.\nlistecmwfvars(:forecast, contain=\"Temperature\")"
  },
  {
    "objectID": "documentation/utilities/listecmwfvars.html#see-also",
    "href": "documentation/utilities/listecmwfvars.html#see-also",
    "title": "listecmwfvars",
    "section": "See Also",
    "text": "See Also\necmwf, era5time, era5vars"
  },
  {
    "objectID": "documentation/utilities/listecmwfvars.html#source-code",
    "href": "documentation/utilities/listecmwfvars.html#source-code",
    "title": "listecmwfvars",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlistecmwfvars(source::Symbol; single, pressure, contain, test) - weather.jl:651\nlistecmwfvars(; ...) - weather.jl:651"
  },
  {
    "objectID": "documentation/utilities/logo.html",
    "href": "documentation/utilities/logo.html",
    "title": "logo",
    "section": "",
    "text": "logo(cmd0::String=\"\"; kwargs...)\nPlots the GMT logo on a map. By default, the GMT logo is 5 cm wide and 2.5 cm high and will be positioned relative to the current plot origin. Use various options to change this and to place a transparent or opaque rectangular map panel behind the GMT logo."
  },
  {
    "objectID": "documentation/utilities/logo.html#parameters",
    "href": "documentation/utilities/logo.html#parameters",
    "title": "logo",
    "section": "Parameters",
    "text": "Parameters\n\npos | position | D: Sets reference point on the map for the image using one of four coordinate systems.\nbox | F: Without further options, draws a rectangular border around the GMT logo using MAP_FRAME_PEN. or map rose (T)\njulia: Create the Julia instead of the GMT logo. Provide circle diameter in centimeters\nGMTjulia: Create the GMT Julia GMT logo. Provide circle diameter in centimeters\nkwargs: keyword/arguments pairs as in plot module"
  },
  {
    "objectID": "documentation/utilities/logo.html#examples",
    "href": "documentation/utilities/logo.html#examples",
    "title": "logo",
    "section": "Examples",
    "text": "Examples\nMake a GMT Julia logo with circles of 1 cm.\n\nusing GMT\n\nlogo(GMTjulia=1, show=true)"
  },
  {
    "objectID": "documentation/utilities/logo.html#see-also",
    "href": "documentation/utilities/logo.html#see-also",
    "title": "logo",
    "section": "See Also",
    "text": "See Also\nplot"
  },
  {
    "objectID": "documentation/utilities/logo.html#source-code",
    "href": "documentation/utilities/logo.html#source-code",
    "title": "logo",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlogo(cmd0::String; first, kwargs...) - gmtlogo.jl:39\nlogo(; ...) - gmtlogo.jl:39"
  },
  {
    "objectID": "documentation/utilities/maregrams.html",
    "href": "documentation/utilities/maregrams.html",
    "title": "maregrams",
    "section": "",
    "text": "D = maregrams(list=false, code=\"\", name=\"\", days::Real=2, starttime::String=\"\", printurl=false)\nor\n\nD = maregrams(lon::Real, lat::Real; days=2, starttime::String=\"\")\nDownload maregrams data from www.ioc-sealevelmonitoring.org.\nThe default is to download the last 2 days, but length and duration is configurable by input options. Since the use of this function requires knowing the station code or name, we provide also the possibility to use coordinates to find the nearest station. The file with stations data locations and names is stored in the TESTSDIR/assets/maregs_online.csv file, which can be accessed using d = GMT.read_maregrams() and its contents are returned in the d dictionary. Note that not all stations sites are always on and running, so errors when requesting data from some stations are, unfortunately, not so uncommon.\nOur reference stations data is a bit old (needs update) and we can find more stations online listed at the www.ioc-sealevelmonitoring.org site. If user provides a station code that we don’t know about, but is a valid one, we still return the data for that station. Example: D = maregrams(code=\"tdoj\")"
  },
  {
    "objectID": "documentation/utilities/maregrams.html#source-code",
    "href": "documentation/utilities/maregrams.html#source-code",
    "title": "maregrams",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmaregrams(; list, code, name, days, starttime, printurl) - maregrams.jl:43\nmaregrams(x::Real, y::Real; days, starttime, printurl) - maregrams.jl:111"
  },
  {
    "objectID": "documentation/utilities/mat2grid.html",
    "href": "documentation/utilities/mat2grid.html",
    "title": "mat2grid",
    "section": "",
    "text": "G = mat2grid(mat; reg=nothing, x=[], y=[], v=[], hdr=nothing, proj4::String=\"\",\n             wkt::String=\"\", title::String=\"\", rem::String=\"\", cmd::String=\"\",\n             names::Vector{String}=String[], scale::Float32=1f0, offset::Float32=0f0)\nTake a 2/3D mat array and a hdr 1x9 [xmin xmax ymin ymax zmin zmax reg xinc yinc] header descriptor and return a grid GMTgrid type. Alternatively to hdr, provide a pair of vectors, x & y, with the X and Y coordinates. Optionally add a v vector with vertical coordinates if mat is a 3D array and one wants to create a cube. Optionally, the HDR arg may be omitted and it will computed from mat alone, but then x=1:ncol, y=1:nrow When hdr is not used, reg=nothing (the default) means create a gridline registration grid and reg=1, or reg=\"pixel\" a pixel registered grid.\nFor 3D arrays the names option is used to give a description for each layer (also saved to file when using a GDAL function).\nThe scale and offset options are used when mat is an Integer type and we want to save the grid with a scale/offset.\nOther methods of this function do:\nCreate Float GMTgrid with size, coordinates and increment determined by the contents of the HDR var. This array, which is now MANDATORY, has either the same meaning as above OR, alternatively, containng only [xmin xmax ymin ymax xinc yinc] val is the value that will be fill the matrix (default val = Float32(0)). To get a Float64 array use, for example, val = 1.0, Any other non Float64 will be converted to Float32. Example: mat2grid(1, hdr=[0. 5 0 5 1 1])\nWhere F is a function and X,Y the vectors coordinates defining it’s domain. Creates a Float32 GMTgrid with size determined by the sizes of the X & Y vectors."
  },
  {
    "objectID": "documentation/utilities/mat2grid.html#example",
    "href": "documentation/utilities/mat2grid.html#example",
    "title": "mat2grid",
    "section": "Example",
    "text": "Example\nf(x,y) = x^2 + y^2;\nG = mat2grid(f, x = -2:0.05:2, y = -2:0.05:2)\nThe method\nG = mat2grid(f::String, ...)\nWhere f is a pre-set function name. Currently available: - “ackley”, “eggbox”, “sombrero”, “parabola” and “rosenbrock”\nX,Y are vectors coordinates defining the function’s domain, but default values are provided for each function. creates a Float32 GMTgrid. Example: G = mat2grid(\"sombrero\")"
  },
  {
    "objectID": "documentation/utilities/mat2grid.html#see-also",
    "href": "documentation/utilities/mat2grid.html#see-also",
    "title": "mat2grid",
    "section": "See Also",
    "text": "See Also\nmat2img, mat2ds"
  },
  {
    "objectID": "documentation/utilities/meteostat.html",
    "href": "documentation/utilities/meteostat.html",
    "title": "meteostat",
    "section": "",
    "text": "D = meteostat()\nDownload the Meteostat stations list and return it as a GMTdataset.\nRetrieve weather data, obtained from the Meteostat, for the station that is closest to the given coordinates."
  },
  {
    "objectID": "documentation/utilities/meteostat.html#see-also",
    "href": "documentation/utilities/meteostat.html#see-also",
    "title": "meteostat",
    "section": "See Also",
    "text": "See Also\nweather, ecmwf"
  },
  {
    "objectID": "documentation/utilities/meteostat.html#source-code",
    "href": "documentation/utilities/meteostat.html#source-code",
    "title": "meteostat",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimshow(arg1::Symbol; horizontal, kw...) - imshow.jl:235\nimshow(arg1::GMTcpt; horizontal, kw...) - imshow.jl:236\nimshow(arg1::GMT.Gdal.AbstractDataset; kw...) - imshow.jl:241\nimshow(x::AbstractVector{Float64}, f::String; kw...) - imshow.jl:270\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::String; kw...) - imshow.jl:269\nimshow(x::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:266\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:246\nimshow(f::Function, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:268\nimshow(f::Function, x::AbstractVector{Float64}; kw...) - imshow.jl:267\nimshow(arg1::GItype; kw...) - imshow.jl:124\nimshow(arg1; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:36"
  },
  {
    "objectID": "documentation/utilities/octahedron.html",
    "href": "documentation/utilities/octahedron.html",
    "title": "octahedron",
    "section": "",
    "text": "FV = octahedron(r=1.0; radius=1.0, origin=(0.0, 0.0, 0.0))::GMTfv\nCreate an octahedron mesh with radius r."
  },
  {
    "objectID": "documentation/utilities/octahedron.html#example",
    "href": "documentation/utilities/octahedron.html#example",
    "title": "octahedron",
    "section": "Example",
    "text": "Example\nCreate a octahedron using the default values.\n\nusing GMT\n\nFV = octahedron();\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/octahedron.html#see-also",
    "href": "documentation/utilities/octahedron.html#see-also",
    "title": "octahedron",
    "section": "See Also",
    "text": "See Also\ncube, cylinder, dodecahedron, icosahedron, replicant, sphere, tetrahedron, torus,"
  },
  {
    "objectID": "documentation/utilities/octahedron.html#source-code",
    "href": "documentation/utilities/octahedron.html#source-code",
    "title": "octahedron",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\noctahedron(; ...) - solids.jl:75\noctahedron(r; radius, origin) - solids.jl:75"
  },
  {
    "objectID": "documentation/utilities/orbits.html",
    "href": "documentation/utilities/orbits.html",
    "title": "orbits",
    "section": "",
    "text": "orbits(xyz::Matrix{&lt;:Real}; first=true, radius=6371.007, height=0, lon0=0, lat0=0, show=false, kw...)\nPlots the orbit, or whatever the input data in xyz represents, about the Earth or other planetary bodies."
  },
  {
    "objectID": "documentation/utilities/orbits.html#examples",
    "href": "documentation/utilities/orbits.html#examples",
    "title": "orbits",
    "section": "Examples",
    "text": "Examples\nPlot the demo spiral.\n\nusing GMT\norbits(show=true)"
  },
  {
    "objectID": "documentation/utilities/orbits.html#see-also",
    "href": "documentation/utilities/orbits.html#see-also",
    "title": "orbits",
    "section": "See Also",
    "text": "See Also\ncoast, [plot3]"
  },
  {
    "objectID": "documentation/utilities/orbits.html#source-code",
    "href": "documentation/utilities/orbits.html#source-code",
    "title": "orbits",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\norbits(; ...) - orbits.jl:33\norbits(D::GMTdataset; radius, height, lon0, lat0, show, kw...) - orbits.jl:100\norbits(xyz::Matrix{&lt;:AbstractFloat}; first, radius, height, lon0, lat0, show, savefig, figname, name, kw...) - orbits.jl:33"
  },
  {
    "objectID": "documentation/utilities/parkermag.html",
    "href": "documentation/utilities/parkermag.html",
    "title": "parkermag",
    "section": "",
    "text": "G = parkermag(mag, bat, dir::String=\"dir\"; year=2020.0, nnx=0, nny=0, nterms=6, zobs=0.0,\n              wshort=0.0, wlong=0.0, slin=0.0, sdip=0.0, sdec=0.0, thickness=0.5, pct=30,\n              geocentric=false, padtype::String=\"taper\", isRTP=false, verbose=false)::GMTgrid\nCalculate the magnetic direct or inverse problem using Parker’s [1973] Fourier series summation approach.\nDepending on the vaule of dir it will calculate the direct or inverse problem. The direct problem calculates magnetic field given a magnetization and bathymetry. The inverse calculates magnetization from magnetic field and bathymetry.\nThis function is an adaptation of the Mirone code that itself was an adaptation of Maurice Tivey’s code MATLAB Version from 1992."
  },
  {
    "objectID": "documentation/utilities/parkermag.html#example",
    "href": "documentation/utilities/parkermag.html#example",
    "title": "parkermag",
    "section": "Example",
    "text": "Example\nA synthetic example. Make a Kaba like magnetization distribution of 10 A/m, compute the magnetic field created by it and invert this field.\n\nusing GMT, FFTW\n\nm = zeros(Float32, 64,64);  m[32:40,32:40] .= 10;\nh = fill(-2.0f0, 64,64);\nGm = mat2grid(m, hdr=[30., 30.32, 30., 30.32]);\nGh = mat2grid(h, hdr=[30., 30.32, 30., 30.32]);\nf3d = parkermag(Gm,  Gh, \"dir\", year=2000, thickness=1, pct=0);\nm3d = parkermag(f3d, Gh, \"inv\", year=2000, thickness=1, pct=0);\n\ngrdimage(f3d, figsize=6, title=\"Field (nT)\", colorbar=true)\ngrdview!(m3d, figsize=6, zsize=4, view=(210, 40), title=\"Magnetization (A/m)\", cmap=:auto, surf=:image, B=:za, xshift=8, show=true)"
  },
  {
    "objectID": "documentation/utilities/parkermag.html#see-also",
    "href": "documentation/utilities/parkermag.html#see-also",
    "title": "parkermag",
    "section": "See Also",
    "text": "See Also\nparkergrav, gravfft"
  },
  {
    "objectID": "documentation/utilities/parkermag.html#source-code",
    "href": "documentation/utilities/parkermag.html#source-code",
    "title": "parkermag",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nparkermag(x, y, z; kw...) - utils.jl:1501\nparkermag(x, y; ...) - utils.jl:1501"
  },
  {
    "objectID": "documentation/utilities/pca.html",
    "href": "documentation/utilities/pca.html",
    "title": "pca",
    "section": "",
    "text": "score, coeff, latent, explained, mu, ems = pca(X; DT::DataType=Float32, npc=0)"
  },
  {
    "objectID": "documentation/utilities/pca.html#returns",
    "href": "documentation/utilities/pca.html#returns",
    "title": "pca",
    "section": "Returns",
    "text": "Returns\n\nscore: The principal components.\ncoeff: The principal component coefficients for the matrix X. Rows of X correspond to observations and columns correspond to variables. The coefficient matrix is npc-by-n. Each column of coeff contains coefficients for one principal component, and the columns are in descending order of component variance.\nlatent: The principal component variances. (The eigenvalues of cov(X))\nexplained: The percentage of the total variance explained by each principal component.\nmu: The mean of each variable in X.\nems: The mean square error incurred in using only the npc eigenvectors corresponding to the largest eigenvalues. ems is 0 if npc = n (the default).\n\nIpca = pca(I::GMTimage; DT::DataType=Float32, npc=0) -&gt; GMTimage{UInt8}\nThis method takes a GMTimage cube, normally satellite data of UInt16 type created with the RemoteS package, and returns a GMTimage cube of UInt8 of the principal components in decreasing order of explained variance. The truecolor(Ipca) (from RemoteS) will show a false color image made of the three largest components.\nGpca = pca(G::GMTgrid; DT::DataType=Float32, npc=0) -&gt; GMTgrid{DT}\nThis method takes a GMTgrid cube and returns another grid, of type DT (Float32 by default), with principal components in decreasing order of explained variance."
  },
  {
    "objectID": "documentation/utilities/pca.html#source-code",
    "href": "documentation/utilities/pca.html#source-code",
    "title": "pca",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npca(G::GMTgrid; DT, npc) - pca.jl:140\npca(I::GMTimage; DT, npc) - pca.jl:113\npca(X::AbstractArray{T}; DT, npc) where T&lt;:Real - pca.jl:108"
  },
  {
    "objectID": "documentation/utilities/plotgrid.html",
    "href": "documentation/utilities/plotgrid.html",
    "title": "plotgrid!",
    "section": "",
    "text": "plotgrid!(GI, grid; annot=true, sides=\"WESN\", fmt=\"\", figname=\"\", show=false)\nPlot grid lines on top of an image created with the worldrectangular function."
  },
  {
    "objectID": "documentation/utilities/plotgrid.html#see-also",
    "href": "documentation/utilities/plotgrid.html#see-also",
    "title": "plotgrid!",
    "section": "See Also",
    "text": "See Also\ncoastlinesproj, graticules, worldrectangular, worldrectgrid, worldrectcoast, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/plotgrid.html#source-code",
    "href": "documentation/utilities/plotgrid.html#source-code",
    "title": "plotgrid!",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nplotgrid!(Dgrat::Vector{&lt;:GMTdataset}; kw...) - utils_project.jl:581\nplotgrid!(GI::GItype; inner, annot, sides, kw...) - utils_project.jl:554\nplotgrid!(GI::GItype, Dgrat::Vector{&lt;:GMTdataset}; annot, sides, kw...) - utils_project.jl:449"
  },
  {
    "objectID": "documentation/utilities/plotyy.html",
    "href": "documentation/utilities/plotyy.html",
    "title": "plotyy",
    "section": "",
    "text": "plotyy(arg1, arg2; kwargs...)\nExample:"
  },
  {
    "objectID": "documentation/utilities/plotyy.html#source-code",
    "href": "documentation/utilities/plotyy.html#source-code",
    "title": "plotyy",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/rasterzones.html",
    "href": "documentation/utilities/rasterzones.html",
    "title": "rasterzones!",
    "section": "",
    "text": "rasterzones!(GI::GItype, shapes::Vector{GMTdataset}, fun::Function)\nApply a unidimensional function fun to to the elements of the grid or image GI that lies inside the polygons of the GMTdataset shapes. The GI array is modified in place."
  },
  {
    "objectID": "documentation/utilities/rasterzones.html#returns",
    "href": "documentation/utilities/rasterzones.html#returns",
    "title": "rasterzones!",
    "section": "Returns",
    "text": "Returns\nIt does’t return anything but the input GI is modified."
  },
  {
    "objectID": "documentation/utilities/rasterzones.html#examples",
    "href": "documentation/utilities/rasterzones.html#examples",
    "title": "rasterzones!",
    "section": "Examples",
    "text": "Examples\nTake the Peaks grid and replace the elements that fall inside a triangle at the center by their average.\n\nusing GMT\n\nG = GMT.peaks();\nD = mat2ds([-1 -1; 0 1; 1 -1; -1 -1]);\nrasterzones!(G, D, mean)\nviz(G)"
  },
  {
    "objectID": "documentation/utilities/rasterzones.html#see-also",
    "href": "documentation/utilities/rasterzones.html#see-also",
    "title": "rasterzones!",
    "section": "See Also",
    "text": "See Also\n[colorzones!]"
  },
  {
    "objectID": "documentation/utilities/rasterzones.html#source-code",
    "href": "documentation/utilities/rasterzones.html#source-code",
    "title": "rasterzones!",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nrasterzones!(GI::GItype, shapes::GDtype, fun::Function; isRaster, touches, byfeatures, groupby) - rasterpolygonfuns.jl:48\nrasterzones!(fun::Function, GI::GItype, shapes::GDtype; isRaster, touches, byfeatures, groupby) - rasterpolygonfuns.jl:46"
  },
  {
    "objectID": "documentation/utilities/remotegrid.html",
    "href": "documentation/utilities/remotegrid.html",
    "title": "remotegrid",
    "section": "",
    "text": "remotegrid(name, res_p::String=\"\"; res::String=\"\", reg::String=\"\", info=false)\nGenerate the full name of a GMT “Remote Data Grid” convenient to use in other GMT functions that deal with grids.\nA “Remote Data Sets” set is a grid that is stored on one or more remote servers. It may be a single grid file or a collection of subset tiles making up a larger grid. They are not distributed with GMT or installed during the installation procedures. GMT offers several remote global data grids that you can access via our remote file mechanism. The first time you access one of these files, GMT will download the file (or a subset tile) from the selected GMT server and save it to the server directory under your GMT user directory [~/.gmt]. From then on we read the local file from there. See more at: GMT Remote Data Sets\nThis function lets you access the GMT “Remote Data Sets” grids via simplified syntax. Note that it won’t download the data but generates and returns the full grid name that can be used in other GMT functions (gmtread, grdimage, grdcontour, grdcut, etc…)."
  },
  {
    "objectID": "documentation/utilities/remotegrid.html#parameters",
    "href": "documentation/utilities/remotegrid.html#parameters",
    "title": "remotegrid",
    "section": "Parameters",
    "text": "Parameters\n\nname: The grid name. One of:\n\nearth_age, earth_geoid, earth_mag, earth_gebco, earth_gebcosi, earth_mask, earth_dist, earth_faa, earth_faaerror, earth_edefl, earth_ndefl, earth_mss, earth_mdt, earth_relief, earth_synbath, earth_vgg, earth_wdmam, earth_day, earth_night,\nmars_relief, mercury_relief, moon_relief, pluto_relief, venus_relief."
  },
  {
    "objectID": "documentation/utilities/remotegrid.html#keyword-arguments",
    "href": "documentation/utilities/remotegrid.html#keyword-arguments",
    "title": "remotegrid",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\nrest_p or res: Grid resolution. One of “01d”, “30m”, “20m”, “15m”, “10m”, “06m”, “05m”, “04m”, “03m” or higher for the grids that have finer resolution. Use the info option to inquiry all available resolutions of a grid. The suffix d, m, and s stand for arc-degrees, arc-minutes, and arc-seconds, respectively.\nreg: Grid registration. Choose between ’g’rid or ’p’ixel registration or leave blank for modules to picking the indicated one. By default, a gridline-registered grid is selected unless only the pixel-registered grid is available.\ninfo: Print grid information (true) or just the full grid name (false). Cannot be used with the option res.\n\nTo get only the list of available grid names, type remotegrid().\nAs sated above this function does not download any data but is a convenient helper for those who do. However, one need to be very carefull with the grid sizes. For example, the earth_relief at “15s” weights 2.6 GB … and 45 GB at “01s”. So, for those high resolution grids you should use the the region option provided by the grdcut or gmtread."
  },
  {
    "objectID": "documentation/utilities/remotegrid.html#examples",
    "href": "documentation/utilities/remotegrid.html#examples",
    "title": "remotegrid",
    "section": "Examples",
    "text": "Examples\nSee the Moon grid at “6m” resolution\n\nusing GMT\n\nG = gmtread(remotegrid(\"moon\", res=\"6m\"))\nviz(G, shade=true)\n\n\n\n\n\n\n\n\nSee a region over Oman of the “earth_relief” at “15s” resolution\n\nusing GMT\n\nG = grdcut(remotegrid(\"earth_relief\", res=\"15s\"), region=(55,60,23,28))\nviz(G, proj=:guess, shade=true, coast=true, colorbar=true)\n\n\n\n\n\n\n\n\nSee all details of the “earth_relief” grid (open the GMT site page)\n@? remotegrid(\"earth_relief\", info=true)"
  },
  {
    "objectID": "documentation/utilities/remotegrid.html#see-also",
    "href": "documentation/utilities/remotegrid.html#see-also",
    "title": "remotegrid",
    "section": "See Also",
    "text": "See Also\ngmtread, grdcut"
  },
  {
    "objectID": "documentation/utilities/remotegrid.html#source-code",
    "href": "documentation/utilities/remotegrid.html#source-code",
    "title": "remotegrid",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimshow(arg1::Symbol; horizontal, kw...) - imshow.jl:235\nimshow(arg1::GMTcpt; horizontal, kw...) - imshow.jl:236\nimshow(arg1::GMT.Gdal.AbstractDataset; kw...) - imshow.jl:241\nimshow(x::AbstractVector{Float64}, f::String; kw...) - imshow.jl:270\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::String; kw...) - imshow.jl:269\nimshow(x::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:266\nimshow(x::AbstractVector{Float64}, y::AbstractVector{Float64}, f::Function; kw...) - imshow.jl:246\nimshow(f::Function, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:268\nimshow(f::Function, x::AbstractVector{Float64}; kw...) - imshow.jl:267\nimshow(arg1::GItype; kw...) - imshow.jl:124\nimshow(arg1; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}; ...) - imshow.jl:36\nimshow(arg1, x::AbstractVector{Float64}, y::AbstractVector{Float64}; kw...) - imshow.jl:36"
  },
  {
    "objectID": "documentation/utilities/rescale.html",
    "href": "documentation/utilities/rescale.html",
    "title": "rescale",
    "section": "",
    "text": "R = rescale(A, a=0.0, b=1.0; inputmin=nothing, inputmax=nothing, stretch=false, type=nothing)"
  },
  {
    "objectID": "documentation/utilities/rescale.html#returns",
    "href": "documentation/utilities/rescale.html#returns",
    "title": "rescale",
    "section": "Returns",
    "text": "Returns\nA GMTgrid if A is a GMTgrid of floats, a GMTimage if A is a GMTimage and type is used or an array of Float32|64 otherwise."
  },
  {
    "objectID": "documentation/utilities/rescale.html#see-also",
    "href": "documentation/utilities/rescale.html#see-also",
    "title": "rescale",
    "section": "See Also",
    "text": "See Also\nimagesc"
  },
  {
    "objectID": "documentation/utilities/rescale.html#source-code",
    "href": "documentation/utilities/rescale.html#source-code",
    "title": "rescale",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nrescale(A::String; low, up, inputmin, inputmax, stretch, type) - utils.jl:703\nrescale(A::AbstractArray; low, up, inputmin, inputmax, stretch, type) - utils.jl:707"
  },
  {
    "objectID": "documentation/utilities/sealand.html",
    "href": "documentation/utilities/sealand.html",
    "title": "sealand",
    "section": "",
    "text": "sealand(f1::Function, arg1, t1::NamedTuple, f2::Function, arg2, t2::NamedTuple; kw...)\n\nand\n\nterramar(f1::Function, arg1, t1::NamedTuple, f2::Function, arg2, t2::NamedTuple; kw...)\nThe sealand/terramar pair of functions is intended to simplify the task of mapping one field (grid or image) at the ocean side and another different field (also a grid or image) over land. To achieve this result, we resort to the coast module and its ability to clip the dry and wet parts of the Earth. In the first function, sealand, we pass first the module name and the data that is going to be plotted over the oceanic areas, and second the module and data over land. The second function, terramar does the opposit.\nOther than the above options, we can pass in kw options to be consumed in the coast module and that will result in, for example, plotting the coastlines with pen color, thickness, style, etc… controls. Use it also to instruct this program to finish the figure and display it (the familiar show=true), or to save the figure under a different name/format, e.g. figname=\"blabla.pdf\"."
  },
  {
    "objectID": "documentation/utilities/sealand.html#examples",
    "href": "documentation/utilities/sealand.html#examples",
    "title": "sealand",
    "section": "Examples",
    "text": "Examples\nReproduce the GMT Illustration Gallery example 17.\n\nusing GMT\n\nCgeoid = grd2cpt(\"@india_geoid.nc\");\nCgray  = makecpt(cmap=150, range=\"-10000,10000\", nobg=true);\nsealand(grdimage, \"@india_geoid.nc\", (region=\"@india_geoid.nc\", shade=\"+d\", proj=:Merc,\n                                      cmap=Cgeoid, title=\"Clipping of Images\"),\n        grdimage, \"@india_topo.nc\", (shade=\"+d\", cmap=Cgray), shore=0.5)\ncolorbar!(pos=(inside=true, anchor=:TR, offset=(0.8,0.2), size=(10,0.5), horizontal=true),\n          cmap=Cgeoid, xaxis=(annot=5, ticks=1), ylabel=:m, shade=true, show=true)"
  },
  {
    "objectID": "documentation/utilities/sealand.html#see-also",
    "href": "documentation/utilities/sealand.html#see-also",
    "title": "sealand",
    "section": "See Also",
    "text": "See Also\ncoast, grdimage, grdview, plot"
  },
  {
    "objectID": "documentation/utilities/sealand.html#source-code",
    "href": "documentation/utilities/sealand.html#source-code",
    "title": "sealand",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/sph2cart.html",
    "href": "documentation/utilities/sph2cart.html",
    "title": "sph2cart",
    "section": "",
    "text": "x, y, z = sph2cart(az, elev, rho; deg=false)\nTransform spherical coordinates to Cartesian. Angles are in radians by default. Use deg=true if angles are in degrees. Input can be scalar, vectors or matrices."
  },
  {
    "objectID": "documentation/utilities/sph2cart.html#source-code",
    "href": "documentation/utilities/sph2cart.html#source-code",
    "title": "sph2cart",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/stackgrids.html",
    "href": "documentation/utilities/stackgrids.html",
    "title": "stackgrids",
    "section": "",
    "text": "stackgrids(names::Vector{String}, v=nothing; zcoord=nothing, zdim_name=\"time\",\n           z_unit=\"\", save=\"\", mirone=false)\nStack a bunch of single grids in a multiband cube like file."
  },
  {
    "objectID": "documentation/utilities/stackgrids.html#returns",
    "href": "documentation/utilities/stackgrids.html#returns",
    "title": "stackgrids",
    "section": "Returns",
    "text": "Returns\nA GMTgrid cube object, or nothing if the save option is used."
  },
  {
    "objectID": "documentation/utilities/stackgrids.html#see-also",
    "href": "documentation/utilities/stackgrids.html#see-also",
    "title": "stackgrids",
    "section": "See Also",
    "text": "See Also\ncubeplot, slicecube, xyzw2cube"
  },
  {
    "objectID": "documentation/utilities/stackgrids.html#source-code",
    "href": "documentation/utilities/stackgrids.html#source-code",
    "title": "stackgrids",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nstackgrids(names::Vector{String}; ...) - utils_types.jl:1915\nstackgrids(names::Vector{String}, v; zcoord, zdim_name, z_unit, save, mirone) - utils_types.jl:1915"
  },
  {
    "objectID": "documentation/utilities/streamlines.html",
    "href": "documentation/utilities/streamlines.html",
    "title": "streamlines",
    "section": "",
    "text": "S = streamlines(U::GMTgrid, V::GMTgrid, startX, startY; step=0.1, max_vert::Int=10000)\nCompute 2-D streamlines as a 2-D matrix (in fact, a GMTdataset) of vector fields. The inputs U and V are GMTgrids with the x and y velocity components, and startX and startY are the starting positions of the streamlines. step is the step size in data units for interpolating the vector data and max_vert is the maximum number of vertices in a streamline. startX and startY can both be scalars, vectors or one a scalar and the other a vector. Returns a Vector{GMTdataset} with the streamlines.\nIn this method the streamlines starting positions are fetch from the 2 columns of the D argument. Returns a Vector{GMTdataset} with the streamlines.\nMethod that computes automatically spaced streamlines from 2D grids U and V. Returns the streamlines in the S Vector{GMTdataset} and A holds the positions along the streamlines where to plot arrow-heads if wished.\nHere we auto-generate the starting positions along one of the 4 sides of the grid. Select the wished side with the side keyword. Returns a Vector{GMTdataset} with the streamlines.\nThis last 2D method let users pass the x and y vector data coordinates, U and V are matrices with the velocity data and the remaining arguments have the same meaning as in the other methods. Returns a Vector{GMTdataset} with the streamlines.\nx and y are assumed to be meshgrids with the x and y starting coordinates.\nConpute 3D volume of vector fields with streamline. Here U,V and W are 3D cubes with x,y,z velocity components. startX, startY and startZ can be scalar or vector coordinate arrays. Returns a Vector{GMTdataset} with the streamlines."
  },
  {
    "objectID": "documentation/utilities/streamlines.html#examples",
    "href": "documentation/utilities/streamlines.html#examples",
    "title": "streamlines",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\nx,y = GMT.meshgrid(-10:10);\nu = 2 .* x .* y;\nv = y .^2 - x .^ 2;\nU = mat2grid(u, x[1,:], y[:,1]);\nV = mat2grid(v, x[1,:], y[:,1]);\nr,a = streamlines(U, V);\nplot(r, decorated=(locations=a, symbol=(custom=\"arrow\", size=0.3), fill=:black, dec2=true), show=1)"
  },
  {
    "objectID": "documentation/utilities/streamlines.html#see-also",
    "href": "documentation/utilities/streamlines.html#see-also",
    "title": "streamlines",
    "section": "See Also",
    "text": "See Also\nplot, [plot3], streamlines"
  },
  {
    "objectID": "documentation/utilities/streamlines.html#source-code",
    "href": "documentation/utilities/streamlines.html#source-code",
    "title": "streamlines",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nstreamlines(x::Matrix, y::Matrix, U::Matrix, V::Matrix; step, max_vert) - streamlines.jl:57\nstreamlines(U::GMTgrid, V::GMTgrid, W::GMTgrid, sx::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, sy::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, sz::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}; step, max_vert) - streamlines.jl:231\nstreamlines(U::GMTgrid, V::GMTgrid, W::GMTgrid, startx, starty, startz; step, max_vert) - streamlines.jl:214\nstreamlines(U::GMTgrid, V::GMTgrid; side, step, max_vert, density, max_density) - streamlines.jl:65\nstreamlines(U::GMTgrid, V::GMTgrid, sx::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}, sy::Union{AbstractVector{&lt;:Real}, Matrix{&lt;:Real}}; step, max_vert) - streamlines.jl:100\nstreamlines(U::GMTgrid, V::GMTgrid, sx, sy; step, max_vert) - streamlines.jl:85\nstreamlines(U::GMTgrid, V::GMTgrid, D::GMTdataset; step, max_vert) - streamlines.jl:95\nstreamlines(U::GMTgrid, V::GMTgrid, W::GMTgrid; axis, startx, starty, startz, step, max_vert) - streamlines.jl:195\nstreamlines(x, y, U::Matrix, V::Matrix, sx, sy; step, max_vert) - streamlines.jl:52"
  },
  {
    "objectID": "documentation/utilities/tetrahedron.html",
    "href": "documentation/utilities/tetrahedron.html",
    "title": "tetrahedron",
    "section": "",
    "text": "FV = tetrahedron(r=1.0; radius=1.0, origin=(0.0, 0.0, 0.0))::GMTfv\nCreate an tetrahedron mesh with radius r."
  },
  {
    "objectID": "documentation/utilities/tetrahedron.html#example",
    "href": "documentation/utilities/tetrahedron.html#example",
    "title": "tetrahedron",
    "section": "Example",
    "text": "Example\nCreate a tetrahedron using the default values.\n\nusing GMT\n\nFV = tetrahedron();\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/tetrahedron.html#see-also",
    "href": "documentation/utilities/tetrahedron.html#see-also",
    "title": "tetrahedron",
    "section": "See Also",
    "text": "See Also\ncube, cylinder, dodecahedron, icosahedron, octahedron, replicant, sphere, torus,"
  },
  {
    "objectID": "documentation/utilities/tetrahedron.html#source-code",
    "href": "documentation/utilities/tetrahedron.html#source-code",
    "title": "tetrahedron",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntetrahedron(; ...) - solids.jl:175\ntetrahedron(r; radius, origin) - solids.jl:175"
  },
  {
    "objectID": "documentation/utilities/torus.html",
    "href": "documentation/utilities/torus.html",
    "title": "torus",
    "section": "",
    "text": "FV = torus(; r=2.0, R=5.0, center=(0.0, 0.0, 0.0), nx=100, ny=50)::GMTfv\nCreate a torus mesh with radius r."
  },
  {
    "objectID": "documentation/utilities/torus.html#example",
    "href": "documentation/utilities/torus.html#example",
    "title": "torus",
    "section": "Example",
    "text": "Example\nCreate a torus with radius = 1, and two iterations. Create a torus using the default values.\n\nusing GMT\n\nFV = torus();\nviz(FV)"
  },
  {
    "objectID": "documentation/utilities/torus.html#see-also",
    "href": "documentation/utilities/torus.html#see-also",
    "title": "torus",
    "section": "See Also",
    "text": "See Also\ncube, cylinder, dodecahedron, icosahedron, octahedron, replicant, sphere, tetrahedron"
  },
  {
    "objectID": "documentation/utilities/torus.html#source-code",
    "href": "documentation/utilities/torus.html#source-code",
    "title": "torus",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/vecangles.html",
    "href": "documentation/utilities/vecangles.html",
    "title": "vecangles",
    "section": "",
    "text": "angles, ind = vecangles(lonlat0::VecOrMat{Real}, lonlat1::Matrix{Real}; proj::String=\"\",\n                        s_srs::String=\"\", epsg::Integer=0, sorted=true)\nComputes the angles between lines taken from the central point lonlat0 and those passed in the Mx2 matrix lonlat1.\nArgs:"
  },
  {
    "objectID": "documentation/utilities/vecangles.html#source-code",
    "href": "documentation/utilities/vecangles.html#source-code",
    "title": "vecangles",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/weather.html",
    "href": "documentation/utilities/weather.html",
    "title": "weather",
    "section": "",
    "text": "[D =] weather(lon=0.0, lat=0.0; city::String=\"\", last=0, days=7, year::Int=0, starttime::Union{DateTime, String}=\"\",\n              endtime::Union{DateTime, String}=\"\", variable=\"temperature_2m\", dryrun=false, show=false, kw...)\nPlot and/or retrieve weather data obtained from the Open-Meteo API. Please consult the site for further details. You will find that there are many variables available to plot and with not so obvious names. There are also forecast and archive versions of the variables. This function tries to guess that from the variable names. That list of variable names is a bit extensive and we are not reproducing it entirely here, but given it interest for climatological reason, we do list the so called \\(daily\\) variables.\nA word of aknowledge is also due to the WeatherReport.jl project that inspired this function, that is much smaller (~25 LOC) and has no further dependencies than GMT itself."
  },
  {
    "objectID": "documentation/utilities/weather.html#source-code",
    "href": "documentation/utilities/weather.html#source-code",
    "title": "weather",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nweather(; ...) - weather.jl:45\nweather(lon, lat; city, last, days, year, starttime, endtime, variable, dryrun, debug, show, kw...) - weather.jl:45\nweather(lon; ...) - weather.jl:45"
  },
  {
    "objectID": "documentation/utilities/wmsinfo.html",
    "href": "documentation/utilities/wmsinfo.html",
    "title": "wmsinfo",
    "section": "",
    "text": "wmsinfo(server::String)\nRead the xml information from the WebMapServer service and create a WMS data type that holds the information necessary to download the data. The show method will display the contents of the WMS data type."
  },
  {
    "objectID": "documentation/utilities/wmsinfo.html#examples",
    "href": "documentation/utilities/wmsinfo.html#examples",
    "title": "wmsinfo",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\nwms = wmsinfo(\"http://tiles.maps.eox.at/wms?\")\n\nserverURL:  http://tiles.maps.eox.at/wms?\nOnlineResource: http://tiles.maps.eox.at/?\nversion:    1.1.1\nrequest:    GetMap\nlayernames: \n\n\n\n\n\n[\"osm\", \"blackmarble\", \"terrain-light_3857\", \"bluemarble_3857\", \"overlay_base_3857\", \"s2cloudless\", \"terrain\", \"overlay_bright_3857\", \"coastline_3857\", \"s2cloudless-2020_3857\", \"magnetic_graticules\", \"terrain-light\", \"overlay_base_bright\", \"overlay_base\", \"s2cloudless-2022_3857\", \"s2cloudless-2024_3857\", \"s2cloudless-2018_3857\", \"coastline\", \"s2cloudless-2020\", \"s2cloudless-2021\", \"osm_3857\", \"s2cloudless-2022\", \"s2cloudless-2023\", \"s2cloudless-2024\", \"s2cloudless_3857\", \"terrain_3857\", \"overlay_base_bright_3857\", \"hydrography\", \"graticules\", \"overlay_3857\", \"bluemarble\", \"s2cloudless-2021_3857\", \"s2cloudless-2023_3857\", \"coastline_black\", \"s2cloudless-2017_3857\", \"streets_3857\", \"overlay_bright\", \"s2cloudless-2019_3857\", \"overlay\", \"blackmarble_3857\", \"hydrography_3857\", \"s2cloudless-2017\", \"streets\", \"s2cloudless-2018\", \"s2cloudless-2019\"]\n\nlayer:  45 Layers. Use layer[k] to see the contents of layer k\n\n\nAs an option, use the form\n\nusing GMT\nwmsinfo(wms; layer=1)\n\nWMS:http://tiles.maps.eox.at/?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&LAYERS=osm&SRS=EPSG:4326&BBOX=-180,-90,180,90&FORMAT=image/jpeg&TILESIZE=256&OVERVIEWCOUNT=17&MINRESOLUTION=0.00000536441803&TILED=true\nDriver: WMS/OGC Web Map Service\nFiles: none associated\nSize is 67108864, 33554432\nCoordinate System is:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        MEMBER[\"World Geodetic System 1984 (G2296)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\nData axis to CRS axis mapping: 2,1\nOrigin = (-180.000000000000000,90.000000000000000)\nPixel Size = (0.000005364418030,-0.000005364418030)\nImage Structure Metadata:\n  INTERLEAVE=PIXEL\nCorner Coordinates:\nUpper Left  (-180.0000000,  90.0000000) (180d 0' 0.00\"W, 90d 0' 0.00\"N)\nLower Left  (-180.0000000, -90.0000000) (180d 0' 0.00\"W, 90d 0' 0.00\"S)\nUpper Right ( 180.0000000,  90.0000000) (180d 0' 0.00\"E, 90d 0' 0.00\"N)\nLower Right ( 180.0000000, -90.0000000) (180d 0' 0.00\"E, 90d 0' 0.00\"S)\nCenter      (   0.0000000,   0.0000000) (  0d 0' 0.01\"E,  0d 0' 0.01\"N)\nBand 1 Block=256x256 Type=Byte, ColorInterp=Red\n  Overviews: 33554432x16777216, 16777216x8388608, 8388608x4194304, 4194304x2097152, 2097152x1048576, 1048576x524288, 524288x262144, 262144x131072, 131072x65536, 65536x32768, 32768x16384, 16384x8192, 8192x4096, 4096x2048, 2048x1024, 1024x512, 512x256\nBand 2 Block=256x256 Type=Byte, ColorInterp=Green\n  Overviews: 33554432x16777216, 16777216x8388608, 8388608x4194304, 4194304x2097152, 2097152x1048576, 1048576x524288, 524288x262144, 262144x131072, 131072x65536, 65536x32768, 32768x16384, 16384x8192, 8192x4096, 4096x2048, 2048x1024, 1024x512, 512x256\nBand 3 Block=256x256 Type=Byte, ColorInterp=Blue\n  Overviews: 33554432x16777216, 16777216x8388608, 8388608x4194304, 4194304x2097152, 2097152x1048576, 1048576x524288, 524288x262144, 262144x131072, 131072x65536, 65536x32768, 32768x16384, 16384x8192, 8192x4096, 4096x2048, 2048x1024, 1024x512, 512x256\n\n\n\nto get further information, in particular the number of bands and sizes, of the layer number or layer name layer. wms is returned by the first form."
  },
  {
    "objectID": "documentation/utilities/wmsinfo.html#see-also",
    "href": "documentation/utilities/wmsinfo.html#see-also",
    "title": "wmsinfo",
    "section": "See Also",
    "text": "See Also\nwmsread, wmstest"
  },
  {
    "objectID": "documentation/utilities/wmsinfo.html#source-code",
    "href": "documentation/utilities/wmsinfo.html#source-code",
    "title": "wmsinfo",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nwmsinfo(wms::GMT.WMS; layer, stronly) - webmapserver.jl:86\nwmsinfo(server::String) - webmapserver.jl:42"
  },
  {
    "objectID": "documentation/utilities/wmstest.html",
    "href": "documentation/utilities/wmstest.html",
    "title": "wmstest",
    "section": "",
    "text": "wmstest(wms::WMS; layer, size::Bool=false, kwargs...)\nTest function that generates the GetMap request string or the size of the resulting image given the requested resolution. It is meant to generate first the command that gets the image/grid but not running it. Specially usefull to check that the resulting image size is not huge."
  },
  {
    "objectID": "documentation/utilities/wmstest.html#returns",
    "href": "documentation/utilities/wmstest.html#returns",
    "title": "wmstest",
    "section": "Returns",
    "text": "Returns\nEither a the GetMap request string (when size=false) or the resulting image/grid size dim_x, dim_y"
  },
  {
    "objectID": "documentation/utilities/wmstest.html#examples",
    "href": "documentation/utilities/wmstest.html#examples",
    "title": "wmstest",
    "section": "Examples",
    "text": "Examples\nusing GMT\n\nwmstest(wms, layer=34, region=(-8,39, 100000), pixelsize=100)"
  },
  {
    "objectID": "documentation/utilities/wmstest.html#see-also",
    "href": "documentation/utilities/wmstest.html#see-also",
    "title": "wmstest",
    "section": "See Also",
    "text": "See Also\nwmsinfo, wmsread"
  },
  {
    "objectID": "documentation/utilities/wmstest.html#source-code",
    "href": "documentation/utilities/wmstest.html#source-code",
    "title": "wmstest",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/worldrectcoast.html",
    "href": "documentation/utilities/worldrectcoast.html",
    "title": "worldrectcoast",
    "section": "",
    "text": "cl = worldrectcoast(proj=\"?\", res=\"crude\", coastlines=nothing, limits=Float64[])\nReturn a project coastline, at res resolution, suitable to overlain in a grid created with the worldrectangular function. Note that this function, contrary to coastlinesproj, returns coastline data that spans &gt; 360 degrees."
  },
  {
    "objectID": "documentation/utilities/worldrectcoast.html#returns",
    "href": "documentation/utilities/worldrectcoast.html#returns",
    "title": "worldrectcoast",
    "section": "Returns",
    "text": "Returns\nA Vector of GMTdataset containing the projected world GSHHG coastlines at resolution res."
  },
  {
    "objectID": "documentation/utilities/worldrectcoast.html#see-also",
    "href": "documentation/utilities/worldrectcoast.html#see-also",
    "title": "worldrectcoast",
    "section": "See Also",
    "text": "See Also\ncoastlinesproj, graticules, [plotgrid!], worldrectangular, worldrectgrid, [Best rectangular world map projection]"
  },
  {
    "objectID": "documentation/utilities/worldrectcoast.html#source-code",
    "href": "documentation/utilities/worldrectcoast.html#source-code",
    "title": "worldrectcoast",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/xyzw2cube.html",
    "href": "documentation/utilities/xyzw2cube.html",
    "title": "xyzw2cube",
    "section": "",
    "text": "xyzw2cube(fname::AbstractString; datatype::DataType=Float32, proj4::String=\"\", wkt::String=\"\",\n            epsg::Int=0, tit::String=\"\", names::Vector{String}=String[])\nConvert data table containing a cube into a GMTgrid cube. The input data must contain a completelly filled 3D matrix and the data layout is guessed from file analysis (if it fails … bad luck)."
  },
  {
    "objectID": "documentation/utilities/xyzw2cube.html#returns",
    "href": "documentation/utilities/xyzw2cube.html#returns",
    "title": "xyzw2cube",
    "section": "Returns",
    "text": "Returns\nA GMTgrid cube object."
  },
  {
    "objectID": "documentation/utilities/xyzw2cube.html#see-also",
    "href": "documentation/utilities/xyzw2cube.html#see-also",
    "title": "xyzw2cube",
    "section": "See Also",
    "text": "See Also\ncubeplot, slicecube, stackgrids"
  },
  {
    "objectID": "documentation/utilities/xyzw2cube.html#source-code",
    "href": "documentation/utilities/xyzw2cube.html#source-code",
    "title": "xyzw2cube",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nxyzw2cube(D::GMTdataset{T, N}; zcol, datatype, tit, names, varnames) where {T&lt;:Real, N} - utils_types.jl:1815\nxyzw2cube(fname::AbstractString; zcol, datatype, proj4, wkt, epsg, tit, names, varnames) - utils_types.jl:1794"
  },
  {
    "objectID": "documentation/utilities/arrows.html",
    "href": "documentation/utilities/arrows.html",
    "title": "arrows",
    "section": "",
    "text": "arrows(cmd0::String=\"\", arg1=nothing; arrow=(...), kwargs...)\nPlot an arrow field.\nWhen the keyword arrow=(...) or vector=(...) is used, the direction (in degrees counter-clockwise from horizontal) and length must be found in columns 3 and 4, and size, if not specified on the command-line, should be present in column 5. The size is the length of the vector head. Vector stem width is set by option pen or line_attrib.\nThe vecmap=(...) variation is similar to above except azimuth (in degrees east of north) should be given instead of direction. The azimuth will be mapped into an angle based on the chosen map projection. If length is not in plot units but in arbitrary user units (e.g., a rate in mm/yr) then you can use the input_col option to scale the corresponding column via the +sscale modifier.\nThe geovec=(...) or geovector=(...) keywords plot geovectors. In geovectors, azimuth (in degrees east from north) and geographical length must be found in columns 3 and 4. The size is the length of the vector head. Vector width is set by pen or line_attrib. Note: Geovector stems are drawn as thin filled polygons and hence pen attributes like dashed and dotted are not available. For allowable geographical units, see the units=() option.\nThe full arrow options list can be consulted at Vector Attributes"
  },
  {
    "objectID": "documentation/utilities/arrows.html#examples",
    "href": "documentation/utilities/arrows.html#examples",
    "title": "arrows",
    "section": "Examples",
    "text": "Examples\n\nusing GMT\n\narrows([0 8.2 0 6], limits=(-2,4,0,9), arrow=(len=2,stop=1,shape=0.5,fill=:red),\n       axis=:a, pen=\"6p\", show=true)"
  },
  {
    "objectID": "documentation/utilities/arrows.html#source-code",
    "href": "documentation/utilities/arrows.html#source-code",
    "title": "arrows",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\narrows(cmd0::String; ...) - plot.jl:1005\narrows(; ...) - plot.jl:1005\narrows(arg1; kw...) - plot.jl:1017\narrows(cmd0::String, arg1; first, kwargs...) - plot.jl:1005"
  },
  {
    "objectID": "documentation/utilities/autocov.html",
    "href": "documentation/utilities/autocov.html",
    "title": "autocov",
    "section": "",
    "text": "autocov(x, [lags]; demean=true)\nCompute the autocovariance of a vector or matrix x, optionally specifying the lags at which to compute the autocovariance. demean denotes whether the mean of x should be subtracted from x before computing the autocovariance.\nIf x is a vector, return a vector of the same length as lags. If x is a matrix, return a matrix of size (length(lags), size(x,2)), where each column in the result corresponds to a column in x.\nWhen left unspecified, the lags used are the integers from 0 to min(size(x,1)-1, 10*log10(size(x,1))).\nThe output is not normalized. See autocor for a function with normalization."
  },
  {
    "objectID": "documentation/utilities/autocov.html#source-code",
    "href": "documentation/utilities/autocov.html#source-code",
    "title": "autocov",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nautocov(x::AbstractVecOrMat{&lt;:Real}; demean) - signalcorr.jl:312\nautocov(x::AbstractMatrix{&lt;:Real}, lags::AbstractVector{&lt;:Integer}; demean) - signalcorr.jl:307\nautocov(x::AbstractVector{&lt;:Real}, lags::AbstractVector{&lt;:Integer}; demean) - signalcorr.jl:302"
  },
  {
    "objectID": "documentation/utilities/autocov.html#see-also",
    "href": "documentation/utilities/autocov.html#see-also",
    "title": "autocov",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/circfit.html",
    "href": "documentation/utilities/circfit.html",
    "title": "circfit",
    "section": "",
    "text": "xc, yc, R, err = circfit(x,y; taubin=false)\nFits a circle in the x,y plane.\nFrom FEX contribution https://www.mathworks.com/matlabcentral/fileexchange/5557-circle-fit"
  },
  {
    "objectID": "documentation/utilities/circfit.html#source-code",
    "href": "documentation/utilities/circfit.html#source-code",
    "title": "circfit",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncircfit(x, y; taubin) - circfit.jl:21\ncircfit(xy::Union{GMTdataset, Matrix{&lt;:Real}}; taubin) - circfit.jl:20"
  },
  {
    "objectID": "documentation/utilities/circfit.html#see-also",
    "href": "documentation/utilities/circfit.html#see-also",
    "title": "circfit",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/conv.html",
    "href": "documentation/utilities/conv.html",
    "title": "conv",
    "section": "",
    "text": "cv = conv(u::AbstractArray{&lt;:Number, N}, v::AbstractArray{&lt;:Number, N}; shape=:full)\nConvolution of two arrays.\nIf u,v are vectors returns the convolution of vectors u and v. If u,v are matrices returns the two-dimensional convolution of matrices A and B.\nThe keyword argument shape controls if we return the full convolution result (the default) or only the central part of the convolution, the same size as u. In the first case (for the 1D case), the length of the output is length(u) + length(v) - 1.\nWhen we are using convolution to do filtering, we are normaly interested in recieving a result that is of the same size of u. In this case, use the option shape=:same (in fact, anything different from :full will work). But if we were multiplying polynomes, then we would want all convolution terms and shape=:full (again, the default) would give us that."
  },
  {
    "objectID": "documentation/utilities/conv.html#source-code",
    "href": "documentation/utilities/conv.html#source-code",
    "title": "conv",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/conv.html#see-also",
    "href": "documentation/utilities/conv.html#see-also",
    "title": "conv",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/decorated.html",
    "href": "documentation/utilities/decorated.html",
    "title": "decorated",
    "section": "",
    "text": "decorated(;kwargs...)\nCreate decorated lines with symbols or text labels. See Line decorations for complete documentation on decoration options.\nThere are two types of decorated lines:\nBoth types are specified using the decorated=(...) keyword with a named tuple."
  },
  {
    "objectID": "documentation/utilities/decorated.html#quick-examples",
    "href": "documentation/utilities/decorated.html#quick-examples",
    "title": "decorated",
    "section": "Quick Examples",
    "text": "Quick Examples\nFront line with triangles:\ndecorated=(dist=\"2c\", symbol=:triangle, size=\"0.5c\")\nDecorated line with symbols:\ndecorated=(dist=\"5c\", symbol=:circle, size=\"0.3c\", dec2=true)\nFor complete documentation including all placement methods and formatting options, see Line decorations.\n\nfigname or savefig or name : – figname=name.png\nSave the figure with the figname=name.ext where ext chooses the figure image format."
  },
  {
    "objectID": "documentation/utilities/decorated.html#source-code",
    "href": "documentation/utilities/decorated.html#source-code",
    "title": "decorated",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndecorated(; kwargs...) - common_options.jl:3423\ndecorated(nt::NamedTuple) - common_options.jl:3422"
  },
  {
    "objectID": "documentation/utilities/earthregions.html",
    "href": "documentation/utilities/earthregions.html",
    "title": "earthregions",
    "section": "",
    "text": "[GI = ] earthregions(name=\"\"; proj=\"guess\", country=false, dataset=\"\", grid=false,\n                     res=\"\", registration=\"\", round=0, exact=false)\nearthregions plots or automatically extracts grid/image over a named geographic region. A large number of predefined regions is provided via collections, which are lists of names, their rectangular geographic boundaries and a code to access them. Users pick a region by its code(s) and choose between making a map of that region or download topo/bathymetric data (a grid or image) of that area."
  },
  {
    "objectID": "documentation/utilities/earthregions.html#examples",
    "href": "documentation/utilities/earthregions.html#examples",
    "title": "earthregions",
    "section": "Examples",
    "text": "Examples\n   earthregions(\"IHO\")                      # List the ocean regions as named by the IHO\n\n   earthregions(\"PT,ES,FR\", country=true)   # Make a map of Portugal, Spain and France regions.\n\n   G = earthregions(\"IHO31\", grid=true);    # Get a grid of the \"Sea of Azov\"\n\n   viz(G, shade=true, coast=true)           # and make a nice map.\nTo see the plots produced by these examples type: \\(@? earthregions\\)"
  },
  {
    "objectID": "documentation/utilities/earthregions.html#source-code",
    "href": "documentation/utilities/earthregions.html#source-code",
    "title": "earthregions",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nearthregions(name::String; proj, grid, dataset, res, exact, registration, country, round, show, Vd) - pscoast.jl:363\nearthregions(; ...) - pscoast.jl:363"
  },
  {
    "objectID": "documentation/utilities/fields.html",
    "href": "documentation/utilities/fields.html",
    "title": "fields",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the fields function."
  },
  {
    "objectID": "documentation/utilities/fields.html#source-code",
    "href": "documentation/utilities/fields.html#source-code",
    "title": "fields",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nfields(arg::Array) - utils.jl:938\nfields(arg) - utils.jl:937"
  },
  {
    "objectID": "documentation/utilities/fields.html#see-also",
    "href": "documentation/utilities/fields.html#see-also",
    "title": "fields",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/flipdim.html",
    "href": "documentation/utilities/flipdim.html",
    "title": "flipdim",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the flipdim function."
  },
  {
    "objectID": "documentation/utilities/flipdim.html#source-code",
    "href": "documentation/utilities/flipdim.html#source-code",
    "title": "flipdim",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/flipdim.html#see-also",
    "href": "documentation/utilities/flipdim.html#see-also",
    "title": "flipdim",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/flipud.html",
    "href": "documentation/utilities/flipud.html",
    "title": "flipud",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the flipud function."
  },
  {
    "objectID": "documentation/utilities/flipud.html#source-code",
    "href": "documentation/utilities/flipud.html#source-code",
    "title": "flipud",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nflipud(I::GMTimage) - grd_operations.jl:450\nflipud(G::GMTgrid) - grd_operations.jl:448\nflipud(A) - utils.jl:939"
  },
  {
    "objectID": "documentation/utilities/flipud.html#see-also",
    "href": "documentation/utilities/flipud.html#see-also",
    "title": "flipud",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/Gcrossjoin.html",
    "href": "documentation/utilities/Gcrossjoin.html",
    "title": "Gcrossjoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Gcrossjoin function."
  },
  {
    "objectID": "documentation/utilities/Gcrossjoin.html#source-code",
    "href": "documentation/utilities/Gcrossjoin.html#source-code",
    "title": "Gcrossjoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Gcrossjoin.html#see-also",
    "href": "documentation/utilities/Gcrossjoin.html#see-also",
    "title": "Gcrossjoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/getregion.html",
    "href": "documentation/utilities/getregion.html",
    "title": "getregion",
    "section": "",
    "text": "x_min, x_max, y_min, y_max, x_inc_or_z_min, y_inc_or_z_max = getregion(dataset; gridreg=false, sds=0, GMT=false)\nInquire the region extents of a file or GMTgrid, GMTimage, GMTdataset or GDAL dataset.\nOptions gridreg and sds are only for GDAL datasets. When input is a string (a file name) the default is to use GDAL and the region comes in ‘pixel registration’ by default. Use gridreg=true to force ‘grid registration’. Still for input as string, use GMT=true to force the result to be given by grdinfo. An unfortunate consequence of using either GMT or GDAL to inquire a file/object is that the 5th and 6th outputs (only 4 when input is a GMTdataset) have different contents. It will be either x_inc, y_inc when reading with GDAL, and z_min, z_max when reading with GMT."
  },
  {
    "objectID": "documentation/utilities/getregion.html#source-code",
    "href": "documentation/utilities/getregion.html#source-code",
    "title": "getregion",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngetregion(GD::GDtype) - gdal_utils.jl:473\ngetregion(GI::GItype) - gdal_utils.jl:472\ngetregion(input; pad, xSize, ySize, gridreg, sds, GMT) - gdal_utils.jl:486"
  },
  {
    "objectID": "documentation/utilities/getregion.html#see-also",
    "href": "documentation/utilities/getregion.html#see-also",
    "title": "getregion",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/Gleftjoin.html",
    "href": "documentation/utilities/Gleftjoin.html",
    "title": "Gleftjoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Gleftjoin function."
  },
  {
    "objectID": "documentation/utilities/Gleftjoin.html#source-code",
    "href": "documentation/utilities/Gleftjoin.html#source-code",
    "title": "Gleftjoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Gleftjoin.html#see-also",
    "href": "documentation/utilities/Gleftjoin.html#see-also",
    "title": "Gleftjoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/Grightjoin.html",
    "href": "documentation/utilities/Grightjoin.html",
    "title": "Grightjoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Grightjoin function."
  },
  {
    "objectID": "documentation/utilities/Grightjoin.html#source-code",
    "href": "documentation/utilities/Grightjoin.html#source-code",
    "title": "Grightjoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Grightjoin.html#see-also",
    "href": "documentation/utilities/Grightjoin.html#see-also",
    "title": "Grightjoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/Gsemijoin.html",
    "href": "documentation/utilities/Gsemijoin.html",
    "title": "Gsemijoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the Gsemijoin function."
  },
  {
    "objectID": "documentation/utilities/Gsemijoin.html#source-code",
    "href": "documentation/utilities/Gsemijoin.html#source-code",
    "title": "Gsemijoin",
    "section": "Source Code",
    "text": "Source Code"
  },
  {
    "objectID": "documentation/utilities/Gsemijoin.html#see-also",
    "href": "documentation/utilities/Gsemijoin.html#see-also",
    "title": "Gsemijoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/isclockwise.html",
    "href": "documentation/utilities/isclockwise.html",
    "title": "isclockwise",
    "section": "",
    "text": "isclockwise(poly::Matrix{&lt;:AbstractFloat}, view=(0.0,0.0,1.0)) -&gt; Bool\nReturn true if the 2D/3D poly is clockwise when seen from the view direction."
  },
  {
    "objectID": "documentation/utilities/isclockwise.html#source-code",
    "href": "documentation/utilities/isclockwise.html#source-code",
    "title": "isclockwise",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nisclockwise(poly::Matrix{&lt;:AbstractFloat}, view) - utils.jl:1239\nisclockwise(poly::Matrix{&lt;:AbstractFloat}) - utils.jl:1239"
  },
  {
    "objectID": "documentation/utilities/isclockwise.html#see-also",
    "href": "documentation/utilities/isclockwise.html#see-also",
    "title": "isclockwise",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/kmeans.html",
    "href": "documentation/utilities/kmeans.html",
    "title": "kmeans",
    "section": "",
    "text": "Ik = kmeans(I::GMTimage, k=5; seeds=nothing, maxiter=100, tol=1e-7, V=false) -&gt; GMTimage\nCompute a k-means clustering on an RGB image I. It produces a fixed number of clusters, each associated with a center, and each RGB color is assigned to a cluster with the nearest center.\nThis method accepts a M-by-d matrix or a \\(GMTdataset\\) where columns represent the data points and rows the d-dimensional data point."
  },
  {
    "objectID": "documentation/utilities/kmeans.html#source-code",
    "href": "documentation/utilities/kmeans.html#source-code",
    "title": "kmeans",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nkmeans(X::Union{GMTdataset, Matrix{&lt;:Real}}, k; seeds, maxiter, tol, raw, V) - pca.jl:222\nkmeans(X::Union{GMTdataset, Matrix{&lt;:Real}}; ...) - pca.jl:222\nkmeans(I::GMTimage, k; seeds, maxiter, tol, V) - pca.jl:207\nkmeans(I::GMTimage; ...) - pca.jl:207"
  },
  {
    "objectID": "documentation/utilities/kmeans.html#see-also",
    "href": "documentation/utilities/kmeans.html#see-also",
    "title": "kmeans",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/laswrite.html",
    "href": "documentation/utilities/laswrite.html",
    "title": "laswrite",
    "section": "",
    "text": "lazwrite(FileName::AbstractString, xyz; grd_hdr=[], scaleX=nothing, scaleY=nothing, scaleZ=nothing, offX=nothing, offY=nothing, offZ=nothing)\nor\nWrite XYZ data to a LIDAR laz (laszip compressed) or las format file. The second form is used to write a GMTgrid to a laz file. This is a rather more compressed format that waht is achieved with netCDF, but slightly lossy. Use lazread to read the laz file back into a GMTgrid."
  },
  {
    "objectID": "documentation/utilities/laswrite.html#source-code",
    "href": "documentation/utilities/laswrite.html#source-code",
    "title": "laswrite",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlazwrite(fname::AbstractString, G::GMTgrid{Float32, 2}; scaleX, scaleY, scaleZ, offX, offY, offZ) - lazwrite.jl:24\nlazwrite(fname::AbstractString, xyz; grd_hdr, scaleX, scaleY, scaleZ, offX, offY, offZ, layout) - lazwrite.jl:30"
  },
  {
    "objectID": "documentation/utilities/laswrite.html#see-also",
    "href": "documentation/utilities/laswrite.html#see-also",
    "title": "laswrite",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/linspace.html",
    "href": "documentation/utilities/linspace.html",
    "title": "linspace",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the linspace function."
  },
  {
    "objectID": "documentation/utilities/linspace.html#source-code",
    "href": "documentation/utilities/linspace.html#source-code",
    "title": "linspace",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlinspace(start, stop, length) - utils.jl:935\nlinspace(start, stop) - utils.jl:935"
  },
  {
    "objectID": "documentation/utilities/linspace.html#see-also",
    "href": "documentation/utilities/linspace.html#see-also",
    "title": "linspace",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/lowess.html",
    "href": "documentation/utilities/lowess.html",
    "title": "lowess",
    "section": "",
    "text": "lowess(x, y, span = 2 / 3, nsteps = 3, delta = 0.01 * (maximum(x) - minimum(x)))\nCompute the smooth of a scatterplot of y against x using robust locally weighted regression. Input vectors x and y must contain either integers or floats. Parameters span and delta must be of type T, where T &lt;: AbstractFloat. Returns a vector ys; ys[i] is the fitted value at x[i]. To get the smooth plot, ys must be plotted against x."
  },
  {
    "objectID": "documentation/utilities/lowess.html#source-code",
    "href": "documentation/utilities/lowess.html#source-code",
    "title": "lowess",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nlowess(x::AbstractVector{T}, y::AbstractVector{T}; span, nsteps, delta) where T&lt;:AbstractFloat - lowess.jl:49\nlowess(mat::Matrix{&lt;:Real}; span, nsteps, delta) - lowess.jl:43\nlowess(x::AbstractVector{R}, y::AbstractVector{S}; span, nsteps, delta) where {R&lt;:Real, S&lt;:Real} - lowess.jl:38\nlowess(D::GMTdataset; span, nsteps, delta) - lowess.jl:31"
  },
  {
    "objectID": "documentation/utilities/lowess.html#see-also",
    "href": "documentation/utilities/lowess.html#see-also",
    "title": "lowess",
    "section": "See Also",
    "text": "See Also\nwhittaker, hampel\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/makeDCWs.html",
    "href": "documentation/utilities/makeDCWs.html",
    "title": "makeDCWs",
    "section": "",
    "text": "makeDCWs(fname; float=false, name_cdl=\"xxxx.cdl\", name_nc=\"\", compress=true,\n         attrib=\"\", fix_RU::Bool=false, deltmp=true)\nConvert the contents of the OGR file fname into a NetCDF CDL or NC file with the structure of the GMT DCW format. So far, only administrative level 0 polygons (the country borders) are supported."
  },
  {
    "objectID": "documentation/utilities/makeDCWs.html#source-code",
    "href": "documentation/utilities/makeDCWs.html#source-code",
    "title": "makeDCWs",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmakeDCWs(; ...) - makeDCWs.jl:59\nmakeDCWs(fname; float, name_cdl, name_nc, compress, attrib, fix_RU, deltmp) - makeDCWs.jl:59"
  },
  {
    "objectID": "documentation/utilities/makeDCWs.html#see-also",
    "href": "documentation/utilities/makeDCWs.html#see-also",
    "title": "makeDCWs",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mbgetdata.html",
    "href": "documentation/utilities/mbgetdata.html",
    "title": "mbgetdata",
    "section": "",
    "text": "mbgetdata(cmd0::String=\"\"; kwargs...)\nExtract bathymetry, sidescan or amplitude data from datafiles."
  },
  {
    "objectID": "documentation/utilities/mbgetdata.html#parameters",
    "href": "documentation/utilities/mbgetdata.html#parameters",
    "title": "mbgetdata",
    "section": "Parameters",
    "text": "Parameters\n\nA | flagged :: [Type =&gt; Number] \\(Arg = value\\)\nReplace flagged beans with NaN. Use -A to assign a constant value to the flagged beans.\nJ | proj | projection :: [Type =&gt; String]\nSelect map projection. Defaults to 15x10 cm with linear (non-projected) maps.\nC | datatype | data_type :: [Type =&gt; Number | Str | Tuple] \\(Arg = 0 or \"a\"\\)\nOutput SideScan, or amplitude, instead of bathymetry. This case ignores A\nD | scaling :: [Type =&gt; Str | Tuple] \\(Arg = &lt;mode&gt;/&lt;ampscale&gt;/&lt;ampmin&gt;/&lt;ampmax&gt;\\)\nSets scaling of beam amplitude or sidescan pixel values which can be applied before plotting.\nF | format :: [Type =&gt; Int]\nSets the format for the input swath sonar data using MBIO integer format identifiers.\nS | speed :: [Type =&gt; Number]\nSets the parameters controlng simulated illumination of bathymetry.\nT | timegap :: [Type =&gt; number]\nSets the maximum time gap in minutes between adjacent pings before being considered a gap.\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr.\nn | interp | interpolation :: [Type =&gt; Str] \\(Arg = [b|c|l|n][+a][+bBC][+c][+tthreshold]\\)\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation, l for bilinear interpolation, or n for nearest-neighbor value.\nt | alpha | transparency :: [Type =&gt; Str] \\(Arg = transp\\)\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque]."
  },
  {
    "objectID": "documentation/utilities/mbgetdata.html#source-code",
    "href": "documentation/utilities/mbgetdata.html#source-code",
    "title": "mbgetdata",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmbgetdata(cmd0::String; kwargs...) - mbgetdata.jl:33\nmbgetdata(; ...) - mbgetdata.jl:33"
  },
  {
    "objectID": "documentation/utilities/mbgetdata.html#see-also",
    "href": "documentation/utilities/mbgetdata.html#see-also",
    "title": "mbgetdata",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/mblevitus.html",
    "href": "documentation/utilities/mblevitus.html",
    "title": "mblevitus",
    "section": "",
    "text": "mblevitus(cmd0::String=\"\"; kwargs...)\nCreate a water velocity profile which is representative of the mean annual water column for a specified 1 degree by 1 degree region."
  },
  {
    "objectID": "documentation/utilities/mblevitus.html#parameters",
    "href": "documentation/utilities/mblevitus.html#parameters",
    "title": "mblevitus",
    "section": "Parameters",
    "text": "Parameters\n\nA | all4 :: [Type =&gt; Bool]\nPint also depth, velocity, temperature, salinity.\nL | location :: [Type =&gt; Str | Tuple] \\(Arg = lon/lat\\)\nSets the longitude and latitude of the location of the water velocity profile.\nO | outfile | out_file :: [Type =&gt; Str]\nWrite the SVP to .\nH | help :: [Type =&gt; Bool]\nPrint out program’s description.\nz | z_down :: [Type =&gt; Bool]\nMakes Z axes positive down (default here is Z-up).\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr."
  },
  {
    "objectID": "documentation/utilities/mblevitus.html#source-code",
    "href": "documentation/utilities/mblevitus.html#source-code",
    "title": "mblevitus",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmblevitus(cmd0::String; kwargs...) - mblevitus.jl:27\nmblevitus(; ...) - mblevitus.jl:27"
  },
  {
    "objectID": "documentation/utilities/mblevitus.html#see-also",
    "href": "documentation/utilities/mblevitus.html#see-also",
    "title": "mblevitus",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/meshgrid.html",
    "href": "documentation/utilities/meshgrid.html",
    "title": "meshgrid",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the meshgrid function."
  },
  {
    "objectID": "documentation/utilities/meshgrid.html#source-code",
    "href": "documentation/utilities/meshgrid.html#source-code",
    "title": "meshgrid",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nmeshgrid(vx::AbstractVector{T}, vy::AbstractVector{T}, vz::AbstractVector{T}) where T - utils.jl:509\nmeshgrid(vx::AbstractVector{T}, vy::AbstractVector{T}) where T - utils.jl:503\nmeshgrid(v::AbstractVector) - utils.jl:502"
  },
  {
    "objectID": "documentation/utilities/meshgrid.html#see-also",
    "href": "documentation/utilities/meshgrid.html#see-also",
    "title": "meshgrid",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/nanmean.html",
    "href": "documentation/utilities/nanmean.html",
    "title": "nanmean",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the nanmean function."
  },
  {
    "objectID": "documentation/utilities/nanmean.html#source-code",
    "href": "documentation/utilities/nanmean.html#source-code",
    "title": "nanmean",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nnanmean(x, y) - utils.jl:325\nnanmean(x) - utils.jl:324"
  },
  {
    "objectID": "documentation/utilities/nanmean.html#see-also",
    "href": "documentation/utilities/nanmean.html#see-also",
    "title": "nanmean",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/okada.html",
    "href": "documentation/utilities/okada.html",
    "title": "okada",
    "section": "",
    "text": "Gdef = okada(G::GMTgrid; kw...)"
  },
  {
    "objectID": "documentation/utilities/okada.html#source-code",
    "href": "documentation/utilities/okada.html#source-code",
    "title": "okada",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nokada(x::Vector{Float64}, y::Vector{Float64}; kw...) - okada.jl:173\nokada(G::GMTgrid; kw...) - okada.jl:89"
  },
  {
    "objectID": "documentation/utilities/okada.html#see-also",
    "href": "documentation/utilities/okada.html#see-also",
    "title": "okada",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/piechart.html",
    "href": "documentation/utilities/piechart.html",
    "title": "piechart",
    "section": "",
    "text": "piechart(x::VecOrMat; kw...)\nCreate a pie chart of the values in the vector data x.\nEach slice has a label indicating its size as a percentage of the whole pie or a label provided by the user."
  },
  {
    "objectID": "documentation/utilities/piechart.html#source-code",
    "href": "documentation/utilities/piechart.html#source-code",
    "title": "piechart",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/polyfit.html",
    "href": "documentation/utilities/polyfit.html",
    "title": "polyfit",
    "section": "",
    "text": "p = polyfit(x, y, n=length(x)-1; xscale=1)\nReturns the coefficients for a polynomial p(x) of degree n that is the least-squares best fit for the data in y. The coefficients in p are in ascending powers, and the length of p is n+1.\nThe xscale parameter is useful when needing to get coeficients in different x units. For example when converting months or seconds into years."
  },
  {
    "objectID": "documentation/utilities/polyfit.html#source-code",
    "href": "documentation/utilities/polyfit.html#source-code",
    "title": "polyfit",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npolyfit(x, y, n::Int64; xscale) - utils.jl:999\npolyfit(D::GMTdataset, n::Int64; xscale) - utils.jl:998\npolyfit(x, y; ...) - utils.jl:999\npolyfit(D::GMTdataset; ...) - utils.jl:998"
  },
  {
    "objectID": "documentation/utilities/polyfit.html#see-also",
    "href": "documentation/utilities/polyfit.html#see-also",
    "title": "polyfit",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/pow.html",
    "href": "documentation/utilities/pow.html",
    "title": "pow",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the pow function."
  },
  {
    "objectID": "documentation/utilities/pow.html#source-code",
    "href": "documentation/utilities/pow.html#source-code",
    "title": "pow",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/pow.html#see-also",
    "href": "documentation/utilities/pow.html#see-also",
    "title": "pow",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/quadbounds.html",
    "href": "documentation/utilities/quadbounds.html",
    "title": "quadbounds",
    "section": "",
    "text": "Dtiles, zoomL = quadbounds(quadtree; geog=true, quadkey=['0' '1'; '2' '3'])\nCompute the coordinates of the quadtree quadtree. Either a single quadtree string or an array of quadtree strings."
  },
  {
    "objectID": "documentation/utilities/quadbounds.html#source-code",
    "href": "documentation/utilities/quadbounds.html#source-code",
    "title": "quadbounds",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nquadbounds(quadtree::Matrix{String}; geog, quadkey) - imgtiles.jl:691\nquadbounds(quadtree::String; geog, quadkey) - imgtiles.jl:690"
  },
  {
    "objectID": "documentation/utilities/quadbounds.html#see-also",
    "href": "documentation/utilities/quadbounds.html#see-also",
    "title": "quadbounds",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/quiver.html",
    "href": "documentation/utilities/quiver.html",
    "title": "quiver",
    "section": "",
    "text": "grdvector(arg1, arg2, kwargs...)\nTakes two 2-D grid files which represents the x- and y-components of a vector field and produces a vector field plot by drawing vectors with orientation and length according to the information in the files. Alternatively, polar coordinate r, theta grids may be given instead.\nSee full GMT docs at grdvector"
  },
  {
    "objectID": "documentation/utilities/quiver.html#parameters",
    "href": "documentation/utilities/quiver.html#parameters",
    "title": "quiver",
    "section": "Parameters",
    "text": "Parameters\n\nA | polar :: [Type =&gt; Bool]\nThe grid contain polar (r, theta) components instead of Cartesian (x, y) [Default is Cartesian components].\nB | frame | axis | xaxis yaxis:: [Type =&gt; Str]\nSet map boundary frame and axes attributes.\nC | color | colormap | cmap | colorscale :: [Type =&gt; Str] \\(Arg = [cpt |master[+izinc] |color1,color2[,*color3*,…]]\\)\nGive a CPT name or specify -Ccolor1,color2[,color3,…] to build a linear continuous CPT from those colors automatically.\nG | fill :: [Type =&gt; Str | Number]\nSets color or shade for vector interiors [Default is no fill].\nI | inc | increment | spacing :: [Type =&gt; Sytr | Number] \\(Arg=[x]dx[/dy]\\)\nOnly plot vectors at nodes every xinc, yinc apart (must be multiples of original grid spacing).\nmaxlen :: [Type =&gt; Number]\nSet the maximum length in plot units that an arrow will have. By default it’s equal to fig width / 20.\n\nThis option is ignored if **inc** is set.\n\nN | noclip | no_clip :: [Type =&gt; Bool]\nDo NOT clip symbols that fall outside map border\nQ | vec | vector | arrow :: [Type =&gt; Str]\nModify vector parameters. For vector heads, append vector head size [Default is 0, i.e., stick-plot].\nP | portrait :: [Type =&gt; Bool or []]\nTell GMT to NOT draw in portrait mode (that is, make a Landscape plot)\nR | region | limits :: [Type =&gt; Str or list or GMTgrid|image] \\(Arg = (xmin,xmax,ymin,ymax)\\)\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.\nS | vscale | vec_scale :: [Type =&gt; Str | Number] \\(Arg = [i|l]scale[unit]\\)\nSets scale for vector plot length in data units per plot distance measurement unit [1].\nT | sign_scale :: [Type =&gt; Bool]\nMeans the azimuths of Cartesian data sets should be adjusted according to the signs of the scales in the x- and y-directions [Leave alone].\nU | time_stamp | timestamp :: [Type =&gt; Str or Bool or []] \\(Arg = [[just]/dx/dy/][c|label]\\)\nDraw GMT time stamp logo on plot.\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr.\nW | pen :: [Type =&gt; Str | Number]\nSets the attributes for the particular line.\nX | x_offset | xshift :: [Type =&gt; Str] \\(Arg = [a|c|f|r][x-shift[u]]\\)\nY | y_offset | yshift :: [Type =&gt; Str] \\(Arg = [a|c|f|r][y-shift[u]]\\)\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally append the length unit (c, i, or p).\nZ | azimuth :: [Type =&gt; Bool]\nThe theta grid provided contains azimuths rather than directions (implies -A).\nV | verbose :: [Type =&gt; Bool or Str] \\(Arg = [level]\\)\nSelect verbosity level, which will send progress reports to stderr.\nf | geog | colinfo | coltypes | coltype :: [Type =&gt; Str] \\(Arg = [i|o]colinfo\\)\nSpecify the data types of input and/or output columns (time or geographical data).\n\nTo see the full documentation type: \\(@? grdvector\\)"
  },
  {
    "objectID": "documentation/utilities/quiver.html#source-code",
    "href": "documentation/utilities/quiver.html#source-code",
    "title": "quiver",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngrdvector(arg1::Matrix{&lt;:Real}, arg2::Matrix{&lt;:Real}; kw...) - grdvector.jl:186\ngrdvector(arg1, arg2; first, kwargs...) - grdvector.jl:58\ngrdvector(arg1::Matrix{&lt;:Real}, arg2::Matrix{&lt;:Real}, arg3::Matrix{&lt;:Real}, arg4::Matrix{&lt;:Real}; kw...) - grdvector.jl:188"
  },
  {
    "objectID": "documentation/utilities/randinpolygon.html",
    "href": "documentation/utilities/randinpolygon.html",
    "title": "randinpolygon",
    "section": "",
    "text": "D = randinpolygon(Din; density=0.1, np::Int=0)\nGenerate random samples inside polygons. The method used here is that of poin-in-polygon. That is, we generate random points inside a rectangular BoundingBox of each polygon and retain those inside the polygon. For geographical polygons we generate random angles but do NOT connect the polygon sides with great circles, so solution is not really geographic but the error is rather small if the polygon vertices are close to each other."
  },
  {
    "objectID": "documentation/utilities/randinpolygon.html#source-code",
    "href": "documentation/utilities/randinpolygon.html#source-code",
    "title": "randinpolygon",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nrandinpolygon(Din::GDtype; density, np) - spatial_funs.jl:561\nrandinpolygon(mat::Matrix{&lt;:AbstractFloat}; density, np) - spatial_funs.jl:560"
  },
  {
    "objectID": "documentation/utilities/randinpolygon.html#see-also",
    "href": "documentation/utilities/randinpolygon.html#see-also",
    "title": "randinpolygon",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/rotate.html",
    "href": "documentation/utilities/rotate.html",
    "title": "rotate",
    "section": "",
    "text": "FV = rotate(FV::GMTfv, a=Float64[]; rx=0.0, ry=0.0, rz=0.0) -&gt; GMTfv\nRotate the FacesVertices FV by the Euler angles (in degrees) rx, ry and rz.\nThe insitu version rotate!() does it in-place. Note: We set the bfculling value to false because after rotations surfaces are not guaranteed to be CCW."
  },
  {
    "objectID": "documentation/utilities/rotate.html#source-code",
    "href": "documentation/utilities/rotate.html#source-code",
    "title": "rotate",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nrotate(FV::GMTfv, a; rx, ry, rz, insitu) - grd_operations.jl:470\nrotate(FV::GMTfv; ...) - grd_operations.jl:470"
  },
  {
    "objectID": "documentation/utilities/rotate.html#see-also",
    "href": "documentation/utilities/rotate.html#see-also",
    "title": "rotate",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/seismicity.html",
    "href": "documentation/utilities/seismicity.html",
    "title": "seismicity",
    "section": "",
    "text": "seismicity(starttime=\"\", endtime=\"\", minmagnitude=3, mindepth=0, maxdepth=0, last=0, year=0, printurl=false, show=true, kw...)\nMake automatic maps of of world-wide seismicity obtained from the USGS Earthquake Hazards Program page at https://earthquake.usgs.gov"
  },
  {
    "objectID": "documentation/utilities/seismicity.html#source-code",
    "href": "documentation/utilities/seismicity.html#source-code",
    "title": "seismicity",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/spatialjoin.html",
    "href": "documentation/utilities/spatialjoin.html",
    "title": "spatialjoin",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the spatialjoin function."
  },
  {
    "objectID": "documentation/utilities/spatialjoin.html#source-code",
    "href": "documentation/utilities/spatialjoin.html#source-code",
    "title": "spatialjoin",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/spatialjoin.html#see-also",
    "href": "documentation/utilities/spatialjoin.html#see-also",
    "title": "spatialjoin",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/squeeze.html",
    "href": "documentation/utilities/squeeze.html",
    "title": "squeeze",
    "section": "",
    "text": "Gs = squeeze(G::GMTgrid) -&gt; GMTgrid\nRemove singleton dimension from a grid. So far only for vertical slices of 3D grids."
  },
  {
    "objectID": "documentation/utilities/squeeze.html#source-code",
    "href": "documentation/utilities/squeeze.html#source-code",
    "title": "squeeze",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/squeeze.html#see-also",
    "href": "documentation/utilities/squeeze.html#see-also",
    "title": "squeeze",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/tern2cart.html",
    "href": "documentation/utilities/tern2cart.html",
    "title": "tern2cart",
    "section": "",
    "text": "tern2cart(abcz::Matrix{&lt;:Real}, reverse::Bool=false)\nConverts ternary to cartesian units.\nabcz is either a Mx3 (a,b,c) or Mx4 (a,b,c,z) matrix"
  },
  {
    "objectID": "documentation/utilities/tern2cart.html#source-code",
    "href": "documentation/utilities/tern2cart.html#source-code",
    "title": "tern2cart",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntern2cart(abcz::Matrix{&lt;:Real}, reverse::Bool) - plot.jl:1744\ntern2cart(abcz::Matrix{&lt;:Real}) - plot.jl:1744"
  },
  {
    "objectID": "documentation/utilities/tern2cart.html#see-also",
    "href": "documentation/utilities/tern2cart.html#see-also",
    "title": "tern2cart",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/texture_img.html",
    "href": "documentation/utilities/texture_img.html",
    "title": "texture_img",
    "section": "",
    "text": "texture_img(G::GMTgrid; detail=1.0, contrast=2.0, intensity=false)\nCompute the Texture Shading calling functions from the software from Leland Brown at http://www.textureshading.com/Home.html"
  },
  {
    "objectID": "documentation/utilities/texture_img.html#source-code",
    "href": "documentation/utilities/texture_img.html#source-code",
    "title": "texture_img",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/texture_img.html#see-also",
    "href": "documentation/utilities/texture_img.html#see-also",
    "title": "texture_img",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/toc.html",
    "href": "documentation/utilities/toc.html",
    "title": "toc",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the toc function."
  },
  {
    "objectID": "documentation/utilities/toc.html#source-code",
    "href": "documentation/utilities/toc.html#source-code",
    "title": "toc",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntoc() - utils.jl:565\ntoc(V) - utils.jl:565"
  },
  {
    "objectID": "documentation/utilities/toc.html#see-also",
    "href": "documentation/utilities/toc.html#see-also",
    "title": "toc",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/translate.html",
    "href": "documentation/utilities/translate.html",
    "title": "translate",
    "section": "",
    "text": "FV = translate(FV::GMTfv; dx=0.0, dy=0.0, dz=0.0) -&gt; GMTfv\nTranslate the FacesVertices object by dx, dy and dz.\nThe insitu version translate!() does it in-place."
  },
  {
    "objectID": "documentation/utilities/translate.html#source-code",
    "href": "documentation/utilities/translate.html#source-code",
    "title": "translate",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/translate.html#see-also",
    "href": "documentation/utilities/translate.html#see-also",
    "title": "translate",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/upGMT.html",
    "href": "documentation/utilities/upGMT.html",
    "title": "upGMT",
    "section": "",
    "text": "upGMT(up=false)\nCheck if a new GMT (C binaries) version is available. If yes, use upGMT(true) to update it."
  },
  {
    "objectID": "documentation/utilities/upGMT.html#source-code",
    "href": "documentation/utilities/upGMT.html#source-code",
    "title": "upGMT",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nupGMT(up::Bool, auto::Bool) - gmt_main.jl:1512\nupGMT(up::Bool) - gmt_main.jl:1512\nupGMT() - gmt_main.jl:1512"
  },
  {
    "objectID": "documentation/utilities/upGMT.html#see-also",
    "href": "documentation/utilities/upGMT.html#see-also",
    "title": "upGMT",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/vizpdf.html",
    "href": "documentation/utilities/vizpdf.html",
    "title": "vizpdf",
    "section": "",
    "text": "Category: Utilities\nDocumentation for the vizpdf function."
  },
  {
    "objectID": "documentation/utilities/vizpdf.html#source-code",
    "href": "documentation/utilities/vizpdf.html#source-code",
    "title": "vizpdf",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/utilities/vizpdf.html#see-also",
    "href": "documentation/utilities/vizpdf.html#see-also",
    "title": "vizpdf",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/whittaker.html",
    "href": "documentation/utilities/whittaker.html",
    "title": "whittaker",
    "section": "",
    "text": "Dout = whittaker(D::GMTdataset, lambda, d=2; weights=nothing)\nor\nPerform a Whittaker-Henderson smoothing and interpolation."
  },
  {
    "objectID": "documentation/utilities/whittaker.html#source-code",
    "href": "documentation/utilities/whittaker.html#source-code",
    "title": "whittaker",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nwhittaker(x::AbstractVecOrMat{&lt;:Real}, y::AbstractVecOrMat{&lt;:Real}, lambda::Real; ...) - whittaker.jl:62\nwhittaker(D::GMTdataset, lambda::Real, d::Int64; weights) - whittaker.jl:45\nwhittaker(y::AbstractVecOrMat{&lt;:Real}, lambda, d; weights, checkedNaN) - whittaker.jl:86\nwhittaker(D::GMTdataset, lambda::Real; ...) - whittaker.jl:45\nwhittaker(y::AbstractVecOrMat{&lt;:Real}, lambda; ...) - whittaker.jl:86\nwhittaker(x::AbstractVecOrMat{&lt;:Real}, y::AbstractVecOrMat{&lt;:Real}, lambda::Real, d::Int64; weights, checkedNaN) - whittaker.jl:62"
  },
  {
    "objectID": "documentation/utilities/whittaker.html#see-also",
    "href": "documentation/utilities/whittaker.html#see-also",
    "title": "whittaker",
    "section": "See Also",
    "text": "See Also\nlowess, hampel\nAlphabetical Function List"
  },
  {
    "objectID": "documentation/utilities/xcov.html",
    "href": "documentation/utilities/xcov.html",
    "title": "xcov",
    "section": "",
    "text": "xcov(x, y, [lags]; demean=true)\nCompute the cross covariance function (CCF) between real-valued vectors or matrices x and y, optionally specifying the lags. demean specifies whether the respective means of x and y should be subtracted from them before computing their CCF.\nIf both x and y are vectors, return a vector of the same length as lags. Otherwise, compute cross covariances between each pairs of columns in x and y."
  },
  {
    "objectID": "documentation/utilities/xcov.html#source-code",
    "href": "documentation/utilities/xcov.html#source-code",
    "title": "xcov",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nxcov(x::AbstractMatrix{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:129\nxcov(x::AbstractVector{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:123\nxcov(x::AbstractVecOrMat{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:120\nxcov(x::AbstractMatrix{&lt;:Real}, y::AbstractMatrix{&lt;:Real}; lags, demean, maxlags) - signalcorr.jl:103\nxcov(x::AbstractVector{&lt;:Real}, y::AbstractMatrix{&lt;:Real}; lags, demean, maxlags) - signalcorr.jl:97\nxcov(x::AbstractMatrix{&lt;:Real}, y::AbstractVector{&lt;:Real}; lags, demean, maxlags) - signalcorr.jl:91\nxcov(x::AbstractVector{&lt;:Real}, y::AbstractVector{&lt;:Real}; demean, lags, maxlags) - signalcorr.jl:85"
  },
  {
    "objectID": "documentation/utilities/xcov.html#see-also",
    "href": "documentation/utilities/xcov.html#see-also",
    "title": "xcov",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/utilities/zonal_statistics.html",
    "href": "documentation/utilities/zonal_statistics.html",
    "title": "zonal_statistics",
    "section": "",
    "text": "zonal_statistics(GI::GItype, shapes::GDtype, fun::Function; touches=false, byfeatures=false, groupby=\"\")\nor\nor zonal_stats(...)\nCompute the statistics of fun applied to the elements of the grid or image GI that lie inside the polygons of the GMTdataset shapes."
  },
  {
    "objectID": "documentation/utilities/zonal_statistics.html#source-code",
    "href": "documentation/utilities/zonal_statistics.html#source-code",
    "title": "zonal_statistics",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nzonal_statistics(GI::GItype, shapes::GDtype, fun::Function; touches, byfeatures, groupby) - rasterpolygonfuns.jl:192\nzonal_statistics(fun::Function, GI::GItype, shapes::GDtype; touches, byfeatures, groupby) - rasterpolygonfuns.jl:190"
  },
  {
    "objectID": "documentation/utilities/zonal_statistics.html#see-also",
    "href": "documentation/utilities/zonal_statistics.html#see-also",
    "title": "zonal_statistics",
    "section": "See Also",
    "text": "See Also\n\nAlphabetical Function List\nGMT.jl Documentation"
  },
  {
    "objectID": "documentation/gdalfuns.html",
    "href": "documentation/gdalfuns.html",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "Functions for working with geospatial data using GDAL/OGR capabilities.\n\n\n\ngdaltranslate - Convert raster data between different formats\ngdalwarp - Image reprojection and warping\ngdaldem - Tools to analyze and visualize DEMs\nogr2ogr - Convert vector data between file formats\n\n\n\n\n\narccircle - Create circular arcs\narcellipse - Create elliptical arcs\nboundary - Compute geometry boundary\nbuffer - Create buffer around geometry\nbuffergeo - Geographic buffer operations\ncentroid - Compute centroid of geometry\ncircgeo - Geographic circles\nconcavehull - Compute concave hull\nconvexhull - Compute convex hull\ndelaunay - Delaunay triangulation\nenvelope - Compute bounding envelope\nenvelope3d - Compute 3D bounding envelope\npolygonize - Convert raster to polygons\npolyunion - Union of polygons\nsimplify - Simplify geometry\n\n\n\n\n\ncontains - Test if geometry contains another\ncrosses - Test if geometries cross\ndisjoint - Test if geometries are disjoint\nequals - Test if geometries are equal\nintersects - Test if geometries intersect\noverlaps - Test if geometries overlap\ntouches - Test if geometries touch\nwithin - Test if geometry is within another\n\n\n\n\n\ndistance - Compute distance between geometries\ngeodesicarea - Compute geodesic area\ngeomarea - Compute geometry area\ngeomlength - Compute geometry length\n\n\n\n\n\ngeod - Geodesic calculations\ngeodesic - Geodesic line operations\ninvgeod - Inverse geodesic calculations\nloxodrome - Loxodrome (rhumb line) calculations\nloxodrome_direct - Direct loxodrome problem\nloxodrome_inverse - Inverse loxodrome problem\n\n\n\n\n\nepsg2proj - Convert EPSG code to PROJ string\nepsg2wkt - Convert EPSG code to WKT\nlonlat2xy - Convert lon/lat to projected coordinates\nproj2wkt - Convert PROJ string to WKT\nsetproj! - Set projection for data\nwkt2proj - Convert WKT to PROJ string\nxy2lonlat - Convert projected coordinates to lon/lat\n\n\n\n\n\ndifference - Compute difference of geometries\nintersection - Compute intersection of geometries\nsymdifference - Compute symmetric difference\n\n\n\n\n\ndither - Apply dithering to image\nfillnodata - Fill nodata values in raster\n\n\n\n\n\ngd2gmt - Convert GDAL dataset to GMT object\ngdalshade - Create shaded relief\ngdalread - Read geospatial data with GDAL\ngdalwrite - Write geospatial data with GDAL\ngmt2gd - Convert GMT object to GDAL dataset\n\n\n\n\n\npointalongline - Get point at distance along line"
  },
  {
    "objectID": "documentation/gdalfuns.html#core-gdal-tools",
    "href": "documentation/gdalfuns.html#core-gdal-tools",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "gdaltranslate - Convert raster data between different formats\ngdalwarp - Image reprojection and warping\ngdaldem - Tools to analyze and visualize DEMs\nogr2ogr - Convert vector data between file formats"
  },
  {
    "objectID": "documentation/gdalfuns.html#geometric-operations",
    "href": "documentation/gdalfuns.html#geometric-operations",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "arccircle - Create circular arcs\narcellipse - Create elliptical arcs\nboundary - Compute geometry boundary\nbuffer - Create buffer around geometry\nbuffergeo - Geographic buffer operations\ncentroid - Compute centroid of geometry\ncircgeo - Geographic circles\nconcavehull - Compute concave hull\nconvexhull - Compute convex hull\ndelaunay - Delaunay triangulation\nenvelope - Compute bounding envelope\nenvelope3d - Compute 3D bounding envelope\npolygonize - Convert raster to polygons\npolyunion - Union of polygons\nsimplify - Simplify geometry"
  },
  {
    "objectID": "documentation/gdalfuns.html#spatial-relationships",
    "href": "documentation/gdalfuns.html#spatial-relationships",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "contains - Test if geometry contains another\ncrosses - Test if geometries cross\ndisjoint - Test if geometries are disjoint\nequals - Test if geometries are equal\nintersects - Test if geometries intersect\noverlaps - Test if geometries overlap\ntouches - Test if geometries touch\nwithin - Test if geometry is within another"
  },
  {
    "objectID": "documentation/gdalfuns.html#distance-area-calculations",
    "href": "documentation/gdalfuns.html#distance-area-calculations",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "distance - Compute distance between geometries\ngeodesicarea - Compute geodesic area\ngeomarea - Compute geometry area\ngeomlength - Compute geometry length"
  },
  {
    "objectID": "documentation/gdalfuns.html#geodetic-operations",
    "href": "documentation/gdalfuns.html#geodetic-operations",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "geod - Geodesic calculations\ngeodesic - Geodesic line operations\ninvgeod - Inverse geodesic calculations\nloxodrome - Loxodrome (rhumb line) calculations\nloxodrome_direct - Direct loxodrome problem\nloxodrome_inverse - Inverse loxodrome problem"
  },
  {
    "objectID": "documentation/gdalfuns.html#projection-coordinate-functions",
    "href": "documentation/gdalfuns.html#projection-coordinate-functions",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "epsg2proj - Convert EPSG code to PROJ string\nepsg2wkt - Convert EPSG code to WKT\nlonlat2xy - Convert lon/lat to projected coordinates\nproj2wkt - Convert PROJ string to WKT\nsetproj! - Set projection for data\nwkt2proj - Convert WKT to PROJ string\nxy2lonlat - Convert projected coordinates to lon/lat"
  },
  {
    "objectID": "documentation/gdalfuns.html#set-operations",
    "href": "documentation/gdalfuns.html#set-operations",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "difference - Compute difference of geometries\nintersection - Compute intersection of geometries\nsymdifference - Compute symmetric difference"
  },
  {
    "objectID": "documentation/gdalfuns.html#data-processing",
    "href": "documentation/gdalfuns.html#data-processing",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "dither - Apply dithering to image\nfillnodata - Fill nodata values in raster"
  },
  {
    "objectID": "documentation/gdalfuns.html#gmt-integration",
    "href": "documentation/gdalfuns.html#gmt-integration",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "gd2gmt - Convert GDAL dataset to GMT object\ngdalshade - Create shaded relief\ngdalread - Read geospatial data with GDAL\ngdalwrite - Write geospatial data with GDAL\ngmt2gd - Convert GMT object to GDAL dataset"
  },
  {
    "objectID": "documentation/gdalfuns.html#miscellaneous",
    "href": "documentation/gdalfuns.html#miscellaneous",
    "title": "GDAL Utility Functions",
    "section": "",
    "text": "pointalongline - Get point at distance along line"
  },
  {
    "objectID": "documentation/gdalfuns/arcellipse.html",
    "href": "documentation/gdalfuns/arcellipse.html",
    "title": "arcellipse",
    "section": "",
    "text": "arcellipse(x0, y0, primary_radius, secondary_radius, start_angle, end_angle; rotation=0, z0=0, inc=2, gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/arcellipse.html#source-code",
    "href": "documentation/gdalfuns/arcellipse.html#source-code",
    "title": "arcellipse",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/gdalfuns/buffer.html",
    "href": "documentation/gdalfuns/buffer.html",
    "title": "buffer",
    "section": "",
    "text": "buffer(geom, dist::Real, quadsegs::Integer=30; gdataset=false)\nCompute buffer of a geometry."
  },
  {
    "objectID": "documentation/gdalfuns/buffer.html#source-code",
    "href": "documentation/gdalfuns/buffer.html#source-code",
    "title": "buffer",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbuffer(D::AbstractArray, dist::Real, quadsegs::Integer; gdataset) - gdal_extensions.jl:66\nbuffer(D::AbstractArray, dist::Real; ...) - gdal_extensions.jl:66\nbuffer(geom::GMT.Gdal.AbstractGeometry, dist::Real, quadsegs::Integer) - gdal_extensions.jl:65\nbuffer(geom::GMT.Gdal.AbstractGeometry, dist::Real) - gdal_extensions.jl:65"
  },
  {
    "objectID": "documentation/gdalfuns/centroid.html",
    "href": "documentation/gdalfuns/centroid.html",
    "title": "centroid",
    "section": "",
    "text": "centroid(geom; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/centroid.html#source-code",
    "href": "documentation/gdalfuns/centroid.html#source-code",
    "title": "centroid",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ncentroid(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:94\ncentroid(D; gdataset) - gdal_extensions.jl:99"
  },
  {
    "objectID": "documentation/gdalfuns/concavehull.html",
    "href": "documentation/gdalfuns/concavehull.html",
    "title": "concavehull",
    "section": "",
    "text": "concavehull(geom, ratio, allow_holes::Bool=true; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/concavehull.html#source-code",
    "href": "documentation/gdalfuns/concavehull.html#source-code",
    "title": "concavehull",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nconcavehull(geom::GMT.Gdal.AbstractGeometry, ratio, holes::Bool) - gdal_extensions.jl:468\nconcavehull(D, ratio, holes::Bool; gdataset) - gdal_extensions.jl:469\nconcavehull(geom::GMT.Gdal.AbstractGeometry, ratio) - gdal_extensions.jl:468\nconcavehull(D, ratio; ...) - gdal_extensions.jl:469"
  },
  {
    "objectID": "documentation/gdalfuns/convexhull.html",
    "href": "documentation/gdalfuns/convexhull.html",
    "title": "convexhull",
    "section": "",
    "text": "convexhull(geom; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/convexhull.html#source-code",
    "href": "documentation/gdalfuns/convexhull.html#source-code",
    "title": "convexhull",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nconvexhull(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:452\nconvexhull(D; gdataset) - gdal_extensions.jl:453"
  },
  {
    "objectID": "documentation/gdalfuns/delaunay.html",
    "href": "documentation/gdalfuns/delaunay.html",
    "title": "delaunay",
    "section": "",
    "text": "delaunay(geom::AbstractGeometry, tol::Real=0, onlyedges::Bool=true; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/delaunay.html#source-code",
    "href": "documentation/gdalfuns/delaunay.html#source-code",
    "title": "delaunay",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndelaunaytriangulation(D; ...) - gdal_extensions.jl:306\ndelaunaytriangulation(geom::GMT.Gdal.AbstractGeometry, tol::Real, edges::Bool) - gdal_extensions.jl:305\ndelaunaytriangulation(D, tol::Real, edges::Bool; gdataset) - gdal_extensions.jl:306\ndelaunaytriangulation(D, tol::Real; ...) - gdal_extensions.jl:306"
  },
  {
    "objectID": "documentation/gdalfuns/disjoint.html",
    "href": "documentation/gdalfuns/disjoint.html",
    "title": "disjoint",
    "section": "",
    "text": "disjoint(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/disjoint.html#source-code",
    "href": "documentation/gdalfuns/disjoint.html#source-code",
    "title": "disjoint",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndisjoint(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:354\ndisjoint(D1, D2) - gdal_extensions.jl:355"
  },
  {
    "objectID": "documentation/gdalfuns/dither.html",
    "href": "documentation/gdalfuns/dither.html",
    "title": "dither",
    "section": "",
    "text": "dither(indata; n_colors=256, save=““, gdataset=false)\nConvert a 24bit RGB image to 8bit paletted. - Use the save=fname option to save the result to disk in a GeoTiff file fname. If fname has no extension a .tif one will be appended. Alternatively give file names with extension .png or .nc to save the file in one of those formats. - gdataset=true: to return a GDAL dataset. The default is to return a GMTimage object. - n_colors: Select the number of colors in the generated color table. Defaults to 256."
  },
  {
    "objectID": "documentation/gdalfuns/dither.html#source-code",
    "href": "documentation/gdalfuns/dither.html#source-code",
    "title": "dither",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ndither(indata, opts; n_colors, save, gdataset) - gdal_tools.jl:569\ndither(indata; ...) - gdal_tools.jl:569"
  },
  {
    "objectID": "documentation/gdalfuns/envelope3d.html",
    "href": "documentation/gdalfuns/envelope3d.html",
    "title": "envelope3d",
    "section": "",
    "text": "envelope3d(geom)"
  },
  {
    "objectID": "documentation/gdalfuns/envelope3d.html#source-code",
    "href": "documentation/gdalfuns/envelope3d.html#source-code",
    "title": "envelope3d",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nenvelope3d(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:266\nenvelope3d(D) - gdal_extensions.jl:271"
  },
  {
    "objectID": "documentation/gdalfuns/epsg2wkt.html",
    "href": "documentation/gdalfuns/epsg2wkt.html",
    "title": "epsg2wkt",
    "section": "",
    "text": "epsg2wkt(code::Integer, pretty::Bool=false)\nConvert a EPSG code into the WKT form. Use pretty=true to return a more human readable text."
  },
  {
    "objectID": "documentation/gdalfuns/epsg2wkt.html#source-code",
    "href": "documentation/gdalfuns/epsg2wkt.html#source-code",
    "title": "epsg2wkt",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/gdalfuns/fillnodata.html",
    "href": "documentation/gdalfuns/fillnodata.html",
    "title": "fillnodata!",
    "section": "",
    "text": "gdaltranslate(indata, options=String[]; dest=“/vsimem/tmp”, kwargs…)\nConvert raster data between different formats.\nOperations provided by the GDAL ‘gdal_translate’ tool. Namely sub-region extraction and resampling. The kwargs options accept the GMT region (-R), increment (-I), target SRS (-J). Any of the keywords outgrid, outfile or save = outputname options to make this function save the result on a file designated by ‘outputname’. The file format is picked from the ‘outputname’ file extension. When no output file name is provided it returns a GMT object (either a grid or an image, depending on the input type). To force the return of a GDAL dataset use the option gdataset=true."
  },
  {
    "objectID": "documentation/gdalfuns/fillnodata.html#source-code",
    "href": "documentation/gdalfuns/fillnodata.html#source-code",
    "title": "fillnodata!",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/gdalfuns/gdaldem.html",
    "href": "documentation/gdalfuns/gdaldem.html",
    "title": "gdaldem",
    "section": "",
    "text": "gdaldem(dataset, method, options=String[]; dest=\"/vsimem/tmp\", color=name|GMTcpt, kw...)\nTools to analyze and visualize DEMs."
  },
  {
    "objectID": "documentation/gdalfuns/gdaldem.html#source-code",
    "href": "documentation/gdalfuns/gdaldem.html#source-code",
    "title": "gdaldem",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngdaldem(ds::GMT.Gdal.IDataset, processing::String, opts::Vector{String}; dest, gdataset, colorfile) - gdal.jl:1663\ngdaldem(ds::GMT.Gdal.IDataset, processing::String; ...) - gdal.jl:1663\ngdaldem(dataset::GMT.Gdal.Dataset, processing::String, options::Vector{String}; dest, gdataset, colorfile, save) - gdal.jl:1649\ngdaldem(dataset::GMT.Gdal.Dataset, processing::String; ...) - gdal.jl:1649\ngdaldem(indata, method::String, opts::Vector{String}; dest, kwargs...) - gdal_tools.jl:248\ngdaldem(indata, method::String; ...) - gdal_tools.jl:248"
  },
  {
    "objectID": "documentation/gdalfuns/gdalshade.html",
    "href": "documentation/gdalfuns/gdalshade.html",
    "title": "gdalshade",
    "section": "",
    "text": "gdalshade(filename; kwargs…)\nCreate a shaded relief with the GDAL method (color image blended with shaded intensity).\nExample: I = gdalshade(“hawaii_south.grd”, C=“faa.cpt”, zfactor=4);"
  },
  {
    "objectID": "documentation/gdalfuns/gdalshade.html#source-code",
    "href": "documentation/gdalfuns/gdalshade.html#source-code",
    "title": "gdalshade",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/gdalfuns/gdalwarp.html",
    "href": "documentation/gdalfuns/gdalwarp.html",
    "title": "gdalwarp",
    "section": "",
    "text": "gdaltranslate(indata, options=String[]; dest=“/vsimem/tmp”, kwargs…)\nConvert raster data between different formats.\nOperations provided by the GDAL ‘gdal_translate’ tool. Namely sub-region extraction and resampling. The kwargs options accept the GMT region (-R), increment (-I), target SRS (-J). Any of the keywords outgrid, outfile or save = outputname options to make this function save the result on a file designated by ‘outputname’. The file format is picked from the ‘outputname’ file extension. When no output file name is provided it returns a GMT object (either a grid or an image, depending on the input type). To force the return of a GDAL dataset use the option gdataset=true."
  },
  {
    "objectID": "documentation/gdalfuns/gdalwarp.html#source-code",
    "href": "documentation/gdalfuns/gdalwarp.html#source-code",
    "title": "gdalwarp",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngdalwarp(datasets::Vector{GMT.Gdal.Dataset}; ...) - gdal.jl:1594\ngdalwarp(datasets::Vector{GMT.Gdal.Dataset}, options; dest, gdataset, save) - gdal.jl:1594\ngdalwarp(ds::GMT.Gdal.IDataset; ...) - gdal.jl:1606\ngdalwarp(ds::GMT.Gdal.IDataset, opts; dest, gdataset) - gdal.jl:1606\ngdalwarp(ds::GMT.Gdal.Dataset; ...) - gdal.jl:1605\ngdalwarp(ds::GMT.Gdal.Dataset, opts; dest, gdataset) - gdal.jl:1605\ngdalwarp(indata, opts; dest, kwargs...) - gdal_tools.jl:52\ngdalwarp(indata; ...) - gdal_tools.jl:52"
  },
  {
    "objectID": "documentation/gdalfuns/geod.html",
    "href": "documentation/gdalfuns/geod.html",
    "title": "geod",
    "section": "",
    "text": "dest, azim = geod(lonlat, azim, distance; proj::String=\"\", s_srs::String=\"\", epsg::Integer=0, dataset=false, unit=:m)\nSolve the direct geodesic problem.\nArgs:\nThe distance argument can be a scalar, a Vector, a Vector{Vector} or an AbstractRange. The azimuth can be a scalar or a Vector.\nWhen azimuth is a Vector we always return a GMTdataset with the multiple lines. Use this together with a non-scalar distance to get lines with multiple points along the line. The number of points along line does not need to be the same. For data, give the distance as a Vector{Vector} where each element of distance is a vector with the distances of the points along a line. In this case the number of distance elements must be equal to the number of azimuth."
  },
  {
    "objectID": "documentation/gdalfuns/geod.html#example",
    "href": "documentation/gdalfuns/geod.html#example",
    "title": "geod",
    "section": "Example",
    "text": "Example\nCompute two lines starting at (0,0) with lengths 111100 & 50000, heading at 15 and 45 degrees.\ndest, = geod([0., 0], [15., 45], [[0, 10000, 50000, 111100.], [0., 50000]])[1]"
  },
  {
    "objectID": "documentation/gdalfuns/geod.html#source-code",
    "href": "documentation/gdalfuns/geod.html#source-code",
    "title": "geod",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngeod(lonlat::Matrix{&lt;:Real}, azim, distance; proj, s_srs, epsg, dataset, unit, backward) - proj_utils.jl:80\ngeod(lonlat::Vector{&lt;:Real}, azim, distance; proj, s_srs, epsg, dataset, unit, backward) - proj_utils.jl:76"
  },
  {
    "objectID": "documentation/gdalfuns/geodesicarea.html",
    "href": "documentation/gdalfuns/geodesicarea.html",
    "title": "geodesicarea",
    "section": "",
    "text": "geodesicarea(geom)\nCompute geometry area, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry. The returned area will always be in square meters, and assumes that polygon edges describe geodesic lines on the ellipsoid. If the geometry’ SRS is not a geographic one, geometries are reprojected to the underlying geographic SRS of the geometry’ SRS."
  },
  {
    "objectID": "documentation/gdalfuns/geodesicarea.html#source-code",
    "href": "documentation/gdalfuns/geodesicarea.html#source-code",
    "title": "geodesicarea",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngeodesicarea(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:226\ngeodesicarea(D) - gdal_extensions.jl:227"
  },
  {
    "objectID": "documentation/gdalfuns/geomlength.html",
    "href": "documentation/gdalfuns/geomlength.html",
    "title": "geomlength",
    "section": "",
    "text": "geomlength(geom)"
  },
  {
    "objectID": "documentation/gdalfuns/geomlength.html#source-code",
    "href": "documentation/gdalfuns/geomlength.html#source-code",
    "title": "geomlength",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ngeomlength(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:238\ngeomlength(D) - gdal_extensions.jl:239"
  },
  {
    "objectID": "documentation/gdalfuns/intersection.html",
    "href": "documentation/gdalfuns/intersection.html",
    "title": "intersection",
    "section": "",
    "text": "intersection(geom1, geom2; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/intersection.html#source-code",
    "href": "documentation/gdalfuns/intersection.html#source-code",
    "title": "intersection",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nintersection(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:127\nintersection(D1, D2; gdataset) - gdal_extensions.jl:128"
  },
  {
    "objectID": "documentation/gdalfuns/invgeod.html",
    "href": "documentation/gdalfuns/invgeod.html",
    "title": "invgeod",
    "section": "",
    "text": "dist, az1, az2 = invgeod(lonlat1::Vector{&lt;:Real}, lonlat2::Vector{&lt;:Real}; proj::String=““, s_srs::String=”“, epsg::Integer=0, backward=false)\nSolve the inverse geodesic problem.\nArgs:"
  },
  {
    "objectID": "documentation/gdalfuns/invgeod.html#section",
    "href": "documentation/gdalfuns/invgeod.html#section",
    "title": "invgeod",
    "section": "————————————————————————————————-",
    "text": "————————————————————————————————-"
  },
  {
    "objectID": "documentation/gdalfuns/invgeod.html#source-code",
    "href": "documentation/gdalfuns/invgeod.html#source-code",
    "title": "invgeod",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ninvgeod(lonlat1::Matrix{&lt;:Real}, lonlat2::Matrix{&lt;:Real}; proj, s_srs, epsg, backward) - proj_utils.jl:148\ninvgeod(lonlat1::Vector{&lt;:Real}, lonlat2::Vector{&lt;:Real}; proj, s_srs, epsg, backward) - proj_utils.jl:145"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome.html",
    "href": "documentation/gdalfuns/loxodrome.html",
    "title": "loxodrome",
    "section": "",
    "text": "function loxodrome(lon1,lat1,lon2,lat2; step=0, unit=:m, np=0, proj::String=““, epsg::Integer=0) or\nGenerate a loxodrome (rhumb line) on an ellipsoid. Input data can be two or more points. In later case each line segment is descretized at step increments,"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome.html#example-compute-an-loxodrome-between-points-00-and-3050-discretized-at-100-km-steps.",
    "href": "documentation/gdalfuns/loxodrome.html#example-compute-an-loxodrome-between-points-00-and-3050-discretized-at-100-km-steps.",
    "title": "loxodrome",
    "section": "Example: Compute an loxodrome between points (0,0) and (30,50) discretized at 100 km steps.",
    "text": "Example: Compute an loxodrome between points (0,0) and (30,50) discretized at 100 km steps.\nloxo = loxodrome([0 0; 30 50], step=100, unit=:k);"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome.html#source-code",
    "href": "documentation/gdalfuns/loxodrome.html#source-code",
    "title": "loxodrome",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nloxodrome(line::Matrix{&lt;:Real}; step, np, unit, proj, epsg) - proj_utils.jl:568\nloxodrome(D::GMTdataset; step, unit, np, proj, epsg) - proj_utils.jl:564\nloxodrome(lon1::Real, lat1::Real, lon2::Real, lat2::Real; step, unit, np, proj, epsg) - proj_utils.jl:561"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome_inverse.html",
    "href": "documentation/gdalfuns/loxodrome_inverse.html",
    "title": "loxodrome_inverse",
    "section": "",
    "text": "function loxodrome_inverse(lon1, lat1, lon2, lat2, a=6378137.0, f=0.0033528106647474805)\nCompute the inverse problem of a loxodrome on the ellipsoid.\nGiven latitudes and longitudes of P1 and P2 on the ellipsoid, compute the azimuth a12 of the loxodrome P1P2, the arc length s along the loxodrome curve.\nArgs:"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome_inverse.html#example",
    "href": "documentation/gdalfuns/loxodrome_inverse.html#example",
    "title": "loxodrome_inverse",
    "section": "Example",
    "text": "Example\nCompute the distance and azimuth beyween points (0,0) and (5,5)\ndist, azim = loxodrome_inverse(0,0,5,5)"
  },
  {
    "objectID": "documentation/gdalfuns/loxodrome_inverse.html#source-code",
    "href": "documentation/gdalfuns/loxodrome_inverse.html#source-code",
    "title": "loxodrome_inverse",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nloxodrome_inverse(lon1, lat1, lon2, lat2, a, f) - loxodromics.jl:25\nloxodrome_inverse(lon1, lat1, lon2, lat2, a) - loxodromics.jl:25\nloxodrome_inverse(lon1, lat1, lon2, lat2) - loxodromics.jl:25"
  },
  {
    "objectID": "documentation/gdalfuns/overlaps.html",
    "href": "documentation/gdalfuns/overlaps.html",
    "title": "overlaps",
    "section": "",
    "text": "overlaps(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/overlaps.html#source-code",
    "href": "documentation/gdalfuns/overlaps.html#source-code",
    "title": "overlaps",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\noverlaps(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:419\noverlaps(D1, D2) - gdal_extensions.jl:420"
  },
  {
    "objectID": "documentation/gdalfuns/polygonize.html",
    "href": "documentation/gdalfuns/polygonize.html",
    "title": "polygonize",
    "section": "",
    "text": "polygonize(geom; gdataset=false)"
  },
  {
    "objectID": "documentation/gdalfuns/polygonize.html#source-code",
    "href": "documentation/gdalfuns/polygonize.html#source-code",
    "title": "polygonize",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\npolygonize(data::String; kwargs...) - gdal_tools.jl:176\npolygonize(data::GItype; gdataset, kwargs...) - gdal_tools.jl:130\npolygonize(geom::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:565\npolygonize(D; gdataset) - gdal_extensions.jl:566"
  },
  {
    "objectID": "documentation/gdalfuns/proj2wkt.html",
    "href": "documentation/gdalfuns/proj2wkt.html",
    "title": "proj2wkt",
    "section": "",
    "text": "proj2wkt(proj4_str::String, pretty::Bool=false)\nConvert a PROJ4 string into the WKT form. Use pretty=true to return a more human readable text."
  },
  {
    "objectID": "documentation/gdalfuns/proj2wkt.html#source-code",
    "href": "documentation/gdalfuns/proj2wkt.html#source-code",
    "title": "proj2wkt",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/gdalfuns/simplify.html",
    "href": "documentation/gdalfuns/simplify.html",
    "title": "simplify",
    "section": "",
    "text": "simplify(geom::AbstractGeometry, tol::Real; gdataset=false)\nCompute a simplified geometry."
  },
  {
    "objectID": "documentation/gdalfuns/simplify.html#source-code",
    "href": "documentation/gdalfuns/simplify.html#source-code",
    "title": "simplify",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nsimplify(geom::GMT.Gdal.AbstractGeometry, tol::Real) - gdal_extensions.jl:286\nsimplify(D, tol::Real; gdataset) - gdal_extensions.jl:287"
  },
  {
    "objectID": "documentation/gdalfuns/touches.html",
    "href": "documentation/gdalfuns/touches.html",
    "title": "touches",
    "section": "",
    "text": "touches(geom1, geom2)"
  },
  {
    "objectID": "documentation/gdalfuns/touches.html#source-code",
    "href": "documentation/gdalfuns/touches.html#source-code",
    "title": "touches",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\ntouches(g1::GMT.Gdal.AbstractGeometry, g2::GMT.Gdal.AbstractGeometry) - gdal_extensions.jl:367\ntouches(D1, D2) - gdal_extensions.jl:368"
  },
  {
    "objectID": "documentation/gdalfuns/wkt2proj.html",
    "href": "documentation/gdalfuns/wkt2proj.html",
    "title": "wkt2proj",
    "section": "",
    "text": "wkt2proj(wkt_str::String)\nConvert a WKT SRS string into the PROJ4 form."
  },
  {
    "objectID": "documentation/gdalfuns/wkt2proj.html#source-code",
    "href": "documentation/gdalfuns/wkt2proj.html#source-code",
    "title": "wkt2proj",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/solids.html",
    "href": "documentation/solids.html",
    "title": "3D Solids Functions",
    "section": "",
    "text": "Functions for creating, manipulating, and visualizing 3D geometric solids and mesh structures."
  },
  {
    "objectID": "documentation/solids.html#basic-3d-shapes",
    "href": "documentation/solids.html#basic-3d-shapes",
    "title": "3D Solids Functions",
    "section": "Basic 3D Shapes",
    "text": "Basic 3D Shapes\n\ncube - Create a 3D cube\ncylinder - Create a 3D cylinder\nsphere - Create a 3D sphere\ntorus - Create a 3D torus\nellipse3D - Create a 3D ellipse"
  },
  {
    "objectID": "documentation/solids.html#platonic-solids",
    "href": "documentation/solids.html#platonic-solids",
    "title": "3D Solids Functions",
    "section": "Platonic Solids",
    "text": "Platonic Solids\n\ntetrahedron - Create a tetrahedron (4 faces)\noctahedron - Create an octahedron (8 faces)\ndodecahedron - Create a dodecahedron (12 faces)\nicosahedron - Create an icosahedron (20 faces)"
  },
  {
    "objectID": "documentation/solids.html#d-mesh-operations",
    "href": "documentation/solids.html#d-mesh-operations",
    "title": "3D Solids Functions",
    "section": "3D Mesh Operations",
    "text": "3D Mesh Operations\n\nextrude - Extrude a 2D shape into 3D\nrevolve - Create 3D solid by revolution\nloft - Create 3D surface by lofting through curves\nreplicant - Replicate 3D objects\nflatfv - Create flat face-vertex mesh\nfv2fv - Convert between face-vertex formats"
  },
  {
    "objectID": "documentation/solids.html#grid-surface-to-mesh",
    "href": "documentation/solids.html#grid-surface-to-mesh",
    "title": "3D Solids Functions",
    "section": "Grid & Surface to Mesh",
    "text": "Grid & Surface to Mesh\n\ngrid2tri - Convert grid to triangulated mesh\nsurf2fv - Convert surface to face-vertex representation"
  },
  {
    "objectID": "documentation/imgproc/binarize.html",
    "href": "documentation/imgproc/binarize.html",
    "title": "binarize",
    "section": "",
    "text": "Ibw = binarize(I::GMTimage, threshold::Int=0; band=1, threshold::Int=0, revert=false, bool::Bool=false) -&gt; GMTimage\nusing GMT\n\nI = gdalread(GMT.TESTSDIR * \"assets/coins.jpg\");\nIbw = binarize(I, band=1)\n\n# Show the two side-by-side\ngrdimage(I, figsize=6)\ngrdimage!(Ibw, figsize=6, xshift=6.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/binarize.html#source-code",
    "href": "documentation/imgproc/binarize.html#source-code",
    "title": "binarize",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbinarize(I::GMTimage, thresh::Vector{Int64}; band, revert, bool) - img_funs.jl:116\nbinarize(I::GMTimage, thresh::Int64; band, threshold, revert, bool) - img_funs.jl:103\nbinarize(I::GMTimage; ...) - img_funs.jl:103"
  },
  {
    "objectID": "documentation/imgproc/binarize.html#see-also",
    "href": "documentation/imgproc/binarize.html#see-also",
    "title": "binarize",
    "section": "See Also",
    "text": "See Also\nimcomplement"
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html",
    "href": "documentation/imgproc/bwconncomp.html",
    "title": "bwconncomp",
    "section": "",
    "text": "CC = bwconncomp(BW; conn=8)\nFind and count connected components in binary image."
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#description",
    "href": "documentation/imgproc/bwconncomp.html#description",
    "title": "bwconncomp",
    "section": "Description",
    "text": "Description\nFinds and counts the connected components in the binary image BW. The function returns a structure containing the total number of connected components, such as regions of interest (ROIs), in the image and the pixel indices assigned to each component."
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#parameters",
    "href": "documentation/imgproc/bwconncomp.html#parameters",
    "title": "bwconncomp",
    "section": "Parameters",
    "text": "Parameters\n\nBW: Binary 2D image. For numeric input, any nonzero pixels are considered to be 1 (true).\n\nType: Array{&lt;:Real} or GMTgrid"
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#keyword-arguments",
    "href": "documentation/imgproc/bwconncomp.html#keyword-arguments",
    "title": "bwconncomp",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\nconn: Connectivity for connected components\n\nType: Integer or Array\nDefault: 8\nOptions:\n\nFor 2D images:\n\n4 — 4-connected neighborhood (edge connectivity)\n8 — 8-connected neighborhood (edge and corner connectivity)\n\nAlternatively, can be a connectivity array of 0s and 1s with the same dimensionality as BW. The 1-valued elements define neighborhood locations relative to the center element. The center element must be 1. The connectivity array size must be odd along each dimension."
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#returns",
    "href": "documentation/imgproc/bwconncomp.html#returns",
    "title": "bwconncomp",
    "section": "Returns",
    "text": "Returns\nConnected components, specified as a structure with the following fields:\n\n\n\nField\nDescription\n\n\n\n\nconnectivity\nConnectivity of the connected components\n\n\nimage_size\nSize of the binary image\n\n\nnum_objects\nNumber of connected components in the binary image\n\n\nrange\nRange of the image coordinates\n\n\ninc\nImage’s increment (!= 1 whem image is referenced)\n\n\nregistration\nRegistration of the image\n\n\nx\nX coordinates of the image\n\n\ny\nY coordinates of the image\n\n\nlayout\nMemory layout of the image\n\n\nproj4\nProjection definition (optional)\n\n\nwkt\nWell-known text definition (optional)\n\n\nepsg\nEPSG code of the image\n\n\nbbox\nThe bounding boxes as a vector of GMTdataset\n\n\npixel_list\nVector where each element contains the linear indices of the pixels in each object\n\n\ncentroid\nA Float64 Matrix with the x,y coordinates of the centroids for each component\n\n\narea\nA vector of Float64 with the areas of each component\n\n\n\n\nTo compute a label matrix with a memory-efficient data type (for instance, UInt8 versus Float64), use the labelmatrix function on the output of bwconncomp:\n\nCC = bwconncomp(BW)\nL = labelmatrix(CC)"
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#examples",
    "href": "documentation/imgproc/bwconncomp.html#examples",
    "title": "bwconncomp",
    "section": "Examples",
    "text": "Examples\n\nFind Connected Components in Binary Image\n\nusing GMT\n\n# Create a binary image\nBW = [1 1 0 0 0 0 0 0\n      1 1 0 1 1 0 0 0\n      0 0 0 1 1 0 0 0\n      0 0 0 0 0 1 1 0\n      0 0 0 0 0 1 1 0\n      0 0 0 0 0 0 0 0]\n\n# Find connected components\nCC = bwconncomp(BW)\n\nprintln(\"Number of connected components: \", CC.num_objects)\n\nNumber of connected components: 2\n\n\n\n\nSpecify Connectivity\nFind connected components using 4-connectivity instead of the default 8-connectivity:\n\nusing GMT\n\nBW = [1 1 0 0 0 0 0 0\n      1 1 0 1 1 0 0 0\n      0 0 0 1 1 0 0 0\n      0 0 0 0 0 1 1 0\n      0 0 0 0 0 1 1 0\n      0 0 0 0 0 0 0 0]\n\n# 4-connectivity\nCC4 = bwconncomp(BW, conn=4)\nprintln(\"Number of components (4-conn): \", CC4.num_objects)\n\n# 8-connectivity\nCC8 = bwconncomp(BW, conn=8)\nprintln(\"Number of components (8-conn): \", CC8.num_objects)\n\nNumber of components (4-conn): 3\nNumber of components (8-conn): 2\n\n\n\n\nExtract Properties of Connected Components\nUse the output structure to analyze individual components:\n\nusing GMT\n\nBW = [1 1 0 0 0 0 0 0\n      1 1 0 1 1 0 0 0\n      0 0 0 1 1 0 0 0\n      0 0 0 0 0 1 1 0\n      0 0 0 0 0 1 1 0\n      0 0 0 0 0 0 0 0]\n\nCC = bwconncomp(BW)\n\n# Number of pixels in each component\nnumPixels = [length(CC.pixel_list[i]) for i in 1:CC.num_objects]\nprintln(\"Pixels per component: \", numPixels)\n\n# Find the largest component\nlargest = argmax(numPixels)\nprintln(\"Largest component is #\", largest, \" with \", numPixels[largest], \" pixels\")\n\nPixels per component: [4, 8]\nLargest component is #2 with 8 pixels"
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#source-code",
    "href": "documentation/imgproc/bwconncomp.html#source-code",
    "title": "bwconncomp",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nbwconncomp(G::GMTgrid{Bool, 2}; conn) - lepto_funs.jl:1214\nbwconncomp(mat::BitMatrix; conn) - lepto_funs.jl:1211\nbwconncomp(I::GMTimage; conn) - lepto_funs.jl:1215\nbwconncomp(mat::Matrix{&lt;:Bool}; conn) - lepto_funs.jl:1212\nbwconncomp(mat::Matrix{&lt;:Integer}; conn) - lepto_funs.jl:1213"
  },
  {
    "objectID": "documentation/imgproc/bwconncomp.html#see-also",
    "href": "documentation/imgproc/bwconncomp.html#see-also",
    "title": "bwconncomp",
    "section": "See Also",
    "text": "See Also\ncc2bw"
  },
  {
    "objectID": "documentation/imgproc/bwhitmiss.html",
    "href": "documentation/imgproc/bwhitmiss.html",
    "title": "bwhitmiss",
    "section": "",
    "text": "J = bwhitmiss(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}, interval::Matrix{&lt;:Integer})::GMTimage\nPerforms the hit-miss operation on a binary image defined in terms of a matrix called an interval.\nAn interval is a matrix whose elements are 0 or 1 or 2 and results from joining two structural elements SE1 and SE2. 0’s are ignored. The 1’s make up the domain of SE1 and the 2’s the domain of SE2."
  },
  {
    "objectID": "documentation/imgproc/bwhitmiss.html#example",
    "href": "documentation/imgproc/bwhitmiss.html#example",
    "title": "bwhitmiss",
    "section": "Example",
    "text": "Example\nConsider the task of locating upper-left corner pixels of objects in an bw image. We want to locate foreground pixels that have east and south neighbors (these are ‘hits’) and that have no northeast, northwest, west or southwest neighbors (these are ‘misses’). These requirements lead to the following interval matrix:\n\nusing GMT\n\ninterval = [2 2 2; 2 1 1; 2 1 0];\nI = gmtread(TESTSDIR * \"assets/small_squares.png\");\nJ = bwhitmiss(I, interval);\ngrdimage(I, figsize=6)\ngrdimage!(J, figsize=6, xshift=6.05, show=true)"
  },
  {
    "objectID": "documentation/imgproc/bwhitmiss.html#source-code",
    "href": "documentation/imgproc/bwhitmiss.html#source-code",
    "title": "bwhitmiss",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/bwhitmiss.html#see-also",
    "href": "documentation/imgproc/bwhitmiss.html#see-also",
    "title": "bwhitmiss",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode"
  },
  {
    "objectID": "documentation/imgproc/bwskell.html",
    "href": "documentation/imgproc/bwskell.html",
    "title": "bwskell",
    "section": "",
    "text": "J = bwskell(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; type::Int=1, maxiters::Int=0, conn::Int=4)::GMTimage\nReduce all objects to lines in 2-D binary image.\nReduces all objects in the 2-D binary image I to 1-pixel wide curved lines, without changing the essential structure of the image. This process, called skeletonization, extracts the centerline while preserving the topology."
  },
  {
    "objectID": "documentation/imgproc/bwskell.html#example",
    "href": "documentation/imgproc/bwskell.html#example",
    "title": "bwskell",
    "section": "Example",
    "text": "Example\nSkeletonize a binary image.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/bone.png\");\nJ = bwskell(I);\ngrdimage(I, figsize=6)\ngrdimage!(J, figsize=6, xshift=6, show=true)"
  },
  {
    "objectID": "documentation/imgproc/bwskell.html#source-code",
    "href": "documentation/imgproc/bwskell.html#source-code",
    "title": "bwskell",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/fillsinks.html",
    "href": "documentation/imgproc/fillsinks.html",
    "title": "fillsinks",
    "section": "",
    "text": "fillsinks(G::GMTgrid; conn=8, region=nothing, saco=false, insitu=false)\nFill sinks in a grid.\nThis function uses the imfill function to find how to fill sinks in a grid. But since imfill operates on UInt8 matrices only the vertical (z) descrimination of the grid is reduced to 256 levels, which is not that much."
  },
  {
    "objectID": "documentation/imgproc/fillsinks.html#examples",
    "href": "documentation/imgproc/fillsinks.html#examples",
    "title": "fillsinks",
    "section": "Examples",
    "text": "Examples\nFill the depressions of the peaks surface. Show original and sinks filled side by side.\n\nusing GMT\n\nG = peaks(N=128);\nG2 = fillsinks(G);\ngrdimage(G, figsize=6, shade=true)\ngrdimage!(G2, figsize=6, xshift=6.2, frame=\"wSen\", shade=true, show=true)"
  },
  {
    "objectID": "documentation/imgproc/fillsinks.html#source-code",
    "href": "documentation/imgproc/fillsinks.html#source-code",
    "title": "fillsinks",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/fillsinks.html#see-also",
    "href": "documentation/imgproc/fillsinks.html#see-also",
    "title": "fillsinks",
    "section": "See Also",
    "text": "See Also\nimfill"
  },
  {
    "objectID": "documentation/imgproc/imbothat.html",
    "href": "documentation/imgproc/imbothat.html",
    "title": "imbothat",
    "section": "",
    "text": "J = imbothat(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3)::GMTimage\nDo a morphological bop-hat operation on a grayscale or binary image.\nBottom-hat computes the morphological closing of the image and does a: closing - orig_image This transform isolates pixels that are darker than other pixels in their neighborhood."
  },
  {
    "objectID": "documentation/imgproc/imbothat.html#source-code",
    "href": "documentation/imgproc/imbothat.html#source-code",
    "title": "imbothat",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imbothat.html#see-also",
    "href": "documentation/imgproc/imbothat.html#see-also",
    "title": "imbothat",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode, imopen, imtophat"
  },
  {
    "objectID": "documentation/imgproc/imcomplement.html",
    "href": "documentation/imgproc/imcomplement.html",
    "title": "imcomplement",
    "section": "",
    "text": "J = imcomplement(I::GMTimage) -&gt; GMTimage\nCompute the complement of the image I and returns the result in J.\nI can be a binary, intensity, or truecolor image. J has the same type and size as I. I can also be just a matrix. All types numeric (but complex) are allowed.\nIn the complement of a binary image, black becomes white and white becomes black. In the case of a grayscale or truecolor image, dark areas become lighter and light areas become darker.\nThe imcomplement! function works in-place and returns the modified I."
  },
  {
    "objectID": "documentation/imgproc/imcomplement.html#example",
    "href": "documentation/imgproc/imcomplement.html#example",
    "title": "imcomplement",
    "section": "Example",
    "text": "Example\nReverse Black and White in a Binary Image.\n\nusing GMT\n\ntext([\"Hello World\"], region=(1.92,2.08,1.97,2.02), x=2.0, y=2.0,\n     font=(30, \"Helvetica-Bold\", :white),\n     frame=(axes=:none, bg=:black), figsize=(6,0), name=\"tmp.png\")\n\n# Read only one band (althouh gray scale, the \"tmp.png\" is actually RGB)\nI = gmtread(\"tmp.png\", band=1);\nIc = imcomplement(I);\n\n# Show the two\ngrdimage(I, figsize=8)\ngrdimage!(Ic, figsize=8, yshift=-2.57, show=true)\n\n\n\n\n\n\n\n\nCreate the Complement of a Color Image\n\nusing GMT\n\nI = gmtread(GMT.TESTSDIR * \"assets/table_flowers.jpg\");\nIc = imcomplement(I);\n\ngrdimage(I, figsize=6)\ngrdimage!(Ic, figsize=6, xshift=6, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imcomplement.html#source-code",
    "href": "documentation/imgproc/imcomplement.html#source-code",
    "title": "imcomplement",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimcomplement(I::GMTimage; insitu) - img_funs.jl:460\nimcomplement(mat::AbstractArray{&lt;:Real}) - img_funs.jl:479"
  },
  {
    "objectID": "documentation/imgproc/imcomplement.html#see-also",
    "href": "documentation/imgproc/imcomplement.html#see-also",
    "title": "imcomplement",
    "section": "See Also",
    "text": "See Also\nbinarize"
  },
  {
    "objectID": "documentation/imgproc/imerode.html",
    "href": "documentation/imgproc/imerode.html",
    "title": "imerode",
    "section": "",
    "text": "J = imerode(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3, sel=nothing)::GMTimage\nErode the grayscale or binary image I.\nThe erosion is performed with a matrix of 0’s and 1’s with width hsize and height vsize, or, if possible, with the structuring element strel. Later case is faster but it is only available for binary images, where by binary images we mean Boolean images or images with only 0’s and 1’s of UInt8 type."
  },
  {
    "objectID": "documentation/imgproc/imerode.html#examples",
    "href": "documentation/imgproc/imerode.html#examples",
    "title": "imerode",
    "section": "Examples",
    "text": "Examples\nErosion with a disk radius of 10, 5 and 20\nI = gmtread(TESTSDIR * \"assets/chip.png\");\nJ1 = imerode(I, sel=strel(\"disk\", 10));\nJ2 = imerode(I, sel=strel(\"disk\", 5));\nJ3 = imerode(I, sel=strel(\"disk\", 20));\ngrdimage(I, figsize=6)\ngrdimage!(J1, figsize=6, xshift=6.1)\ngrdimage!(J2, figsize=6, xshift=-6.1, yshift=-6.1)\ngrdimage!(J3, figsize=6, xshift=6.1, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imerode.html#source-code",
    "href": "documentation/imgproc/imerode.html#source-code",
    "title": "imerode",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimerode(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize, vsize, sel) - lepto_funs.jl:481\nimerode(G::AbstractMatrix{T}, sel::Matrix{&lt;:Real}) where T&lt;:Union{AbstractFloat, Integer} - lepto_funs.jl:479\nimerode(G::AbstractMatrix{T}; hsize, vsize, sel) where T&lt;:Union{AbstractFloat, Integer} - lepto_funs.jl:475\n\n\nSee Also\nimdilate, imopen, imclose, strel"
  },
  {
    "objectID": "documentation/imgproc/imfilter.html",
    "href": "documentation/imgproc/imfilter.html",
    "title": "imfilter",
    "section": "",
    "text": "J = imfilter(I::GMTimage, kernel::Matrix{&lt;:Real}; normalize::Int=1, sep::Bool=false)::GMTimage"
  },
  {
    "objectID": "documentation/imgproc/imfilter.html#example",
    "href": "documentation/imgproc/imfilter.html#example",
    "title": "imfilter",
    "section": "Example",
    "text": "Example\nApply an 3x3 Mean Removal filter to the image “moon.png”.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/moon.png\");\nJ = imfilter(I, [-1 -1 -1; -1 9 -1; -1 -1 -1]);\ngrdimage(I, figsize=5)\ngrdimage!(J, figsize=5, xshift=5, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imfilter.html#source-code",
    "href": "documentation/imgproc/imfilter.html#source-code",
    "title": "imfilter",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imfilter.html#see-also",
    "href": "documentation/imgproc/imfilter.html#see-also",
    "title": "imfilter",
    "section": "See Also",
    "text": "See Also\nimfill, bwskell, imerode, imsobel"
  },
  {
    "objectID": "documentation/imgproc/imhmax.html",
    "href": "documentation/imgproc/imhmax.html",
    "title": "imhmax",
    "section": "",
    "text": "J = imhmax(I::GMTimage{&lt;:UInt8, 2}, H; conn=4)::GMTimage\nSuppress regional maxima in image using H-maxima transform.\nThe H-maxima transform decreases the height of all regional maxima by an amount up to H. As a result, the transform fully suppresses regional maxima whose height is less than H. Regional maxima are connected pixels with the same intensity value, t, that are surrounded by pixels with an intensity value less than t."
  },
  {
    "objectID": "documentation/imgproc/imhmax.html#example",
    "href": "documentation/imgproc/imhmax.html#example",
    "title": "imhmax",
    "section": "Example",
    "text": "Example\nThe result will look like the outline of the object.\n\nusing GMT\n\na = fill(UInt8(10),10,10);\na[2:4,2:4] .= UInt8(13);\na[6:8,6:8] .= UInt8(18);\nI = imhmax(mat2img(a), 4);"
  },
  {
    "objectID": "documentation/imgproc/imhmax.html#source-code",
    "href": "documentation/imgproc/imhmax.html#source-code",
    "title": "imhmax",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imhmax.html#see-also",
    "href": "documentation/imgproc/imhmax.html#see-also",
    "title": "imhmax",
    "section": "See Also",
    "text": "See Also\nimhdome, imhmin"
  },
  {
    "objectID": "documentation/imgproc/immorphgrad.html",
    "href": "documentation/imgproc/immorphgrad.html",
    "title": "immorphgrad",
    "section": "",
    "text": "J = immorphgrad(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3, smooth=0)::GMTimage\nCompute the morphological gradient of a grayscale or binary image.\nThis is the difference between dilation and erosion of an image. The parameter smooth can be used to smooth the result."
  },
  {
    "objectID": "documentation/imgproc/immorphgrad.html#example",
    "href": "documentation/imgproc/immorphgrad.html#example",
    "title": "immorphgrad",
    "section": "Example",
    "text": "Example\nThe result will look like the outline of the object.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/j.png\");\nJ = immorphgrad(I, hsize=5, vsize=5);\ngrdimage(I, figsize=5)\ngrdimage!(J, figsize=5, xshift=5, show=true)"
  },
  {
    "objectID": "documentation/imgproc/immorphgrad.html#source-code",
    "href": "documentation/imgproc/immorphgrad.html#source-code",
    "title": "immorphgrad",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/immorphgrad.html#see-also",
    "href": "documentation/imgproc/immorphgrad.html#see-also",
    "title": "immorphgrad",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode"
  },
  {
    "objectID": "documentation/imgproc/imrankfilter.html",
    "href": "documentation/imgproc/imrankfilter.html",
    "title": "imrankfilter",
    "section": "",
    "text": "J = imrankfilter(I::GMTimage; width::Int=3, height::Int=0, rank=0.5)::GMTimage\nRank order filter.\nThis defines, for each pixel, a neighborhood of pixels given by a rectangle “centered” on the pixel. This set of width x height pixels has a distribution of values, and if they are sorted in increasing order, we choose the pixel such that rank(wfhf-1) pixels have a lower or equal value and (1-rank)(wfhf-1) pixels have an equal or greater value. In other words, rank=0 returns the minimun, rank=1 returns the maximum in box and rank=0.5 returns the median. Other values return the quantile."
  },
  {
    "objectID": "documentation/imgproc/imrankfilter.html#example",
    "href": "documentation/imgproc/imrankfilter.html#example",
    "title": "imrankfilter",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/small_squares.png\");\nJ = imrankfilter(I, width=10);\ngrdimage(I, figsize=6)\ngrdimage!(J, figsize=6, xshift=6, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imrankfilter.html#source-code",
    "href": "documentation/imgproc/imrankfilter.html#source-code",
    "title": "imrankfilter",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imrankfilter.html#see-also",
    "href": "documentation/imgproc/imrankfilter.html#see-also",
    "title": "imrankfilter",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode, imopen, imclose"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html",
    "href": "documentation/imgproc/imregionalmax.html",
    "title": "imregionalmax",
    "section": "",
    "text": "Regional maxima"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#description",
    "href": "documentation/imgproc/imregionalmax.html#description",
    "title": "imregionalmax",
    "section": "Description",
    "text": "Description\nBW = imregionalmax(I)\nReturns the binary image BW that identifies the regional maxima in the 2-D grayscale image I. Regional maxima are connected components of pixels with a constant intensity value, surrounded by pixels with a lower value.\nBW = imregionalmax(I, conn)\nComputes the regional maxima using the specified connectivity conn."
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#input-arguments",
    "href": "documentation/imgproc/imregionalmax.html#input-arguments",
    "title": "imregionalmax",
    "section": "Input Arguments",
    "text": "Input Arguments\n\nI — GMTgrid|image or Matrix\nGrayscale 2-D image, specified as a numeric matrix.\nData Types: UInt8 and Floating point types. In this later case an UInt8 representation is used internally.\n\n\nconn — Pixel connectivity\nPixel connectivity, specified as one of the values in this table. The default connectivity is 8 for 2-D images.\n\nTwo-Dimensional Connectivities\n\n\n\n\n\n\n\nValue\nMeaning\n\n\n\n\n4\nPixels are connected if their edges touch. The neighborhood of a pixel are the adjacent pixels in the horizontal or vertical direction.\n\n\n8\nPixels are connected if their edges or corners touch. The neighborhood of a pixel are the adjacent pixels in the horizontal, vertical, or diagonal direction.\n\n\n\nConnectivity can also be defined by specifying a 3-by-3 matrix of 0s and 1s. The 1-valued elements define neighborhood locations relative to the center element of conn. Note that conn must be symmetric about its center element.\nData Types: Int, or array of Bool"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#output-arguments",
    "href": "documentation/imgproc/imregionalmax.html#output-arguments",
    "title": "imregionalmax",
    "section": "Output Arguments",
    "text": "Output Arguments\n\nBW — GMTimage with locations of regional minima\nLocations of regional maxima, returned as a logical array of the same size as I. Pixels with the value true (or 1) indicate regional maxima; all other pixels are set to false (or 0).\nData Types: Bool"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#notes",
    "href": "documentation/imgproc/imregionalmax.html#notes",
    "title": "imregionalmax",
    "section": "Notes",
    "text": "Notes\n\nRegional Maxima vs. Local Maxima: A regional maximum is a connected component of pixels with constant intensity, all of whose neighbors have a strictly lower value. This is different from a local maximum, which is a single pixel whose value is greater than or equal to all its neighbors.\n\n\nFlat Regions: If an image contains large flat regions at the maximum intensity level, the entire flat region will be marked as a regional maximum.\n\n\nConnectivity Impact: Higher connectivity values (e.g., 8 vs 4 in 2-D) can merge what would be separate regional maxima under lower connectivity, reducing the total number of detected maxima.\n\n\nNoise Sensitivity: imregionalmax can be sensitive to noise and may detect many spurious maxima. Consider preprocessing with imhmax (h-maxima transform) or post-processing with bwareaopen to remove small or shallow maxima."
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#tips",
    "href": "documentation/imgproc/imregionalmax.html#tips",
    "title": "imregionalmax",
    "section": "Tips",
    "text": "Tips\n\nUse imhmax to suppress shallow regional maxima before detection\nApply bwareaopen to remove small spurious regional maxima\nCombine with watershed for marker-based image segmentation\nFor elevation data, regional maxima identify peaks and summits\nUse imextendedmax to apply the H-maxima transform and find regional maxima in one step\nThe complement operation can be used to find regional minima: imregionalmax(-I) or use imregionalmin(I)"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#examples",
    "href": "documentation/imgproc/imregionalmax.html#examples",
    "title": "imregionalmax",
    "section": "Examples",
    "text": "Examples\n\nFind Regional Maxima in Simple Array\nCreate a simple sample array with several regional maxima:\nA = 10 * ones(10, 10)\nA[2:4, 2:4] .= 22\nA[6:8, 6:8] .= 33\nA[2, 7] = 44\nA[3, 8] = 45\nA[4, 9] = 44\nOutput:\n10×10 Matrix{Float64}:\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0  22.0  22.0  22.0  10.0  10.0  44.0  10.0  10.0  10.0\n 10.0  22.0  22.0  22.0  10.0  10.0  10.0  45.0  10.0  10.0\n 10.0  22.0  22.0  22.0  10.0  10.0  10.0  10.0  44.0  10.0\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  33.0  33.0  33.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  33.0  33.0  33.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  33.0  33.0  33.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\n 10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0  10.0\nCalculate the regional maxima. The function returns a binary image, the same size as the input image, in which pixels with the value true (or 1) represent the regional maxima. imregionalmax sets all other pixels to false (or 0):\nregmax = imregionalmax(A)\nOutput:\n10×10 BitMatrix:\n 0  0  0  0  0  0  0  0  0  0\n 0  1  1  1  0  0  0  0  0  0\n 0  1  1  1  0  0  0  1  0  0\n 0  1  1  1  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  1  1  1  0  0\n 0  0  0  0  0  1  1  1  0  0\n 0  0  0  0  0  1  1  1  0  0\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0\nNote that the pixel at position (3, 8) with value 45 is identified as a regional maximum because it is higher than all its neighbors.\n\n\nFind Regional Maxima in Grayscale Image\nLoad a grayscale image:\nI = gmtread(\"coins.png\")\nimshow(I)\nFind the regional maxima:\nBW = imregionalmax(I)\nimshow(BW)\nOverlay the regional maxima on the original image:\n# Create an overlay showing maxima in green\nimshow(I)\noverlay!(BW, color=:green)\n\n\nCompare Different Connectivity Settings\nCreate a test image with a ridge structure:\n# Create an image with a ridge\nI = zeros(UInt8, 15, 15)\nI[8, :] .= 100  # Horizontal ridge\nI[:, 8] .= 100  # Vertical ridge\nI[8, 8] = 150   # Peak at intersection\nCompute regional maxima with different connectivity:\n# 4-connectivity (edges only)\nBW4 = imregionalmax(I, 4)\n\n# 8-connectivity (edges and corners)\nBW8 = imregionalmax(I, 8)\n\n# Display results\nsubplot(1, 3, 1)\nimshow(I)\ntitle!(\"Original Image\")\n\nsubplot(1, 3, 2)\nimshow(BW4)\ntitle!(\"4-Connectivity\")\n\nsubplot(1, 3, 3)\nimshow(BW8)\ntitle!(\"8-Connectivity\")\n\nshowfig()\n\n\nUse Regional Maxima for Marker-Based Watershed Segmentation\nRegional maxima are often used to identify seed points for marker-based watershed segmentation:\n# Load image\nI = gmtread(\"coins.png\")\n\n# Compute distance transform\nD = bwdist(.!imbinarize(I))\n\n# Find regional maxima in distance transform\nmaxima = imregionalmax(D)\n\n# Remove small regional maxima (noise)\nmaxima_filtered = bwareaopen(maxima, 10)\n\n# Label the maxima as markers\nmarkers = label_components(maxima_filtered)\n\n# Impose maxima on negative distance for watershed\nD_comp = -D\nD_mod = imimposemin(D_comp, maxima_filtered)\n\n# Perform watershed segmentation\nL = watershed(D_mod)\n\n# Display results\nsubplot(1, 3, 1)\nimshow(I)\ntitle!(\"Original\")\n\nsubplot(1, 3, 2)\nimshow(maxima_filtered)\ntitle!(\"Filtered Maxima\")\n\nsubplot(1, 3, 3)\nimshow(label2rgb(L))\ntitle!(\"Watershed Segmentation\")\n\nshowfig()\n\n\nDetect Peaks in Elevation Data\n(These are Claude.ai dreams but maybe worth including)\nUse regional maxima to find peaks in a digital elevation model:\n# Load elevation data\nDEM = gmtread(\"elevation.tif\")\n\n# Find regional maxima (peaks, summits)\npeaks = imregionalmax(DEM)\n\n# Remove small spurious maxima\npeaks_clean = bwareaopen(peaks, 20)\n\n# Overlay peaks on elevation map\nimshow(DEM, cmap=:terrain)\noverlay!(peaks_clean, color=:red, alpha=0.8)\ncolorbar!()\ntitle!(\"Peaks in Elevation Data\")\n\n\nPre-process Image with H-Maxima Transform\nSuppress shallow maxima before finding regional maxima:\n# Load image\nI = gmtread(\"rice.png\")\n\n# Original regional maxima (many spurious maxima)\nmaxima_orig = imregionalmax(I)\n\n# Apply H-maxima transform to suppress shallow maxima\nI_hmax = imhmax(I, 10)\n\n# Find regional maxima after suppression\nmaxima_filtered = imregionalmax(I_hmax)\n\n# Compare results\nsubplot(1, 3, 1)\nimshow(I)\ntitle!(\"Original\")\n\nsubplot(1, 3, 2)\nimshow(maxima_orig)\ntitle!(\"Original Maxima ($(sum(maxima_orig)) regions)\")\n\nsubplot(1, 3, 3)\nimshow(maxima_filtered)\ntitle!(\"Filtered Maxima ($(sum(maxima_filtered)) regions)\")\n\nshowfig()\n\n\nCount Number of Regional Maxima\nTo count the number of regional maxima pixels:\nI = gmtread(\"sample.png\")\nBW = imregionalmax(I)\n\n# Count maxima pixels\nn_pixels = sum(BW)\nprintln(\"Number of regional maxima pixels: $n_pixels\")\n\n# Count maxima regions (connected components)\nCC = bwconncomp(BW)\nn_regions = CC.NumObjects\nprintln(\"Number of regional maxima regions: $n_regions\")"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#source-code",
    "href": "documentation/imgproc/imregionalmax.html#source-code",
    "title": "imregionalmax",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nimregionalmax(G::Union{GMTgrid, Matrix{&lt;:AbstractFloat}}; minmax) - lepto_funs.jl:1112\nimregionalmax(I; minmax) - lepto_funs.jl:1117"
  },
  {
    "objectID": "documentation/imgproc/imregionalmax.html#see-also",
    "href": "documentation/imgproc/imregionalmax.html#see-also",
    "title": "imregionalmax",
    "section": "See Also",
    "text": "See Also\nimregionalmin, imhmax, [watershed], imreconstruct, bwareaopen, bwdist"
  },
  {
    "objectID": "documentation/imgproc/imsegment.html",
    "href": "documentation/imgproc/imsegment.html",
    "title": "imsegment",
    "section": "",
    "text": "J = function imsegment(I::GMTimage{&lt;:UInt8, 3}; maxdist::Int=0, maxcolors::Int=0, selsize::Int=3, colors::Int=5)::GMTimage\nUnsupervised RGB color segmentation.\nFor more details see the docs in Leptonica’s function pixColorSegment (in src/colorseg.c)."
  },
  {
    "objectID": "documentation/imgproc/imsegment.html#examples",
    "href": "documentation/imgproc/imsegment.html#examples",
    "title": "imsegment",
    "section": "Examples",
    "text": "Examples\nThis was thought as a simple example but turned out to show a bit tricky result. The image “bunny_cenora.jpg” is simple and we can clearly see that it has only 6 colors, so we would expect that colors=6 would do the job. But in fact we need to set colors=7 because the outline (black) is in fact picked as two different (dark) colors.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/bunny_cenora.jpg\");\nJ = imsegment(I, colors=7);\ngrdimage(I, figsize=6)\ngrdimage!(J, figsize=6, xshift=6, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imsegment.html#source-code",
    "href": "documentation/imgproc/imsegment.html#source-code",
    "title": "imsegment",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imtophat.html",
    "href": "documentation/imgproc/imtophat.html",
    "title": "imtophat",
    "section": "",
    "text": "J = imtophat(I::Union{GMTimage{&lt;:UInt8, 2}, GMTimage{&lt;:Bool, 2}}; hsize=3, vsize=3)::GMTimage\nDo a morphological top-hat operation on a grayscale or binary image.\nTop-hat computes the morphological opening of the image and does a: orig_image - opening\nThis transform can be used to enhance contrast in a grayscale image with nonuniform illumination. It can also isolate small bright objects in an image."
  },
  {
    "objectID": "documentation/imgproc/imtophat.html#example",
    "href": "documentation/imgproc/imtophat.html#example",
    "title": "imtophat",
    "section": "Example",
    "text": "Example\nPerform the top-hat filtering and display the image.\n\nusing GMT\n\nI = gmtread(TESTSDIR * \"assets/rice.png\");\nJ = imtophat(I, hsize=11, vsize=11);\ngrdimage(I, figsize=6)\ngrdimage!(J, figsize=6, xshift=6, show=true)"
  },
  {
    "objectID": "documentation/imgproc/imtophat.html#source-code",
    "href": "documentation/imgproc/imtophat.html#source-code",
    "title": "imtophat",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/imtophat.html#see-also",
    "href": "documentation/imgproc/imtophat.html#see-also",
    "title": "imtophat",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode, imopen, imbothat"
  },
  {
    "objectID": "documentation/imgproc/padarray.html",
    "href": "documentation/imgproc/padarray.html",
    "title": "padarray",
    "section": "",
    "text": "B = padarray(A, padsize; padval=nothing)\nPad matrix A with an amount of padding in each dimension specified by padsize."
  },
  {
    "objectID": "documentation/imgproc/padarray.html#example",
    "href": "documentation/imgproc/padarray.html#example",
    "title": "padarray",
    "section": "Example",
    "text": "Example\nA = [1 2; 3 4];\nB = padarray(A,1)\n4×4 Matrix{Int64}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4"
  },
  {
    "objectID": "documentation/imgproc/padarray.html#source-code",
    "href": "documentation/imgproc/padarray.html#source-code",
    "title": "padarray",
    "section": "Source Code",
    "text": "Source Code\nView the source code for this function."
  },
  {
    "objectID": "documentation/imgproc/rgb2lab.html",
    "href": "documentation/imgproc/rgb2lab.html",
    "title": "rgb2lab",
    "section": "",
    "text": "img = rgb2lab(I::GMTimage{UInt8, 3})\n\nor\n\n    L, a, b = rgb2lab(I::GMTimage{UInt8, 3}, L=false, a=false, b=false)\nConvert RGB to CIE 1976 Lab*\nOptionally, return only one to three of: L, a* and b* separate images. For that use the keywords: L, a or b. Each true occurence makes it return that component, otherwise it returns an empty image."
  },
  {
    "objectID": "documentation/imgproc/rgb2lab.html#example",
    "href": "documentation/imgproc/rgb2lab.html#example",
    "title": "rgb2lab",
    "section": "Example",
    "text": "Example\n\nusing GMT\n\n# Read an RGB image and compute the Lab transform.\nI = gmtread(GMT.TESTSDIR * \"assets/seis_section_rgb.jpg\");\nIlab = rgb2lab(I);\n\n# The L, a* and b* components\nL,a,b = rgb2lab(I, L=true, a=true, b=true);\n\n# Show the five.\ngrdimage(I, figsize=8)\ngrdimage!(Ilab, figsize=8, yshift=-3.8)\ngrdimage!(L, figsize=8, yshift=-3.8)\ngrdimage!(a, figsize=8, yshift=-3.8)\ngrdimage!(b, figsize=8, yshift=-3.8, show=true)"
  },
  {
    "objectID": "documentation/imgproc/rgb2lab.html#source-code",
    "href": "documentation/imgproc/rgb2lab.html#source-code",
    "title": "rgb2lab",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nrgb2lab(I::GMTimage{UInt8, 3}; L, a, b) - img_funs.jl:394\nrgb2lab(r, g, b) - img_funs.jl:348"
  },
  {
    "objectID": "documentation/imgproc/rgb2lab.html#see-also",
    "href": "documentation/imgproc/rgb2lab.html#see-also",
    "title": "rgb2lab",
    "section": "See Also",
    "text": "See Also\nrgb2ycbcr"
  },
  {
    "objectID": "documentation/imgproc/strel.html",
    "href": "documentation/imgproc/strel.html",
    "title": "strel",
    "section": "",
    "text": "sel = strel(nhood::Matrix{&lt;:Integer})::Sel\n\nor\n\n    sel = strel(name::String, par1::Int, par2::Int=0)::Sel\nCreate a strel (structuring element) object for morphological operations. A flat structuring element is a binary valued neighborhood in which the 1’s pixels are included in the morphological computation, and the 0’s pixels are not."
  },
  {
    "objectID": "documentation/imgproc/strel.html#source-code",
    "href": "documentation/imgproc/strel.html#source-code",
    "title": "strel",
    "section": "Source Code",
    "text": "Source Code\nThis function has multiple methods:\n\nstrel(name::String, par1::Int64, par2::Int64) - lepto_funs.jl:1393\nstrel(name::String, par1::Int64) - lepto_funs.jl:1393\nstrel(nhood::Vector{&lt;:Integer}; name) - lepto_funs.jl:1390\nstrel(nhood::Matrix{&lt;:Integer}; name) - lepto_funs.jl:1380"
  },
  {
    "objectID": "documentation/imgproc/strel.html#see-also",
    "href": "documentation/imgproc/strel.html#see-also",
    "title": "strel",
    "section": "See Also",
    "text": "See Also\nimdilate, imerode, imclose, imopen"
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "GMT.jl Gallery\nClassic GMT examples ported to Julia. Each example demonstrates specific GMT.jl capabilities.\n\n\n\nExample 01  Contour maps\n\n\n\n\nExample 02  Image presentations\n\n\n\n\nExample 03  Spectral estimation and xy-plots\n\n\n\n\nExample 04  A 3-D perspective mesh plot\n\n\n\n\nExample 05  A 3-D illuminated surface (in bw)\n\n\n\n\nExample 06  Plotting of histograms\n\n\n\n\nExample 07  A simple location map\n\n\n\n\nExample 08  A 3-D histogram\n\n\n\n\nExample 09  Time-series along tracks\n\n\n\n\nExample 10  A geographical bar graph plot\n\n\n\n\nExample 12  Optimal triangulation of data\n\n\n\n\nExample 13  Plotting of vector fields\n\n\n\n\nExample 14  Gridding of data and trend surfaces\n\n\n\n\nExample 15  Gridding, contouring, and masking of unconstrained areas\n\n\n\n\nExample 16  Gridding of data, continued\n\n\n\n\nExample 17  Images clipped by coastlines\n\n\n\n\nExample 18  Volumes and Spatial Selections\n\n\n\n\nExample 19  Color patterns on maps\n\n\n\n\nExample 20  Custom plot symbols\n\n\n\n\nExample 21  Time-series of RedHat stock price\n\n\n\n\nExample 22  World-wide seismicity of last month\n\n\n\n\nExample 23  All great-circle paths lead to Rome\n\n\n\n\nExample 24  Data selection based on geospatial criteria\n\n\n\n\nExample 25  Global distribution of antipodes\n\n\n\n\nExample 26  General vertical perspective projection\n\n\n\n\nExample 27  Plotting Sandwell/Smith Mercator img grids\n\n\n\n\nExample 28  Mixing UTM and geographic data sets\n\n\n\n\nExample 29  Gridding spherical surface data using splines\n\n\n\n\nExample 30  Trigonometric functions plotted in graph mode\n\n\n\n\nExample 33  Stacking automatically generated cross-profiles\n\n\n\n\nExample 34  Using country polygons for plotting and shading\n\n\n\n\nExample 35  Spherical triangulation and distance calculations\n\n\n\n\nExample 36  Spherical gridding using Renka’s algorithms\n\n\n\n\nExample 40  Line simplification\n\n\n\n\nExample 41  Legend with tables\n\n\n\n\nExample 42  Antarctica and stereographic data\n\n\n\n\nExample 44  Map insets\n\n\n\n\nExample 45  Trend modeling\n\n\n\n\nExample 46  Day-light terminators and other sunlight parameters\n\n\n\n\nExample 48  Line networks, map embellishments, and curved titles"
  },
  {
    "objectID": "gallery/ex02.html",
    "href": "gallery/ex02.html",
    "title": "(2) Image presentations",
    "section": "",
    "text": "As our second example we will demonstrate how to make color images from gridded data sets (again, we will defer the actual making of grid files to later examples). We have prepared two 2-D grid files of bathymetry and Geosat geoid heights from global grids and will put the two images on the same page. The region of interest is the Hawaiian Islands, and due to the oblique trend of the island chain we prefer to rotate our geographical data sets using an oblique Mercator projection defined by the hotspot pole at (68W, 69N). We choose the point (190, 25.5) to be the center of our projection (e.g., the local origin), and we want to image a rectangular region defined by the longitudes and latitudes of the lower left and upper right corner of region. In our case we choose (160, 20) and (220, 30) as the corners. We twice use [grdimage] to make the illustration:\n\nusing GMT\n\ngmtset(FONT_TITLE=30, MAP_ANNOT_OBLIQUE=0)\ng_cpt = makecpt(color=:rainbow, T=(-2,14,2))\ngrdimage(\"@HI_geoid_02.nc\", region_diag=(160,220,20,30),\n         proj=(name=:omercp, center=[190 25.5], parallels=[292 69]),\n         dpi=50, frame=(annot=10,), xshift=3.8, yshift=3.2, figsize=12)\ncolorbar!(pos=(anchor=:RM, offset=(1.5,0), triangles=true, neon=true),\n          xaxis=(annot=2, label=:GEOID), yaxis=(label=:m,))\n        \n# Now the topography map\nt_cpt = grd2cpt(\"@HI_topo_02.nc\", cmap=:relief, continuous=true)\ngrdimage!(\"@HI_topo_02.nc\", frame=(title=\"H@#awaiian@# T@#opo and @#G@#eoid@#\", annot=10),\n          shade=\"+a0\", dpi=50, yshift=11, par=(:MAP_TITLE_OFFSET, 1.25))\ncolorbar!(pos=(anchor=:RM, offset=(1.5,0), neon=true), shade=0.3,\n          xaxis=(annot=2, label=:TOPO), yaxis=(label=:km,))\nT = mat2ds([-0.4 7.5; -0.4 3.0], [\"a)\", \"b)\"])\npstext!(T, region=(0,21.6,0,29.94), font=(30,\"Helvetica-Bold\"), justify=:CB,\n        yshift=11, proj=:linear, scale=1, show=true)\n\n\n\n\n\n\n\n\nWe again set up a 2 by 1 subplot layout and specify the actual region and map projection we wish to use for the two map panels. We use [makecpt] to generate a linear color palette file for the geoid and use [grd2cpt] to get a histogram-equalized CPT for the topography data. We run [grdimage] to create a color-coded image of the topography, and to emphasize the structures in the data we use the slopes in the north-south direction to modulate the color image via the shade option. Then, we place a color legend to the right of the image with [colorbar]. We repeat these steps for the Geosat geoid grid. Again, the labeling of the two plots with a) and b) is automatically done by [subplot]."
  },
  {
    "objectID": "gallery/ex04.html",
    "href": "gallery/ex04.html",
    "title": "(4) A 3-D perspective mesh plot",
    "section": "",
    "text": "This example will illustrate how to make a fairly complicated composite figure. We need a subset of the ETOPO5 bathymetry 1 and Geosat geoid data sets which we have extracted from the global data grids using grdcut and access those files here as remote files on the GMT data server. We would like to show a 2-layer perspective plot where layer one shows a contour map of the marine geoid with the location of the Hawaiian islands superposed, and a second layer showing the 3-D mesh plot of the topography. We also add an arrow pointing north and some text. The first part of this script shows how to do it:\n\nusing GMT\n\nmakecpt(cmap=(255,100), range=(-10,10,10), no_bg=true);\ngrdcontour(\"@HI_geoid_04.nc\", region=(195,210,18,25), view=(60,30), cont=1,\n           annot=(int=5, labels=(rounded=true,)), labels=(dist=10,),\n           xshift=3, yshift=3, proj=:merc, figscale=1.1)\ncoast!(p=true, frame=(annot=2, axes=:NEsw), land=:black,\n       rose=(inside=true, anchor=:BR, width=2.5, offset=0.25, label=true))\ngrdview!(\"@HI_topo_04.nc\", p=true, region=(195,210,18,25,-6,4),\n         plane=(-6,:lightgray), surftype=(surf=true, mesh=true), Jz=\"0.9\",\n         frame=(axes=:wesnZ, annot=2), zaxis=(annot=2, label=\"Topo (km)\"), yshift=5.6)\ntext!(\"H@#awaiian@# R@#idge@#\", x=7.5, y=14.0, region=(0,21,0,28),\n      font=(60,\"ZapfChancery-MediumItalic\"), justify=:CB, proj=:linear,\n      view=:none, figscale=1, show=true)\n\n\n\n\n\n\n\n\nThe purpose of the CPT zero.cpt is to have the positive topography mesh painted light gray (the remainder is white). The left side of Figure shows the complete illustration.\nThe second part of the script shows how to make the color version of this figure that was printed in our first article in EOS Trans. AGU (8 October 1991). Using [grdview] one can choose to either plot a mesh surface (left) or a color-coded surface (right). We have also added artificial illumination from a light-source due north, which is simulated by computing the gradient of the surface grid in that direction though the [grdgradient] program. We choose to use the -Qc option in [grdview] to achieve a high degree of smoothness. Here, we select 100 dpi since that will be the resolution of our final raster (The EOS raster was 300 dpi). Note that the size of the resulting output file is directly dependent on the square of the dpi chosen for the scanline conversion and how well the resulting image compresses. A higher value for dpi in -Qc would have resulted in a much larger output file. The CPTs were taken from Example (2) Image presentations."
  },
  {
    "objectID": "gallery/ex06.html",
    "href": "gallery/ex06.html",
    "title": "(6) Plotting of histograms",
    "section": "",
    "text": "GMT provides two tools to render histograms: [histogram] and [rose]. The former takes care of regular histograms whereas the latter deals with polar histograms (rose diagrams, sector diagrams, and wind rose diagrams). We will show an example that involves both programs. The remote file fractures_06.txt contains a compilation of fracture lengths and directions as digitized from geological maps. The remote file v3206_06.txt contains all the bathymetry measurements from Vema cruise 3206. Our complete figure was made as a 2 by 1 [subplot] figure by running this script:\n\nusing GMT\n\nsubplot(grid=(2,1), autolabel=(Anchor=:TL, offset=0.8), margins=1, panel_size=(15,9))\n    histogram!(\"@v3206_06.txt\", limits=(-6000,0,0,30), pen=1, yaxis=(label=:Frequency, suffix=\" %\"),\n               axis=(axes=:WSne, title=:Histograms, xlabel=\"Topography (m)\", fill=:lightblue), fill=:orange, kind=(freq=true,), bin=250)\n           \n    rose(panel=:next, \"@fractures_06.txt\", limits=(0,1,0,360), swap_xy=true, sector=(width=10, rose=true),\n         norm=true, fill=:orange, axis=(grid=:auto, fill=:lightblue,), pen=1)\nsubplot(\"show\")"
  },
  {
    "objectID": "gallery/ex08.html",
    "href": "gallery/ex08.html",
    "title": "(8) A 3-D histogram",
    "section": "",
    "text": "The program [plot3d] allows us to plot three-dimensional symbols, including columnar plots. As a simple demonstration, we will convert a gridded netCDF of bathymetry into an ASCII xyz table and use the height information to draw a 2-D histogram in a 3-D perspective view. We also use the height information to set to color of each column via a CPT file. Our gridded bathymetry file is the 5 arc-minute global relief. Depth ranges from -5000 meter to sea-level. We produce the Figure by running this script:\n\nusing GMT\n\nC = makecpt(color=:cubhelix, T=(-5000,0))\nbar3(gmtread(\"@earth_relief_05m_g\", region=(0,5,0,5)), region=(0,5,0,5,-5000,0), base=-5000,\n     frame=(annot=1, axes=:WSneZ, title=:ETOPO5, cube=true),\n     zaxis=(annot=1000, label=\"Topography (m)\"), color=C,\n     lw=:thinnest, proj=:Mercator, figsize=12, zsize=13, view=(200,30))\ntext!(mat2ds([0.1 4.7], \"This is the surface of cube\"), JZ=true, Z=0,\n      font=(24,\"Helvetica-Bold\"), justify=:TL, show=true)"
  },
  {
    "objectID": "gallery/ex10.html",
    "href": "gallery/ex10.html",
    "title": "(10) A geographical bar graph plot",
    "section": "",
    "text": "Our next and perhaps most business-like example presents a three-dimensional bar graph plot showing the geographic distribution of all the languages of the world. The input data was taken from Ethnologue. We decide to plot a 3-D multi-band column centered on each continent with a height that is proportional to the languages used. We choose a plain linear projection for the basemap and add the multi-band columns and text on top. The different bands in the columns indicate how commonly the languages are used, from institutional languages to languages threatened by extinction. The script also shows how to effectively use transparency of the boxes around the numbers and in the shade surrounding the legend. Our script that produces Figure 10 reads:\n\nusing GMT\n\ncoast(region=:global, shore=:faint, land=:wheat, ocean=:azure2, area=5000,\n      view=(200,40), proj=(name=:PlateCarree, center=(0,37.5)))\nD = gmtread(\"@languages_10.txt\")\ntext!(vec(string.(Int.(sum(D[:, 3:end], dims=2)))), x=D[:,1], y=D[:,2],       # Sum by continents\n      font=(20,\"Helvetica-Bold\",\"firebrick=thinner\"), justify=:RM, fill=\"white@30\", offset=(-0.6,0))\ncpt = makecpt(color=(:purple, :blue, :darkgreen, :yellow, :red), range=\"0,1,2,3,4,5\")\nbar3!(D, region=(-180,180,-90,90,0,2500), color=cpt, bar=(width=0.6, Nbands=5),\n      frame=(axes=:WSneZ, annot=:auto, ticks=:auto, title=\"World Languages By Continent\"),\n      zaxis=(annot=500, label=:Languages), fill=:purple, lw=:thinner, zsize=8,\n      par=(FONT_TITLE=\"30p,Times-Bold\", MAP_TITLE_OFFSET=-1.8, FORMAT_GEO_MAP=:dddF), view=(200,40))\nlegend!(\"@legend_10.txt\", JZ=true, pos=(anchor=:LB, width=3.5, justify=:LB, offset=0.5),\n        par=(:FONT,\"Helvetica-Bold\"),\n        box=(fill=:lightgrey, pen=:thinner, shaded=\"-4p/-6p/grey20@40\"), show=true)"
  },
  {
    "objectID": "gallery/ex13.html",
    "href": "gallery/ex13.html",
    "title": "(13) Plotting of vector fields",
    "section": "",
    "text": "In many areas, such as fluid dynamics and elasticity, it is desirable to plot vector fields of various kinds. GMT provides a way to illustrate 2-component vector fields using the [grdvector] utility. The two components of the field (Cartesian or polar components) are stored in separate grid files. In this example we use grdmath to generate a surface and to calculate by returning the x- and y-derivatives separately. We superpose the gradient vector field and the surface z and also plot the components of the gradient in separate windows. A [text] call to place a header finishes the plot\n\nusing GMT\n\ngmtset(FONT_HEADING=\"40p,Times-Italic\",)\nGz = gmt(\"grdmath -R-2/2/-2/2 -I0.1 X Y R2 NEG EXP X MUL =\");\nGdzdx = gmt(\"grdmath ? DDX\", Gz);\nGdzdy = gmt(\"grdmath ? DDY\", Gz);\nsubplot(grid=(2,2), splot_size=15, margins=0.1, title=\"z(x,y) = x@~\\327@~exp(-x@+2@+-y@+2@+)\")\n    grdcontour(Gz, cont=0.05, annot=0.1, labels=(dist=5,), smooth=4, ticks=(gap=(0.25,0.08),))\n    subplot(:set, panel=(1,2))\n    grdcontour(Gz, cont=0.05, labels=(dist=5,), smooth=4)\n    grdvector(Gdzdx, Gdzdy, inc=0.2, arrow=(len=0.25, shape=0.5, stop=true, norm=0.6),\n              fill=:black, pen=1, vec_scale=2)\n    subplot(:set, panel=(2,1))\n    grdcontour(Gdzdx, cont=0.1, annot=0.5, labels=(dist=5,), smooth=4, ticks=(gap=(0.25,0.08),))\n    subplot(:set, panel=(2,2))\n    grdcontour(Gdzdy, cont=0.05, annot=0.2, labels=(dist=5,), smooth=4, ticks=(gap=(0.25,0.08),))\nsubplot(\"show\")"
  },
  {
    "objectID": "gallery/ex15.html",
    "href": "gallery/ex15.html",
    "title": "(15) Gridding, contouring, and masking of unconstrained areas",
    "section": "",
    "text": "This example demonstrates some off the different ways one can use to grid data in GMT, and how to deal with unconstrained areas. We first convert a large remote ASCII file to binary with [gmtconvert] since the binary file will read and process much faster. Our lower left plot illustrates the results of gridding using a nearest neighbor technique ([nearneighbor]) which is a local method: No output is given where there are no data. Next (lower right), we use a minimum curvature technique ([surface]) which is a global method. Hence, the contours cover the entire map although the data are only available for portions of the area (indicated by the gray areas plotted using [mask]). The top left scenario illustrates how we can create a clip path (using [mask]) based on the data coverage to eliminate contours outside the constrained area. Finally (top right) we simply employ coast to overlay gray land masses to cover up the unwanted contours, and end by plotting a red star at the deepest point on the map with [plot]. This point was extracted from the grid files using [grdinfo].\n\nusing GMT\n\nship_d = gmtread(\"@ship_15.txt\")\nregion = gmtinfo(ship_d, inc=1)\n\nR = region.text[1][3:end]\nGship  = nearneighbor(ship_d, region=R, inc=\"10m\", S=\"40k\")\ngrdcontour(Gship, frame=(axes=:WSne, annot=2), cont=250, annot=1000,\n           labels=(dist=5,), proj=:merc, figsize=7.5)\n\nship_10m = blockmedian(ship_d, region=R, inc=\"10m\")\nGship = surface(ship_10m, region=R, inc=\"10m\")\nmask!(ship_d, region=R, inc=\"10m\", fill=:lightgray, tiles=true, xshift=9.1)\ngrdcontour!(Gship, cont=250, annot=1000, labels=(dist=5,), range=(-8000,0), frame=:same)\n\nmask!(ship_10m, region=R, inc=\"10m\", xshift=-9.1, yshift=9.5, frame=:same)\ngrdcontour!(Gship, cont=250, annot=1000, labels=(dist=5,), range=(-8000,0))\nmask!(end_clip_path=true)   \n\nGship_clipped = grdclip(Gship, above=\"-1/NaN\")\ngrdcontour!(Gship_clipped, cont=250, annot=1000, labels=(dist=5,), range=(-8000,0), xshift=9.1)\ncoast!(land=:gray, shore=:thinnest, frame=:same)\ninfo = grdinfo(Gship, C=\"n\", minmax_pos=true)\nplot!(info, marker=:star, ms=0.4, i=\"10,11\", lw=:thick)\ntext!(text_record([-0.3 3.6], \"Gridding with missing data\"), region=(0,3,0,4),\n      font=(24,\"Helvetica-Bold\"), justify=:CB, no_clip=true, figscale=2.5,\n      proj=:linear, show=true)"
  },
  {
    "objectID": "gallery/ex17.html",
    "href": "gallery/ex17.html",
    "title": "(17) Images clipped by coastlines",
    "section": "",
    "text": "This example demonstrates how [coast] can be used to set up clip paths based on coastlines. This approach is well suited when different gridded data sets are to be merged on a plot using different CPTs. Merging the files themselves may not be doable since they may represent different data sets, as we show in this example. Here, we lay down a color map of the geoid field near India with [grdimage], use [coast] to set up land clip paths, and then overlay topography from the ETOPO5 data set with another call to [grdimage].\nWe also plot a color legend on top of the land. So here we basically have three layers of “paint” stacked on top of each other: the underlying geoid map, the land mask, and finally the color legend. This legend makes clear how [grd2cpt] distributed the colors over the range: they are not of equal length put are associated with equal amounts of area in the plot. Since the high amounts (in red) are not very prevalent, that color spans a long range.\nFor this image it is appropriate to use the shade option in colorbar so the legend gets shaded, similar to the geoid grid. See [Of Colors and Color Legends] to learn more about CPTs and ways to draw color legends.\n\nusing GMT\n\nCgeoid = grd2cpt(\"@india_geoid.nc\");\nCgray  = makecpt(cmap=150, range=\"-10000,10000\", nobg=true);\nsealand(grdimage, \"@india_geoid.nc\", (region=\"@india_geoid.nc\", shade=\"+d\", proj=:Merc,\n                                      cmap=Cgeoid, title=\"Clipping of Images\"),\n        grdimage, \"@india_topo.nc\", (shade=\"+d\", cmap=Cgray), shore=0.5)\ncolorbar!(pos=(inside=true, anchor=:TR, offset=(0.8,0.2), size=(10,0.5), horizontal=true),\n          cmap=Cgeoid, xaxis=(annot=5, ticks=1), ylabel=:m, shade=true)\n\n# Add a text paragraph\nt = [\"@_@%5%Example 17.@%%@_  We first plot the color geoid image\"\n    \"for the entire region, followed by a gray-shaded @#etopo5@#\"\n    \"image that is clipped so it is only visible inside the coastlines.\"]\ntext!(mat2ds(t, hdr=\"&gt; 90 -10 12p 8c j\"), paragraph=true, fill=:white, pen=:thinner,\n      clearance=(round=true,), offset=(-0.25,0.25), font=(12,\"Times-Roman\"), justify=:RB, show=true)"
  },
  {
    "objectID": "gallery/ex19.html",
    "href": "gallery/ex19.html",
    "title": "(19) Color patterns on maps",
    "section": "",
    "text": "GMT supports color patterns and this example gives a few cases of how to use this new feature. We make a phony poster that advertises an international conference on GMT in Honolulu. We use grdmath, [makecpt], and [grdimage] to draw pleasing color backgrounds on maps, and overlay [coast] clip paths to have the patterns change at the coastlines. The middle panel demonstrates a simple coast call where the built-in pattern # 86 is drawn at 100 dpi but with the black and white pixels replaced with color combinations. At the same time the ocean is filled with a repeating image of a circuit board (provides in PNG raster format). The text GMT in the center is an off-line PostScript file that was overlaid using [image]. The final panel in the 3 by 1 [subplot] sequence repeats the top panel except that the land and sea images have changed places.\n\nusing GMT\n\nGlat = gmt(\"grdmath -Rd -I1 -r Y COSD 2 POW =\")\nGlon = gmt(\"grdmath -Rd -I1 -r X =\")\nlat_cpt = makecpt(color=\"white,blue\", range=(0,1), continuous=true, no_bg=true)\nlon_cpt = makecpt(cmap=:rainbow, range=(-180,180))\ngrdimage(Glat, cmap=lat_cpt, frame=:none, interp=:l, proj=:sinu, figsize=16, yshift=18)\ncoast!(area=5000, clip=:land)\ngrdimage!(Glon, cmap=lon_cpt, interp=:l)\ncoast!(clip=:end)\ncoast!(area=5000, shore=:thinnest)\ntext!(text_record([0 20], \"16TH INTERNATIONAL\"), font=(32,\"Helvetica-Bold\",\"red=thinner\"))\ntext!(text_record([0 -10], \"GMT CONFERENCE\"), font=(32,\"Helvetica-Bold\",\"red=thinner\"))\ntext!(text_record([0 -30], \"Honolulu, Hawaii, April 1, 2019\"), font=(18,\"Helvetica-Bold\",\"green=thinner\"))\n\n# Then show example of color patterns and placing a PostScript image\ncoast!(area=5000, land=(pattern=86, bg=:yellow, fg=:red, dpi=100), water=(pattern=\"@circuit.png\", dpi=100), frame=:none, yshift=-8)\ntext!(text_record([0 30], \"SILLY USES OF\"), font=(32,\"Helvetica-Bold\",\"lightgreen=thinner\"))\ntext!(text_record([0 -30], \"COLOR PATTERNS\"), font=(32,\"Helvetica-Bold\",\"magenta=thinner\"))\npsimage!(\"@GMT_covertext.eps\", D=\"jCM+w3i\")\n\n# Finally repeat 1st plot but exchange the patterns\ngrdimage!(Glon, cmap=lon_cpt, frame=:none, interp=:l, yshift=-8)\ncoast!(area=5000, clip=:land)\ngrdimage!(Glat, cmap=lat_cpt, interp=:l)\ncoast!(clip=:end)\ncoast!(area=5000, shore=:thinnest)\ntext!(text_record([0  20], \"15TH INTERNATIONAL\"), font=(32,\"Helvetica-Bold\",\"red=thinner\"))\ntext!(text_record([0 -10], \"GMT CONFERENCE\"), font=(32,\"Helvetica-Bold\",\"red=thinner\"))\ntext!(text_record([0 -30], \"Honolulu, Hawaii, April 1, 2018\"), font=(18,\"Helvetica-Bold\",\"green=thinner\"), show=true)"
  },
  {
    "objectID": "gallery/ex21.html",
    "href": "gallery/ex21.html",
    "title": "(21) Time-series of RedHat stock price",
    "section": "",
    "text": "As discussed in the Technical Reference Section Cartesian time axes, the annotation of time-series is generally more complicated due to the extra degrees of freedom afforded by the dual annotation system. In this example we will display the trend of the stock price of RedHat (RHAT) from their initial public offering until late 2006. The data file is a comma-separated table and the records look like this:\n\nDate,Open,High,Low,Close,Volume,Adj.Close*\n12-Mar-04,17.74,18.49,17.67,18.02,4827500,18.02\n11-Mar-04,17.60,18.90,17.37,18.09,7700400,18.09\n\n\nUndefVarError: `Date` not defined\n\nStacktrace:\n [1] top-level scope\n   @ In[2]:1\n\n\n\nHence, we have a single header record and various prices in USD for each day of business. We will plot the trend of the opening price as a red line superimposed on a yellow envelope representing the low-to-high fluctuation during each day. We also indicate when and at what cost Paul Wessel bought a few shares, and zoom in on the developments since 2004; in the inset we label the time-axis in Finnish in honor of Linus Thorvalds. Because the time coordinates are Y2K-challenged and the order is backwards (big units of years come after smaller units like days) we must change the default input/output formats used by GMT. Finally, we want to prefix prices with the $ symbol to indicate the currency. Here is how it all comes out:\n\nusing GMT\n\ngmtbegin()\ngmtset(FORMAT_DATE_IN=\"dd-o-yy\", FORMAT_DATE_MAP=:o, FONT_ANNOT_PRIMARY=\"+10p\",\n       FORMAT_TIME_PRIMARY_MAP=:abbreviated, PS_CHAR_ENCODING=\"ISOLatin1+\")\n\n# Unfortunately, for time data some things must be numeric (seconds) other time strings\nwesn = gmtinfo(\"@RHAT_price.csv\", f=:T, inc=50, per_column=true)\n\n# This provides the min/max time as a time string (1999-08-11T00:00:00/2007-12-31T00:00:00/0.0/300.0)\nR = gmtinfo(\"@RHAT_price.csv\", f=:T, inc=50)   # The output is a cell\nR = R.text[1][3:end]\nwT, eT, sF, = split(R, '/')\n\n# Lay down the basemap:\nbasemap(region=R, frame=(axes=:WSen, title=\"RedHat (RHT) Stock Price Trend since IPO\", fill=:lightgreen),\n        xaxis=(annot=3, annot_unit=:month, ticks=1, ticks_unit=\"month2\"),\n        yaxis=(annot=50, prefix=\"\\$ \",), xaxis2=(annot=1, annot_unit=:year), figsize=(22,15), portrait=false)\n\n# Plot main window with open price as red line over yellow envelope of low/highs\nRHAT1_env = gmtconvert(\"@RHAT_price.csv\", outcols=\"0,2\", colinfo=\"0T\")\nRHAT2_env = gmtconvert(\"@RHAT_price.csv\", outcols=\"0,3\", colinfo=\"0T\", reverse=true, suppress=true)\nRHAT_env = [RHAT1_env.data; RHAT2_env.data]\nplot!(RHAT_env, fill=:yellow)\nplot!(\"@RHAT_price.csv\", lw=:thin, lc=:red)\n\n# Draw P Wessel's purchase price as line and label it.  Note we temporary switch\n# back to default yyyy-mm-dd format since that is what gmt info gave us.\nfid = open(\"RHAT.pw\",\"w\")\nprintln(fid, \"05-May-00 0\")\nprintln(fid, \"05-May-00 300\")\nclose(fid)\nplot!(\"RHAT.pw\", lw=:thinner, ls=:dash, f=:T)\nfid = open(\"RHAT.pw\",\"w\")\nprintln(fid, \"01-Jan-99 25\")\nprintln(fid, \"01-Jan-02 25\")\nclose(fid)\nplot!(\"RHAT.pw\", lw=:thick, ls=:dash, f=:T)\ntext!(mat2ds([wesn.data[1] 25], \"PW buy\"), offset=(3.8, 0.15), font=(12, \"Bookman-Demi\"), justify=:LB)\n\n# Draw P Wessel's sales price as line and label it.\nfid = open(\"RHAT.pw\",\"w\")\nprintln(fid, \"25-Jun-07 0\")\nprintln(fid, \"25-Jun-07 300\")\nclose(fid)\nplot!(\"RHAT.pw\", lw=:thinner, ls=:dash, f=:T)\nfid = open(\"RHAT.pw\",\"w\")\nprintln(fid, \"01-Aug-06 23.8852\");\nprintln(fid, \"01-Jan-08 23.8852\");\nclose(fid);\nplot!(\"RHAT.pw\", lw=:thick, ls=:dash, f=:T)\ntext!(mat2ds([wesn.data[2] 23.8852], \"PW sell\"), offset=(-2, 0.15), font=(12, \"Bookman-Demi\"), justify=:RB)\n\n# Get smaller region for insert for trend since 2004\nR = \"2004T/\" * eT * '/' * sF * \"/40\"\n\n# Lay down the basemap, using Finnish annotations and place the insert in the upper right\nbasemap!(region=R, frame=(axes=:ESw, fill=:lightblue),\n         xaxis=(annot=3, annot_unit=:month, ticks=3, ticks_unit=\"month2\"),\n         yaxis=(annot=10, prefix=\"\\$ \",), xaxis2=(annot=1, annot_unit=:year),\n         proj=:linear, figsize=(15, 7.5), xshift=7, yshift=7.5, par=(:GMT_LANGUAGE, :fi))\n\n# Again, plot close price as red line over yellow envelope of low/highs\nplot!(RHAT_env, fill=:yellow)\nplot!(\"@RHAT_price.csv\", lw=:thin, lc=:red)\n\n# Draw P Wessel's sales price as dashed line\nplot!(\"RHAT.pw\", lw=:thick, ls=:dash, f=:T)\n\n# Mark sales date\nfid = open(\"RHAT.pw\",\"w\")\nprintln(fid, \"25-Jun-07 0\")\nprintln(fid, \"25-Jun-07 300\")\nclose(fid)\nplot!(\"RHAT.pw\", lw=:thinner, ls=:dash, f=:T)\nrm(\"RHAT.pw\")\ngmtend(:show)\n\ngmt2kml [WARNING]: Column selected for latitude-formatting has values that exceed +/- 90; set to NaN"
  },
  {
    "objectID": "gallery/ex23.html",
    "href": "gallery/ex23.html",
    "title": "(23) All great-circle paths lead to Rome",
    "section": "",
    "text": "While motorists recently have started to question the old saying “all roads lead to Rome”, aircraft pilots have known from the start that only one great-circle path connects the points of departure and arrival 1. This provides the inspiration for our next example which uses grdmath to calculate distances from Rome to anywhere on Earth and [grdcontour] to contour these distances. We pick five cities that we connect to Rome with great circle arcs, and label these cities with their names and distances (in km) from Rome, all laid down on top of a beautiful world map. Note that we specify that contour labels only be placed along the straight map-line connecting Rome to its antipode, and request curved labels that follows the shape of the contours.\nThe script produces the plot in Figure; note how interesting the path to Seattle appears in this particular projection (Hammer). We also note that Rome’s antipode lies somewhere near the Chatham plateau (antipodes will be revisited in Example [(25) Global distribution of antipodes]).\n\nusing GMT\nresetGMT() # hide\n\nlon  = 12.50\nlat  = 41.99\nGdist = gmt(\"grdmath -Rg -I1 12.5 41.99 SDIST\")\n\ncoast(region=:global, land=:lightgreen, ocean=:blue, shore=:thinnest, area=1000,\n      frame=(grid=30, title=\"Distances from Rome to the World\"),\n      proj=(name=:Hammer, center=90), figsize=20, portrait=false)\ngrdcontour!(Gdist, annot=(int=1000, labels=(curved=true, unit=\"\\\" km\\\"\", font=\"white\")),\n            labels=(line=\"Z-/Z+\",), smooth=8, cont=500,\n            pen=((contour=true,pen=\"thinnest,white,-\"), (annot=true, pen=\"thin,white\")) )\n\n# Location info for 5 other cities + label justification\ncities = [105.87 21.02; 282.95  -12.1; 178.42 -18.13; 237.67 47.58; 28.20 -25.75];\njust_names = [\"LM HANOI\", \"LM LIMA\", \"LM SUVA\", \"RM SEATTLE\", \"LM PRETORIA\"];\nD = mat2ds(cities, just_names)\n\n# For each of the cities, plot great circle arc to Rome with gmt psxy\nplot!([lon lat; 105.87 21.02], lw=:thickest, lc=:red)\nplot!([lon lat; 282.95 -12.1], lw=:thickest, lc=:red)\nplot!([lon lat; 178.42 -18.13],lw=:thickest, lc=:red)\nplot!([lon lat; 237.67 47.58], lw=:thickest, lc=:red)\nplot!([lon lat; 28.20 -25.75], lw=:thickest, lc=:red)\n\n# Plot red squares at cities and plot names:\nplot!(cities, marker=:square, ms=0.2, fill=:red, markerline=:thinnest)\ntext!(D, offset=(away=true, shift=(0.15,0)), font=(12,\"Courier-Bold\",:red),\n      justify=true, no_clip=true)\n\n# Place a yellow star at Rome\nplot!([12.5 41.99], marker=:star, ms=0.5, fill=:yellow, ml=:thin)\n\n# Sample the distance grid at the cities and use the distance in km for labels\ndist = grdtrack(Gdist, D);\ntext!(dist, offset=(0, -0.5), noclip=true, fill=:white, pen=true, clearance=0.05,\n      font=(12,\"Helvetica-Bold\"), justify=:CT, zvalues=\"%.0f\", show=true)"
  },
  {
    "objectID": "gallery/ex25.html",
    "href": "gallery/ex25.html",
    "title": "(25) Global distribution of antipodes",
    "section": "",
    "text": "As promised in Example [(23) All great-circle paths lead to Rome], we will study antipodes. The antipode of a point at is the point at . We seek an answer to the question that has plagued so many for so long: Given the distribution of land and ocean, how often is the antipode of a point on land also on land? And what about marine antipodes? We use [grdlandmask] and grdmath to map these distributions and calculate the area of the Earth (in percent) that goes with each of the three possibilities. To make sense of our grdmath equations below, note that we first calculate a grid that is +1 when a point and its antipode is on land, -1 if both are in the ocean, and 0 elsewhere. We then seek to calculate the area distribution of dry antipodes by only pulling out the nodes that equal +1. As each point represent an area approximated by where the term’s actual dimension depends on, we need to allow for that shrinkage, normalize our sum to that of the whole area of the Earth, and finally convert that ratio to percent. Since the , terms appear twice in these expressions they cancel out, leaving the somewhat intractable expressions below where the sum of for all is known to equal\nIn the end we obtain a funny-looking map depicting the antipodal distribution as well as displaying in legend form the requested percentages. Note that the script is set to evaluate a global 30 minute grid for expediency (D = 30), hence several smaller land masses that do have terrestrial antipodes do not show up. If you want a more accurate map you can set the parameter D to a smaller increment (try 5 and wait a few minutes).\nThe call to [grdimage] includes the interp=:n to suspend interpolation and only return the value of the nearest neighbor. This option is particularly practical for plotting categorical data, like these, that should not be interpolated.\n\nusing GMT, Printf\nresetGMT() # hide\n\nGwetdry = grdlandmask(region=:global360, inc=\"30m\", res=:crude, area=500, N=\"-1/1/1/1/1\", reg=true);\n# Manipulate so -1 means ocean/ocean antipode, +1 = land/land, and 0 elsewhere\nGkey = gmt(\"grdmath -fg ? DUP 180 ROTX FLIPUD ADD 2 DIV =\", Gwetdry);\n# Calculate percentage area of each type of antipode match.\nGscale = gmt(\"grdmath -Rg -I30m -r Y COSD 60 30 DIV 360 MUL DUP MUL PI DIV DIV 100 MUL =\");\nGtmp   = gmt(\"grdmath -fg ? -1 EQ 0 NAN =\", Gkey);\nGtmp  *= Gscale;\n\nkey    = grd2xyz(Gtmp, skip_NaN=true, onecol=:TLf);\nocean  = gmt(\"gmtmath -bi1f -Ca -S ? SUM UPPER RINT =\", key);\nGtmp   = gmt(\"grdmath -fg ? 1 EQ 0 NAN =\", Gkey)\nGtmp  *= Gscale;\nkey    = grd2xyz(Gtmp, skip_NaN=true, onecol=:TLf)\nland   = gmt(\"gmtmath -bi1f -Ca -S ? SUM UPPER RINT =\", key)\nGtmp   = gmt(\"grdmath -fg ? 0 EQ 0 NAN\", Gkey)\nGtmp  *= Gscale;\nkey    = grd2xyz(Gtmp, skip_NaN=true, onecol=:TLf)\nmixed  = gmt(\"gmtmath -bi1f -Ca -S ? SUM UPPER RINT =\", key)\n\n# Generate corresponding color table\nC = makecpt(color=\"blue,gray,red\", range=(-1.5,1.5,1))\n# But unfortunately this palette is not correct, so lets patch it\nC.colormap[1,1:2] .= 0;   C.colormap[1,3] = 1;\nC.colormap[3,2:3] .= 0;   C.colormap[3,1] = 1;\n\n# Create the final plot and overlay coastlines\ngmtset(FONT_ANNOT_PRIMARY=\"+8p\", FORMAT_GEO_MAP=:dddF)\ngrdimage(Gkey, proj=(name=:EckertVI, center=180), frame=(axes=:WsNE, title=\"Antipodal comparisons\"),\n         xaxis=(annot=60,), yaxis=(annot=30,), yshift=3, interp=:n)\ncoast!(shore=:thinnest, area=500)\n\n# Place an explanatory legend below\nlegend!(pos=(anchor=:BC, width=10), box=(pen=:thick,), yshift=-1.0, par=(:FONT_ANNOT_PRIMARY,7),\n    text_record([\"N 3\"\n    string(\"S 0.3 s 0.25 red  0.25p 0.5 Terrestrial Antipodes [\", round(Int, land.data[1]), \" %]\", )\n    string(\"S 0.3 s 0.25 blue 0.25p 0.5 Oceanic Antipodes [\", round(Int, ocean.data[1]), \" %]\", )\n    string(\"S 0.3 s 0.25 gray 0.25p 0.5 Mixed Antipodes [\", round(Int, mixed.data[1]), \" %]\", )]), show=true)"
  },
  {
    "objectID": "gallery/ex27.html",
    "href": "gallery/ex27.html",
    "title": "(27) Plotting Sandwell/Smith Mercator img grids",
    "section": "",
    "text": "Next, we show how to plot a data grid that is distributed in projected form. The gravity and predicted bathymetry grids produced by David Sandwell and Walter H. F. Smith are not geographical grids but instead given on a spherical Mercator grid. The GMT supplement imgsrc has tools to extract subsets of these large grids. If you need to make a non-Mercator map then you must extract a geographic grid using img2grd and then plot it using your desired map projection. However, if you want to make a Mercator map then you can save time and preserve data quality by avoiding to re-project the data set twice since it is already in a Mercator projection. This example shows how this is accomplished. We have used the -M option in img2grd 1 to pull out the grid in Mercator units (i.e., do not invert the Mercator projection) and then simply plot this remote grid using a linear projection with a suitable scale (here 0.25 inches per degrees of longitude). To overlay basemaps and features that has geographic longitude/latitude coordinates we must remember two key issues:\n- This is a spherical Mercator grid so we must use ``par=(PROJ_ELLIPSOID=:Sphere,)`` with all\ncommands that involve projections (or use gmtset to change the setting).\n\n- Select Mercator projection and use the same scale that was used with the linear projection.\nThis map of the Tasman Sea shows the marine gravity anomalies with land painted black. A color scale bar was then added to complete the illustration.\n\nusing GMT\nresetGMT() # hide\n\n# Gravity in tasman_grav.nc is in 0.1 mGal increments and the grid\n# is already in projected Mercator x/y units.\n\n# Make a suitable cpt file for mGal\ngrav_cpt = makecpt(range=(-120,120))\n\n# Since this is a Mercator grid we use a linear projection\ngrdimage(\"@tasman_grav.nc=ns+s0.1\", frame=:none, shade=:default, figscale=0.635)\n\n# Then use gmt pscoast to plot land; get original -R from grid remark\n# and use Mercator gmt projection with same scale as above on a spherical Earth\nR = grdinfo(\"@tasman_grav.nc\", nearest=:i)\nR = R.text[1][3:end]\ncoast!(region=R, proj=:merc, figscale=0.635, frame=(axes=:WSne, annot=10, ticks=5),\n       land=:black, river_fill=:white, res=:high,\n       par=(FORMAT_GEO_MAP=\"dddF\", PROJ_ELLIPSOID=:Sphere))\n\n# Put a color legend in top-left corner of the land mask\ncolorbar!(region=R, pos=(inside=true, anchor=:TL, offset=1, length=(5, 0.4)),\n          xaxis=(annot=50, ticks=10), ylabel=\"mGal\", shade=true, box=(pen=1, fill=:white), show=true)"
  },
  {
    "objectID": "gallery/ex29.html",
    "href": "gallery/ex29.html",
    "title": "(29) Gridding spherical surface data using splines",
    "section": "",
    "text": "Finally, we demonstrate how gridding on a spherical surface can be accomplished using Green’s functions of surface splines, with or without tension. Global gridding does not work particularly well in Cartesian coordinates hence the chosen approach. We use [greenspline] to produce a crude topography grid for Mars based on radii estimates from the Mariner 9 and Viking Orbiter spacecrafts. This data comes from Smith and Zuber [Science, 1996] and is used here as a small (N = 370) remote data set we can use to demonstrate spherical surface gridding. Since [greenspline] must solve a N by N matrix system your system memory may impose limits on how large data sets you can handle; also note that the spherical surface spline in tension is particularly slow to compute.\nOur script must first estimate the ellipsoidal shape of Mars from the parameters given by Smith and Zuber so that we can remove this reference surface from the gridded radii. We run the gridding twice: First with no tension using Parker‘s [1990] method and then with tension using the Wessel and Becker [2008] method. The grids are then imaged with grdimage and grdcontour and a color bar is placed between them.\n\nusing GMT\nresetGMT() # hide\n\n# Make Mars PROJ_ELLIPSOID given their three best-fitting axes:\na = 3399.472; b = 3394.329; c = 3376.502;\nGproj_ellipsoid = gmt(\"grdmath -Rg -I4 -r X COSD \" * \"$a\" * \" DIV DUP MUL X SIND \" * \"$b\" * \n                      \" DIV DUP MUL ADD Y COSD DUP MUL MUL Y SIND \" * \"$c\" * \" DIV DUP MUL ADD SQRT INV =\")\n#  Do both Parker and Wessel/Becker solutions (tension = 0.9975)\nGmars  = greenspline(\"@mars370.txt\", region=:global360, inc=4, reg=true,  grid=true, mode=4, splines=:p)\nGmars2 = gmt(\"greenspline -R? @mars370.txt -D4 -Sq0.9975 -G\", Gproj_ellipsoid);\n# Scale to km and remove PROJ_ELLIPSOID\nGmars  = Gmars  / 1000 - Gproj_ellipsoid\nGmars2 = Gmars2 / 1000 - Gproj_ellipsoid\nmars_cpt = makecpt(cmap=:rainbow, range=(-7,15));\n\ngrdimage(Gmars2, region=:global360, shade=(azim=45, norm=\"e0.75\"),\nframe=(axes=:Wsne, annot=30, grid=30), proj=(name=:Hammer, center=0), xshift=2)\ngrdcontour!(Gmars2, cont=1, annot=5, labels=(line=\"z+/z-\",))\nplot!(\"@mars370.txt\", marker=:circle, ms=0.1, fill=:black)\ntext!(mat2ds([0 90], \"b)\"), noclip=true, offset=(-9, -0.5), font=(14,\"Helvetica-Bold\"), justify=:LB)\n\ngrdimage!(Gmars, frame=:same, shade=(azim=45, norm=\"e0.75\"), yshift=9, dpi=200)\ngrdcontour!(Gmars, cont=1, annot=5, labels=(line=\"z+/z-\",))\nplot!(\"@mars370.txt\", marker=:circle, ms=0.1, fill=:black )\ncolorbar!(pos=(anchor=:BC, offset=(0,0.4), length=(12, 0.25), horizontal=true),\n          shade=true, frame=(annot=2, ticks=1), ylabel=:km)\ntext!(text_record([0 90], \"a)\"), noclip=true, offset=(-9, -0.5),\n      font=(14,\"Helvetica-Bold\"), justify=:LB, show=true)"
  },
  {
    "objectID": "gallery/ex33.html",
    "href": "gallery/ex33.html",
    "title": "(33) Stacking automatically generated cross-profiles",
    "section": "",
    "text": "The script produces the plot in Figure. Here we demonstrate how [grdtrack] can be used to automatically create a suite of crossing profiles of uniform spacing and length and then sample one or more grids along these profiles; we also use the median stacking option to create a stacked profile, showed above the map, with the gray area representing the 2σ confidence bounds on the stacked median profile.\n\nusing GMT\nresetGMT() # hide\n\nmakecpt(cmap=:rainbow, range=(-5000,-2000))\nG = grdcut(\"@earth_relief_01m\", region=(-118,-107,-49,-42))\ngrdimage(G, shade=(angle=15, norm=\"e0.75\"), proj=:merc)\n#resetGMT()        # Need to find a fix for this. It lets the API in a geog mode\n\n# Select two points along the ridge\nridge_pts = [-111.6 -43.0; -113.3 -47.5];\n\n# Plot ridge segment and end points\nplot!(ridge_pts, region=G, symbol=(symb=:circle, size=0.25), fill=:blue, pen=(2,:blue))\n\n# Generate cross-profiles 400 km long, spaced 10 km, samped every 2km\n# and stack these using the median, write stacked profile\ntable, stack = grdtrack(G, ridge_pts, equidistant=\"400k/2k/10k+v\", stack=\"m+s\")\nplot!(table, pen=0.5)\n\n# Show upper/lower values encountered as an envelope\nplot!(stack[:,[1,2,6,7]], region=(-200,200,-3500,-2000), frame=(axes=:WSne, annot=:auto, ticks=:auto),\n      xaxis=(grid=1000, label=\"Distance from ridge (km)\"), ylabel=\"Depth (m)\",\n      figsize=(15,7.5), fill=:lightgray, close=(envelope=true,), yshift=16)\nplot!(stack, pen=3)\ntext!(mat2ds([0 -2000], \"MEDIAN STACKED PROFILE\"), fill=:white, font=14, justify=:TC,\n      offset=(away=true, shift=0.25), show=true)"
  },
  {
    "objectID": "gallery/ex35.html",
    "href": "gallery/ex35.html",
    "title": "(35) Spherical triangulation and distance calculations",
    "section": "",
    "text": "The script produces the plot in Figure. Here we demonstrate how [sphtriangulate] and [sphdistance] are used to compute the Delauney and Voronoi information on a sphere, using a decimated GSHHG crude coastline. We show a color image of the distances, highlighted with 500-km contours, and overlay the Voronoi polygons in green. Finally, the continents are placed on top.\n\nusing GMT\nresetGMT() # hide\n\npol, nodes = sphtriangulate(\"@gshhs_c.txt\", voronoi=:v, skip=true, nodes=true)\n\n# Compute distances in km\nGtt = sphdistance(pol, region=:global360, inc=1, voronoi=true, nodes=nodes, dist_unit=:k)\nt_cpt = makecpt(cmap=:hot, range=(0,3500))\n\n# Make a basic image plot and overlay contours, Voronoi polygons and coastlines\ngrdimage(Gtt, proj=(name=:ortho, center=(-140,30)), figsize=16, xshift=2, yshift=5)\ngrdcontour!(Gtt, cont=500, annot=(int=1000, labels=(font=(10,:Helvetica,:white),)),\n            range=500, labels=(Line=[0 90 203 -10; 175 60 170 -30; -50 30 220 -5],),\n            pen=((annot=true, pen=(0.75,:white)), (contour=true, pen=(0.25,:white))) )\n\nplot!(pol, pen=(0.25, :green, :dotted))\ncoast!(shore=1, land=:steelblue, area=(0,1,1),\n       frame=(annot=30, grid=30, title=\"Distances from GSHHG crude coastlines\"), show=true)\n\nsphtriangulate [WARNING]: Skipped 21 duplicate points in segments"
  },
  {
    "objectID": "gallery/ex40.html",
    "href": "gallery/ex40.html",
    "title": "(40) Line simplification",
    "section": "",
    "text": "This example demonstrate the Douglas-Peucker line simplification algorithm as implemented in the tool [gmtsimplify]. We show the full resolution coastline of Australia and two much simplified versions using two different thresholds.\n\nusing GMT, Printf\nresetGMT() # hide\n\n# Interpolate data of Mars radius from Mariner9 and Viking Orbiter spacecrafts\nmakecpt(cmap=:rainbow, range=(-7000,15000))\n\ncentroid = gmtspatial(\"@GSHHS_h_Australia.txt\", colinfo=:g, length=:k)\nbasemap(region=(112,154,-40,-10), proj=:Merc, figsize=14, frame=(axes=:WSne, annot=20, bg=[240,255,240]))\nplot!(\"@GSHHS_h_Australia.txt\", pen=:faint, fill=(240,255,240))\nplot!(\"@GSHHS_h_Australia.txt\", ms=0.025, fill=:red)\nT500k = gmtsimplify(\"@GSHHS_h_Australia.txt\", tolerance=\"500k\");\nt = gmtspatial(\"@GSHHS_h_Australia.txt\", colinfo=:g, length=:k);\narea = @sprintf(\"Full area = %.0f km@+2@+\", t.data[3]);\nt = gmtspatial(T500k, colinfo=:g, length=:k); \narea_T500k = @sprintf(\"Reduced area = %.0f km@+2@+\", t.data[3]);\nplot!(T500k, pen=(1,:blue))\nplot!(centroid, marker=:cross, ms=0.75, ml=3)\ntext!(text_record([112 -10], \"T = 500 km\"), offset=(away=true, shift=(0.25,0.25)), font=18, justify=:TL)\ntext!(text_record(area), font=14, region_justify=:CM)\ntext!(text_record(area_T500k), font=14, region_justify=:LB, offset=(away=true, shift=0.5))\nbasemap!(frame=(axes=:Wsne, annot=20, bg=[240,255,240]), yshift=12)\nplot!(\"@GSHHS_h_Australia.txt\", pen=:faint, fill=(240,255,240))\nplot!(\"@GSHHS_h_Australia.txt\", ms=0.025, fill=:red)\nT100k = gmtsimplify(\"@GSHHS_h_Australia.txt\", tolerance=\"100k\");\nt = gmtspatial(T100k, colinfo=:g, length=:k);\narea_T100k = @sprintf(\"Reduced area = %.0f km@+2@+\", t.data[3]);\nplot!(T100k, pen=(1,:blue))\nplot!(centroid, marker=:cross, ms=0.75, ml=3)\ntext!(text_record([112 -10], \"T = 100 km\"), offset=(away=true, shift=(0.25,0.25)), font=18, justify=:TL)\ntext!(text_record(area), font=14, region_justify=:CM)\ntext!(text_record(area_T100k), font=14, region_justify=:LB, offset=(away=true, shift=0.5), show=true)"
  },
  {
    "objectID": "gallery/ex42.html",
    "href": "gallery/ex42.html",
    "title": "(42) Antarctica and stereographic data",
    "section": "",
    "text": "In this example we demonstrate how one can use combine Cartesian data for Antarctica (here the BEDMAP data already projected via a stereographic projection) with geographic data, all using the same map scale. It also shows how one would set up minor legends and map scales.\n\nusing GMT\nresetGMT() # hide\n\n# Data obtained via website and converted to netCDF thus:\n# curl http://www.antarctica.ac.uk//bas_research/data/access/bedmap/download/bedelev.asc.gz\n# gunzip bedelev.asc.gz\n# grdreformat bedelev.asc BEDMAP_elevation.nc=ns -V\nmakecpt(cmap=:earth, range=(-7000,4000))\ngrdimage(\"@BEDMAP_elevation.nc\", frame=:none, proj=:linear, figscale=\"1:60000000\", nan_alpha=true)\ncoast!(region=(-180,180,-90,-60), frame=\"afg\", proj=(name=:stere, center=(0,-90), parallel=-71),\n       figscale=\"1:60000000\", shore=0.25)\ncolorbar!(pos=(inside=true, anchor=:RM, length=(6.4,0.5), offset=(1.25,0), justify=:LM, neon=true),\n          box=(pen=true, inner=true), xaxis=(annot=1000, label=:ELEVATION), ylabel=:m)\n\n# GSHHG\ncoast!(land=:lightblue, water=:royalblue2, frame=\"none\", xshift=5, yshift=12)\ncoast!(land=:lightbrown, frame=\"afg\", area=\"+ag\")\nlegend!(region=(-180,180,-90,-60), box=(pen=true, inner=true),\n        pos=(inside=true, anchor=:LM, width=4.3, justify=:RM, offset=(1.25,0)),\n        mat2ds([\"H 18p,Times-Roman Legend\"\n               \"D 0.1i 1p\"\n               \"S 0.15i s 0.2i blue  0.25p 0.3i Ocean\"\n               \"S 0.15i s 0.2i lightblue  0.25p 0.3i Ice front\"\n               \"S 0.15i s 0.2i lightbrown  0.25p 0.3i Grounding line\"])\n       )\n\n# Fancy line\nplot!(region=(0,7.5,0,10), proj=:linear, figscale=2.5, frame=:bare, lw=2,\n      xshift=-6.35, yshift=-13.3,\n      [0 5.55\n      2.5 5.55\n      5.0 4.55\n      7.5 4.55])\n\ntext!(text_record([0 5.2; 0 9.65], [\"BEDMAP\", \"GSHHG\"]), font=18, justify=:BL,\n      offset=(away=true, shift=(0.25,0)), show=true)"
  },
  {
    "objectID": "gallery/ex45.html",
    "href": "gallery/ex45.html",
    "title": "(45) Trend modeling",
    "section": "",
    "text": "In this example show how the module [trend1d] is used to fit the CO2 data set collected from the top of Mauna Loa. This yields the famous Keeling curve.\n\nusing GMT\nresetGMT() # hide\n\n# Basic LS line y = a + bx\nmodel = trend1d(\"@MaunaLoa_CO2.txt\", output=:xm, model=:p1)\nplot(\"@MaunaLoa_CO2.txt\", region=(1958,2016,310,410), frame=(axes=:WSen, bg=:azure1),\n     xaxis=(annot=:auto, ticks=:auto), yaxis=(annot=:auto, ticks=:auto, suffix=\" ppm\"),\n     marker=:circle, ms=0.05, fill=:red, figsize=(15,5), xshift=4)\nplot!(model, pen=(0.5,:blue))\ntext!(mat2ds(\"m@-2@-(t) = a + b@~\\\\327@~t\"), font=12, region_justify=:TL,\n      offset=(away=true, shift=0.25), fill=:lightyellow)\n\n# Basic LS line y = a + bx + cx^2\nmodel = trend1d(\"@MaunaLoa_CO2.txt\", output=:xm, model=:p2)\nplot!(\"@MaunaLoa_CO2.txt\", frame=:same, ms=0.05, fill=:red, yshift=6)\nplot!(model, pen=(0.5,:blue))\ntext!(mat2ds(\"m@-3@-(t) = a + b@~\\\\327@~t + c@~\\\\327@~t@+2@+\"), font=12,\n      region_justify=:TL, offset=(away=true, shift=0.25), fill=:lightyellow)\n\n# Basic LS line y = a + bx + cx^2 + seasonal change\nmodel = trend1d(\"@MaunaLoa_CO2.txt\", output=:xmr, model=\"p2,f1+o1958+l1\")\nplot!(\"@MaunaLoa_CO2.txt\", frame=:same, ms=0.05, fill=:red, yshift=6)\nplot!(model, pen=(0.25,:blue))\ntext!(mat2ds(\"m@-5@-(t) = a + b@~\\\\327@~t + c@~\\\\327@~t@+2@+ + d@~\\\\327@~cos(2@~p@~t) + e@~\\\\327@~sin(2@~p@~t)\"),\n      font=12, region_justify=:TL, offset=(away=true, shift=0.25), fill=:lightyellow)\n      \n# Plot residuals of last model\nplot!(model, region=(1958,2016,-4,4), frame=(axes=:WSen, bg=:azure1,\n      title=\"The Keeling Curve [CO@-2@- at Mauna Loa]\"), xaxis=(annot=:auto, ticks=:auto),\n      yaxis=(annot=:auto, ticks=:auto, suffix=\" ppm\"),\n      ms=0.05, fill=:red, incols=\"0,2\", yshift=6)\ntext!(mat2ds(\"@~e@~(t) = y(t) - m@-5@-(t)\"), font=12, region_justify=:TL,\n      offset=(away=true, shift=0.25),fill=:lightyellow, show=true)"
  },
  {
    "objectID": "gallery/ex48.html",
    "href": "gallery/ex48.html",
    "title": "(48) Line networks, map embellishments, and curved titles",
    "section": "",
    "text": "In this example we show how the module [plot] can be used to create a network of lines based on a file with just the nodes (the siz airports). We also demonstrate how the lines can be shortened by (a) a given measure (here 250 km) and then (b) the length of the added vector heads. The airspace closest to each airport is identified as spherical Voronoi cells by [sphtriangulate] and filled with transparent coloring, allowing us to see the seafloor texture beneath. Finally, we add six local spiderweb azimuth/distance gridlines and set a curved plot title.\n\nusing GMT\nresetGMT() # hide\n\nloc = [-157.858  21.307   61 300\n       -149.558 -17.552 -120 120\n        139.692  35.689   56 170\n        -70.669 -33.449  215 322\n        151.207 -33.867  -10 145\n       -118.244  34.052  142 306]\npar = [[\"HNL\" \"BC\" \"1.5\"];\n       [\"PPT\" \"TC\" \"1.5\"];\n       [\"HND\" \"RB\" \"0.75\"];\n       [\"SCL\" \"TL\" \"0.6\"];\n       [\"SYD\" \"TR\" \"2.2\"];\n       [\"LAX\" \"BL\" \"2.0\"]]\n\nmakecpt(cmap=:lightgray, range=\"-12000,12000\")\ngrdimage(\"@earth_relief_10m\", region=:global360, shade=(azim=45, norm=\"t2\"),\n         proj=(name=:ortho, center=(205,-10)), figsize=18)\nnear_area = sphtriangulate(loc, voronoi=:v)\nt_cpt = makecpt(cmap=:categorical, range=(0,6,1))\nplot!(near_area, close=true, cmap=t_cpt, alpha=65)\n\n# Make a 15 degrees by 250 km spiderweb grid around each airport\nplot!(loc, marker=(Web=true, size=(\"2000k\",\"250k\"), arc=\"250k\", radial=15), pen=0.5, fill=\"white@40\")\ncoast!(land=:black, area=500, frame=(annot=:auto, ticks=:auto, grid=:auto))\n\n# Then place custom labels.\nfor k = 1:size(loc,1)\n    text!(loc[k:k,1:2], txt=par[k,1], offset=(corners=true, shift=par[k,3], line=(0.5,:white)),\n          font=16, justify=par[k,2], noclip=true)\n    text!(loc[k:k,1:2], text=par[k,1], offset=(corners=true, shift=par[k,3], line=0.25), font=16,\n          justify=par[k,2], noclip=true, fill=:white, pen=0.25)\nend\n\n# Plot trimmed lines and overlay airport locations\nlines!(loc, connection=:network, pen=(lw=1.5, arrow=(len=0.5,fill=:red,shape=0.5,pen=0.5), offset=\"250k\"))\nplot!(loc, symbol=\"E-500\", fill=:orange, ml=0.25)\n\n# Make an arc of radius 12 cm from 45 to 135 degrees around map center and use it to place text\npath = [cosd.(45:135) sind.(45:135)] .* 12\n# Move up 8 cm so origin is at the map center\nlines!(path, region=(-9.0,9.0,0,15), proj=:linear, figscale=1.0, decorated=(quoted=true, n_labels=1,\n       const_label=\"IMPORTANT PACIFIC AIRPORTS\", font=32, curved=true),\npen=(:faint,:white), noclip=true, yshift=8, show=true)"
  },
  {
    "objectID": "tutorials/blender_shading/blender_rt.html",
    "href": "tutorials/blender_shading/blender_rt.html",
    "title": "Shading with Blender",
    "section": "",
    "text": "This tutorial shows how we can create stunning shaded relief images using the Blender ray tracer to solve the hard job of computing illumination with realist shadows of a DEM surface. The tutorial linked below takes some time to follow and the time needed to compute the raytraced image is on the order of minutes. However, as the author says at the end, once we have it set for one case it is easy and fast to adapt it to other cases. In a posterior improvement of this tutorial we will show how to modify needed parameters of the .blend file that is run by Blender to create the raytraced image.\n\nusing GMT\n\n# Extract a region of West Ibaria from the 15 arc sec grids stored in the GMT server\nGwib = grdcut(\"@earth_relief_15s\", region=(-10.5, -5, 35, 44));\n\n# Create a tint image from the Gwib grid\nI = grdimage(Gwib, C=:earth, img_out=true);\nviz(I, coast=true)\n\nGMT [WARNING]: gmtapi_change_imagelayout: reordering function for case TRPa -&gt; BRP not yet written. Doing nothing.\n\n\n\n\n\n\n\n\n\nLoad the previously created raytrace image computed with Blender following the tutorial Creating Shaded Relief in Blender But note that the first part of that tutorial where it explains how to create the UInt16 heightmap can be replaced by this simple command:\ngdalwrite(\"Gwib.tiff\", rescale(Gwib, type=UInt16))\nLoad the gray scale image and show it:\n\nusing GMT\n\nIblend = gmtread(\"https://oceania.generic-mapping-tools.org/cache/wiberia_shade_blender.png\");\nviz(Iblend)\n\n\n\n\n\n\n\n\nNow apply the techniques explained in this tutorial Adding Shaded Relief in Photoshop to blend the tint, the shades and illumination\n\nusing GMT\n\nI = grdimage(Gwib, C=:earth, img_out=true);     # Hide\nIblend = gmtread(\"https://oceania.generic-mapping-tools.org/cache/wiberia_shade_blender.png\");  # Hide\n# Blend the tint and the shades (darken)\nIburn = blendimg!(I, Iblend, mode=\"LinearBurn\", new=true);\n\n# Apply illunination to the previous image\nIb = blendimg!(Iburn, Iblend, mode=\"Screen\", new=true);\n\nviz(Ib, coast=true)\n\nGMT [WARNING]: gmtapi_change_imagelayout: reordering function for case TRPa -&gt; BRP not yet written. Doing nothing."
  },
  {
    "objectID": "tutorials/coast/coastlines.html",
    "href": "tutorials/coast/coastlines.html",
    "title": "Coastlines and borders",
    "section": "",
    "text": "GMT uses the coast utility to access a version of the GSHHG data specially formatted for GMT. The GSHHG data have strengths and weaknesses. It is global and open source, but is based on relatively old datasets and hence may not be accurate enough for very large-scale mapping projects. For more information about the coastlines data-set see the GSHHG repository"
  },
  {
    "objectID": "tutorials/coast/coastlines.html#shorelines",
    "href": "tutorials/coast/coastlines.html#shorelines",
    "title": "Coastlines and borders",
    "section": "Shorelines",
    "text": "Shorelines\nUse the shore option to plot only the shorelines:\n\nusing GMT\ncoast(region=:global, proj=:Mollweide, shore=true, show=true)\n\n\n\n\n\n\n\n\nThe shorelines are divided in 4 levels:\n\ncoastline\nlakeshore\nisland-in-lake shore\nlake-in-island-in-lake shore\n\nYou can specify which level you want to plot by appending the level number and a GMT pen configuration to the shore option. For example, to plot just the coastlines with 0.5 thickness and black lines:\n\nusing GMT\ncoast(region=:global, proj=:Mollweide, shore=(level=1, pen=(0.5,:black)), show=true)\n\n\n\n\n\n\n\n\nWe can specify multiple levels by using the shore option more than once by using a Tuple of NamedTuples. That is, in this case we can no longer use the simpler form we used above but must instead do:\n\nusing GMT\ncoast(region=:global, proj=:Mollweide,\n      shore=((level=1, pen=(0.5,:black)), (level=2, pen=(0.5,:red))), show=true)\n\n\n\n\n\n\n\n\nResolutions\nThe coastline database comes with 5 resolutions, which can be set using the res or resolution options. The resolution drops by 80% between levels:\n\ncrude\nlow\nintermediate\nhigh\nfull\n\n\nusing GMT\n\n# Need to take one out of the cycle to start the figure.\ncoast(region=(-158.3,-157.6,21.2,21.8), proj=:Mercator, res=:crude, shore=1, frame=:none)\nfor res in [\"low\", \"intermediate\", \"high\", \"full\"]\n    coast!(shore=1, resolution=res, xshift=12)\nend\nshowfig()"
  },
  {
    "objectID": "tutorials/coast/coastlines.html#land-and-water",
    "href": "tutorials/coast/coastlines.html#land-and-water",
    "title": "Coastlines and borders",
    "section": "Land and water",
    "text": "Land and water\nUse the land and water options to specify a fill color for land and water bodies. The colors can be given by name or hex codes:\n\nusing GMT\ncoast(region=:global, proj=:Mollweide, land=\"#666666\", water=:skyblue, show=true)"
  },
  {
    "objectID": "tutorials/coast/coastlines.html#political-boundaries",
    "href": "tutorials/coast/coastlines.html#political-boundaries",
    "title": "Coastlines and borders",
    "section": "Political Boundaries",
    "text": "Political Boundaries\nThe borders option of coast specifies levels of political boundaries to plot and the pen used to draw them. Choose from the list of boundaries below:\n\n1 = National boundaries\n2 = State boundaries within the Americas\n3 = Marine boundaries\na = All boundaries (1-3)\n\nFor example, to draw national boundaries with a line thickness of 1p and black line color use borders=(1,(\"1p\",:black)), or borders=(type=1, pen=(0.5, :black)). We can draw multiple boundaries by passing in a tuple of NamedTuples to borders (for repeating the option we must use the NamedTuple form). The following example uses a Sinusoidal projection map of the Americas with automatic annotations and ticks.\n\nusing GMT\ncoast(region=[-150, -30, -60, 60], land=:gray, projection=(name=:Sinusoidal, center=-90),\n      borders=((type=1, pen=(0.5, :black)), (type=2, pen=(0.5, :red)), (type=3, pen=(0.5, :blue))),\n      show=true)"
  },
  {
    "objectID": "tutorials/coast/coastlines.html#rivers",
    "href": "tutorials/coast/coastlines.html#rivers",
    "title": "Coastlines and borders",
    "section": "Rivers",
    "text": "Rivers\nThe situation with plotting rivers is a bit less good and we hope to improve it when modern data is incorporated in the databse. But we can still do pretty maps of the permanent major rivers. A rivers version of the figure above is obtained with (the code :r means All permanent rivers):\n\nusing GMT\ncoast(region=[-150, -30, -60, 60], land=:gray, projection=(name=:Sinusoidal, center=-90),\n      rivers=(:r,:blue), show=true)"
  },
  {
    "objectID": "tutorials/Landsat8/histogram_stretch.html",
    "href": "tutorials/Landsat8/histogram_stretch.html",
    "title": "Plot Landsat 8 images",
    "section": "",
    "text": "Plot Landsat 8 images\nThe data used in this example is the band 4 (red channel) of a Landsat 8 scene. Those are relatively big images (~116 MB) so we will download it first and take that into account when the results of the commands bellow do not show instantly.\nIr = gmtread(\"/vsicurl/http://landsat-pds.s3.amazonaws.com/c1/L8/037/034/LC08_L1TP_037034_20160712_20170221_01_T1/LC08_L1TP_037034_20160712_20170221_01_T1_B4.TIF\");\nand have a look at what we got\nimshow(Ir)\n\n\n\nAh, nice … but it’s so dark that we can’t really see much!\n\n\nWell that is true and has one explanation. Modern satellite data is acquired with sensors of 12 bits or more but the data is stored in variables with 16 bits. This means that many of those data bits will not be used. But on screens we are limited to 8 bits per channel so we must scale the full 16 bits range [0 65535] to the [0 255] interval and in this process we tend to have much more dark pixels.\nTo see this better, let’s look at the image’s histogram.\nhistogram(Ir, auto=true, bin=20, show=true)\n\n\n\n.\n\n\nWe have used here the option auto=true that will try to guess where the data in histogram plot starts and ~ ends. It did behave well and we will use those numbers to do an operation that is called histogram stretch that consists in picking only part of the histogram and stretch it to [0 255]. Note that in fact we have data to the 40000 DN (Digital Number) but they are very few and at the end we must choose a balance to show almost all DNs and not making the image too dark.\nimshow(I, stretch=[6000 23800])\n\n\n\n.\n\n\nNow that we feel confident with the auto-stretching algorithm we can create a true color image. True color images are obtained by inserting the Landsat8 band 4 in the Red channel, band 3 in Green and band 2 in Blue. Looking at the file name that we downloaded it’s easy to guess that bands “…T1_B3.TIF” and “…T1_B2.TIF” contain the green and blue channels that we need. So download them (takes a little time).\nIg = gmtread(\"/vsicurl/http://landsat-pds.s3.amazonaws.com/c1/L8/037/034/LC08_L1TP_037034_20160712_20170221_01_T1/LC08_L1TP_037034_20160712_20170221_01_T1_B3.TIF\");\n\nIb = gmtread(\"/vsicurl/http://landsat-pds.s3.amazonaws.com/c1/L8/037/034/LC08_L1TP_037034_20160712_20170221_01_T1/LC08_L1TP_037034_20160712_20170221_01_T1_B2.TIF\");\nand compose a true color image with the function truecolor() from the RemoteS package that will do the auto-stretching automatically for us\nusing RemoteS\nIrgb = truecolor(Ir, Ig, Ib);\n\n\n\n."
  },
  {
    "objectID": "tutorials/mosaics/mosaics.html",
    "href": "tutorials/mosaics/mosaics.html",
    "title": "Mosaicing from Web tiles servers",
    "section": "",
    "text": "The mosaic function let us download map tiles from Web Map Tiles servers given a BoundingBox limits in geographical coordinates. The function has many use options and we will show here the result of using some of them. By default it downloads images from the Bing servers but data from OpenStreetMap, Google, ESRI, Nimbo and other providers can be accessed as well.\nTo start with we create an image over Iberia using only default values. i.,e. Bing images and image resolution (that is, the zoom level) computed automatically for that area.\n\nusing GMT\n\nI = mosaic([-10, 3.5], [36.0, 44])\nviz(I)\n\n\n\n\n\n\n\n\nIf we want instead a map from OpenStreetMap, we need to specify that via the provider option. To know more about the provider usage, see the manual of the getprovider function (e.,g._ type ? getprovider in the Julia command window.)\n\nusing GMT\n\nI = mosaic([-10, 3.5], [36.0, 44], provider=:OSM)\nviz(I)\n\n\n\n\n\n\n\n\nA question that will often arise is: but what if I want to control the resolution, what zoom level should I choose?. Well, the answer is using trial an error or help yourself a bit and make a figures with the tiles limits. For that we use the mesh option and plot the tiles limits only.\n\nusing GMT\n\nD = mosaic([-10, 3.5], [36.0, 44], mesh=true)\nviz(D, coast=true)\n\n\n\n\n\n\n\n\nTyping D[1].comment shows that the default zoom level for that area is 8\njulia&gt; D[1].comment\n1-element Vector{String}:\n \"Zoom level = 8\"`\nSo, if we want a twice resolution map we would do (for the first example). Mind you that each increase of one unit in the zoom level duplicates the resolution and multiply by 4 the number of download tiles.\nI = mosaic([-10, 3.5], [36.0, 44], zoom=9)\nviz(I)\nSo, we saw how to make maps over large areas, but when it comes to smaller areas it becomes more (or much more) cumbersome to find the appropriate map limits. That is when the geocoder function comes into our rescue. Basically, it takes as input an address and return a [GMTdataset] with information on that place, and in particular its coordinates and BoundingBox.\nThe syntax is very simple. Just give an address that it understands. It can be a general address like:\nD = geocoder(\"Big Island Hawaii, USA\")\n\nAttribute table\n┌────────────┬──────────────┬────────┬────────────────┬────────────┬───────┬────────────────────┬──────────────┬────────┬──────────┬───────\n│        lat │ country_code │   type │ ISO3166-2-lvl4 │ place_rank │ class │         importance │          lon │  state │ osm_type │ addr ⋯\n├────────────┼──────────────┼────────┼────────────────┼────────────┼───────┼────────────────────┼──────────────┼────────┼──────────┼───────\n│ 19.5895548 │           us │ island │          US-HI │         17 │ place │ 0.5331294636028157 │ -155.4486983 │ Hawaii │ relation │      ⋯\n└────────────┴──────────────┴────────┴────────────────┴────────────┴───────┴────────────────────┴──────────────┴────────┴──────────┴───────\n                                                                                                                          8 columns omitted\nBoundingBox: [-155.4486983, -155.4486983, 19.5895548, 19.5895548]\nGlobal BoundingBox: [-156.0618813, -154.806698, 18.9106939, 20.2685021]\nPROJ: +proj=longlat +datum=WGS84 +units=m +no_defs\n\n1×2 GMTdataset{Float64, 2}\n Row │      Lon      Lat\n─────┼───────────────────\n   1 │ -155.449  19.5896\n```ion │      ⋯\n└────────────┴──────────────┴────────┴────────────────┴────────────┴───────┴────────────────────┴──────────────┴────────┴──────────┴───────\n                                                                                                                          8 columns omitted\nBoundingBox: [-155.4486983, -155.4486983, 19.5895548, 19.5895548]\nGlobal BoundingBox: [-156.0618813, -154.806698, 18.9106939, 20.2685021]\nPROJ: +proj=longlat +datum=WGS84 +units=m +no_defs\n\n1×2 GMTdataset{Float64, 2}\n Row │      Lon      Lat\n─────┼───────────────────\n   1 │ -155.449  19.5896\nSince this still represents a somewhat large area we will use the reported BoundingBox via the bbox option. So, to create an image of the Big Island, Hawaii we do:\n\nusing GMT\n\nD = geocoder(\"Hawaii Big Island, USA\");\nI = mosaic(D, bbox=true);\nviz(I)\n\n\n\n\n\n\n\n\nBut when it comes to image real small areas the BoundingBox trick no longer works because it normally is … too small. We must than use the alternative, which is to specify the number of neighbor tiles around the obtained address. And here we must specify the zoom level manually.\nExample of a high-resolution map over the S. Peters Piazza, Vatican.\n\nusing GMT\n\nD = geocoder(\"Piazza San Pietro, Vatican\");\nI = mosaic(D, zoom=19, neighbors=7);\nviz(I)\n\n\n\n\n\n\n\n\nBut not all small and beautifull places are geocoded. To see the lovely Fish Island in Croatia, we still have to provide the central coordinates (or the right BoundingBox).\n\nusing GMT\n\nI = mosaic(13.71862, 44.939234, zoom=18, provider=:Google, neighbors=[7,5]);\nviz(I, proj=:guess)"
  },
  {
    "objectID": "tutorials/signal/signal.html",
    "href": "tutorials/signal/signal.html",
    "title": "Signal processing examples",
    "section": "",
    "text": "Signal processing examples\nSome examples of using GMT to do time series signal processing.\n\n\n\nAutocorr and periods I \n\n\n\n\nAutocorr and periods II \n\n\n\n\nSmooth a Tide Record \n\n\n\n\nClean Outliers \n\n\n\n\nSimple FFT \n\n\n\n\nTide components, FFT \n\n\n\n\nKeeling curve"
  },
  {
    "objectID": "tutorials/signal/autocorr_periodic/autocorr_periodic.html",
    "href": "tutorials/signal/autocorr_periodic/autocorr_periodic.html",
    "title": "Find Periodicity Using Autocorrelation",
    "section": "",
    "text": "(Example from Matlab documentation)\nThe autocorrelation sequence of a periodic signal has the same cyclic characteristics as the signal itself. Thus, autocorrelation can help verify the presence of cycles and determine their durations.\nConsider a set of temperature data collected by a thermometer inside an office building. The device takes a reading every half hour for four months. Load the data and plot it. Subtract the mean to concentrate on temperature fluctuations. Convert the temperature to degrees Celsius. Measure time in days. The sample rate is thus 2 measurements/hour × 24 hours/day = 48 measurements/day.\n\nusing GMT\n\nD = gmtread(TESTSDIR * \"assets/temps.dat\");\ntempC = (D-32)*5/9;\ntempnorm = tempC - mean(tempC);\nfs = 2*24;\nt = (0:length(tempnorm) - 1)/fs;\nplot(t,tempnorm, xlabel=\"Time (days)\", ylabel=\"Temperature (°C)\", title=\"Temperature time series\", figsize=(15, 6), show=true)\n\n\n\n\n\n\n\n\nThe temperature does seem to oscillate, but the lengths of the cycles cannot be read out easily.\nCompute the autocorrelation of the temperature such that it is unity at zero lag. Restrict the positive and negative lags to three weeks. Note the double periodicity of the signal.\n\nlags = 0:3*7*fs;\nac = GMT.autocor(tempnorm, lags);\nlocs = findpeaks(ac);\nplot(lags/fs, ac, figsize=(15, 7))\nscatter!(lags[locs]/fs,ac[locs], show=1)\n\n\n\n\n\n\n\n\nDetermine the short and long periods by finding the peak locations and determining the average time differences between them.\nTo find the long period, restrict findpeaks to look for peaks separated by more than the short period and with a minimum height of 0.3.\n\nshortT = mean(diff(sort(locs))) / fs\nlocs_long = findpeaks(ac, min_dist=ceil(shortT)*fs, min_height=0.3);\nlongT = mean(diff(locs_long))/fs\nplot(lags/fs, ac, figsize=(15, 7))\nscatter!(lags[locs]/fs,ac[locs], fill=:red)\nscatter!(lags[locs_long]/fs, ac[locs_long], fill=:blue, show=1)\n\n\n\n\n\n\n\n\nTo a very good approximation, the autocorrelation oscillates both daily and weekly. This is to be expected, since the temperature in the building is higher when people are at work and lower at nights and on weekends."
  },
  {
    "objectID": "tutorials/signal/fft_ex1/fft_ex1.html",
    "href": "tutorials/signal/fft_ex1/fft_ex1.html",
    "title": "FFT example I",
    "section": "",
    "text": "Example on how to decompose and filter a synthetic time series with Fourier analysis.\n\nusing GMT\n\nfunc(x) = sin(x) + 1/3*sin(3x) + 1/5*sin(5x) + 1/7*sin(7x);\nx = 0:0.01:4pi;\n\nEvaluate func at x and plot its value.\n\ny = func.(x);\nviz(x,y, figsize=(14,3))\n\n\n\n\n\n\n\n\n\nFs = 50000;     # Sampling frequency\nT = 1/Fs;       # Sampling period\nL = 10000;      # Length of signal\nt = (0:L-1)*T;  # Time vector\n\nA1 = 325;       # Amplitude of first sinusoid\nf1 = 50;       # Frequency of first sinusoid\nA2=200;         # Amplitude of second sinusoid\nf2=400;         # Frequency of second sinusoid\nA3=150;         # Amplitude of third sinusoid\nf3=800;         # Frequency of third sinusoid\n\n\n\nGenerate three sine waves with different frequencies and amplitudes.\n\nusing GMT, FFTW\n\nsig1 = A1*sin.(2*pi*f1*t);\nsig2 = A2*sin.(2*pi*f2*t);\nsig3 = A3*sin.(2*pi*f3*t);\nplot(t, sig1, xlabel=\"Time [s]\", ylabel=\"Amplitude\", label=\"Signal 1\", lc=:red, figsize=(14,6))\nplot!(t, sig2, label=\"Signal 2\", lc=:green)\nplot!(t, sig3, label=\"Signal 3\", lc=:blue, show=true)\n\n\n\n\n\n\n\n\nAdd the three signals together and plot the result.\n\nfinal= sig1 .+ sig2 .+ sig3;    # Add the three signals together\nplot(t, final, xlabel=\"Time [s]\", ylabel=\"Amplitude\", figsize=(14,6), show=1)\n\n\n\n\n\n\n\n\nDecompose the 3 added components into its constituent frequencies.\n\n# Compute the signal's spectra using FFT\nY = fft(final);\n\n# Generate a vector from 0 to Fs/2 (see the manual of the 'fftfreq' function)\nf = Fs * (0:(L/2)-1)/L;\n\nP = abs.(Y / L);        # Need to take the 'abs' because the FFT returns complex numbers\nplot(f, 2*P[1:length(f)], limits=(0,1000,0,350), xlabel=\"Frequency [hz]\", ylabel=\"Amplitude\", figsize=(14,6), show=1)\n\n\n\n\n\n\n\n\nWhile in this simple example we can visually see that the peaks corresponds to the frequencies of the three sine waves that we generated (sig1, sig2 and sig3), let us find that numerically using the function findpeaks that we used in the autocorrelation example.\n# Find the peaks in `P` but only those with a height of at least 10 to avoid the noise.\nind = findpeaks(P, min_height=10.0, xsorted=true)\n\n6-element Vector{Int64}:\n   11\n   81\n  161\n 9841\n 9921\n 9991\nWe found 6 peaks instead of 3 because the FFT is symetrical around the center frequency (Fs / 2) and the peaks at 9991, 9921 and 9841 are the same as the peaks at 11, 81 and 161 (exercise, confirm that).\n# Print frequencies of the first 3 peaks.\nf[[11,81,161]]\nLet’s now see how we can use the FFT transformed signal to filter some of the frequencies. First we remove only the highest frequency. Since that highest frequency is at position after 81 of the FFT transformed signal, we can simply remove it by setting to zero all elements &gt; 100.\n\nYfilt = copy(Y);\nYfilt[100:end] .= 0;\ninv = ifft(Yfilt);\nviz(real(inv), figsize=(14,6))\n\n\n\n\n\n\n\n\nAnd if we want to retain only the lowest frequency component, we remove everything above 11’th element\n\nYfilt = copy(Y);\nYfilt[20:end] .= 0;\ninv = ifft(Yfilt);\nviz(real(inv), figsize=(14,6))\n\n\n\n\n\n\n\n\nExercise: remove only the lowest frequency."
  },
  {
    "objectID": "tutorials/signal/keeling/keeling.html",
    "href": "tutorials/signal/keeling/keeling.html",
    "title": "Trend modeling",
    "section": "",
    "text": "This example (from the GMT gallery - EX45) shows how the module trend1d is used to fit the CO2 data set collected from the top of Mauna Loa. This yields the famous Keeling curve.\nBasic LS (Least Squares) line y = a + bx\n\nusing GMT\n\nmodel = trend1d(\"@MaunaLoa_CO2.txt\", output=:xm, model=(polynome=1,))\nplot(\"@MaunaLoa_CO2.txt\", region=(1958,2016,310,410), frame=(axes=:WSen, bg=:azure1),\n     xaxis=(annot=:auto, ticks=:auto), yaxis=(annot=:auto, ticks=:auto, suffix=\" ppm\"),\n     marker=:circle, ms=0.05, fill=:red, figsize=(12,5))\nplot!(model, pen=(0.5,:blue))\ntext!(mat2ds(\"m@-2@-(t) = a + b@~\\\\327@~t\"), font=12, region_justify=:TL,\n      offset=(away=true, shift=0.25), fill=:lightyellow, show=true)\n\n\n\n\n\n\n\n\nBasic LS line y = a + bx + cx^2\n\nmodel = trend1d(\"@MaunaLoa_CO2.txt\", output=:xm, model=(polynome=2,))\nplot(\"@MaunaLoa_CO2.txt\", frame=:same, ms=0.05, fill=:red, figsize=(12,5))\nplot!(model, lt=0.5, lc=:blue)\ntext!(mat2ds(\"m@-3@-(t) = a + b@~\\\\327@~t + c@~\\\\327@~t@+2@+\"), font=12,\n      region_justify=:TL, offset=(away=true, shift=0.25), fill=:lightyellow, show=true)\n\n\n\n\n\n\n\n\nBasic LS line y = a + bx + cx^2 + seasonal change\n\nmodel = trend1d(\"@MaunaLoa_CO2.txt\", output=:xmr, model=((polynome=2,), (fourier=1, origin=1958, length=1)))\nplot(\"@MaunaLoa_CO2.txt\", frame=:same, ms=0.05, fill=:red, figsize=(12,5))\nplot!(model, pen=(0.25,:blue))\ntext!(mat2ds(\"m@-5@-(t) = a + b@~\\\\327@~t + c@~\\\\327@~t@+2@+ + d@~\\\\327@~cos(2@~p@~t) + e@~\\\\327@~sin(2@~p@~t)\"),\n      font=12, region_justify=:TL, offset=(away=true, shift=0.25), fill=:lightyellow, show=true)\n\n\n\n\n\n\n\n\nPlot residuals of last model\n\nplot(model, region=(1958,2016,-4,4), frame=(axes=:WSen, bg=:azure1,\n      title=\"The Keeling Curve [CO@-2@- at Mauna Loa]\"), xaxis=(annot=:auto, ticks=:auto),\n      yaxis=(annot=:auto, ticks=:auto, suffix=\" ppm\"),\n      ms=0.05, fill=:red, incols=\"0,2\", figsize=(12,5))\ntext!(mat2ds(\"@~e@~(t) = y(t) - m@-5@-(t)\"), font=12, region_justify=:TL,\n      offset=(away=true, shift=0.25),fill=:lightyellow, show=true)"
  },
  {
    "objectID": "tutorials/texture_shading/texture.html",
    "href": "tutorials/texture_shading/texture.html",
    "title": "Leland Brown’s “texture shading”",
    "section": "",
    "text": "This tutorial starts with the examples shown by @KristofKoch in the Github issue that lead to inclusion of Leland Brown’s “texture shading” technique in the GMT lib (not in any executable sofar) and postior wrapping in Julia GMT.jl\nFor the time being it is a set of examples on how to use the lelandshade and dependent functions. In the first example we get a demo grid from the GMT server and build a texture shaded image showing the inners of the calculation.\nusing GMT\n\n# Extract a region from the SRTM1 grids stored in the GMT server\nG = gmtread(\"@earth_relief_01s_g\", region=(-114.14,-111.28,35.50,37.06));\n\n# Compute the Leland texture\nI1 = texture_img(G);\n\n# Compute the grid's hillshade using GDAL's gdaldem program\nIhill = gdaldem(G, \"hillshade\", zfactor=3);     # The zfactor=3 is a terrain amplification factor\n\n# Blend both images and Viz it.\nI2 = blendimg!(I1, Ihill, new=true, transparency=0.6);\nviz(I2)\nThe new=true option above forced the creation of the new array I2, but we could have just done blendimg!(I1, Ihill, transparency=0.6) and the final image would be stored in (overritten) I1. That is what is implemented in the wrapper function lelandshade that aglutinates all of the above steps, plus some extra options, in a single function.\nMap again the same refion but using this time a linear color scale. Since the G grid object is originated from the SRTM1 (1 arc second = ~30 m) stored in the GMT store, it comes with the indication of a default color map (geo) and is what we see (but we can select any cmap that we want).\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-114.14,-111.28,35.50,37.06));   # Hide\nlelandshade(G, color=true, colorbar=true, show=true)\nA variation of the above is to make the color image with equalized color distribution where each color covers approximatelly the same area in the figure. We do that using the equalize=true option.\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-114.14,-111.28,35.50,37.06));   # Hide\nlelandshade(G, color=true, equalize=true, colorbar=true, show=true)"
  },
  {
    "objectID": "tutorials/texture_shading/texture.html#the-effect-of-the-transparency-option.",
    "href": "tutorials/texture_shading/texture.html#the-effect-of-the-transparency-option.",
    "title": "Leland Brown’s “texture shading”",
    "section": "The effect of the transparency option.",
    "text": "The effect of the transparency option.\nThe examples shown above all used a transparency=0.6. Remember (from the manual) that the transparency represent the weight of the img2 with respect to img1 in the blend img1 + img2. So, when we used transparency=0.6 explicitly in the first example, or implicitly in the 2nd and 3rth examples, we imposed that the texture image weighted 60% and the hillshade 40%. This parameter has a relevant importance in the final image, so let us see examples of it by varying the amount of transparency in the mixture. And for better appreciate it we will use grayscale images and over a smaller region.\n\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-112.06, -111.60, 35.97, 36.25));\nlelandshade(G, transparency=0.0, title=\"0 % texture shading\", par=(FONT_TITLE=10,), show=true)\n\n\n\n\n\n\n\n\n\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-112.06, -111.60, 35.97, 36.25));    # Hide\nlelandshade(G, transparency=0.3, title=\"30 % texture shading\", par=(FONT_TITLE=10,), show=true)\n\n\n\n\n\n\n\n\n\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-112.06, -111.60, 35.97, 36.25));    # Hide\nlelandshade(G, transparency=0.6, title=\"60 % texture shading\", par=(FONT_TITLE=10,), show=true)\n\n\n\n\n\n\n\n\n\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-112.06, -111.60, 35.97, 36.25));    # Hide\nlelandshade(G, transparency=0.8, title=\"80 % texture shading\", par=(FONT_TITLE=10,), show=true)\n\n\n\n\n\n\n\n\n\nusing GMT   # Hide\nG = gmtread(\"@earth_relief_01s_g\", region=(-112.06, -111.60, 35.97, 36.25));    # Hide\nlelandshade(G, transparency=1.0, title=\"100 % texture shading\", par=(FONT_TITLE=10,), show=true)\n\n\n\n\n\n\n\n\nOther than the transparency, several other parameters influence the look of the texture shaded images. Consult the lelandshade manual to learn about them."
  },
  {
    "objectID": "geophysics.html",
    "href": "geophysics.html",
    "title": "Geophysics",
    "section": "",
    "text": "Geophysics Examples\nSpecialized geophysics applications and examples using GMT.jl.\n\n\n\nSeismology \n\nFocal mechanisms, seismicity plots, and earthquake data visualization\n\n\n\n\n\nEarth Tides \n\nComputing and visualizing Earth tide effects\n\n\n\n\n\nWeather Maps \n\nMeteorological data visualization and weather mapping"
  },
  {
    "objectID": "geophysics/seismicity/global_seis.html",
    "href": "geophysics/seismicity/global_seis.html",
    "title": "Global seismicity",
    "section": "",
    "text": "These set of examples show how to plot the global seismicity in Julia using GMT.\nThe function downloads data from the USGS Earthquake Hazards Program page at USGS and makes global seismicity maps with nice automatic legends. By default, it plots the earthquakes served from that site for the last 30 days and it usage is simply:\n\nusing GMT\nseismicity()\n\n\n\n\n\n\n\n\nBut we can select the period that we want under the condition that the request doesn’t imply more than 20,000 events (that is why we restrict the next search to events of magnitude &gt;= 4). For example, to plot the last year of seismicity:\n\nusing GMT\nseismicity(last=\"1Y\", minmagnitude=4)\n\n\n\n\n\n\n\n\nIn the examples above we used the default linear scale for the earthquake magnitudes. But we know that magnitudes follow a logarithmic scale. But the problem of applying an exponential function to the events sizes is that if we start with a certain size, large events are so much bigger than other that they risk to hide almost everything. To prevent that, we can specify the min and max symbol size and let the point sizes follow a certain expression. For example, next example shows events size from 2 to 12 points for earthquakes with magnitudes between 3 and 9. We take the opportunity to also show the effect of a couple of other options, namely defining a region, a fixed period and selecting non-default continent and ocean colors.\n\nusing GMT   # Hide\nseismicity(region=\"86/175/-25/33\", size=(exp, [2 12], [3 9]), land=:lightbrown,\n           ocean=:lightblue, starttime=\"2020-01-01\", endtime=\"2022-12-31\")"
  },
  {
    "objectID": "geophysics/earthtides/01_earthtides.html",
    "href": "geophysics/earthtides/01_earthtides.html",
    "title": "Earth tides",
    "section": "",
    "text": "Did you know that it’s not only the oceans that have a tide? Yes, the solid Earth has tides as well, and they are not so small as one might imagine."
  },
  {
    "objectID": "geophysics/earthtides/01_earthtides.html#a-global-view",
    "href": "geophysics/earthtides/01_earthtides.html#a-global-view",
    "title": "Earth tides",
    "section": "A global view",
    "text": "A global view\nThis example shows a global view of the vertical component of the Earth tide for a perticular data.\n\nusing GMT\nGMT.resetGMT() # hide\nG = earthtide(T=\"2022-07-07T12:00:00\");\nimshow(G, coast=true, colorbar=true, title=\"Earth tide at noon 7-July-2022\")"
  },
  {
    "objectID": "geophysics/earthtides/01_earthtides.html#the-3-components",
    "href": "geophysics/earthtides/01_earthtides.html#the-3-components",
    "title": "Earth tides",
    "section": "The 3 components",
    "text": "The 3 components\nNow we show the three components of the Earth tide for a specific location (the Panama Cannal) and time interval (the 7’th July 2022).\nFirst we compute the components that will come out in a with named columns. This is handy because we can refer to them by name instead of by column number.\nD = earthtide(range=(\"2022-07-07T\", \"2022-07-08T\", \"1m\"), location=(-82,9))\n\n1441×4 GMTdataset{Float64, 2}\n Row │                Time        East        North  Vertical\n─────┼────────────────────────────────────────────────────────\n   1 │ 2022-07-07T00:00:00  -0.0186548  -0.0120856   0.152718\n   2 │ 2022-07-07T00:01:00  -0.0187063  -0.0123039   0.152364\n   3 │ 2022-07-07T00:02:00  -0.0187575  -0.0125214   0.152003\n   4 │ 2022-07-07T00:03:00  -0.0188083  -0.0127382   0.151636\n   5 │ 2022-07-07T00:04:00  -0.0188586  -0.0129542   0.151263\n   6 │ 2022-07-07T00:05:00  -0.0189085  -0.0131695   0.150883\n   7 │ 2022-07-07T00:06:00  -0.018958   -0.0133839   0.150496\n   8 │ 2022-07-07T00:07:00  -0.0190071  -0.0135975   0.150103\n   9 │ 2022-07-07T00:08:00  -0.0190558  -0.0138102   0.149704\n  10 │ 2022-07-07T00:09:00  -0.0191041  -0.0140221   0.149298\n  11 │ 2022-07-07T00:10:00  -0.0191519  -0.0142331   0.148886\n  12 │ 2022-07-07T00:11:00  -0.0191993  -0.0144432   0.148468\n  13 │ 2022-07-07T00:12:00  -0.0192463  -0.0146525   0.148044\n  ⋮  │          ⋮               ⋮            ⋮          ⋮\nNow plot the three of them with a legend\n\nD = earthtide(range=\"2022-07-07T/2022-07-08T/1m\", location=(-82,9));    # hide\nplot(D[:Time, :Vertical], lc=:red, lw=1, legend=:Vertical,\n     title=\"Earth tide components (m) at Panama Cannal\")\nplot!(D[:Time, :East],  lc=:green, lw=1, legend=:East)\nplot!(D[:Time, :North], lc=:blue,  lw=1, legend=:North, show=true)"
  },
  {
    "objectID": "geophysics/earthtides/01_earthtides.html#one-month-of-tides",
    "href": "geophysics/earthtides/01_earthtides.html#one-month-of-tides",
    "title": "Earth tides",
    "section": "One month of tides",
    "text": "One month of tides\nAnd now, let’s see a full month of tidal data (vertical component).\n\nD = earthtide(range=(\"2022-07-01T\", \"2022-07-31T\", \"1m\"), location=(-82,9));\nplot(D[:Time, :Vertical], lc=:blue, legend=:Vertical, title=\"Tides (m), one month\", show=true)"
  },
  {
    "objectID": "examples/frames/frames.html",
    "href": "examples/frames/frames.html",
    "title": "Draw Frames",
    "section": "",
    "text": "Explore different types of frame and axis configurations in GMT.jl.\n\n\n\n\nGeographic basemaps \n\n\n\n\nCartesian linear \n\n\n\n\nLog10 axes \n\n\n\n\nExponential axes \n\n\n\n\nTime axes \n\n\n\n\nCustom axes"
  },
  {
    "objectID": "examples/frames/frames.html#gallery",
    "href": "examples/frames/frames.html#gallery",
    "title": "Draw Frames",
    "section": "",
    "text": "Explore different types of frame and axis configurations in GMT.jl.\n\n\n\n\nGeographic basemaps \n\n\n\n\nCartesian linear \n\n\n\n\nLog10 axes \n\n\n\n\nExponential axes \n\n\n\n\nTime axes \n\n\n\n\nCustom axes"
  },
  {
    "objectID": "examples/frames/frames.html#geographic-basemaps",
    "href": "examples/frames/frames.html#geographic-basemaps",
    "title": "Draw Frames",
    "section": "Geographic basemaps",
    "text": "Geographic basemaps\nGeographic base maps may differ from regular plot axes in that some projections support a “fancy” form of axis and is selected by the MAP_FRAME_TYPE setting. The annotations will be formatted according to the FORMAT_GEO_MAP template and MAP_DEGREE_SYMBOL setting. A simple example of part of a base map is shown in Figure Geographic map border.\n\nusing GMT\n\nbasemap(limits=(-1,2,0,0.4), proj=:Mercator, figsize=12,\n        frame=(axes=:S, annot=1, ticks=\"15m\",grid=\"5m\"))\nt = [-1.0 0 0 3.33\n      0.25 0 0 0.833\n      1.25 0 0 0.28];\narrows!(t, arrow=(length=\"2p\",start=true,stop=true,angle=60), lw=0.5,\n        fill=:black, noclip=true, yshift=-0.9)\n\nT = text_record([-0.5 0.05; 0.375 0.05; 1.29166666 0.05], [\"annotation\", \"frame\", \"grid\"]);\ntext!(T, font=9, justify=:CB, show=true)\n\n\n\n\n\n\n\n\nThe machinery for primary and secondary annotations axes can be utilized for geographic base maps. This may be used to separate degree annotations from minutes- and seconds-annotations. For a more complicated base map example using several sets of intervals, including different intervals and pen attributes for grid lines and grid crosses.\n\nusing GMT\nbasemap(region=(-2,1,0,0.35), proj=:Mercator, figsize=10,\n        frame=(axes=:wSe, annot=\"15m\", ticks=\"5m\",grid=\"5m\"),\n        axis2=(annot=1, ticks=\"30m\", grid=\"15m\"),\n        conf=(MAP_FRAME_TYPE=\"fancy+\", MAP_GRID_PEN_PRIMARY=\"thinnest,black,.\",\n              MAP_GRID_CROSS_SIZE_SECONDARY=0.25, MAP_FRAME_WIDTH=0.2,\n              MAP_TICK_LENGTH_PRIMARY=0.25, FORMAT_GEO_MAP=\"ddd:mm:ssF\",\n              FONT_ANNOT_PRIMARY=\"+8\", FONT_ANNOT_SECONDARY=12))\n# Draw Arrows and text\nt = [-1.875    0 0 0.85\n     -0.45833  0 0 0.3\n      0.541666 0 0 0.3]\narrows!(t, arrow=(length=0.08, start=true, stop=true, justify=:center),\n        lw=0.5, fill=:black, y_offset=-1, no_clip=true)\nT = text_record([-2.1 0.025; -1.875 0.05; -0.45833 0.05; 0.541666 0.05],\n                [\"10p RM P:\", \"6p CB annotation\", \"6p CB frame\", \"6p CB grid\"])\ntext!(T, font=\"\", justify=\"\", no_clip=true)\nt = [-1.5 0 0 3.4; -0.25 0 0 1.7; 0.625 0 0 0.85]\narrows!(t, arrow=(length=0.08, start=true, stop=true, justify=:center),\n        lw=0.5, fill=:black, y_offset=-0.6, no_clip=true)\n\nT = text_record([-2.1 0.025; -1.5  0.05; -0.25 0.05; 0.625 0.05],\n                [\"10p RM S:\", \"9p CB annotation\", \"9p CB frame\", \"9p CB grid\"])\ntext!(T, font=\"\", justify=\"\", no_clip=true, show=true)"
  },
  {
    "objectID": "examples/frames/frames.html#cartesian-linear-axes",
    "href": "examples/frames/frames.html#cartesian-linear-axes",
    "title": "Draw Frames",
    "section": "Cartesian linear axes",
    "text": "Cartesian linear axes\nFor non-geographic axes, the MAP_FRAME_TYPE setting is implicitly set to plain. Other than that, cartesian linear axes are very similar to geographic axes. The annotation format may be controlled with the FORMAT_FLOAT_OUT parameter. By default, it is set to “%g”, which is a C language format statement for floating point numbers, and with this setting the various axis routines will automatically determine how many decimal points should be used by inspecting the stride settings. If FORMAT_FLOAT_OUT is set to another format it will be used directly (.e.g, “%.2f” for a fixed, two decimals format). Note that for these axes you may use the unit setting to add a unit string to each annotation.\n\nusing GMT\nbasemap(region=(0,12,0,1), figsize=(12,1),\n        frame=(annot=4, ticks=2, grid=1, xlabel=\"Frequency\", suffix=\"%\"),\n        axis2=(axes=\"S\",))\nt = [0 0 0 4.0; 6.0 0 0 2.0; 9.0 0 0 1.0];\narrows!(t, arrow=(length=\"2p\",start=true,stop=true,angle=60),\n        lw=0.5, fill=:black, y_offset=0.25, no_clip=true)\nT = text_record([2 0.2; 7 0.2; 9.5 0.2], [\"annotation\", \"frame\", \"grid\"]);\ntext!(T, font=9, justify=:CB, clearance=(0.025,0.025), fill=:white, show=true)\n\n\n\n\n\n\n\n\nThere are occasions when the length of the annotations are such that placing them horizontally (which is the default) may lead to overprinting or too few annotations. One solution is to request slanted annotations for the x-axis via the slanted keyword in frame.\n\nusing GMT\nbasemap(region=(2000,2020,35,45), frame=(axes=:S, annot=2, ticks=:auto, slanted=-30), show=true)"
  },
  {
    "objectID": "examples/frames/frames.html#cartesian-log10-axes",
    "href": "examples/frames/frames.html#cartesian-log10-axes",
    "title": "Draw Frames",
    "section": "Cartesian log10 axes",
    "text": "Cartesian log10 axes\nDue to the logarithmic nature of annotation spacings, the stride parameter takes on specific meanings. The following concerns are specific to log axes (see Figure Logarithmic projection axis):\n\nstride must be 1, 2, 3, or a negative integer -n. Annotations/ticks will then occur at 1, 1-2-5, or 1,2,3,4,…,9, respectively, for each magnitude range. For -n the annotations will take place every n‘th magnitude.\nAppend l to stride. Then, log10 of the annotation is plotted at every integer log10 value (e.g., x = 100 will be annotated as “2”) [Default annotates x as is].\nAppend p to stride. Then, annotations appear as 10 raised to log10 of the value (e.g., 10-5).\n\n\nusing GMT\ngmt(\"set MAP_GRID_PEN_PRIMARY thinnest,.\")\nbasemap(region=(1,1000,0,1), proj=:logx, figsize=(8,0.7),\n        frame=(axes=:S, annot=1, ticks=2, grid=3, scale=:pow, xlabel=\"Axis Label\"))\nbasemap!(frame=(axes=:S, annot=1, ticks=2, grid=3, scale=:log,\n                xlabel=\"Axis Label\"), y_offset=2.2)\nbasemap!(frame=(axes=:S, annot=1, ticks=2, grid=3,\n                xlabel=\"Axis Label\"), y_offset=2.2, show=true)"
  },
  {
    "objectID": "examples/frames/frames.html#cartesian-exponential-axes",
    "href": "examples/frames/frames.html#cartesian-exponential-axes",
    "title": "Draw Frames",
    "section": "Cartesian exponential axes",
    "text": "Cartesian exponential axes\nNormally, stride will be used to create equidistant (in the user’s unit) annotations or ticks, but because of the exponential nature of the axis, such annotations may converge on each other at one end of the axis. To avoid this problem, you can append p to stride, and the annotation interval is expected to be in transformed units, yet the annotation itself will be plotted as un-transformed units. E.g., if stride = 1 and power = 0.5 (i.e., sqrt), then equidistant annotations labeled 1, 4, 9, … will appear.\n\nusing GMT\ngmt(\"set MAP_GRID_PEN_PRIMARY thinnest,.\")\nbasemap(region=(0,100,0,0.9), proj=\"powx,0.5\", figsize=(10, 0.65),\n       frame=(axes=:S, annot=3, ticks=2, grid=1, scale=:pow, xlabel=\"Axis Label\"))\nbasemap!(frame=(axes=:S, annot=20, ticks=10, grid=5, xlabel=\"Axis Label\"),\n         y_offset=2.2, show=true)"
  },
  {
    "objectID": "examples/frames/frames.html#cartesian-time-axes",
    "href": "examples/frames/frames.html#cartesian-time-axes",
    "title": "Draw Frames",
    "section": "Cartesian time axes",
    "text": "Cartesian time axes\nWhat sets time axis apart from the other kinds of plot axes is the numerous ways in which we may want to tick and annotate the axis. Not only do we have both primary and secondary annotation items but we also have interval annotations versus tick-mark annotations, numerous time units, and several ways in which to modify the plot. We will demonstrate this flexibility with a series of examples. While all our examples will only show a single x-axis (south, selected via -BS), time-axis annotations are supported for all axes.\nOur first example shows a time period of almost two months in Spring 2000. We want to annotate the month intervals as well as the date at the start of each week. Note the leading hyphen in the FORMAT_DATE_MAP removes leading zeros from calendar items (e.g., 03 becomes 3).\n\nusing GMT\nbasemap(region=\"2000-4-1T/2000-5-25T/0/1\", figsize=(12,0.5),\n        frame=(axes=:S, annot=7, annot_unit=:day_week, ticks=1, ticks_unit=:day_date),\n        axis2=(annot=1, annot_unit=:month),\n        conf=(FORMAT_DATE_MAP=\"-o\", FONT_ANNOT_PRIMARY=\"+9p\"), show=true)\n\n\n\n\n\n\n\n\nThe next example shows two different ways to annotate an axis portraying 2 days in July 1969:\n\nusing GMT\n#gmtset(FORMAT_DATE_MAP=\"\\\"o dd\\\"\", FORMAT_CLOCK_MAP=\"hh:mm\", FONT_ANNOT_PRIMARY=9)\nbasemap(region=\"1969-7-21T/1969-7-23T/0/1\", figsize=(12,0.5),\n        frame=(axes=:S, annot=6, annot_unit=:hour, ticks=1, ticks_unit=:hour2),\n        axis2=(annot=1, annot_unit=:ISOweekday), par=(FORMAT_DATE_MAP=\"\\\"o dd\\\"\", FORMAT_CLOCK_MAP=\"hh:mm\", FONT_ANNOT_PRIMARY=9))\nbasemap!(frame=(axes=:S, annot=6, annot_unit=:H, ticks=1, ticks_unit=:hour2),\n         axis2=(annot=1, annot_unit=:date), y_offset=1.7, par=(FORMAT_DATE_MAP=\"\\\"o dd\\\"\", FORMAT_CLOCK_MAP=\"hh:mm\", FONT_ANNOT_PRIMARY=9), show=true)\n\n\n\n\n\n\n\n\nThe lower example chooses to annotate the weekdays (by specifying a1K) while the upper example choses dates (by specifying a1D). Note how the clock format only selects hours and minutes (no seconds) and the date format selects a month name, followed by one space and a two-digit day-of-month number.\nThe lower example chooses to annotate the weekdays (by specifying a1K) while the upper example choses dates (by specifying a1D). Note how the clock format only selects hours and minutes (no seconds) and the date format selects a month name, followed by one space and a two-digit day-of-month number.\nThe third example presents two years, annotating both the years and every 3rd month.\n\nusing GMT\nbasemap(region=(\"1997T\",\"1999T\",0,1), figsize=(12,0.25),\n        frame=(axes=:S, annot=3, annot_unit=:month, ticks=1, ticks_unit=:month2),\n        xaxis2=(annot=1, annot_unit=:Y),\n        conf=(FORMAT_DATE_MAP=\"o\", FORMAT_TIME_PRIMARY_MAP=\"Character\", FONT_ANNOT_PRIMARY=\"+9p\"), show=true)\n\n\n\n\n\n\n\n\nNote that while the year annotation is centered on the 1-year interval, the month annotations must be centered on the corresponding month and not the 3-month interval. The FORMAT_DATE_MAP selects month name only and FORMAT_TIME_PRIMARY_MAP selects the 1-character, upper case abbreviation of month names using the current language (selected by GMT_LANGUAGE).\nThe fourth example only shows a few hours of a day, using relative time by specifying t in the region option while the TIME_UNIT is d (for days). We select both primary and secondary annotations, ask for a 12-hour clock, and let time go from right to left:\n\nusing GMT\nbasemap(region=(\"0.2t\",\"0.35t\",0,1), figsize=(-12,0.25),\n        frame=(axes=:S, annot=\"15m\", ticks=\"5m\"), axis2=(annot=1, annot_unit=:hour),\n        conf=(FORMAT_CLOCK_MAP=\"-hham\", FONT_ANNOT_PRIMARY=\"+9p\", TIME_UNIT=\"d\"), show=true)\n\n\n\n\n\n\n\n\nThe fifth example shows a few weeks of time (Figure Cartesian time axis, example 5). The lower axis shows ISO weeks with week numbers and abbreviated names of the weekdays. The upper uses Gregorian weeks (which start at the day chosen by TIME_WEEK_START); they do not have numbers.\n\nusing GMT\nbasemap(region=\"1969-7-21T/1969-8-9T/0/1\", figsize=(12,0.25),\n        frame=(axes=:S, annot=1, annot_unit=:ISOweekday),\n        axis2=(annot=1, annot_unit=:ISOweek),\n        conf=(FORMAT_DATE_MAP=:u, FORMAT_TIME_PRIMARY_MAP=:Character, FORMAT_TIME_SECONDARY_MAP=:full, FONT_ANNOT_PRIMARY=9))\nbasemap!(frame=(axes=:S, annot=3, annot_unit=:ISOweekday, ticks=1, ticks_unit=:weekday),\n         axis2=(annot=1, annot_unit=:Gregorian_week),\n         conf=(FORMAT_DATE_MAP=:o, TIME_WEEK_START=:Sunday, FORMAT_TIME_SECONDARY_MAP=:Character),\n         y_offset=1.7, show=true)\n\n\n\n\n\n\n\n\nOur sixth example shows the first five months of 1996, and we have annotated each month with an abbreviated, upper case name and 2-digit year. Only the primary axes information is specified.\n\nusing GMT\nbasemap(region=(\"1996T\",\"1996-6T\",0,1), figsize=(12,0.25),\n        frame=(axes=:S, annot=1, annot_unit=:month, ticks=1, ticks_unit=:day_date),\n        conf=(FORMAT_DATE_MAP=\"\\\"o yy\\\"\", FORMAT_TIME_PRIMARY_MAP=\"Abbreviated\"), show=true)\n\n\n\n\n\n\n\n\nOur seventh and final example illustrates annotation of year-days. Unless we specify the formatting with a leading hyphen in FORMAT_DATE_MAP we get 3-digit integer days. Note that in order to have the two years annotated we need to allow for the annotation of small fractional intervals; normally such truncated interval must be at least half of a full interval.\n\nusing GMT\nbasemap(region=(\"2000-12-15T\",\"2001-1-15T\",0,1), figsize=(12,0.25),\n        frame=(axes=:S, annot=5, annot_unit=:date, ticks=1, ticks_unit=:day_date),\n        axis2=(annot=1, annot_unit=:year),\n        conf=(FORMAT_DATE_MAP=\"jjj\", TIME_INTERVAL_FRACTION=0.05, FONT_ANNOT_PRIMARY=\"+9p\"), show=true)"
  },
  {
    "objectID": "examples/frames/frames.html#custom-axes",
    "href": "examples/frames/frames.html#custom-axes",
    "title": "Draw Frames",
    "section": "Custom axes",
    "text": "Custom axes\n\nusing GMT\nbasemap(region=(416,542,0,6.2831852), figsize=(-12,5),\n        frame=(frame=(:left_full, :bot_full), fill=:lightblue),\n        xaxis=(annot=25, ticks=5, grid=25, suffix=\" Ma\"),\n        yaxis=(custom=(pos=[0 1 2 2.71828 3 3.1415926 4 5 6 6.2831852],\n               type=[\"a\", \"a\", \"f\", \"ag e\", \"f\", \"ag @~p@~\", \"f\", \"f\", \"f\", \"ag 2@~p@~\"]),),)\n\nbasemap!(frame=(axes=(:left_full, :bot_full),),\n        xaxis2=(custom=(pos=[416.0, 443.7, 488.3, 542],\n                        type=[\"ig Devonian\", \"ig Silurian\", \"ig Ordovician\", \"ig Cambrian\"]),),\n        par=(MAP_ANNOT_OFFSET_SECONDARY=\"10p\", MAP_GRID_PEN_SECONDARY=\"2p\"), show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html",
    "href": "examples/plotting_functions/01_lines.html",
    "title": "Line plots",
    "section": "",
    "text": "using GMT\nplot(1:10, rand(10), lw=1, lc=:blue, marker=:square,\n     markeredgecolor=0, size=0.2, markerfacecolor=:red, title=\"Hello World\",\n     xlabel=\"Spoons\", ylabel=\"Forks\", show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#hello-world",
    "href": "examples/plotting_functions/01_lines.html#hello-world",
    "title": "Line plots",
    "section": "",
    "text": "using GMT\nplot(1:10, rand(10), lw=1, lc=:blue, marker=:square,\n     markeredgecolor=0, size=0.2, markerfacecolor=:red, title=\"Hello World\",\n     xlabel=\"Spoons\", ylabel=\"Forks\", show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#section",
    "href": "examples/plotting_functions/01_lines.html#section",
    "title": "Line plots",
    "section": "",
    "text": "In this example the lines color is set using a custom CPT. Pen thickness is assigned automatically.\nThe custom CPT is used by setting the plot command’s cmap argument to true. This workas because we previously computed the CPT and it will remain in memory until it’s consumed when we finish the plot. The level argument sets the color to be used from the custom CPT.\nIn fact, in this case with a CPT already in memory, the level option alone would have triggered the line coloring and the cmap option could have been droped.\nNormally we don’t need to start a figure with a call to basemap because the plot function takes care of guessing reasonable defaults, but in this case we start with a curve with small amplitude and we grow the figure by adding more lines. So if we leave it to automatic guessing one would have to start by the largest amplitude curve.\n\nusing GMT\nC = makecpt(range=(0,10,1));\nbasemap(region=(20,30,-10,10), figsize=(12,8))\nx = 20:0.1:30;\nfor amp = 0:10\n    yy = amp .* sin.(x)\n    plot!(x, yy, cmap=true, level=(data=amp, nofill=true))\nend\ncolorbar!(show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#line-colors-with-the-automatic-color-scheme",
    "href": "examples/plotting_functions/01_lines.html#line-colors-with-the-automatic-color-scheme",
    "title": "Line plots",
    "section": "Line colors with the automatic color scheme",
    "text": "Line colors with the automatic color scheme\nHere we are showing how to plot several lines at once and color them according to a circular color scheme comprised of 7 distinct colors. We start by generating a dummy matrix 8x5, where rows represent the vertex and the columns hold the lines. To tell the program that first column contains the coordinates and the remaining are all lines to be plotted we use the option multicol=true\n\nusing GMT\nmat = GMT.fakedata(8, 5);\nlines(mat, multicol=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#line-colors-with-user-set-color-scheme",
    "href": "examples/plotting_functions/01_lines.html#line-colors-with-user-set-color-scheme",
    "title": "Line plots",
    "section": "Line colors with user set color scheme",
    "text": "Line colors with user set color scheme\nBut if we want choose the colors ourselves, it is also easy though we need to go a bit lower in the data preparation.\nThe basic data type to transfer tabular data to GMT is the GMTdataset and the above command has converted the matrix into a GMTdataset under the hood but now we need to create one ourselves and fine control more details, like the colors and line thickness of the individual lines. Not that we have 5 lines but will provide 3 colors and 3 lines thicknesses. When we do this those properties are wrapped modulo its number.\n\nusing GMT\nmat = GMT.fakedata(8, 5);\nD = mat2ds(mat, color=[\"brown\", \"green\", \"blue\"], linethick=[2, 1.0, 0.5, 0.25], multi=true);\n\n# And now we just call *lines* (but using *plot* would have been the same) with the **D** argument.\n\nlines(D, figsize=(14, 9.5), show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#bezier-curve",
    "href": "examples/plotting_functions/01_lines.html#bezier-curve",
    "title": "Line plots",
    "section": "Bezier curve",
    "text": "Bezier curve\n\nusing GMT\nx = [0, 1, 2, 3, 2];  y = [0, 1, 1, 0.5, 0.25];\nlines(x,y, limits=(-1,4,-0.5,2.0), scale=3.0, lw=1, markerfacecolor=:red,\n      size=0.5, bezier=true, title=\"Bezier curve\", show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#decorated-line",
    "href": "examples/plotting_functions/01_lines.html#decorated-line",
    "title": "Line plots",
    "section": "Decorated line",
    "text": "Decorated line\n\nusing GMT\nxy = sind.(0:180) .+ 4.5\nlines(xy, limits=(-5,185,4,6), figsize=(16,8), pen=(1,:red),\n      decorated=(dist=(2.5,0.25), symbol=:star, size=1,\n                 pen=(0.5,:green), fill=:blue, dec2=true),\n      title=:Decorated, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#text-decorated-line",
    "href": "examples/plotting_functions/01_lines.html#text-decorated-line",
    "title": "Line plots",
    "section": "Text decorated line",
    "text": "Text decorated line\n\nusing GMT\n# Create a log spiral\nt = linspace(0,2pi,100);\nx = cos.(t) .* t;       y = sin.(t) .* t;\ntxt = \" In Vino Veritas  - In Aqua, Rãs & Toads\"\nlines(x,y, region=(-4,7,-5.5,2.5), lw=2, lc=:sienna,\n      decorated=(quoted=true, const_label=txt, font=(25,\"Times-Italic\"),\n                 curved=true, pen=(0.5,:red)),\n      aspect=:equal, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#the-snake-skier",
    "href": "examples/plotting_functions/01_lines.html#the-snake-skier",
    "title": "Line plots",
    "section": "The snake skier",
    "text": "The snake skier\nPlot a skier on a sinusoid.\n\nusing GMT\n\nx = GMT.linspace(0, 2pi);  y = cos.(2x)*0.9;\n\nlines(x,y,                           # The data\n      limits=(0,6.5,-1,2.0),         # Fig limits\n      pen=(lw=7,lc=:sienna, arrow=(len=2.2,shape=:arrow, fill=:darkgreen)),  # The \"Snake\"\n      figsize=(16,12),               # Fig size\n      title=\"Double Snake\")\nplot!(3.49, 0.97,                    # Coordinates where to plot symbol\n      custom_symbol=(name=\"ski_alpine\", size=1.7),    # The skier symbol\n      fill=:black, show=true)        # Fill the symbol in black"
  },
  {
    "objectID": "examples/plotting_functions/01_lines.html#variable-sizedcolors-points",
    "href": "examples/plotting_functions/01_lines.html#variable-sizedcolors-points",
    "title": "Line plots",
    "section": "Variable sized/colors points",
    "text": "Variable sized/colors points\n\nusing GMT\nxs = linspace(0,10,30);\nys = 0.5 .* sin.(xs);\nscatter(xs, ys, zcolor=true, ms=linspace(2,15,30).*2.54/72, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/02_2stairs.html",
    "href": "examples/plotting_functions/02_2stairs.html",
    "title": "Stairs",
    "section": "",
    "text": "Create a stairs plot of sine evaluated at 50 equally spaced values between 0 and 4π.\n\nusing GMT\nx = linspace(0, 4*pi, 50);\nstairs(x, sin.(x), lw=0.5, marker=:circ, show=true)\n\n\n\n\n\n\n\n\nRepeat but this time with lines moving first along y.\n\nusing GMT\nx = linspace(0, 4*pi, 50);\nstairs(x, sin.(x), step=:pre, lw=0.5, marker=:circ, show=true)\n\n\n\n\n\n\n\n\nCreate a stairs plot of sine and a cosine evaluated at same points as above and add a circle marker at the points location. Note that now we are selectiong the columns from teir names in the D GMTdataset.\n\nusing GMT\n# Create a GMTdataset with named columns.\nD = mat2ds([x sin.(x) cos.(x)], colnames=[\"x\", \"sin(x)\", \"cos(x)\"]);\nstairs(D, xvar=:x, yvar=[\"sin(x)\", \"cos(x)\"], lw=0.5, marker=:circ, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/02_plotyy.html",
    "href": "examples/plotting_functions/02_plotyy.html",
    "title": "Plotyy",
    "section": "",
    "text": "Likewise contourf GMT does not have a plotyy module. A plotyy plot is a one where we plot Y1 versus X1 with y-axis labeling on the left and plots Y2 versus X2 with y-axis labeling on the right. So it’s basically a two plots overlain but the details to make it nice can be a bit boring and long.\n\nusing GMT\nx = 0:0.01:20;\ny1 = 200 * exp.(-0.05x) .* sin.(x);\ny2 = 0.8 * exp.(-0.5x)  .* sin.(10x);\nplotyy(y1, y2, title=\"Vibrating dishes\", ylabel=:Knifes, xlabel=:Forks,\n       seclabel=:Spoons, show=true)\n\n\n\n\n\n\n\n\nNote that to make the command shorter and nicer to read we have used a less known option in GMT. The secondary label of an axes. In this example we also didn’t set the xx coordinates so the program plotted from 1 to numbers of points.\nIn the general case the data has xx coordinates and they don’t even need to be the same for Y1 and Y2 (but they need to have a shared interval). In that case we should set the plot limits because otherwise the guessing done from xx,Y1 risk to not capture the total Y1+Y2 extent.\n\nusing GMT\nx = 0:0.01:20;\ny1 = 200 * exp.(-0.05x) .* sin.(x);\ny2 = 0.8 * exp.(-0.5x)  .* sin.(10x);\nplotyy([x[:] y1[:]], [x[:] y2[:]], title=\"Vibrating dishes\",\n       ylabel=:Knifes, xlabel=\"2000 Forks\", seclabel=:Spoons, show=1)"
  },
  {
    "objectID": "examples/plotting_functions/02_plotyy.html#examples",
    "href": "examples/plotting_functions/02_plotyy.html#examples",
    "title": "Plotyy",
    "section": "",
    "text": "Likewise contourf GMT does not have a plotyy module. A plotyy plot is a one where we plot Y1 versus X1 with y-axis labeling on the left and plots Y2 versus X2 with y-axis labeling on the right. So it’s basically a two plots overlain but the details to make it nice can be a bit boring and long.\n\nusing GMT\nx = 0:0.01:20;\ny1 = 200 * exp.(-0.05x) .* sin.(x);\ny2 = 0.8 * exp.(-0.5x)  .* sin.(10x);\nplotyy(y1, y2, title=\"Vibrating dishes\", ylabel=:Knifes, xlabel=:Forks,\n       seclabel=:Spoons, show=true)\n\n\n\n\n\n\n\n\nNote that to make the command shorter and nicer to read we have used a less known option in GMT. The secondary label of an axes. In this example we also didn’t set the xx coordinates so the program plotted from 1 to numbers of points.\nIn the general case the data has xx coordinates and they don’t even need to be the same for Y1 and Y2 (but they need to have a shared interval). In that case we should set the plot limits because otherwise the guessing done from xx,Y1 risk to not capture the total Y1+Y2 extent.\n\nusing GMT\nx = 0:0.01:20;\ny1 = 200 * exp.(-0.05x) .* sin.(x);\ny2 = 0.8 * exp.(-0.5x)  .* sin.(10x);\nplotyy([x[:] y1[:]], [x[:] y2[:]], title=\"Vibrating dishes\",\n       ylabel=:Knifes, xlabel=\"2000 Forks\", seclabel=:Spoons, show=1)"
  },
  {
    "objectID": "examples/plotting_functions/03_bars.html",
    "href": "examples/plotting_functions/03_bars.html",
    "title": "Bar plots",
    "section": "",
    "text": "A simple bar plot showing color and bar width (in data units) assignement.\n\nusing GMT\nbar(1:5, (20, 35, 30, 35, 27), width=0.5, color=:lightblue,\n    limits=(0.5,5.5,0,40), show=true)\n\n\n\n\n\n\n\n\nA colored bar plot with colors proportional to bar heights. In this case we let the plot limits be determined from data. We also plot a colorbar by using the colorbar=true option.\n\nusing GMT\nbar(rand(15), color=:turbo, figsize=(14,8), title=\"Colored bars\",\n    colorbar=true, show=true)\n\n\n\n\n\n\n\n\nExample showing how to plot bar groups and at same time assign variable transparency to each of the group’s band usinf the fillalpha option. Here, each row on the input data represents a bar group that has as many bands as n_columns - 1. -1 because first column must hold the xx coordinates of each group. The colors come from the automatic cyclic scheme.\n\nusing GMT\nbar([0. 1 2 3; 1 2 3 4], fillalpha=[0.3 0.5 0.7], show=true)\n\n\n\n\n\n\n\n\nAnd we can also make plots with bar groups where each group has a variable number of bars. For that, pass NaN’s in place of the missing bars for a particular group. For example:\n\nusing GMT\nbar([2 0.5 1 NaN 1; 4 NaN NaN 2 NaN; 1 3 4 3 2; NaN 3 NaN 1 2], fillalpha=[0.3 0.5 0.7],\n    xticks=(:d1, :d2, :d3, :d4), show=true)\n\n\n\n\n\n\n\n\nNext example shows how to plot error bars in a grouped bar. Similar to this mapplotlib’s example (labels will come later).\n\nusing GMT\nbar(1:5, [20 25; 35 32; 30 34; 35 20; 27 25], width=0.7, fill=[\"lightblue\", \"brown\"],\n    error_bars=(y=[2 3; 3 5; 4 2; 1 3; 2 3],),\n    xticks=(:G1, :G2, :G3, :G4, :G5), yaxis=(annot=5,label=:Scores),\n    frame=(title=\"Scores by group and gender\", axes=:WSrt), show=true)\n\n\n\n\n\n\n\n\nExample of a verticaly stacked bar plot. In this exampled we pass the xx coordinates as first argument and the individual bar heights in a matrix with smae number of rows as the number of elements in the x vector. To make it plot a stracked bar we used the option stacked=true.\n\nusing GMT\nbar(1:3,[-5 -15 20; 17 10 21; 10 5 15], stacked=1, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/03_bars.html#examples",
    "href": "examples/plotting_functions/03_bars.html#examples",
    "title": "Bar plots",
    "section": "",
    "text": "A simple bar plot showing color and bar width (in data units) assignement.\n\nusing GMT\nbar(1:5, (20, 35, 30, 35, 27), width=0.5, color=:lightblue,\n    limits=(0.5,5.5,0,40), show=true)\n\n\n\n\n\n\n\n\nA colored bar plot with colors proportional to bar heights. In this case we let the plot limits be determined from data. We also plot a colorbar by using the colorbar=true option.\n\nusing GMT\nbar(rand(15), color=:turbo, figsize=(14,8), title=\"Colored bars\",\n    colorbar=true, show=true)\n\n\n\n\n\n\n\n\nExample showing how to plot bar groups and at same time assign variable transparency to each of the group’s band usinf the fillalpha option. Here, each row on the input data represents a bar group that has as many bands as n_columns - 1. -1 because first column must hold the xx coordinates of each group. The colors come from the automatic cyclic scheme.\n\nusing GMT\nbar([0. 1 2 3; 1 2 3 4], fillalpha=[0.3 0.5 0.7], show=true)\n\n\n\n\n\n\n\n\nAnd we can also make plots with bar groups where each group has a variable number of bars. For that, pass NaN’s in place of the missing bars for a particular group. For example:\n\nusing GMT\nbar([2 0.5 1 NaN 1; 4 NaN NaN 2 NaN; 1 3 4 3 2; NaN 3 NaN 1 2], fillalpha=[0.3 0.5 0.7],\n    xticks=(:d1, :d2, :d3, :d4), show=true)\n\n\n\n\n\n\n\n\nNext example shows how to plot error bars in a grouped bar. Similar to this mapplotlib’s example (labels will come later).\n\nusing GMT\nbar(1:5, [20 25; 35 32; 30 34; 35 20; 27 25], width=0.7, fill=[\"lightblue\", \"brown\"],\n    error_bars=(y=[2 3; 3 5; 4 2; 1 3; 2 3],),\n    xticks=(:G1, :G2, :G3, :G4, :G5), yaxis=(annot=5,label=:Scores),\n    frame=(title=\"Scores by group and gender\", axes=:WSrt), show=true)\n\n\n\n\n\n\n\n\nExample of a verticaly stacked bar plot. In this exampled we pass the xx coordinates as first argument and the individual bar heights in a matrix with smae number of rows as the number of elements in the x vector. To make it plot a stracked bar we used the option stacked=true.\n\nusing GMT\nbar(1:3,[-5 -15 20; 17 10 21; 10 5 15], stacked=1, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/03_bars.html#a-waterfall-chart",
    "href": "examples/plotting_functions/03_bars.html#a-waterfall-chart",
    "title": "Bar plots",
    "section": "A waterfall chart",
    "text": "A waterfall chart\n\nusing GMT\nbar([1 2 3 0 -1 -2 0], stacked=:water, connector=true, bargap=25,\n    xticks=(:A, :B, :C, :Partial, :D, :E, :Total), show=true)"
  },
  {
    "objectID": "examples/plotting_functions/03_bars.html#horizontal-bar-plots",
    "href": "examples/plotting_functions/03_bars.html#horizontal-bar-plots",
    "title": "Bar plots",
    "section": "Horizontal bar plots",
    "text": "Horizontal bar plots\nTo create an horizontal bar plot we use the hbar=true option\n\nusing GMT\nbar([0. 1 2 3; 1 2 3 4], hbar=true, show=true)\n\n\n\n\n\n\n\n\nAnd one horizontally stacked but this time we pick the colors.\n\nusing GMT\nbar([0. 1 2 3; 1 2 3 4], stack=true, hbar=true, fill=[\"red\", \"green\", \"blue\"], show=true)"
  },
  {
    "objectID": "examples/plotting_functions/03_bars.html#make-a-3d-bar-plot-with-constant-color",
    "href": "examples/plotting_functions/03_bars.html#make-a-3d-bar-plot-with-constant-color",
    "title": "Bar plots",
    "section": "Make a 3D bar plot with constant color",
    "text": "Make a 3D bar plot with constant color\n\nusing GMT\n\n#Create a 3x3 grid\nG = gmt(\"grdmath -R0/2/0/2 -I1 X Y R2 NEG EXP X MUL =\");\n\n# Plot that grid as 3D prisms\nbar3(G,                 # 'G' is the grid created above\n     fill=[0,115,190],  # Fill prisms with this RGB color\n     lw=:thinnest,      # Line thickness (0.25 pt)\n     show=true)         # Display the figure.\n\n\n┌ Warning: 'multile coluns' in 3D plots are not allowed. Ignoring.\n\n└ @ GMT C:\\Users\\j\\.julia\\dev\\GMT\\src\\psxy.jl:521\n\n\n\n\n\n\n\n\n\n\n\n\nPlot a grid as 3D prisms.\n\nusing GMT\n\nG = GMT.peaks();      # Create a 'peaks' grid\ncmap = grd2cpt(G);    # Colormap with the grid's data range\n\nbar3(G,               # 'G' is the grid created above\n     lw=:thinnest,    # Line thickness (0.25 pt)\n     color=cmap,      # Paint the prisms with colormap computed from grid\n     show=true)       # Display the figure."
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html",
    "href": "examples/plotting_functions/05_1_stats.html",
    "title": "Stat plots",
    "section": "",
    "text": "using GMT\ndensity(randn(200), fill=true, show=true)\n\n\n\n\n\n\n\n\n\nusing GMT\ndensity(randn(200), nbins=20, horizontal=true, fill=true, extend=2, show=true)\n\n\n\n\n\n\n\n\nExpand the density profile with 4 x the set bandwidth, such that it decays to zero. By lowering the bandwidth we forcing the line to be less smoth.\n\nusing GMT\ndensity(randn(200), fill=:orange, lc=:red, lw=1, bandwidth=0.15, extend=4, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#examples-of-density-plots",
    "href": "examples/plotting_functions/05_1_stats.html#examples-of-density-plots",
    "title": "Stat plots",
    "section": "",
    "text": "using GMT\ndensity(randn(200), fill=true, show=true)\n\n\n\n\n\n\n\n\n\nusing GMT\ndensity(randn(200), nbins=20, horizontal=true, fill=true, extend=2, show=true)\n\n\n\n\n\n\n\n\nExpand the density profile with 4 x the set bandwidth, such that it decays to zero. By lowering the bandwidth we forcing the line to be less smoth.\n\nusing GMT\ndensity(randn(200), fill=:orange, lc=:red, lw=1, bandwidth=0.15, extend=4, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#box-plots",
    "href": "examples/plotting_functions/05_1_stats.html#box-plots",
    "title": "Stat plots",
    "section": "Box plots",
    "text": "Box plots\nAn horizontal boxplot with default colors, displaying outliers as 6p black stars. Noches are also shown but this requires GMT6.5.\n\nusing GMT\nboxplot(randn(50,6), notch=true, fill=true, outliers=(size=\"6p\",), hbar=true, show=1)\n\n\n\n\n\n\n\n\nA plot of three groups of two elements each and where we assign the same color to the elements of each group.\n\nusing GMT\nboxplot(randn(50,3,2), boxwidth=\"20p\", notch=true, fill=true, ccolor=true, show=1)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#violin-plots",
    "href": "examples/plotting_functions/05_1_stats.html#violin-plots",
    "title": "Stat plots",
    "section": "Violin plots",
    "text": "Violin plots\nCreate a plot with 8 violins colored with the default colors.\n\nusing GMT\nviolin(randn(100,8), fill=true, show=true)\n\n\n\n\n\n\n\n\nNow add boxplot, scatter and outliers to a plot similar to above. The outliers show as black stars with a fait gray outline.\n\nusing GMT\nviolin(randn(100,8), fill=true, boxplot=true, scatter=true, outliers=true, show=true)\n\n\n\n\n\n\n\n\nAnd a group example with red dashed separator lines and variable level of transparency for each element in the group. Note that this case uses input data as a Vector{Vector{Vector}}, which more representative of a real case as each violin is allowed to be made of a different number of observations.\n\nusing GMT\nvvv = [[randn(50), randn(30)], [randn(40), randn(48), randn(45)], [randn(35), randn(43)]];\nviolin(vvv, fill=true, fillalpha=[0.5, 0.7, 0.85], boxplot=true, separator=(:red, :dash),\n       scatter=true, outliers=true, show=true)\n\n\n\n\n\n\n\n\nJoin the left and right halves of each of the two element in the group.\n\nusing GMT\nviolin(randn(100,3,2), fill=true, scatter=true, split=true, xticks=[\"First\",\"Second\",\"Third\"], show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#q-q-plots",
    "href": "examples/plotting_functions/05_1_stats.html#q-q-plots",
    "title": "Stat plots",
    "section": "Q-Q plots",
    "text": "Q-Q plots\nTest if x and y follow the same distribution.\n\nusing GMT\nqqplot(randn(100), randn(100), qqline=:identity, title=\"Q-Q plot\", show=true)\n\n\n\n\n\n\n\n\nTest if x is normally distributed. the :fitrobust default line passes through the 1st and 3rd quartiles of the distribution\n\nusing GMT\nqqnorm(randn(200), qqline=:fitrobust, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#ecdf-plot",
    "href": "examples/plotting_functions/05_1_stats.html#ecdf-plot",
    "title": "Stat plots",
    "section": "ECDF plot",
    "text": "ECDF plot\n\nusing GMT\necdfplot(randn(100), title=\"ECDF plot\", show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#parallel-plots",
    "href": "examples/plotting_functions/05_1_stats.html#parallel-plots",
    "title": "Stat plots",
    "section": "Parallel plots",
    "text": "Parallel plots\nSee docs in parallelplot\nCreate a parallel plot using the measurement data in iris.dat. Use a different color for each group as identified in species, and label the horizontal axis using the variable names.\n\nusing GMT\nparallelplot(TESTSDIR * \"assets/iris.dat\", groupvar=\"text\", normalize=\"none\", legend=true,\n             title=\"Parallel plot\", show=true)\n\n\n\n\n\n\n\n\nPlot only the median, 25 percent, and 75 percent quartile values for each group identified in species. Label the horizontal axis using the variable names.\n\nusing GMT\nparallelplot(TESTSDIR * \"assets/iris.dat\", groupvar=\"text\", quantile=0.25, legend=true, show=true)\n\n\n\n\n\n\n\n\nPlot bands enveloping the +- 25% percentil arround the median.\n\nusing GMT\nparallelplot(TESTSDIR * \"assets/iris.dat\", groupvar=\"text\", band=true, legend=true, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#corner-plots",
    "href": "examples/plotting_functions/05_1_stats.html#corner-plots",
    "title": "Stat plots",
    "section": "Corner plots",
    "text": "Corner plots\nCreate a cornerplot plot with hexagonal bins, setting the color map, the vriable names, plot truth and title.\n\nusing GMT\ncornerplot(randn(4000,3), cmap=:viridis, truths=[0.25, 0.5, 0.75],\n           varnames=[\"Ai\", \"Oi\", \"Ui\"], title=\"Corner plot\", show=true)\n\n\n\n\n\n\n\n\nExample on how to control the symbol types, size and color.\n\nusing GMT\ncornerplot(randn(1500,3), scatter=true, marker=:cross, mec=:red, ms=\"3p\", show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#marginalhist-plots",
    "href": "examples/plotting_functions/05_1_stats.html#marginalhist-plots",
    "title": "Stat plots",
    "section": "Marginalhist plots",
    "text": "Marginalhist plots\nA scatter plot with histograms on the sides\n\nusing GMT\nmarginalhist(randn(2000,2), histkw=(frame=\"none\",), show=true)\n\n\n\n\n\n\n\n\nA scatter plot with density curves on the sides\n\nusing GMT\n marginalhist(randn(2000,2), histkw=(frame=\"none\", fill=\"red@60\"), density=true, show=true)\n\n\n\n\n\n\n\n\nAn hexbin scater plot with marginal density plots. Note that we must set aspect=:equal to have that hexbin plot.\n\nusing GMT\nmarginalhist(randn(2500,2), cmap=:lisbon, density=true, histkw=(fill=\"darkgreen@60\",),\n             aspect=:equal, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_1_stats.html#line-fits",
    "href": "examples/plotting_functions/05_1_stats.html#line-fits",
    "title": "Stat plots",
    "section": "Line fits",
    "text": "Line fits\nPlot a regression fit over a scatter plot (no errors in X nor in Y). Example0 in https://github.com/rafael-guerra-www/LinearFitXYerrors.jl/blob/master/examples/example0.jl\n\nusing GMT\nD = linearfitxy([91., 104, 107, 107, 106, 100, 92, 92, 105, 108],\n                [9.8, 7.4, 7.9, 8.3, 8.3, 9.0, 9.7, 8.8, 7.6, 6.9]);\nplot(D, linefit=true, band_ab=true, band_ci=true, legend=true, show=true)\n\n\n\n\n\n\n\n\nNon-correlated errors in X and in Y Example2 in https://github.com/rafael-guerra-www/LinearFitXYerrors.jl/blob/master/examples/example2.jl\n\nusing GMT\nD = linearfitxy([0.0, 0.9, 1.8, 2.6, 3.3, 4.4, 5.2, 6.1, 6.5, 7.4],\n                [5.9, 5.4, 4.4, 4.6, 3.5, 3.7, 2.8, 2.8, 2.4, 1.5],\n                sx=1 ./ sqrt.([1000., 1000, 500, 800, 200, 80,  60, 20, 1.8, 1]),\n                sy=1 ./ sqrt.([1., 1.8, 4, 8, 20, 20, 70, 70, 100, 500]));\nplot(D, linefit=true, band_ab=true, band_ci=true, ellipses=true, legend=true, show=1)\n\n\n\n\n\n\n\n\nCondition the regression fit on another variable and represent it using color.\n\nusing GMT\nD = gmtread(TESTSDIR * \"assets/iris.dat\");\nplot(D, xvar=1, yvar=2, hue=\"Species\", xlabel=:auto, ylabel=:auto, linefit=true,\n     band_ci=true, legend=true, show=1)"
  },
  {
    "objectID": "examples/plotting_functions/05_error_bars.html",
    "href": "examples/plotting_functions/05_error_bars.html",
    "title": "Error bars",
    "section": "",
    "text": "Plot error bars with different color control\n\nusing GMT\n\nC = makecpt(range=(0,6,1));\nt = [1 1 1 1\n    2 2 2 1\n    3 3 3 1\n    4 4 4 1\n    5 5 5 1];\nplot(t, limits=(0,6,0,6), figsize=7, frame=:noannot, marker=:circle, ms=0.5,\n     color=C, ml=0.25, error_bars=(x=:x, pen=(2,:red)), yshift=5)\nplot!(t, frame=:noannot, marker=:circle, ms=0.5, color=C, ml=0.25,\n      error_bars=(y=:y, pen=1, cline=true), xshift=7.5)\n# Use the color map to paint the symbol marker line\nplot!(t, frame=:noannot, marker=:circle, ms=0.5, color=C,\n      ml=(lw=5, colored=true), error_bars=(y=:y, pen=1, csymbol=true),\n      xshift=-7.5, yshift=7.5)\n# Pretend our data array has only the coordinates and pass color col & errors via args\ntt = t[:,1:2]\nplot!(tt, frame=:noannot, marker=:circle, ms=0.5, color=C, mz=[1 2 3 4 5],\n      ml=(0.25,:red), error_bars=(x=ones(5,1), pen=1, cline=true),\n      xshift=7.5, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/05_error_bars.html#examples",
    "href": "examples/plotting_functions/05_error_bars.html#examples",
    "title": "Error bars",
    "section": "",
    "text": "Plot error bars with different color control\n\nusing GMT\n\nC = makecpt(range=(0,6,1));\nt = [1 1 1 1\n    2 2 2 1\n    3 3 3 1\n    4 4 4 1\n    5 5 5 1];\nplot(t, limits=(0,6,0,6), figsize=7, frame=:noannot, marker=:circle, ms=0.5,\n     color=C, ml=0.25, error_bars=(x=:x, pen=(2,:red)), yshift=5)\nplot!(t, frame=:noannot, marker=:circle, ms=0.5, color=C, ml=0.25,\n      error_bars=(y=:y, pen=1, cline=true), xshift=7.5)\n# Use the color map to paint the symbol marker line\nplot!(t, frame=:noannot, marker=:circle, ms=0.5, color=C,\n      ml=(lw=5, colored=true), error_bars=(y=:y, pen=1, csymbol=true),\n      xshift=-7.5, yshift=7.5)\n# Pretend our data array has only the coordinates and pass color col & errors via args\ntt = t[:,1:2]\nplot!(tt, frame=:noannot, marker=:circle, ms=0.5, color=C, mz=[1 2 3 4 5],\n      ml=(0.25,:red), error_bars=(x=ones(5,1), pen=1, cline=true),\n      xshift=7.5, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/07_symbols.html",
    "href": "examples/plotting_functions/07_symbols.html",
    "title": "Symbols & Linestyes",
    "section": "",
    "text": "using GMT\n\nls = [\"pen=0.5\",                      # default (a 0.5 points continuous black line)\n      \"pen=(\\\"1p\\\",:red,:dash)\",      # dashed line\n      \"pen=(1,:blue,:dot)\",           # dotted line\n      \"pen=(1,:lightblue,:DashDot)\",  # dash-dotted line\n      \"pen=(2,:blue,:DotDotDash)\",    # dot-dot-dashed line\n      \"pen=(2,:tomato,:DashDashDot)\", # dash-dash-dotted line\n      \"pen=(2,:tomato,\\\"4_2:2p\\\")\",   # A pattern of 4-point-long line segments and 2-point-long gaps between\n                                      # segments, with pattern offset by 2 points from the origin\n      \"pen=(5,:black)\",               # First line of the railway \n      \"pen=(4,:white,\\\"20p_20p\\\")\"];  # Second line of the railway. Together they make the desired effect\n\n# Helper variable with the above verbose pen settings converted to GMT hard-core syntax\n_ls = [\"0.5\", \"1p,red,-\", \"1p,blue,.\", \"1p,lightblue,-.\", \"2p,blue,..-\",\n      \"2p,tomato,--.\", \"2p,tomato,4_2:2p\", \"5,black\", \"4p,white,20p_20p\"];\n\n# line coordinates\nx = [0 7];  y = [9 8 7 6 5 4 3 2 2; 9 8 7 6 5 4 3 2 2];\nD = mat2ds(y, x=x, pen=_ls, multi=true);    # GMTdataset with all info about the lines\n\n# Plot the lines\nplot(D, region=(0,11,1,9.5), title=\"Line styles\", frame=:none)\n\n# Plot all texts but the one referring to last line that must be broken in two tokens\nfor k = 1:length(ls)-2\n    text!(x=x[end], y=y[1,k], text=ls[k], justify=:ML, offset=(0.2,0))\nend\ntext!(x=x[end], y=y[1,end], text=ls[end-1], justify=:ML, offset=(0.2,0.2))\ntext!(x=x[end], y=y[1,end], text=ls[end],   justify=:ML, offset=(0.2,-0.2), show=true)\n\n\n\n\n\n\n\n\n\n\n\nDraw a so-called front which allows to plot specific symbols distributed along a line or curve. Typical use cases are weather fronts, fault lines, subduction zones, and more.\n\nusing GMT\n\n# keyword/value way of controlling the Front line styles.\nfs = [\"decorated=(dist=(1,0.25), symbol=:fault)\",\n      \"decorated=(dist=(1,0.25), symbol=:box)\",\n      \"decorated=(dist=(1,0.25), symbol=:circle)\",\n      \"decorated=(dist=(1,0.30), symbol=:triangle)\",\n      \"decorated=(dist=(2,1.00), symbol=\\\"s45\\\", side=:left, offset=2.25)\",\n      \"decorated=(dist=(1,0.40), symbol=:fault, side=:left)\",\n      \"decorated=(dist=(1,0.30), symbol=:box, side=:left)\",\n      \"decorated=(dist=(1,0.40), symbol=:circle, right=true)\",\n      \"decorated=(dist=(1,0.30), symbol=:triangle, side=:left)\",\n      \"decorated=(dist=(1,0.40), symbol=:fault, side=:right, pen=(1.5,:dodgerblue))\",\n      \"decorated=(dist=(0.5,0.3), symbol=:triang, side=:right, offset=0.3, pen=true)\",\n      \"decorated=(dist=(0.5,0.3), symbol=:triang, side=:right, offset=0.3, pen='''', noline=true)\"];\n\n# Helper variable with the above verbose pen settings converted to GMT hard-core syntax\n_fs = [\"1c/0.25c\", \"1c/0.25c+b\", \"1c/0.25c+c\", \"1c/0.3c+t\", \"2c/1c+l+s45+o2.25c\", \"1c/0.4c+l\",\n       \"1c/0.3c+l+b\", \"1c/0.4c+r+c\", \"1c/0.3c+l+t\", \"1c/0.4c+r+t+p1.5p,dodgerblue\",\n       \"0.5c/0.3c+r+t+o0.3c+p\", \"0.5c/0.3c+r+t+o0.3c+p+i\"];\n\n# line coordinates\nx = [1 6];  y = [20 19 18 17 16 15 14 13 12 11 10 9; 20 19 18 17 16 15 14 13 12 11 10 9];\nD = mat2ds(y, x=x, lt=1.25, front=_fs, fill=[\"red\"], multi=true);    # GMTdataset with all info about the lines\n\n# Plot the lines\nplot(D, region=(0,21,8,20.5), figsize=(16,10), title=\"Line fronts\", symbol=:f, frame=:none)\n\n# Plot the texts with the verbose front style settings\nfor k = 1:length(fs)\n    text!(x=x[end], y=y[1,k], text=fs[k], font=8, justify=:ML, offset=(0.5,0))\nend\nshowfig()\n\n\n\n\n\n\n\n\n\n\n\n\nusing GMT\n\nfont = \"9p,Helvetica-Bold\"\n\nplot(region=[0, 8, 0, 3], figsize=(12,4), x=1, y=2, marker=\"-\", ms=0.9,\n     ml=(2,:gray40), title=\"Basic symbols\", text=(txt=\"-\", x=1, y=2.6, font=font))\n\nplot!(x=2, y=2, marker=\"+\", ms=0.9, ml=(2,:gray40),\n      text=(txt=\"+\", x=2, y=2.6, font=font))\n\nplot!(x=3, y=2, marker=:star, ms=0.9, mc=:darkorange,\n      ml=1, text=(txt=\"star\", x=3, y=2.6, font=font))\n\nplot!(x=4, y=2, marker=:circ, ms=0.9, mc=:darkred,\n      ml=1, text=(txt=\"circle\", x=4, y=2.6, font=font))\n\nplot!(x=5, y=2, marker=:diamond, ms=0.9, mc=:seagreen,\n      ml=1, text=(txt=\"diamond\", x=5, y=2.6, font=font))\n\nplot!(x=6, y=2, marker=:octagon, ms=0.9, mc=:dodgerblue4,\n      ml=1, text=(txt=\"octagon\", x=6, y=2.6, font=font))\n\nplot!(x=7, y=2, marker=:hexagon, ms=0.9, mc=:lightgray,\n      ml=1, text=(txt=\"hexagon\", x=7, y=2.6, font=font))\n\nplot!(x=1, y=0.5, marker=:inverted_tri, ms=0.9, mc=:tomato,\n      ml=1, text=(txt=\"inverted_tri\", x=1, y=1.1, font=\"7p,Helvetica-Bold\"))\n\nplot!(x=2, y=0.5, marker=:pentagon, ms=0.9, mc=:lightseagreen,\n      ml=1, text=(txt=\"pentagon\", x=2, y=1.1, font=font))\n\nplot!(x=3, y=0.5, marker=:point, ms=0.9, mc=:slateblue,\n      ml=1, text=(txt=\"point\", x=3, y=1.1, font=font))\n\nplot!(x=4, y=0.5, marker=:square, ms=0.9, mc=:gold2,\n      ml=1, text=(txt=\"square\", x=4, y=1.1, font=font))\n\nplot!(x=5, y=0.5, marker=:triangle, ms=0.9, mc=:magenta4,\n      ml=1, text=(txt=\"triangle\", x=5, y=1.1, font=font))\n\nplot!(x=6, y=0.5, marker=:cross, ms=0.9, ml=(2,:gray40), \n      text=(txt=\"cross\", x=6, y=1.1, font=font))\n\nplot!(x=7, y=0.5, marker=\"y-dash\", ms=0.9, ml=(2,:gray40), \n      text=(txt=\"y-dash\", x=7, y=1.1, font=font))\n\nshowfig()\n\n\n\n\n\n\n\n\n\n\n\n\nusing GMT\n\nplot([0 0], limits=(-1,6,-1,6), figsize=(15,15), marker=:circle, ms=0.75,\n     fill=:green, frame=(axes=:WSen, annot=2,grid=1, title=\"Symbols & pens\"))\nplot!([1 0], marker=:circle, ms=0.75, fill=:green, ml=(1,:black))\nplot!([2 0], marker=:circle, ms=0.75, fill=:green, ml=(1,\"0/130/0\"))\nplot!([3 0], marker=:circle, ms=0.75, fill=:green, ml=(1,:black, :dashed))\nplot!([4 0], marker=:circle, ms=0.75, fill=:green, ml=(1,:black, \"-.\"))\nplot!([5 0], marker=:circle, ms=0.75, fill=\"-\",    ml=(1,\"0/130/0\"))\nplot!([0 1], marker=:star,   ms=0.75, fill=:red,   ml=(1,:black))\nplot!([1 1], marker=:triang, ms=0.75, fill=:red,   ml=(1,:black,:dashed))\nplot!([2 1], marker=:diamond,ms=0.75, fill=:red)\nplot!([3 1], marker=:hexagon,ms=0.75, fill=:red,   ml=(0.5,:black))\nplot!([4 1], marker=:plus,   ms=0.75, ml=(2,:red))\nplot!([5 1], marker=:square, ms=0.75, fill=:red)\nplot!([0 3], marker=(custom=\"flash\", size=1.5),  ml=1, fill=:brown)\nplot!([1 3], marker=(custom=\"hurricane\", size=1.5),  ml=1, fill=:blue)\nplot!([2 3], marker=(custom=\"pacman\",  size=1.5),  ml=1, fill=:gray)\nplot!([3 3], marker=(custom=\"star3\",   size=1.5),  ml=1, fill=:brown)\nplot!([4 3], marker=(custom=\"sun\",     size=1.5),  ml=1, fill=:yellow)\nplot!([5 3], marker=(custom=\"volcano\", size=1.5),  ml=1, fill=:red)\nplot!([1 5], marker=(custom=\"@gallo\",  size=3.5))\nplot!([4 5], marker=(custom=\"@sardinha\", size=6.0), show=true)\n\n\n\n\n\n\n\n\n\n\n\nPlot Pies, Wedges or Web (spiders). They are all synonims. We show here three different ways of plotting this symbol (depending of its complexity)\n\nusing GMT\nplot([0.5 0.5 30 100], limits=(0,6,0,3), figscale=2.5, frame=\"afg\",\n     marker=:wedge, ms=5, fill=:lightyellow, ml=2, title=\"Spiders\")\nplot!([2.5 0.5 30 100], marker=:wedge, ms=5, fill=:yellow)\nplot!([0.5 1.75 30 100], marker=(web=true, size=5, arc=0.7, pen=(0.5,:red)), ml=1)\nplot!([2.5 1.75 30 100], marker=(web=true, size=5, radial=15),\n      fill=:lightyellow, ml=0.5)\n# But we can also send the Web angle info via marker and use a Tuple as argument.\nplot!([4.5 1.75], marker=(:web, [30 330], (size=5, arc=0.7, radial=15, pen=0.25)),\n      fill=:pink, ml=1, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/07_symbols.html#examples",
    "href": "examples/plotting_functions/07_symbols.html#examples",
    "title": "Symbols & Linestyes",
    "section": "",
    "text": "using GMT\n\nls = [\"pen=0.5\",                      # default (a 0.5 points continuous black line)\n      \"pen=(\\\"1p\\\",:red,:dash)\",      # dashed line\n      \"pen=(1,:blue,:dot)\",           # dotted line\n      \"pen=(1,:lightblue,:DashDot)\",  # dash-dotted line\n      \"pen=(2,:blue,:DotDotDash)\",    # dot-dot-dashed line\n      \"pen=(2,:tomato,:DashDashDot)\", # dash-dash-dotted line\n      \"pen=(2,:tomato,\\\"4_2:2p\\\")\",   # A pattern of 4-point-long line segments and 2-point-long gaps between\n                                      # segments, with pattern offset by 2 points from the origin\n      \"pen=(5,:black)\",               # First line of the railway \n      \"pen=(4,:white,\\\"20p_20p\\\")\"];  # Second line of the railway. Together they make the desired effect\n\n# Helper variable with the above verbose pen settings converted to GMT hard-core syntax\n_ls = [\"0.5\", \"1p,red,-\", \"1p,blue,.\", \"1p,lightblue,-.\", \"2p,blue,..-\",\n      \"2p,tomato,--.\", \"2p,tomato,4_2:2p\", \"5,black\", \"4p,white,20p_20p\"];\n\n# line coordinates\nx = [0 7];  y = [9 8 7 6 5 4 3 2 2; 9 8 7 6 5 4 3 2 2];\nD = mat2ds(y, x=x, pen=_ls, multi=true);    # GMTdataset with all info about the lines\n\n# Plot the lines\nplot(D, region=(0,11,1,9.5), title=\"Line styles\", frame=:none)\n\n# Plot all texts but the one referring to last line that must be broken in two tokens\nfor k = 1:length(ls)-2\n    text!(x=x[end], y=y[1,k], text=ls[k], justify=:ML, offset=(0.2,0))\nend\ntext!(x=x[end], y=y[1,end], text=ls[end-1], justify=:ML, offset=(0.2,0.2))\ntext!(x=x[end], y=y[1,end], text=ls[end],   justify=:ML, offset=(0.2,-0.2), show=true)\n\n\n\n\n\n\n\n\n\n\n\nDraw a so-called front which allows to plot specific symbols distributed along a line or curve. Typical use cases are weather fronts, fault lines, subduction zones, and more.\n\nusing GMT\n\n# keyword/value way of controlling the Front line styles.\nfs = [\"decorated=(dist=(1,0.25), symbol=:fault)\",\n      \"decorated=(dist=(1,0.25), symbol=:box)\",\n      \"decorated=(dist=(1,0.25), symbol=:circle)\",\n      \"decorated=(dist=(1,0.30), symbol=:triangle)\",\n      \"decorated=(dist=(2,1.00), symbol=\\\"s45\\\", side=:left, offset=2.25)\",\n      \"decorated=(dist=(1,0.40), symbol=:fault, side=:left)\",\n      \"decorated=(dist=(1,0.30), symbol=:box, side=:left)\",\n      \"decorated=(dist=(1,0.40), symbol=:circle, right=true)\",\n      \"decorated=(dist=(1,0.30), symbol=:triangle, side=:left)\",\n      \"decorated=(dist=(1,0.40), symbol=:fault, side=:right, pen=(1.5,:dodgerblue))\",\n      \"decorated=(dist=(0.5,0.3), symbol=:triang, side=:right, offset=0.3, pen=true)\",\n      \"decorated=(dist=(0.5,0.3), symbol=:triang, side=:right, offset=0.3, pen='''', noline=true)\"];\n\n# Helper variable with the above verbose pen settings converted to GMT hard-core syntax\n_fs = [\"1c/0.25c\", \"1c/0.25c+b\", \"1c/0.25c+c\", \"1c/0.3c+t\", \"2c/1c+l+s45+o2.25c\", \"1c/0.4c+l\",\n       \"1c/0.3c+l+b\", \"1c/0.4c+r+c\", \"1c/0.3c+l+t\", \"1c/0.4c+r+t+p1.5p,dodgerblue\",\n       \"0.5c/0.3c+r+t+o0.3c+p\", \"0.5c/0.3c+r+t+o0.3c+p+i\"];\n\n# line coordinates\nx = [1 6];  y = [20 19 18 17 16 15 14 13 12 11 10 9; 20 19 18 17 16 15 14 13 12 11 10 9];\nD = mat2ds(y, x=x, lt=1.25, front=_fs, fill=[\"red\"], multi=true);    # GMTdataset with all info about the lines\n\n# Plot the lines\nplot(D, region=(0,21,8,20.5), figsize=(16,10), title=\"Line fronts\", symbol=:f, frame=:none)\n\n# Plot the texts with the verbose front style settings\nfor k = 1:length(fs)\n    text!(x=x[end], y=y[1,k], text=fs[k], font=8, justify=:ML, offset=(0.5,0))\nend\nshowfig()\n\n\n\n\n\n\n\n\n\n\n\n\nusing GMT\n\nfont = \"9p,Helvetica-Bold\"\n\nplot(region=[0, 8, 0, 3], figsize=(12,4), x=1, y=2, marker=\"-\", ms=0.9,\n     ml=(2,:gray40), title=\"Basic symbols\", text=(txt=\"-\", x=1, y=2.6, font=font))\n\nplot!(x=2, y=2, marker=\"+\", ms=0.9, ml=(2,:gray40),\n      text=(txt=\"+\", x=2, y=2.6, font=font))\n\nplot!(x=3, y=2, marker=:star, ms=0.9, mc=:darkorange,\n      ml=1, text=(txt=\"star\", x=3, y=2.6, font=font))\n\nplot!(x=4, y=2, marker=:circ, ms=0.9, mc=:darkred,\n      ml=1, text=(txt=\"circle\", x=4, y=2.6, font=font))\n\nplot!(x=5, y=2, marker=:diamond, ms=0.9, mc=:seagreen,\n      ml=1, text=(txt=\"diamond\", x=5, y=2.6, font=font))\n\nplot!(x=6, y=2, marker=:octagon, ms=0.9, mc=:dodgerblue4,\n      ml=1, text=(txt=\"octagon\", x=6, y=2.6, font=font))\n\nplot!(x=7, y=2, marker=:hexagon, ms=0.9, mc=:lightgray,\n      ml=1, text=(txt=\"hexagon\", x=7, y=2.6, font=font))\n\nplot!(x=1, y=0.5, marker=:inverted_tri, ms=0.9, mc=:tomato,\n      ml=1, text=(txt=\"inverted_tri\", x=1, y=1.1, font=\"7p,Helvetica-Bold\"))\n\nplot!(x=2, y=0.5, marker=:pentagon, ms=0.9, mc=:lightseagreen,\n      ml=1, text=(txt=\"pentagon\", x=2, y=1.1, font=font))\n\nplot!(x=3, y=0.5, marker=:point, ms=0.9, mc=:slateblue,\n      ml=1, text=(txt=\"point\", x=3, y=1.1, font=font))\n\nplot!(x=4, y=0.5, marker=:square, ms=0.9, mc=:gold2,\n      ml=1, text=(txt=\"square\", x=4, y=1.1, font=font))\n\nplot!(x=5, y=0.5, marker=:triangle, ms=0.9, mc=:magenta4,\n      ml=1, text=(txt=\"triangle\", x=5, y=1.1, font=font))\n\nplot!(x=6, y=0.5, marker=:cross, ms=0.9, ml=(2,:gray40), \n      text=(txt=\"cross\", x=6, y=1.1, font=font))\n\nplot!(x=7, y=0.5, marker=\"y-dash\", ms=0.9, ml=(2,:gray40), \n      text=(txt=\"y-dash\", x=7, y=1.1, font=font))\n\nshowfig()\n\n\n\n\n\n\n\n\n\n\n\n\nusing GMT\n\nplot([0 0], limits=(-1,6,-1,6), figsize=(15,15), marker=:circle, ms=0.75,\n     fill=:green, frame=(axes=:WSen, annot=2,grid=1, title=\"Symbols & pens\"))\nplot!([1 0], marker=:circle, ms=0.75, fill=:green, ml=(1,:black))\nplot!([2 0], marker=:circle, ms=0.75, fill=:green, ml=(1,\"0/130/0\"))\nplot!([3 0], marker=:circle, ms=0.75, fill=:green, ml=(1,:black, :dashed))\nplot!([4 0], marker=:circle, ms=0.75, fill=:green, ml=(1,:black, \"-.\"))\nplot!([5 0], marker=:circle, ms=0.75, fill=\"-\",    ml=(1,\"0/130/0\"))\nplot!([0 1], marker=:star,   ms=0.75, fill=:red,   ml=(1,:black))\nplot!([1 1], marker=:triang, ms=0.75, fill=:red,   ml=(1,:black,:dashed))\nplot!([2 1], marker=:diamond,ms=0.75, fill=:red)\nplot!([3 1], marker=:hexagon,ms=0.75, fill=:red,   ml=(0.5,:black))\nplot!([4 1], marker=:plus,   ms=0.75, ml=(2,:red))\nplot!([5 1], marker=:square, ms=0.75, fill=:red)\nplot!([0 3], marker=(custom=\"flash\", size=1.5),  ml=1, fill=:brown)\nplot!([1 3], marker=(custom=\"hurricane\", size=1.5),  ml=1, fill=:blue)\nplot!([2 3], marker=(custom=\"pacman\",  size=1.5),  ml=1, fill=:gray)\nplot!([3 3], marker=(custom=\"star3\",   size=1.5),  ml=1, fill=:brown)\nplot!([4 3], marker=(custom=\"sun\",     size=1.5),  ml=1, fill=:yellow)\nplot!([5 3], marker=(custom=\"volcano\", size=1.5),  ml=1, fill=:red)\nplot!([1 5], marker=(custom=\"@gallo\",  size=3.5))\nplot!([4 5], marker=(custom=\"@sardinha\", size=6.0), show=true)\n\n\n\n\n\n\n\n\n\n\n\nPlot Pies, Wedges or Web (spiders). They are all synonims. We show here three different ways of plotting this symbol (depending of its complexity)\n\nusing GMT\nplot([0.5 0.5 30 100], limits=(0,6,0,3), figscale=2.5, frame=\"afg\",\n     marker=:wedge, ms=5, fill=:lightyellow, ml=2, title=\"Spiders\")\nplot!([2.5 0.5 30 100], marker=:wedge, ms=5, fill=:yellow)\nplot!([0.5 1.75 30 100], marker=(web=true, size=5, arc=0.7, pen=(0.5,:red)), ml=1)\nplot!([2.5 1.75 30 100], marker=(web=true, size=5, radial=15),\n      fill=:lightyellow, ml=0.5)\n# But we can also send the Web angle info via marker and use a Tuple as argument.\nplot!([4.5 1.75], marker=(:web, [30 330], (size=5, arc=0.7, radial=15, pen=0.25)),\n      fill=:pink, ml=1, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/10_histograms.html",
    "href": "examples/plotting_functions/10_histograms.html",
    "title": "Histograms",
    "section": "",
    "text": "The remote file v3206_06.txt contains bathymetry measurements from Vema cruise 3206. Make a frequency histogram of those depths.\nIn this example we break the frame settings in several pieces, specally because we want to add a suffix to the yy annotations.\n\nusing GMT\nhistogram(\"@v3206_06.txt\", region=(-6000,0,0,30),\n          frame=(axes=:WSen, annot=:auto, title=\"Histogram\", fill=:lightblue),\n          xlabel=\"Topography (m)\", yaxis=(label=\"Frequency\", suffix=\" %\"),\n          fill=:orange, pen=0.5, kind=:frequency, bin=250, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/10_histograms.html#fequency-histogram",
    "href": "examples/plotting_functions/10_histograms.html#fequency-histogram",
    "title": "Histograms",
    "section": "",
    "text": "The remote file v3206_06.txt contains bathymetry measurements from Vema cruise 3206. Make a frequency histogram of those depths.\nIn this example we break the frame settings in several pieces, specally because we want to add a suffix to the yy annotations.\n\nusing GMT\nhistogram(\"@v3206_06.txt\", region=(-6000,0,0,30),\n          frame=(axes=:WSen, annot=:auto, title=\"Histogram\", fill=:lightblue),\n          xlabel=\"Topography (m)\", yaxis=(label=\"Frequency\", suffix=\" %\"),\n          fill=:orange, pen=0.5, kind=:frequency, bin=250, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/10_histograms.html#polar-histogram",
    "href": "examples/plotting_functions/10_histograms.html#polar-histogram",
    "title": "Histograms",
    "section": "Polar histogram",
    "text": "Polar histogram\nThe remote file fractures_06.txt contains a compilation of fracture lengths and directions as digitized from geological maps. We will use it to create a rose diagram.\n\nusing GMT\nrose(\"@fractures_06.txt\", region=(0,1,0,360), frame=(grid=:auto, fill=:lightblue),\n     yx=true, sector=(width=10, rose=true), normalize=true, fill=:orange, pen=0.5, show=true)"
  },
  {
    "objectID": "examples/plotting_functions/10_histograms.html#stepped-patch-histogram",
    "href": "examples/plotting_functions/10_histograms.html#stepped-patch-histogram",
    "title": "Histograms",
    "section": "Stepped patch histogram",
    "text": "Stepped patch histogram\nDraw a histogram as a stepped patch\n\nusing GMT\nD1 = histogram(randn(1000), I=:o, bin=0.1);  # Create histogrammed data with bin = 0.1 (I=:o to create the dataset)\nD2 = histogram(randn(500),  I=:o, bin=0.1);\n\nlines(D1,                    # The data\n      steps=(x=true,),       # Make steps a xx\n      close=(bot=\"\",),       # Close polygon at the bottom\n      fill=(pattern=20, bg=:green, dpi=200),    # Set the pattern code, the background color and dpi\n      figsize=(15,10))       # Set fig size of 15x10 cm\nlines!(D2,                   # Second dataset\n      steps=(x=true,),       \n      close=(bot=\"\",),\n      fill=(pattern=82,bg=:blue,dpi=100),\n      title=\"Stepped patch histogram\", show=true)"
  },
  {
    "objectID": "examples/projections/index.html",
    "href": "examples/projections/index.html",
    "title": "Map Projections",
    "section": "",
    "text": "Explore various map projection types and coordinate systems available in GMT.jl."
  },
  {
    "objectID": "examples/projections/index.html#examples",
    "href": "examples/projections/index.html#examples",
    "title": "Map Projections",
    "section": "Examples",
    "text": "Examples\n\n\n\nThe true Hello World \n\n\n\n\nGMT Map Projections \n\n\n\n\nBest Rectangular World Map \n\n\n\n\nMixing UTM and Geographic Axes \n\n\n\n\nLee Oblated Stereographic \n\n\n\n\nSpilhaus Projection \n\n\n\n\nStereonets"
  },
  {
    "objectID": "examples/projections/02_proj_examples.html",
    "href": "examples/projections/02_proj_examples.html",
    "title": "GMT Map Projections",
    "section": "",
    "text": "GMT implements more than 30 different projections. They all project the input coordinates longitude and latitude to positions on a map. In general, \\(x’ = f(x,y,z)\\) and \\(y’ = g(x,y,z)\\), where z is implicitly given as the radial vector length to the (x,y) point on the chosen ellipsoid. The functions f and g can be quite nasty and we will refrain from presenting details in this document. The interested read is referred to Snyder [1987] [20]. We will mostly be using the coast command to demonstrate each of the projections. GMT map projections are grouped into four categories depending on the nature of the projection. The groups are\nClick on any projection below to jump to its detailed example."
  },
  {
    "objectID": "examples/projections/02_proj_examples.html#conic-projections",
    "href": "examples/projections/02_proj_examples.html#conic-projections",
    "title": "GMT Map Projections",
    "section": "Conic projections",
    "text": "Conic projections\n\nAlbers conic equal-area projection\nThis projection, developed by Albers in 1805, is predominantly used to map regions of large east-west extent, in particular the United States. It is a conic, equal-area projection, in which parallels are unequally spaced arcs of concentric circles, more closely spaced at the north and south edges of the map. Meridians, on the other hand, are equally spaced radii about a common center, and cut the parallels at right angles. Distortion in scale and shape vanishes along the two standard parallels. Between them, the scale along parallels is too small; beyond them it is too large. The opposite is true for the scale along meridians. To define the projection in GMT you need to provide the following information:\n\nName: aea, Albers, GMT code -&gt; B (width) b (scale)\nLongitude and latitude of the projection center.\nTwo standard parallels.\nMap scale in cm/degree or 1:xxxxx notation, or map width.\n\nNote that you must include the 1: if you choose to specify the scale that way. E.g., you can say 0.5 which means 0.5 cm/degree or 1:200000 which means 1 cm on the map equals 200,000 cm along the standard parallels. The projection center defines the origin of the rectangular map coordinates. As an example we will make a map of the region near Taiwan. We choose the center of the projection to be at 125ºE/20ºN and 25ºN and 45ºN as our two standard parallels. We desire a map that is 12 cm wide (the dafault). The complete command needed to generate the map below is therefore given by:\n\nusing GMT\ncoast(region=[110 140 20 35],                                   # The Map limits    \n      proj=(name=:Albers, center=[125 20], parallels=[25 45]),  # The projection parameters\n      frame=:ag,          # Tell it to set annotations and grid lines automatically\n      resolution=:low,    # Use the low resolution coastlines\n      area=250,           # Do not plot polygons with areas &lt; 250 km^2\n      land=:green,        # Paint land with green\n      shore=:thinnest,    # Coastlines are drwan with a 0.1 pt thickness\n      title=\"Albers equal-area conic map projection\",\n      show=true)          # Display the figure\n\n\n\n\n\n\n\n\n\n\nEquidistant conic\nThe equidistant conic projection was described by the Greek philosopher Claudius Ptolemy about A.D. 150. It is neither conformal or equal-area, but serves as a compromise between them. The scale is true along all meridians and the standard parallels. To select this projection in GMT you must provide the same information as for the other conic projection, i.e.,\n\nName: eqdc, conicEquidistant, GMT code -&gt; D (width) d (scale)\nLongitude and latitude of the projection center.\nTwo standard parallels.\nMap scale in cm/degree or 1:xxxxx notation, or map width.\n\nThe equidistant conic projection is often used for atlases with maps of small countries. As an example, we generate a map of Cuba:\n\nusing GMT\ncoast(region=[-88 -70 18 24], proj=(name=:eqdc, center=[-79 21], parallels=[19 23]),\n      frame=:ag, res=:intermediate, borders=(type=1,pen=(\"thick\",\"red\")), land=:green,\n      shore=:thinnest, title=\"Equidistant conic map projection\", show=true)\n\n\n\n\n\n\n\n\n\n\nLambert conic conformal\nThis conic projection was designed by the Alsatian mathematician Johann Heinrich Lambert (1772) and has been used extensively for mapping of regions with predominantly east-west orientation, just like the Albers projection. Unlike the Albers projection, Lambert’s conformal projection is not equal-area. The parallels are arcs of circles with a common origin, and meridians are the equally spaced radii of these circles. As with Albers projection, it is only the two standard parallels that are distortion-free. To select this projection in GMT you must provide the same information as for the Albers projection, i.e.,\n\nName: lcc, lambertConic, GMT code -&gt; L (width) l (scale)\nLongitude and latitude of the projection center.\nTwo standard parallels.\nMap scale in cm/degree or 1:xxxxx notation, or map width.\n\nThe Lambert conformal projection has been used for basemaps for all the 48 contiguous States with the two fixed standard parallels 33ºN and 45ºN. We will generate a map of the continental USA using these parameters. Note that with all the projections you have the option of selecting a rectangular border rather than one defined by meridians and parallels. Here, we choose the regular WESN region, a “fancy” basemap frame, and use degrees west for longitudes. The generating command used is\n\nusing GMT\ncoast(region=[-130 -70 24 52], proj=(name=:lambertConic, center=[-100 35], parallels=[33 45]),\n      frame=:ag, res=:low, borders=((type=1, pen=(\"thick\",\"red\")), (type=2, pen=(\"thinner\",))),\n      area=500, land=:tan, water=:blue, shore=(:thinnest,:white),\n      title=\"Lambert conformal conic map projection\", show=true)\n\n\n\n\n\n\n\n\n\n\n(American) polyconic projection\nThe polyconic projection, in Europe usually referred to as the American polyconic projection, was introduced shortly before 1820 by the Swiss-American cartographer Ferdinand Rodulph Hassler (1770–1843). As head of the Survey of the Coast, he was looking for a projection that would give the least distortion for mapping the coast of the United States. The projection acquired its name from the construction of each parallel, which is achieved by projecting the parallel onto the cone while it is rolled around the globe, along the central meridian, tangent to that parallel. As a consequence, the projection involves many cones rather than a single one used in regular conic projections.\nThe polyconic projection is neither equal-area, nor conformal. It is true to scale without distortion along the central meridian. Each parallel is true to scale as well, but the meridians are not as they get further away from the central meridian. As a consequence, no parallel is standard because conformity is lost with the lengthening of the meridians.\n\nName: poly, Polyconic, GMT code -&gt; Poly (width) poly (scale)\n\nBelow we reproduce the illustration by Snyder [1987], with a gridline every 10 and annotations only every 30º in longitude:\n\nusing GMT\ncoast(region=(-180,-20,0,90), proj=:poly, xaxis=(annot=30,grid=10), yaxis=(annot=10,grid=10),\n      area=1000, land=:lightgray, shore=:thinnest, title=\"(American) polyconic projection\", show=true)"
  },
  {
    "objectID": "examples/projections/02_proj_examples.html#azimuthal-projections",
    "href": "examples/projections/02_proj_examples.html#azimuthal-projections",
    "title": "GMT Map Projections",
    "section": "Azimuthal projections",
    "text": "Azimuthal projections\n\nLambert Azimuthal Equal-Area\nThis projection was developed by Lambert in 1772 and is typically used for mapping large regions like continents and hemispheres. It is an azimuthal, equal-area projection, but is not perspective. Distortion is zero at the center of the projection, and increases radially away from this point. To define this projection in GMT you must provide the following information:\n\nName: laea, lambertAzimuthal, GMT code -&gt; A (width) a (scale)\nLongitude and latitude of the projection center.\nOptionally, the horizon, i.e., the number of degrees from the center to the edge (&lt;= 180, default is 90).\nScale as 1:xxxxx or as radius/latitude where radius is the projected distance on the map from projection center to an oblique latitude where 0 would be the oblique Equator, or map width.\n\nTwo different types of maps can be made with this projection depending on how the region is specified. We will give examples of both types.\n\nRectangular map\nIn this mode we define our region by specifying the longitude/latitude of the lower left and upper right corners instead of the usual west, east, south, north boundaries. The reason for specifying our area this way is that for this and many other projections, lines of equal longitude and latitude are not straight lines and are thus poor choices for map boundaries. Instead we require that the map boundaries be rectangular by defining the corners of a rectangular map boundary. Using 0ºE/40ºS (lower left) and 60ºE/10ºS (upper right) as our corners we try\n.. Este so funciona uma vez por causa do -Gp. Depois e preciso fazer “destroy”\n\nusing GMT\ncoast(region=\"0/-40/60/-10+r\", proj=(name=:laea, center=[30,-30]), frame=:ag,\n      area=500, land=(pattern=10,dpi=300), shore=:thinnest, title=\"Rectangular map\", show=true)\n\n\n\n\n\n\n\n\nNote that an +r is appended to the region option to inform GMT that the region has been selected using the rectangle technique, otherwise it would try to decode the values as west, east, south, north and report an error since east &lt; west.\n\n\nHemisphere map\nHere, you must specify the world as your region. E.g., to obtain a hemisphere view that shows the Americas, try\n\nusing GMT\ncoast(region=:global, proj=(name=:laea, center=[280,30]), frame=:g, area=1000,\n      land=:navy, title=\"Lambert Equal Area\", show=true)\n\n\n\n\n\n\n\n\n\n\n\nStereographic Equal-Angle\nThis is a conformal, azimuthal projection that dates back to the Greeks. Its main use is for mapping the polar regions. In the polar aspect all meridians are straight lines and parallels are arcs of circles. While this is the most common use it is possible to select any point as the center of projection. The requirements are\n\nName: stere, Stereographic, GMT code -&gt; S (width) s (scale)\nLongitude and latitude of the projection center.\nOptionally, the horizon, i.e., the number of degrees from the center to the edge (&lt; 180, default is 90).\nScale as 1:xxxxx (true scale at pole), slat/1:xxxxx (true scale at standard parallel slat), or radius/latitude where radius is distance on map in inches from projection center to a particular oblique latitude, or simply map width.\n\nA default map scale factor of 0.9996 will be applied by default. However, the setting is ignored when a standard parallel has been specified since the scale is then implicitly given. We will look at two different types of maps.\n\nPolar Stereographic Map\nIn our first example we will let the projection center be at the north pole. This means we have a polar stereographic projection and the map boundaries will coincide with lines of constant longitude and latitude. An example is given by\n\nusing GMT\ncoast(region=(-30,30,60,72), proj=(name=:Stereographic, center=[0,90], paralles=60),\n      frame=:a10g, area=250, land=:royalblue, water=:seashell,\n      figscale=\"1:30000000\", title=\"Polar Stereographic\", show=true)\n\n\n\n\n\n\n\n\n\n\nRectangular stereographic map\nAs with Lambert’s azimuthal equal-area projection we have the option to use rectangular boundaries rather than the wedge-shape typically associated with polar projections. This choice is defined by selecting two points as corners in the rectangle and appending an +r to the region option. This command produces a map as presented in\n\nusing GMT\ncoast(region=\"-25/59/70/72+r\", proj=(name=:stereographic, center=(10,90)), frame=:a20g,\n      area=250, land=:darkbrown, shore=:thinnest, water=:lightgray,\n      title=\"Rectangular stereographic\", show=true)\n\n\n\n\n\n\n\n\n\n\nGeneral stereographic map\nIn terms of usage this projection is identical to the Lambert azimuthal equal-area projection. Thus, one can make both rectangular and hemispheric maps. Our example shows Australia using a projection pole at 130ºE/30ºS. The command used was\n\nusing GMT\ncoast(region=\"100/-42/160/-8r\", proj=(name=:stereographic, center=(130,-30)), frame=:ag,\n      area=500, land=:green, ocean=:lightblue, shore=:thinnest,\n      title=\"General stereographic\", show=true)\n\n\n\n\n\n\n\n\n\n\n\nPerspective projection\nThe perspective projection imitates in 2 dimensions the 3-dimensional view of the earth from space. The implementation in GMT is very flexible, and thus requires many input variables. Those are listed and explained below, with the values used in figure below between brackets.\n\nName: GMT code -&gt; G (width) g (scale)\nLongitude and latitude of the projection center (4ºE/52ºN).\nAltitude of the viewer above sea level in kilometers (230 km). If this value is less than 10, it is assumed to be the distance of the viewer from the center of the earth in earth radii. If an +r is appended, it is the distance from the center of the earth in kilometers.\nAzimuth in degrees (90, due east). This is the direction in which you are looking, measured clockwise from north.\nTilt in degrees (60). This is the viewing angle relative to zenith. So a tilt of 0º is looking straight down, 60º is looking from 30º above the horizon.\nTwist in degrees (180). This is the boresight rotation (clockwise) of the image. The twist of 180º in the example mimics the fact that the Space Shuttle flies upside down.\nWidth and height of the viewpoint in degrees (60). This number depends on whether you are looking with the naked eye (in which case you view is about 60º wide), or with binoculars, for example.\nScale as 1:xxxxx or as radius/latitude where radius is distance on map in inches from projection center to a particular oblique latitude, or map width (10 cm).\n\nThe imagined view of northwest Europe from a Space Shuttle at 230 km looking due east is thus accomplished by the following coast command:\n\nusing GMT\ncoast(region=:g, proj=\"G4/52/230/90/60/180/60/60\", xaxis=(annot=2,grid=2), yaxis=(annot=1,grid=1),\n      rivers=:all, land=:lightbrown, ocean=:lightblue, shore=:thinnest,\n      par=(:MAP_ANNOT_MIN_SPACING,0.65), title=\"Perspective\", show=true)\n\n\n\n\n\n\n\n\n\n\nOrthographic\nThe orthographic azimuthal projection is a perspective projection from infinite distance. It is therefore often used to give the appearance of a globe viewed from outer space. As with Lambert’s equal-area and the stereographic projection, only one hemisphere can be viewed at any time. The projection is neither equal-area nor conformal, and much distortion is introduced near the edge of the hemisphere. The directions from the center of projection are true. The projection was known to the Egyptians and Greeks more than 2,000 years ago. Because it is mainly used for pictorial views at a small scale, only the spherical form is necessary.\nTo specify the orthographic projection the same options -Jg or -JG as the perspective projection are used, but with fewer variables to supply:\n\nName: ortho, Ortographic, GMT code -&gt; G (width) g (scale)\nLongitude and latitude of the projection center.\nOptionally, the horizon, i.e., the number of degrees from the center to the edge (&lt;= 90, default is 90).\nScale as 1:xxxxx or as radius/latitude where radius is distance on map in inches from projection center to a particular oblique latitude, or map width.\n\nOur example of a perspective view centered on 75ºW/40ºN can therefore be generated by the following coast command:\n\nusing GMT\ncoast(region=:g, proj=(name=:ortho, center=(-75,41)), frame=:g, area=5000,\n      land=:pink, ocean=:thistle, title=\"Orthographic\", show=true)\n\n\n\n\n\n\n\n\n\n\nAzimuthal Equidistant\nThe most noticeable feature of this azimuthal projection is the fact that distances measured from the center are true. Therefore, a circle about the projection center defines the locus of points that are equally far away from the plot origin. Furthermore, directions from the center are also true. The projection, in the polar aspect, is at least several centuries old. It is a useful projection for a global view of locations at various or identical distance from a given point (the map center).\nTo specify the azimuthal equidistant projection you must supply:\n\nName: aeqd, azimuthalEquidistant, GMT code -&gt; E (width) e (scale)\nLongitude and latitude of the projection center.\nOptionally, the horizon, i.e., the number of degrees from the center to the edge (&lt;= 180, default is 180).\nScale as 1:xxxxx or as radius/latitude where radius is distance on map in inches from projection center to a particular oblique latitude, or map width.\n\nOur example of a global view centered on 100ºW/40ºN can therefore be generated by the following coast command. Note that the antipodal point is 180º away from the center, but in this projection this point plots as the entire map perimeter:\n\nusing GMT\ncoast(region=:global, proj=(name=:azimuthalEquidistant, center=(-100,40)), frame=:g,\n      area=10000, land=:lightgray, shore=:thinnest, title=\"Azimuthal Equidistant\", show=true)\n\npscoast [WARNING]: Fill/clip continent option (-G) may not work for this projection.\npscoast [WARNING]: If the antipode (0/1.16913e-311) is in the ocean then chances are good it will work.\npscoast [WARNING]: Otherwise, avoid projection center coordinates that are exact multiples of 80 degrees.\n\n\n\n\n\n\n\n\n\n\n\nGnomonic\nThe Gnomonic azimuthal projection is a perspective projection from the center onto a plane tangent to the surface. Its origin goes back to the old Greeks who used it for star maps almost 2500 years ago. The projection is neither equal-area nor conformal, and much distortion is introduced near the edge of the hemisphere; in fact, less than a hemisphere may be shown around a given center. The directions from the center of projection are true. Great circles project onto straight lines. Because it is mainly used for pictorial views at a small scale, only the spherical form is necessary.\nTo specify the Gnomonic projection you must supply:\n\nName: gnom, Gnomonic, GMT code -&gt; F (width) f (scale)\nLongitude and latitude of the projection center.\nOptionally, the horizon, i.e., the number of degrees from the center to the edge (&lt; 90, default is 60).\nScale as 1:xxxxx or as radius/latitude where radius is distance on map in cm from projection center to a particular oblique latitude, or map width.\n\nUsing a horizon of 60, our example of this projection centered on 120ºW/35ºN can therefore be generated by the following command:\n\nusing GMT\ncoast(region=:g, proj=(name=:Gnomonic, center=(-120,35), horizon=60),\n      frame=(annot=30, grid=15), area=10000, land=:tan, ocean=:cyan,\n      shore=:thinnest, title=\"Gnomonic\", show=true)"
  },
  {
    "objectID": "examples/projections/02_proj_examples.html#cylindrical-projections",
    "href": "examples/projections/02_proj_examples.html#cylindrical-projections",
    "title": "GMT Map Projections",
    "section": "Cylindrical projections",
    "text": "Cylindrical projections\nCylindrical projections are easily recognized for its shape: maps are rectangular and meridians and parallels are straight lines crossing at right angles. But that is where similarities between the cylindrical projections supported by GMT (Mercator, transverse Mercator, universal transverse Mercator, oblique Mercator, Cassini, cylindrical equidistant, cylindrical equal-area, Miller, and cylindrical stereographic projections) stops. Each have a different way of spacing the meridians and parallels to obtain certain desirable cartographic properties.\n\nMercator\nProbably the most famous of the various map projections, the Mercator projection takes its name from the Flemish cartographer Gheert Cremer, better known as Gerardus Mercator, who presented it in 1569. The projection is a cylindrical and conformal, with no distortion along the equator. A major navigational feature of the projection is that a line of constant azimuth is straight. Such a line is called a rhumb line or loxodrome. Thus, to sail from one point to another one only had to connect the points with a straight line, determine the azimuth of the line, and keep this constant course for the entire voyage. The Mercator projection has been used extensively for world maps in which the distortion towards the polar regions grows rather large, thus incorrectly giving the impression that, for example, Greenland is larger than South America. In reality, the latter is about eight times the size of Greenland. Also, the Former Soviet Union looks much bigger than Africa or South America. One may wonder whether this illusion has had any influence on U.S. foreign policy.\nIn the regular Mercator projection, the cylinder touches the globe along the equator. Other orientations like vertical and oblique give rise to the Transverse and Oblique Mercator projections, respectively. We will discuss these generalizations following the regular Mercator projection.\nThe regular Mercator projection requires a minimum of parameters. To use it in GMT programs you supply this information (the first two items are optional and have defaults):\n\nName: merc, Mercator, GMT code -&gt; M (width) m (scale)\nCentral meridian [Middle of your map].\nStandard parallel for true scale [Equator]. When supplied, central meridian must be supplied as well.\nScale along the equator in cm/degree or 1:xxxxx, or map width.\n\nOur example presents a world map at a scale of 0.012 inch pr degree which will give a map 4.32 inch wide. It was created with the command:\n\nusing GMT\ncoast(region=(0,360,-70,70), proj=:Mercator, xaxis=(annot=60,ticks=15), yaxis=(annot=30,ticks=15),\n      area=:5000, land=:red, scale=0.03, par=(:MAP_FRAME_TYPE,\"fancy+\"), title=\"Mercator\", show=true)\n\n\n\n\n\n\n\n\nWhile this example is centered on the Dateline, one can easily choose another configuration with the region option. A map centered on Greenwich would specify the region with region=(-180,180,-70,70)\n\n\nTransverse Mercator\nThe transverse Mercator was invented by Lambert in 1772. In this projection the cylinder touches a meridian along which there is no distortion. The distortion increases away from the central meridian and goes to infinity at 90º from center. The central meridian, each meridian 90º away from the center, and equator are straight lines; other parallels and meridians are complex curves. The projection is defined by specifying:\n\nName: tmerc, transverseMercator, GMT code -&gt; T (width) t (scale)\nThe central meridian.\nOptionally, the latitude of origin (default is the equator).\nScale along the equator in cm/degree or 1:xxxxx, or map width.\n\nThe optional latitude of origin defaults to Equator if not specified. Although defaulting to 1, you can change the map scale factor via the PROJ_SCALE_FACTOR parameter. Our example shows a transverse Mercator map of south-east Europe and the Middle East with 35ºE as the central meridian:\n\nusing GMT\ncoast(region=\"20/30/50/45r\", proj=(name=:tmerc, center=35), frame=:ag, area=250,\n      land=:lightbrown, ocean=:seashell, shore=:thinnest, scale=0.45,\n      title=\"Transverse Mercator\", show=true)\n\n\n\n\n\n\n\n\nThe transverse Mercator can also be used to generate a global map - the equivalent of the 360º Mercator map. Using the command\n\nusing GMT\ncoast(region=(0,360,-80,80), proj=(name=:tmerc, center=[330 -45]),\n      frame=(annot=30, grid=:auto, axes=:WSne), area=2000, land=:black,\n      water=:lightblue, title=\"Transverse Mercator\", show=true)\n\n\n\n\n\n\n\n\nwe made the map illustrated in figure below. Note that when a world map is given (indicated by region=(0,360,-80,80)), the arguments are interpreted to mean oblique degrees, i.e., the 360º range is understood to mean the extent of the plot along the central meridian, while the “south” and “north” values represent how far from the central longitude we want the plot to extend. These values correspond to latitudes in the regular Mercator projection and must therefore be less than 90.\n\n\nUniversal Transverse Mercator (UTM)\n\n\nOblique Mercator\nOblique configurations of the cylinder give rise to the oblique Mercator projection. It is particularly useful when mapping regions of large lateral extent in an oblique direction. Both parallels and meridians are complex curves. The projection was developed in the early 1900s by several workers. Several parameters must be provided to define the projection. GMT offers three different definitions:\n\nOption -Jo[a|A] or -JO[a|A]:\n\nName: omerc, obliqueMerc1, GMT code -&gt; Oa (width) oa (scale)\nLongitude and latitude of projection center.\nAzimuth of the oblique equator.\nScale in cm/degree or 1:xxxxx along oblique equator, or map width.\n\nOption -Jo[b|B] or -JO[b|B]:\n\nName: omerc2, obliqueMerc2, GMT code -&gt; Ob (width) ob (scale)\nLongitude and latitude of projection center.\nLongitude and latitude of second point on oblique equator.\nScale in cm/degree or 1:xxxxx along oblique equator, or map width.\n\nOption -Joc|C or -JOc|C:\n\nName: omercp, obliqueMerc3, GMT code -&gt; Oc (width) oc (scale)\nLongitude and latitude of projection center.\nLongitude and latitude of projection pole.\nScale in cm/degree or 1:xxxxx along oblique equator, or map width.\n\n\nFor all three definitions, the upper case A|B|C means we will allow projection poles in the southern hemisphere. These forms are only available when using the GMT letters code. Our example was produced by the command\n\nusing GMT\ncoast(region=\"270/20/305/25+r\", proj=(name=:omercp, center=[280 25.5], parallels=[22 69]),\n      frame=:ag, area=250, shore=:thinnest, land=:burlywood, water=:azure,\n      rose=\"jTR+w1+f2+l+o0.4\", par=(FONT_TITLE=8, MAP_TITLE_OFFSET=0.12),\n      title=\"Oblique Mercator\", show=true)\n\n\n\n\n\n\n\n\n\n\nCassini cylindrical\nThis cylindrical projection was developed in 1745 by César-François Cassini de Thury for the survey of France. It is occasionally called Cassini-Soldner since the latter provided the more accurate mathematical analysis that led to the development of the ellipsoidal formulae. The projection is neither conformal nor equal-area, and behaves as a compromise between the two end-members. The distortion is zero along the central meridian. It is best suited for mapping regions of north-south extent. The central meridian, each meridian 90º away, and equator are straight lines; all other meridians and parallels are complex curves. The requirements to define this projection are:\n\nName: cass, Cassini, GMT code -&gt; C (width) c (scale)\nLongitude and latitude of central point.\nScale in cm/degree or as 1:xxxxx, or map width.\n\nA detailed map of the island of Sardinia centered on the 8º45’E meridian using the Cassini projection can be obtained by running the command:\n\nusing GMT\ncoast(region=\"7:30/38:30/10:30/41:30r\", proj=(name=:Cassini, center=[8.75 40]),\n      frame=:afg, map_scale=\"jBR+c40+w100+f+o0.4/0.5\", land=:springgreen,\n      water=:azure, shore=:thinnest, rivers=(type=:all, pen=:thinner),\n      par=(:FONT_LABEL,12), title=\"Cassini cylindrical\", show=true)\n\n\n\n\n\n\n\n\n\n\nCylindrical equidistant\nThis simple cylindrical projection is really a linear scaling of longitudes and latitudes. The most common form is the Plate Carrée projection, where the scaling of longitudes and latitudes is the same. All meridians and parallels are straight lines. The projection can be defined by:\n\nName: eqc, PlateCarree, equidistCylindrical, GMT code -&gt; Q (width) q (scale)\nThe central meridian [Middle of your map].\nStandard parallel [Equator].\nScale in cm/degree or as 1:xxxxx, or map width.\n\nThe first two of these are optional and have defaults. When the standard parallel is defined, the central meridian must be supplied as well.\nA world map centered on the dateline using this projection can be obtained by running the command:\n\nusing GMT\ncoast(region=:global, proj=:equidistCylindrical, frame=(annot=60, ticks=30, grid=30),\n      area=5000, land=:tan4, water=:lightcyan, title=\"Cylindrical equidistant\", show=true)\n\n\n\n\n\n\n\n\nDifferent relative scalings of longitudes and latitudes can be obtained by selecting a standard parallel different from the equator. Some selections for standard parallels have practical properties as shown in table:\n\n\n\nName\nlat\n\n\n\n\nGrafarend and Niermann, minimum linear distortion\n61.7º\n\n\nRonald Miller Equirectangular\n50.5º\n\n\nRonald Miller, minimum continental distortion\n43.5º\n\n\nGrafarend and Niermann\n42º\n\n\nRonald Miller, minimum overall distortion\n37.5º\n\n\nPlate Carrée, Simple Cylindrical, Plain/Plane\n0º\n\n\n\n\n\nCylindrical equal-area\nThis cylindrical projection is actually several projections, depending on what latitude is selected as the standard parallel. However, they are all equal area and hence non-conformal. All meridians and parallels are straight lines. The requirements to define this projection are:\n\nName: cea, cylindricalEqualArea, GMT code -&gt; Y (width) y (scale)\nThe central meridian.\nThe standard parallel.\nScale in cm/degree or as 1:xxxxx, or map width\n\nWhile you may choose any value for the standard parallel and obtain your own personal projection, there are seven choices of standard parallels that result in known (or named) projections. These are listed in Table.\n\n\n\nName\nlat\n\n\n\n\nBalthasart\n50º\n\n\nGall\n45º\n\n\nHobo-Dyer\n37º30’ (= 37.5º)\n\n\nTrystan Edwards\n37º24’ (= 37.4º)\n\n\nCaster\n37º04’ (= 37.0666º)\n\n\nBehrman\n30º\n\n\nLambert\n0º\n\n\n\nFor instance, a world map centered on the 35ºE meridian using the Behrman projection can be obtained by running the command:\n\nusing GMT\ncoast(region=(-145,215,-90,90), proj=(name=:cylindricalEqualArea, center=(35,30)),\n      frame=(annot=45, grid=45), area=10000, water=:dodgerblue,\n      shore=:thinnest, title=\"Cylindrical equal-area\", show=true)\n\n\n\n\n\n\n\n\nAs one can see there is considerable distortion at high latitudes since the poles map into lines.\n\n\nMiller Cylindrical\nThis cylindrical projection, presented by Osborn Maitland Miller of the American Geographic Society in 1942, is neither equal nor conformal. All meridians and parallels are straight lines. The projection was designed to be a compromise between Mercator and other cylindrical projections. Specifically, Miller spaced the parallels by using Mercator’s formula with 0.8 times the actual latitude, thus avoiding the singular poles; the result was then divided by 0.8. There is only a spherical form for this projection. Specify the projection by:\n\nName: mill, Miller, GMT code -&gt; J (width) j (scale)\nOptionally, the central meridian (default is the middle of your map).\nScale in cm/degree or as 1:xxxxx, or map width.\n\nFor instance, a world map centered on the 90ºE meridian at a map scale of 1:400,000,000 can be obtained as follows:\n\nusing GMT\ncoast(region=(-90,270,-80,90), proj=:Miller, xaxis=(annot=45,grid=45),\n      yaxis=(annot=30,grid=30), area=10000, land=:khaki, water=:azure,\n      shore=:thinnest, scale=\"1:400000000\", title=\"Miller Cylindrical\", show=true)\n\n\n\n\n\n\n\n\n\n\nCylindrical stereographic\nThe cylindrical stereographic projections are certainly not as notable as other cylindrical projections, but are still used because of their relative simplicity and their ability to overcome some of the downsides of other cylindrical projections, like extreme distortions of the higher latitudes. The stereographic projections are perspective projections, projecting the sphere onto a cylinder in the direction of the antipodal point on the equator. The cylinder crosses the sphere at two standard parallels, equidistant from the equator. The projections are defined by:\n\nName: cyl_stere, cylindricalStereographic, GMT code -&gt; Cyl_stere (width) cyl_stere (scale)\nThe central meridian (uses the middle of the map when omitted).\nThe standard parallel (default is the Equator). When used, central meridian needs to be given as well.\nScale in cm/degree or as 1:xxxxx, or map width\n\nSome of the selections of the standard parallel are named for the cartographer or publication that popularized the projection\n\n\n\nName\nlat\n\n\n\n\nMiller’s modified Gall\n66.159467º\n\n\nKamenetskiy’s First\n55º\n\n\nGall’s stereographic\n45º\n\n\nBolshoi Sovietskii Atlas Mira or Kamenetskiy’s Second\n30º\n\n\nBraun’s cylindrical\n0º\n\n\n\nA map of the world, centered on the Greenwich meridian, using the Gall’s stereographic projection (standard parallel is 45º, Figure Gall’s stereographic projection), is obtained as follows:\n\nusing GMT\ncoast(region=(-180,180,-60,80), proj=(name=:cylindricalStereographic, center=(0,45)),\n      xaxis=(annot=60,ticks=30, grid=30), yaxis=(annot=30,grid=30), area=5000,\n      shore=:black, land=:seashell4, ocean=:antiquewhite1,\n      title=\"Cylindrical stereographic\", show=true)"
  },
  {
    "objectID": "examples/projections/02_proj_examples.html#miscellaneous-projections",
    "href": "examples/projections/02_proj_examples.html#miscellaneous-projections",
    "title": "GMT Map Projections",
    "section": "Miscellaneous projections",
    "text": "Miscellaneous projections\nGMT supports 8 common projections for global presentation of data or models. These are the Hammer, Mollweide, Winkel Tripel, Robinson, Eckert IV and VI, Sinusoidal, and Van der Grinten projections. Due to the small scale used for global maps these projections all use the spherical approximation rather than more elaborate elliptical formulae.\nIn all cases, the specification of the central meridian can be skipped. The default is the middle of the longitude range of the plot, specified by the (region) option.\n\nHammer\nThe equal-area Hammer projection, first presented by the German mathematician Ernst von Hammer in 1892, is also known as Hammer-Aitoff (the Aitoff projection looks similar, but is not equal-area). The border is an ellipse, equator and central meridian are straight lines, while other parallels and meridians are complex curves. The projection is defined by selecting:\n\nName: hamm, Hammer, GMT code -&gt; H (width) h (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nA view of the Pacific ocean using the Dateline as central meridian is accomplished thus\n\nusing GMT\ncoast(region=:g, proj=:Hammer, frame=:g, area=10000, land=:black,\n      ocean=:cornsilk, title=\"Hammer\", show=true)\n\n\n\n\n\n\n\n\n\n\nMollweide\nThis pseudo-cylindrical, equal-area projection was developed by the German mathematician and astronomer Karl Brandan Mollweide in 1805. Parallels are unequally spaced straight lines with the meridians being equally spaced elliptical arcs. The scale is only true along latitudes 4044’ north and south. The projection is used mainly for global maps showing data distributions. It is occasionally referenced under the name homalographic projection. Like the Hammer projection, outlined above, we need to specify only two parameters to completely define the mapping of longitudes and latitudes into rectangular x/y coordinates:\n\nName: moll, Mollweide, GMT code -&gt; W (width) w (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nAn example centered on Greenwich can be generated thus:\n\nusing GMT\ncoast(region=:d, proj=:Mollweide, frame=:g, area=10000, land=:tomato1,\n      water=:skyblue, title=\"Mollweide\", show=true)\n\n\n\n\n\n\n\n\n\n\nWinkel Tripel\nIn 1921, the German mathematician Oswald Winkel a projection that was to strike a compromise between the properties of three elements (area, angle and distance). The German word “tripel” refers to this junction of where each of these elements are least distorted when plotting global maps. The projection was popularized when Bartholomew and Son started to use it in its world-renowned “The Times Atlas of the World” in the mid 20th century. In 1998, the National Geographic Society made the Winkel Tripel as its map projection of choice for global maps.\nNaturally, this projection is neither conformal, nor equal-area. Central meridian and equator are straight lines; other parallels and meridians are curved. The projection is obtained by averaging the coordinates of the Equidistant Cylindrical and Aitoff (not Hammer-Aitoff) projections. The poles map into straight lines 0.4 times the length of equator. To use it you must enter\n\nName: win, Winkel, GMT code -&gt; R (width) r (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nCentered on Greenwich, the example in Figure Winkel Tripel projection was created by this command:\n\nusing GMT\ncoast(region=:d, proj=:Winkel, frame=:g, area=10000, land=:burlywood4,\n      water=:wheat1, title=\"Winkel Tripel\", show=true)\n\n\n\n\n\n\n\n\n\n\nRobinson\nThe Robinson projection, presented by the American geographer and cartographer Arthur H. Robinson in 1963, is a modified cylindrical projection that is neither conformal nor equal-area. Central meridian and all parallels are straight lines; other meridians are curved. It uses lookup tables rather than analytic expressions to make the world map “look” right [22]. The scale is true along latitudes 38. The projection was originally developed for use by Rand McNally and is currently used by the National Geographic Society. To use it you must enter\n\nName: robin, Robinson, GMT code -&gt; N (width) n (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nAgain centered on Greenwich, the example below was created by this command:\n\nusing GMT\ncoast(region=:d, proj=:Robinson, frame=:g, area=10000, land=:goldenrod,\n      water=:snow2, title=\"Robinson\", show=true)\n\n\n\n\n\n\n\n\n\n\nEckert IV and VI\nThe Eckert IV and VI projections, presented by the German cartographer Max Eckert-Greiffendorff in 1906, are pseudo-cylindrical equal-area projections. Central meridian and all parallels are straight lines; other meridians are equally spaced elliptical arcs (IV) or sinusoids (VI). The scale is true along latitudes 40º30’ (IV) and 49º16’ (VI). Their main use is in thematic world maps. To select Eckert IV you must use EckertIV while Eckert VI is selected with EckertVI. If no modifier is given it defaults to Eckert VI. In addition, you must enter\n\nName: eck4, EckertIV, GMT code -&gt; Kf (width) kf (scale)\nName: eck6, EckertVI, GMT code -&gt; Ks (width) ks (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nCentered on the Dateline, the Eckert IV example below was created by this command:\n\nusing GMT\ncoast(region=:d, proj=:EckertIV, frame=:g, area=10000, land=:ivory,\n      water=:bisque3, shore=:thinnest, title=\"Eckert IV\", show=true)\n\n\n\n\n\n\n\n\nThe same script, EckertVI instead of EckertIV, yields the Eckert VI map:\n\nusing GMT\ncoast(region=:d, proj=:EckertVI, frame=:g, area=10000, land=:ivory,\n      water=:bisque3, shore=:thinnest, title=\"Eckert VI\", show=true)\n\n\n\n\n\n\n\n\n\n\nSinusoidal\nThe sinusoidal projection is one of the oldest known projections, is equal-area, and has been used since the mid-16th century. It has also been called the “Equal-area Mercator” projection. The central meridian is a straight line; all other meridians are sinusoidal curves. Parallels are all equally spaced straight lines, with scale being true along all parallels (and central meridian). To use it, you need to select:\n\nName: sinu, Sinusoidal, GMT code -&gt; I (width) i (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nA simple world map using the sinusoidal projection is therefore obtained by\n\nusing GMT\ncoast(region=:d, proj=:Sinusoidal, xaxis=(grid=30,), yaxis=(grid=15,),\n      area=10000, land=:coral4, water=:azure3, title=\"Sinusoidal\", show=true)\n\n\n\n\n\n\n\n\nTo reduce distortion of shape the interrupted sinusoidal projection was introduced in 1927. Here, three symmetrical segments are used to cover the entire world. Traditionally, the interruptions are at 160ºW, 20ºW, and 60ºE. To make the interrupted map we must call coast for each segment and superpose the results. To produce an interrupted world map (with the traditional boundaries just mentioned) that is 5.04 inches wide we use the scale 12/360 = 0.03333 and offset the subsequent plots horizontally by their widths (140 * 0.03333 and 80 * 0.03333):\n\nusing GMT\ncoast(region=(200,340,-90,90), proj=:Sinusoidal, frame=:g, area=10000,\n      land=:darkred, water=:azure, scale=0.03333)\ncoast!(region=(-20,60,-90,90), frame=:g, area=10000, land=:darkgreen,\n       water=:azure, xshift=4.666)\ncoast!(region=(60,200,-90,90), frame=:g, area=10000, land=:darkblue,\n       water=:azure, xshift=2.6664, title=\"Interupted Sinusoidal\", show=true)\n\n\n\n\n\n\n\n\nThe usefulness of the interrupted sinusoidal projection is basically limited to display of global, discontinuous data distributions like hydrocarbon and mineral resources, etc.\n\n\nVan der Grinten\nThe Van der Grinten projection, presented by Alphons J. van der Grinten in 1904, is neither equal-area nor conformal. Central meridian and Equator are straight lines; other meridians are arcs of circles. The scale is true along the Equator only. Its main use is to show the entire world enclosed in a circle. To use it you must enter\n\nName: vand, VanderGrinten, GMT code -&gt; V (width) v (scale)\nThe central meridian [Middle of your map].\nScale along equator in cm/degree or 1:xxxxx, or map width.\n\nCentered on the Dateline, the example below was created by this command:\n\nusing GMT\ncoast(region=:g, proj=:VanderGrinten, xaxis=(grid=30,), yaxis=(grid=15,),\n      land=:lightgray, water=:cornsilk, area=10000, shore=:thinnest,\n      title=\"Van der Grinten\", show=true)"
  },
  {
    "objectID": "examples/projections/ex28.html",
    "href": "examples/projections/ex28.html",
    "title": "Mixing UTM and geographic axes annotations",
    "section": "",
    "text": "This is a question that comes up regularly such that GMT has a gallery example (famous example 28) to show how to do it. But even with that example it’s not a trivial thing to do.\nHowever it’s trivial from the Julia wrapper under the condition that the grid or image to be displayed is referenced internally. If it is not, grdedit can be used to assign a referencing system via its option proj. The other condition is that grid or image to be displayed is already in memory (so that the internal magicks can work). Given that, example 28 boils down to this (with a little bit less fancy details).\n\nusing GMT\nG = gmtread(\"@Kilauea.utm.nc\");\nC = makecpt(cmap=\"copper\", range=(0,1500));\nimshow(G, cmap=C, shade=true, frame=(axes=\"WS\", annot=true),\n    coast=(shore=true, ocean=:lightblue, frame=(axes=\"EN\", annot=true, grid=true)))\n\n\n\n\n\n\n\n\nThe above example, however, relied in having a UTM-referenced grid file already available. If you want to do the same with a global grid such as @earth_relief_03s, you can request a region in UTM coordinates and ask to project the fetched grid. This can be done on-the-fly by using the region, proj and the convert=true options in gmtread, like so:\n\nusing GMT\nG = gmtread(\"@earth_relief_03s\", region=[420000, 470000, 4510000, 4535000],\n            proj=\"+proj=utm +zone=33\", convert=true);\nimshow(G, shade=true, frame=(axes=\"WS\", annot=true),\n    coast=(shore=true, ocean=:lightblue, frame=(axes=\"EN\", annot=true, grid=true)))"
  },
  {
    "objectID": "examples/projections/spilhaus.html",
    "href": "examples/projections/spilhaus.html",
    "title": "Spilhaus projection",
    "section": "",
    "text": "The Spilhaus Projection presents the world seas and oceans as a single body of water.\n\nusing GMT\ngrdimage(\"@earth_relief_15m\", shade=true, R=:d, proj=\"+proj=spilhaus\",\n          coast=(shore=true, frame=\"Wbet 30g\"), show=true)"
  },
  {
    "objectID": "examples/CPTs/01_cpt_hinge.html",
    "href": "examples/CPTs/01_cpt_hinge.html",
    "title": "Color maps",
    "section": "",
    "text": "The CPTs distributed with GMT are dynamic. This means they have several special properties that modify the behavior of programs that use them. Dynamic CPTs comes in a few different flavors: Some CPTs were designed to behave differently across a hinge value (e.g., a CPT designed specifically for topographic relief may include a discontinuity in color across the coastline at z = 0), and when users select these CPTs they will be stretched to fit the user’s desired data range separately for each side of this hard hinge. Basically, a hard hinge CPT is the juxtaposition of two different CPTs joined at the hinge and these sections are stretched independently.\nIn the figure bellow the top color bar is a dynamic master CPT (here, globe) with a hard hinge at sea level and a natural range from -10,000 to +10,000 meters. However, our data range is asymmetrical, going from -8,000 meter depths up to +3,000 meter elevations. Because of the hinge, the two sides of the CPT will be stretched separately to honor the desired range while utilizing the full color range.\n\nusing GMT\n\nC = makecpt(cmap=:globe, range=(-8000,3000));\ncolorbar(pos=(paper=true, anchor=(0,0), size=(11.5, 0.25), horizontal=true))\ncolorbar!(cmap=:globe, frame=:auto, yshift=1.3,\n          pos=(paper=true, anchor=(0,0), size=(11.5, 0.25), horizontal=true))\nplot!([5.75 0.25 90 0.5], region=(0,11.5,0,2.5), figscale=1, proj=:linear,\n      symbol=\"v0.25+a80+b\", frame=:none, pen=1, fill=:black)\ntext!(text_record([5.7 0.9],[\"HINGE\"]), font=12, justify=:CB, show=true)\n\n\n\n\n\n\n\n\n\n\n\nThere are many ways to turn a master CPT into a custom CPT that works for your particular data range. The tools makecpt and grd2cpt allow several types of transformations to take place:\nExamples of two user CPTs for the range -0.5 to 3 created from the same master. One (left) extracted a subset of the master before scaling while the other (right) used the entire range.\n\nusing GMT\nls = [3 2.9;    # Coordinates of 6 line segments connecting example CPTs\n 5  2.5;;;\n 3  0.1;\n 5  0.5;;;\n 3  2.2;\n 1  2.5;;;\n 3  1.08;\n 1  0.5;;;\n 1  0.785;\n 3  1.5;;;\n 3  1.5;\n 5  0.785];\n\nD = mat2ds(reshape(ls, 2, 2, 6))            # Create a GMTdaset with the six line segments\nD[5].header = D[6].header = \" -W0.25p,-\"    # Tell that last two segments are dashed lines \nlines(D, region=(0,6,0,3), figscale=\"1i\", frame=:none, pen=0.25)\ncolorbar!(cmap=:globe, frame=:auto, pos=(paper=true, anchor=(\"3i\",\"1.5i\"),\n          size=(\"2.8i\",\"0.15i\"), justify=:CM), W=0.001)\nC = makecpt(cmap=:globe, range=(-500, 3000));\ncolorbar!(frame=:auto, pos=(paper=true, anchor=(\"5i\",\"1.5i\"),\n          size=(\"2.0i\",\"0.15i\"), justify=:LM), W=0.001)\nC = makecpt(cmap=:globe, truncate=(-3000,5000), range=(-500, 3000));\ncolorbar!(frame=:auto, pos=(paper=true, anchor=(\"1i\",\"1.5i\"),\n          size=(\"2.0i\",\"0.15i\"), justify=:RM, move_annot=:a), W=0.001)\n\nT = text_record([0 0; 6 0; 3 3.1; 1 3.1; 5 3.1],\n                [\"LB Scale a subset (via @%1%truncate@%%)\"\n                 \"RB    Scale entire range\";\n                 \"CB    Master CPT\";\n                 \"CB    New CPT v1\";\n                 \"CB    New CPT v2\"]);\n\ntext!(T, noclip=true, font=14, justify=true, show=true)\n\n\n\n\n\n\n\n\n\n\n\nThings become a bit more complicated when we want to label the legend with names for certain intervals (like geological time periods in the example below). To accomplish that, one should currently do a hack and add the labels manually in the CGMTcpt fields label and key, and add the equal_size option to the colorbar command that draws the color legend. This option also makes all intervals in the legend of equal length, even it the numerical values are not equally spaced.\nNormally, the name labels are plotted at the lower end of the intervals. But by adding a gap amount (even when zero) to the -L option, they are centered. The example below also shows how to annotate ranges using equal_size=(range=true,) (in which case no name labels should appear in the CPT), and how to switch the color bar around (by using a negative length).\n\nusing GMT\n\nC = makecpt(cmap=((197,0,255),(81,0,255),(0,35,255),(0,151,255),(0,255,244),(0,255,127),(0,255,11),\n                  (104,255,0),(220,255,0),(255,174,0),(255,58,0)),\n            T=[0,23,66,146,200,251,299,359,416,444,488,542]);\n# Add the labels for the periods \nC.label = [\"Neogene\", \"Paleogene\", \"Cretaceous\", \"Jurassic\", \"Triassic\", \"Permian\",\n           \"Carboniferous\", \"Devonian\", \"Silurian\", \"Ordovician\", \"Cambrian;Precambrian\"];\n\ncolorbar(pos=(paper=true,  anchor=(0,13),  size=(-8,0.5), justify=:ML, triangles=:f), B=:none)\ncolorbar!(pos=(paper=true, anchor=(4,13),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=true)\ncolorbar!(pos=(paper=true, anchor=(8,13),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0,))\ncolorbar!(pos=(paper=true, anchor=(12,13), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0.1,))\ncolorbar!(pos=(paper=true, anchor=(16,13), size=(08,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=true)\ncolorbar!(pos=(paper=true, anchor=(20,13), size=(08,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0.1,))\n\n# Remove the labels so that we can plot the ages\nC.label = fill(\"\", length(C.label));\n\ncolorbar!(pos=(paper=true, anchor=(0,4),  size=(08,0.5), justify=:ML, triangles=:f), B=:none)\ncolorbar!(pos=(paper=true, anchor=(4,4),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=true)\ncolorbar!(pos=(paper=true, anchor=(8,4),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0,))\ncolorbar!(pos=(paper=true, anchor=(12,4), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0.1,))\ncolorbar!(pos=(paper=true, anchor=(16,4), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(range=true,))\ncolorbar!(pos=(paper=true, anchor=(20,4), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(range=true, gap=0.1), show=true)"
  },
  {
    "objectID": "examples/CPTs/01_cpt_hinge.html#examples",
    "href": "examples/CPTs/01_cpt_hinge.html#examples",
    "title": "Color maps",
    "section": "",
    "text": "The CPTs distributed with GMT are dynamic. This means they have several special properties that modify the behavior of programs that use them. Dynamic CPTs comes in a few different flavors: Some CPTs were designed to behave differently across a hinge value (e.g., a CPT designed specifically for topographic relief may include a discontinuity in color across the coastline at z = 0), and when users select these CPTs they will be stretched to fit the user’s desired data range separately for each side of this hard hinge. Basically, a hard hinge CPT is the juxtaposition of two different CPTs joined at the hinge and these sections are stretched independently.\nIn the figure bellow the top color bar is a dynamic master CPT (here, globe) with a hard hinge at sea level and a natural range from -10,000 to +10,000 meters. However, our data range is asymmetrical, going from -8,000 meter depths up to +3,000 meter elevations. Because of the hinge, the two sides of the CPT will be stretched separately to honor the desired range while utilizing the full color range.\n\nusing GMT\n\nC = makecpt(cmap=:globe, range=(-8000,3000));\ncolorbar(pos=(paper=true, anchor=(0,0), size=(11.5, 0.25), horizontal=true))\ncolorbar!(cmap=:globe, frame=:auto, yshift=1.3,\n          pos=(paper=true, anchor=(0,0), size=(11.5, 0.25), horizontal=true))\nplot!([5.75 0.25 90 0.5], region=(0,11.5,0,2.5), figscale=1, proj=:linear,\n      symbol=\"v0.25+a80+b\", frame=:none, pen=1, fill=:black)\ntext!(text_record([5.7 0.9],[\"HINGE\"]), font=12, justify=:CB, show=true)\n\n\n\n\n\n\n\n\n\n\n\nThere are many ways to turn a master CPT into a custom CPT that works for your particular data range. The tools makecpt and grd2cpt allow several types of transformations to take place:\nExamples of two user CPTs for the range -0.5 to 3 created from the same master. One (left) extracted a subset of the master before scaling while the other (right) used the entire range.\n\nusing GMT\nls = [3 2.9;    # Coordinates of 6 line segments connecting example CPTs\n 5  2.5;;;\n 3  0.1;\n 5  0.5;;;\n 3  2.2;\n 1  2.5;;;\n 3  1.08;\n 1  0.5;;;\n 1  0.785;\n 3  1.5;;;\n 3  1.5;\n 5  0.785];\n\nD = mat2ds(reshape(ls, 2, 2, 6))            # Create a GMTdaset with the six line segments\nD[5].header = D[6].header = \" -W0.25p,-\"    # Tell that last two segments are dashed lines \nlines(D, region=(0,6,0,3), figscale=\"1i\", frame=:none, pen=0.25)\ncolorbar!(cmap=:globe, frame=:auto, pos=(paper=true, anchor=(\"3i\",\"1.5i\"),\n          size=(\"2.8i\",\"0.15i\"), justify=:CM), W=0.001)\nC = makecpt(cmap=:globe, range=(-500, 3000));\ncolorbar!(frame=:auto, pos=(paper=true, anchor=(\"5i\",\"1.5i\"),\n          size=(\"2.0i\",\"0.15i\"), justify=:LM), W=0.001)\nC = makecpt(cmap=:globe, truncate=(-3000,5000), range=(-500, 3000));\ncolorbar!(frame=:auto, pos=(paper=true, anchor=(\"1i\",\"1.5i\"),\n          size=(\"2.0i\",\"0.15i\"), justify=:RM, move_annot=:a), W=0.001)\n\nT = text_record([0 0; 6 0; 3 3.1; 1 3.1; 5 3.1],\n                [\"LB Scale a subset (via @%1%truncate@%%)\"\n                 \"RB    Scale entire range\";\n                 \"CB    Master CPT\";\n                 \"CB    New CPT v1\";\n                 \"CB    New CPT v2\"]);\n\ntext!(T, noclip=true, font=14, justify=true, show=true)\n\n\n\n\n\n\n\n\n\n\n\nThings become a bit more complicated when we want to label the legend with names for certain intervals (like geological time periods in the example below). To accomplish that, one should currently do a hack and add the labels manually in the CGMTcpt fields label and key, and add the equal_size option to the colorbar command that draws the color legend. This option also makes all intervals in the legend of equal length, even it the numerical values are not equally spaced.\nNormally, the name labels are plotted at the lower end of the intervals. But by adding a gap amount (even when zero) to the -L option, they are centered. The example below also shows how to annotate ranges using equal_size=(range=true,) (in which case no name labels should appear in the CPT), and how to switch the color bar around (by using a negative length).\n\nusing GMT\n\nC = makecpt(cmap=((197,0,255),(81,0,255),(0,35,255),(0,151,255),(0,255,244),(0,255,127),(0,255,11),\n                  (104,255,0),(220,255,0),(255,174,0),(255,58,0)),\n            T=[0,23,66,146,200,251,299,359,416,444,488,542]);\n# Add the labels for the periods \nC.label = [\"Neogene\", \"Paleogene\", \"Cretaceous\", \"Jurassic\", \"Triassic\", \"Permian\",\n           \"Carboniferous\", \"Devonian\", \"Silurian\", \"Ordovician\", \"Cambrian;Precambrian\"];\n\ncolorbar(pos=(paper=true,  anchor=(0,13),  size=(-8,0.5), justify=:ML, triangles=:f), B=:none)\ncolorbar!(pos=(paper=true, anchor=(4,13),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=true)\ncolorbar!(pos=(paper=true, anchor=(8,13),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0,))\ncolorbar!(pos=(paper=true, anchor=(12,13), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0.1,))\ncolorbar!(pos=(paper=true, anchor=(16,13), size=(08,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=true)\ncolorbar!(pos=(paper=true, anchor=(20,13), size=(08,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0.1,))\n\n# Remove the labels so that we can plot the ages\nC.label = fill(\"\", length(C.label));\n\ncolorbar!(pos=(paper=true, anchor=(0,4),  size=(08,0.5), justify=:ML, triangles=:f), B=:none)\ncolorbar!(pos=(paper=true, anchor=(4,4),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=true)\ncolorbar!(pos=(paper=true, anchor=(8,4),  size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0,))\ncolorbar!(pos=(paper=true, anchor=(12,4), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(gap=0.1,))\ncolorbar!(pos=(paper=true, anchor=(16,4), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(range=true,))\ncolorbar!(pos=(paper=true, anchor=(20,4), size=(-8,0.5), justify=:ML, triangles=:f),\n          B=:none, equal_size=(range=true, gap=0.1), show=true)"
  },
  {
    "objectID": "examples/contours/01_contour_examples.html",
    "href": "examples/contours/01_contour_examples.html",
    "title": "Contours",
    "section": "",
    "text": "Examples created with grdcontour, contour, contourf"
  },
  {
    "objectID": "examples/contours/01_contour_examples.html#examples",
    "href": "examples/contours/01_contour_examples.html#examples",
    "title": "Contours",
    "section": "Examples",
    "text": "Examples\n\nSimple contours\nContours are created with grdcontour that takes a grid as input (or a GMTgrid data type). This example shows uses the peaks function to create a classical example. Note, however, that the memory consumption in this example, when creating the plot, is much lower than traditional likewise examples because we will be using only one 2D array instead of 3 3D arrays (ref). In the example cont=1 and annot=2 means draw contours at every 1 unit of the G grid and annotate at every other contour line. axes=“a” means pick a default automatic annotation and labeling for the axes.\n\nusing GMT\nG = GMT.peaks();\ngrdcontour(G, cont=1, annot=2, show=true)\n\n\n\n\n\n\n\n\n\n\nColored contours\nTo make colored contours we need to generate a color map and use it. Notice that we must specify a pen attribute to get the colored contours because pen specifications are always set separately. Here we will create first a colormap with makecpt that will from -6 to 8 with steps of 1. These values are picked up after the z values of the G grid.\n\nusing GMT\nG = GMT.peaks();\ncpt = makecpt(range=(-6,8,1));      # Create the color map\ngrdcontour(G, pen=(colored=true,), show=true)\n\n\n\n\n\n\n\n\n\n\nContourf examples\nGMT does not actually have a contourf module like Matlab for example, but we can obtain the same result using grdview, grdcontour and pscontour. However, to make things the Julia wrapper wrapped up a module called contourf that makes it really easy to use. To show how it works let’s start by creating an example grid and a CPT.\n\nusing GMT\nG = GMT.peaks();\nC = makecpt(T=(-7,9,2));\ncontourf(G, C, show=true)\n\n\n\n\n\n\n\n\nIf we want to just draw some contours and not annotate them, we pass an array with the contours to be drawn.\n\nusing GMT\nG = GMT.peaks();\nC = makecpt(T=(-7,9,2));\ncontourf(G, C, contour=[-2, 0, 2, 5], show=true)\n\n\n\n\n\n\n\n\n\n\nContours from x,y,z\nThis example uses synthetic data.\n\nusing GMT\nd = [0 2 5; 1 4 5; 2 0.5 5; 3 3 9; 4 4.5 5; 4.2 1.2 5; 6 3 1; 8 1 5; 9 4.5 5];\ncontourf(d, limits=(-0.5,9.5,0,5), pen=0.25, labels=(line=(:min,:max),), show=true)\n\n\n\n\n\n\n\n\nIn the above since we did not specify a CPT the program picked the GMT’s default one. But if we want use another one it’s only a question of creating and passed it in.\n\nusing GMT\nd = [0 2 5; 1 4 5; 2 0.5 5; 3 3 9; 4 4.5 5; 4.2 1.2 5; 6 3 1; 8 1 5; 9 4.5 5];\ncpt = makecpt(range=(0,10,1), cmap=:batlow);\ncontourf(d, contours=cpt, limits=(-0.5,9.5,0,5), pen=0.25, labels=(line=(:min,:max),), show=true)\n\n\n\n\n\n\n\n\n\n\nEarth is round and GMT knows it\nCreating a periodic 0/360 grid then selecting a central meridian for a contour map.\n\nusing GMT\nG = grdmath(\"-Rg -I5 35 21 SDIST\");    # Example grid\ngrdcontour(G, region=:global360, proj=(name=:Mollweide, center=35),\n           cont=2000, pen=:thin, frame=:bare, coast=true, show=true)\n\n\n\n\n\n\n\n\n\n\nStreamlines\n\nusing GMT\nx,y = GMT.meshgrid(-10:10);\nu = 2 .* x .* y;\nv = y .^2 - x .^ 2;\nU = mat2grid(u, x[1,:], y[:,1]);\nV = mat2grid(v, x[1,:], y[:,1]);\nr,a = streamlines(U, V);\nplot(r, decorated=(locations=a, symbol=(custom=\"arrow\", size=0.3), fill=:black,\n          dec2=true), title=\"Someone wanted flowlines?\", show=true)"
  },
  {
    "objectID": "examples/legends/01_legends.html",
    "href": "examples/legends/01_legends.html",
    "title": "Legends",
    "section": "",
    "text": "Legend example using the classic mode. In this example we show the two ways in which the legend option can be used. First one is only legend=\"Bla\" and in the second one, argument as a NamedTuple, we set more detailed instructions about the legend.\n\nusing GMT\nx = linspace(0,2π,50);\nlines(x,  sin.(x), ls=\"lineDiamond\", legend=\"sin(x)\", grid=(pen=\"gray90\",), theme=(\"A2\"), xaxis=(annot=\"pi2\",))\nlines!(x, cos.(x), ls=\"linesquare\",  legend=(label=\"cos(x)\", pos=:MiddleCenter, box=:none), mc=:red, show=true)\n\n\n\n\n\n\n\n\n\n\nWith different page and frame colors filling\nWe can set the frame filling color in any of the frame, xaxis or yaxis option, and the frame and page colors can be different. Use this fact to show a equation in a legend.\n\nusing GMT\nx = 1:10\nlines(x, x.^2, limits=(0,10,0,100), linewidth=2, linestyle=\".-\", pagecolor=\"#D0DFE6FF\",\n      xaxis=(xlabel=\"x\", bgcolor=:lightgray), ylabel=\"x@+2@+\", legend=(label=\"x@+2@+\", pos=:LT), show=true)\n\n\n\n\n\n\n\n\n\n\nApples & Oranges\nThe legend method can automatically create a legend for symbols plotted using plot. Legend entries are only created when the legend option is used (but see also the legend module.)\n\nusing GMT\ngmtbegin()\n    plot(\"@Table_5_11.txt\", region=[0., 7.2, 3, 7.2], figscale=2, pen=(1.5, :gray),\n         legend=\"Branch lines\", frame=:a)\n    plot(\"@Table_5_11.txt\", marker=:circle, markersize=0.35, markercolor=\"lightgreen\",\n         markerline=\"faint\", legend=\"Apples\")\n    plot(\"@Table_5_11.txt\", marker=:triangle, ms=0.35, fill=\"orange\", legend=\"Oranges\")\n    legend(position=(anchor=:TR, width=3, offset=0.25), box=(pen=1, fill=\"gray95\", shaded=true))\ngmtend(:show)\n\n\n\n\n\n\n\n\n\n\n\nA more complex example using the legend module.\n\nusing GMT\nmakecpt(\"-Cpanoply -T-8/8 &gt; tt.cpt\")\n\nlegend((\n        vspace=-0.25,\n        header=(text=\"My Map Legend\", font=(24,\"Times-Roman\")),\n        hline=(pen=1, offset=0.5),\n        ncolumns=2,\n        vline=(pen=1, offset=0),\n        symbol1=(marker=:circ,    size=0.4, dx_left=0.25, fill=\"p300/12\", dx_right=0.75, text=\"This circle is hachured\"),\n        symbol2=(marker=:ellipse, size=0.4, dx_left=0.25, fill=:yellow,   dx_right=0.75, text=\"This ellipse is yellow\"),\n        symbol3=(marker=:wedge,   size=0.4, dx_left=0.25, fill=:green, pen=0.25, dx_right=0.75, text=\"This wedge is green\"),\n        symbol4=(marker=:fault,   size=0.65,dx_left=0.25, fill=:blue, dx_right=0.75, text=\"This is a fault\"),\n        symbol5=(marker=\"-\",      size=0.4, dx_left=0.25, pen=(0.25,:dash), dx_right=0.75, text=\"A contour\"),\n        symbol6=(marker=:vector,  size=0.65,dx_left=0.25, fill=:magenta, pen=0.5, dx_right=0.75, text=\"This is a vector\"),\n        symbol7=(marker=\"i\", size=0.4, dx_left=0.25, fill=:cyan, pen=0.25, dx_right=0.75, text=\"This triangle is boring\"),\n        hline2=(pen=1, offset=0.5),\n        vline2=(pen=1, offset=0),\n        ncolumns2=1,\n        map_scale=(lon=5, lat=5, length=\"600+u+f\"),\n        vspace2=0.13,\n        image=(width=7.5, fname=\"@SOEST_block4.png\", justify=:CT),\n        vspacep3=0.13,\n        colorbar=(name=\"tt.cpt\", offset=0.5, height=0.5, extra=\"-B0\"),\n        label=(txt=\"Smith et al., @%5%J. Geophys. Res., 99@%%, 2000\", justify=:R, font=(9, \"Times-Roman\")),\n        vspace4=0.25,\n        text1=\"Let us just try some simple text that can go on a few lines. There is no easy way to predetermine\",\n        text2=\"how many lines may be required so we may have to adjust the height to get the right size box.\"\n       ),\n       region=(0,10,0,8), pos=(paper=(1.25,1.25), width=14, justify=:BL, spacing=1.2),\n       clearance=(0.25,0.25), box=(pen=0.5, fill=:azure1),\n       figsize=16, proj=:Mercator, show=true\n      )"
  },
  {
    "objectID": "examples/ternary/ternary_examples.html",
    "href": "examples/ternary/ternary_examples.html",
    "title": "Ternary plots",
    "section": "",
    "text": "See manual at ternary\n\nA scatter plot example\nTo plot points on a ternary diagram at the positions listed in the file ternary.txt (that GMT knows where to find it), with default annotations and gridline spacings, using the specified labeling, do:\n\nusing GMT\nternary(\"@ternary.txt\", labels=(\"Clay\",\"Silt\",\"Sand\"), marker=:p, show=true)\n\n\n\n\n\n\n\n\n– Ok, good but a bit dull. What about coloring the points? And if I want to have the axes runing in clock-wise order? And what about adding a percentage symbol to the annotations?\nSimple. First we create a colormap and to rotte the axes we use the option clockwise=true. Regarding the % sign, it requires using the frame option and that obliges to be explicit on the axes labels because we are no longer using handy defaults.\n\nusing GMT\n# Make use of the knowledge that z ranges berween 0 and 71 (gmtinfo module is a friend)\nC = makecpt(T=(0,71));\nternary(\"@ternary.txt\",  marker=:p, cmap=C, clockwise=true, \n        frame=(annot=:auto, grid=:a, ticks=:a, alabel=\"Clay\", blabel=\"Silt\",\n        clabel=\"Sand\", suffix=\" %\"), show=true)\n\n\n\n\n\n\n\n\n\n\nTernary with image\nAh, much better, but now I would like to display the above data as an image.\nSolution: use the image=true option. Note that we may skip the cmap option and an automatic cmap is compute for us (but one can use whatever cmap we want, just create a colormap with the wished colors)\n\nusing GMT\nternary(\"@ternary.txt\", marker=:p, image=true, clockwise=true,\n        frame=(annot=:auto, grid=:a, ticks=:a, alabel=\"Clay\", blabel=\"Silt\",\n        clabel=\"Sand\", suffix=\" %\"), show=true)\n\n\n\n\n\n\n\n\nAnd to overlay some contours?\nAdd the contour option. This option works either with automatically picked parameters or under the user full control (which contours to draw and which to annotate, etc). For simplicity we could use the automatic mode (just set contour=true) but the ternary plots may have several short contour lines that would not be annotated because they are too short for the default setting. So, and for demonstration sake, we will use the explicit contour form where we set also the distance between the labels.\n\nusing GMT\nternary(\"@ternary.txt\", clockwise=true, image=true, \n        frame=(annot=:auto, grid=:a, ticks=:a, alabel=\"Clay\", blabel=\"Silt\", clabel=\"Sand\", suffix=\" %\"),\n        contour=(annot=10, cont=5, labels=(distance=3,)),\n        colorbar=true, show=true)\n\n\n\n\n\n\n\n\nAnd we can do a contourf style plot too, but in this case only the area inside the data cloud is imaged since the method used involves a Delaunay triangulation.\n\nusing GMT\nternary(\"@ternary.txt\", marker=:p, clockwise=true, \n        frame=(annot=:auto, grid=:a, ticks=:a, alabel=\"Clay\", blabel=\"Silt\", clabel=\"Sand\", suffix=\" %\"),\n        contourf=(annot=10, cont=5), show=true)\n\n\n\n\n\n\n\n\n\n\nDiagram with lines and text\nThis example makes use of the [tern2cart] function that converts from ternary to cartesian coordinates. It is based on this discussion of the Julia forum.\n\nusing GMT\n\nb = 0:0.01:0.3\nc1 = (1 .- b).^3 .- 0.7^3\nc2 = (1 .- 2*b).^2 .- 0.4^2\n\n# Generate the coordinates of two lines.\nt1 = tern2cart([(1 .- b .- c1) b c1])    # Note that GMT.jl function expects a Mx3 matrix\nt2 = tern2cart([(1 .- b .- c2) b c2])\n\nternary(labels=(\"A\", \"B\", \"C\"))\n\nplot!(t1, lw=2, lc=:red, ls=\"line& (a) &\")  # line style -&gt; fancy stuff\nplot!(t2, lw=2, lc=:blue)\ntext!(tern2cart([0.3 0.4 0.3]), text=\"Umbilicus\", font=18, show=true)"
  },
  {
    "objectID": "examples/themes/01_themes.html",
    "href": "examples/themes/01_themes.html",
    "title": "Theming",
    "section": "",
    "text": "See the theme docs\n\nHow to sin\n\nusing GMT\nx = linspace(0,2π,50);\nplot(x, sin.(x), linestyle=\"Line&I am sinning&\", theme=(\"A2GraphDark\"), show=true)\n\n\n\n\n\n\n\n\n\n\n\n\nusing GMT\nx = -2π:0.1:2π\nlines(x, sin.(x), limits=(-2π, 2π, -1,1), lc=\"#56B4E9\", lw=2, label=\"sin(x)\",\n      xaxis=(label=\"x\",annot=5, grid=5), ylabel=\"f(x)\", grid=(pen=(:red,:dash),), theme=(\"A2\"))\nlines!(x, cos.(x), lw=2, linestyle=:dash, legend=(label=\"cos(x)\", pos=:BL), show=true)"
  },
  {
    "objectID": "examples/embellish/01_mapscale.html",
    "href": "examples/embellish/01_mapscale.html",
    "title": "Map scales",
    "section": "",
    "text": "Example of two map scales for a Mercator projection evaluated at 53 degrees north.\n\nusing GMT\n\nbasemap(region=(0,40,50,56), proj=:Mercator, figsize=13,\n        map_scale=(anchor=:ML, scale_at_lat=53, length=\"1000k\", label=\"Scale at 53@.N\", fancy=true),\n        box=(fill=:lightcyan, clearance=0, pen=1))\n\nbasemap!(map_scale=(anchor=:BR, scale_at_lat=53, length=\"1000k\", label=true, fancy=true),\n        box=(fill=:white, clearance=0.25, pen=1, inner=true), show=true)"
  },
  {
    "objectID": "examples/arrows/11_feathers.html",
    "href": "examples/arrows/11_feathers.html",
    "title": "Feathers",
    "section": "",
    "text": "uv = [0.0 0 2.0; 0.0 30 2; 0.0 60 2; 0.0 90 2; 0.0 120 2; 0.0 150 2; 0.0 180 2; 0.0 210 2; 0.0 240 2; 0.0 270 2; 0.0 300 2; 0.0 330 2; 0.0 360 2]\n\nusing GMT\nuv = [0.0 0 2.0; 0.0 30 2; 0.0 60 2; 0.0 90 2; 0.0 120 2; 0.0 150 2; 0.0 180 2; 0.0 210 2; 0.0 240 2; 0.0 270 2; 0.0 300 2; 0.0 330 2; 0.0 360 2];\nfeather(uv, rtheta=true, aspect=\"1:1\", arrow=(len=0.5, shape=0.5,),\n        lw=0.5, fill=:green, show=true)\n\n\n\n\n\n\n\n\nSimple arrows and in function of number of arrows.\n\nusing GMT\nt = -pi/2:pi/8:pi/2; u = 10*sin.(t); v = 10*cos.(t);\nfeather(u,v, show=true)\n\n\n\n\n\n\n\n\nShow the data used in this example.\nusing GMT, PrettyTables   # hide\ngetpath4docs(file::String) = joinpath(\"..\", \"..\", \"..\", \"..\", \"..\", file) # hide\nio = IOBuffer() # hide\nD = gmtread(TESTSDIR * \"assets/wind_faro_s.dat\")\nPrettyTables.pretty_table(io, D.data; header=D.colnames, backend=Val(:html))    # hide\nprintln(\"~~~\" * String(take!(io)) * \"~~~\") # hide\nCreate a winbarb plot. Note that since the data has 4 columns we must select the 3 that we want to use in the plot. We select the columns from teir names in the D GMTdataset.\n\nusing GMT\nresetGMT()      # hide\nfeather(TESTSDIR * \"assets/wind_faro.dat\", xvar=:Time, yvar=[:azimuth, :vmean],\n        rtheta=true, nohead=1, lw=0.1, show=true)"
  },
  {
    "objectID": "examples/embellish/02_roses.html",
    "href": "examples/embellish/02_roses.html",
    "title": "Magnetic compass",
    "section": "",
    "text": "Draw a magnetic compass\nusing GMT\n\nbasemap(region=(-8,8,-6,6), proj=:Mercator,\n        compass=(map=\"\", anchor=(0,0), width=6, dec=-14.5, annot=(45,10,5,30,10,2),\n                 rose_primary=(0.25,:blue), rose_secondary=0.5, labels=\"\", justify=:CM),\n        par=(FONT_ANNOT_PRIMARY=9, FONT_LABEL=14, FONT_TITLE=24, MAP_TITLE_OFFSET=\"7p\",\n             MAP_VECTOR_SHAPE=0.5, MAP_TICK_PEN_SECONDARY=\"thinner,red\",\n             MAP_TICK_PEN_PRIMARY=\"thinner,blue\"),\n        show=true)"
  },
  {
    "objectID": "examples/embellish/02_roses.html#plain-and-fancy-directional-map-roses.",
    "href": "examples/embellish/02_roses.html#plain-and-fancy-directional-map-roses.",
    "title": "Magnetic compass",
    "section": "Plain and fancy directional map roses.",
    "text": "Plain and fancy directional map roses.\n\nusing GMT\n\n# Bare-bones plain rose showing arrow towards north and a cross indicating the cardinal directions \nbasemap(region=(-5,5,-5,5), proj=:merc, figscale=0.4, frame=:none,\n        rose=(map=true, anchor=(0,0), justify=:CM, width=2.5))\n\n# Fancy rose width a north label\nbasemap!(rose=(map=true, anchor=(0,0), justify=:CM, width=2.5, fancy=true, labels=\",,,N\"), xshift=3)\n\n# Fancy directional rose at level 3 with labels\nbasemap!(rose=(map=true, anchor=(0,0), justify=:CM, width=2.5, fancy=3, labels=true),\n         region=(-7,7,-5,5), xshift=3.5, show=true)"
  },
  {
    "objectID": "examples/images/01b_grdview.html",
    "href": "examples/images/01b_grdview.html",
    "title": "Perspective view",
    "section": "",
    "text": "We will make a perspective, color-coded view of the US Rockies from the southeast.\n\nusing GMT\n\ntopo = makecpt(color=:rainbow, range=(1000,5000,500), continuous=true);\ngrdview(\"@tut_relief.nc\", proj=:Mercator, zsize=1, shade=(azim=100, norm=\"e0.8\"), view=(135,30),\n        frame=:a, Q=\"i100\", show=true)"
  },
  {
    "objectID": "examples/images/02_pcolor.html",
    "href": "examples/images/02_pcolor.html",
    "title": "Pcolor",
    "section": "",
    "text": "{{doc pcolor}}"
  },
  {
    "objectID": "examples/images/02_pcolor.html#rectangular-grid",
    "href": "examples/images/02_pcolor.html#rectangular-grid",
    "title": "Pcolor",
    "section": "Rectangular grid",
    "text": "Rectangular grid\nCreate a pseudocolor plot with a rectangular grid.\n\nusing GMT\nG = GMT.peaks(N=21);\npcolor(G, outline=(0.5,:dot), show=true)"
  },
  {
    "objectID": "examples/images/02_pcolor.html#rectangular-grid-with-labels",
    "href": "examples/images/02_pcolor.html#rectangular-grid-with-labels",
    "title": "Pcolor",
    "section": "Rectangular grid with labels",
    "text": "Rectangular grid with labels\n\nusing GMT\nG = GMT.peaks(N=21);\npcolor(G.x, G.y, G.z, labels=:yes, show=true)"
  },
  {
    "objectID": "examples/images/02_pcolor.html#non-rectangular-grid",
    "href": "examples/images/02_pcolor.html#non-rectangular-grid",
    "title": "Pcolor",
    "section": "Non-rectangular grid",
    "text": "Non-rectangular grid\nCreate a pseudocolor plot with a non-rectangular grid.\n\nusing GMT\nX,Y = GMT.meshgrid(-3:6/17:3);\nXX = 2*X .* Y;\nYY = X.^2 .- Y.^2;\npcolor(XX,YY, reshape(repeat([1:18; 18:-1:1], 9,1), size(XX)), lc=:black, show=true)"
  },
  {
    "objectID": "examples/images/04_triplot.html",
    "href": "examples/images/04_triplot.html",
    "title": "Triplot",
    "section": "",
    "text": "{{doc triplot}}"
  },
  {
    "objectID": "examples/images/04_triplot.html#delaunay-triangulation",
    "href": "examples/images/04_triplot.html#delaunay-triangulation",
    "title": "Triplot",
    "section": "Delaunay triangulation",
    "text": "Delaunay triangulation\n\nusing GMT\ntriplot(rand(10,3), lc=:red, title=\"Delaunay\", show=true)"
  },
  {
    "objectID": "examples/misc/cube_sides.html",
    "href": "examples/misc/cube_sides.html",
    "title": "Plot on the sides of a cube",
    "section": "",
    "text": "This example shows how we can plot images on the sides of a cube. We can print them either on the back side and use the left available space to plot another thing, as in:\n\nusing GMT\n\nviz(GMT.peaks(N=100), zsize=8, facades=(GMT.TESTSDIR * \"assets/cenora_base.jpg\",\n                                        GMT.TESTSDIR * \"assets/bunny_cenora.jpg\",\n                                        GMT.TESTSDIR * \"assets/burro_cenora.jpg\"))\n\n\n\n\n\n\n\n\nThe above example used the helper function imshow (well, its alias viz) that knew what to do when it found the keyword facades, but in fact the work was done by the function cubeplot. Next example shows how to call that function directly to plot three images in the front sides of the cube.\n\nusing GMT      # Hide\n\ncubeplot(GMT.TESTSDIR * \"assets/seila_gray.jpg\",\n         GMT.TESTSDIR * \"assets/seis_section_rgb.jpg\",\n         GMT.TESTSDIR * \"assets/seis_section_gray.jpg\",\n         zsize=6, show=true)"
  },
  {
    "objectID": "examples/misc/mix_paper_geog.html",
    "href": "examples/misc/mix_paper_geog.html",
    "title": "Annotations in geog maps",
    "section": "",
    "text": "When we want to make annotations or draw additional symbols outside of a map in geographical coordinates, we have a problem. Because the geographical coordinates are active one cannot plot outside of Earth. The solution is to define a larger cartesian frame and do the annotations using this new reference. To make this process simpler we use the option paper option that is available in the plot, text and colorbar modules. This option sets and unsets the temporary cartesian frame under the hood and we only have to care to use cm (or inch) as units.\nTo help even further, we can ask to plot a paper grid that will show the paper coordinates. That is obtained by using paper=:grid\n\nusing GMT\n\n# First plot in geographical coordinates\ncoast(region=:global, projection=:ortho, figsize=10, land=\"brown\")\n\n# Add annotations using paper coordinates and ask to plot also the paper grid\narrows!([1 1 6.5 6.5; -1 10 5 10; 10 19 10 15; 21 10 15 10; 19 1 13.5 6.5],\n        lw=2, fill=:darkgreen, arrow=(length=\"20p\",), endpoint=true,\n        paper=:grid, noclip=true)\ntext!(text=\"Cupidos Invasion\", x=14, y=15, justify=:BL, font=18, paper=true, show=1)\n\n\n\n\n\n\n\n\nOnce we are satisfied with the annotations we redo the map but this time with paper=true Note also that we can specify the arrow head size with the markersize (or ms) keyword.\n\nusing GMT\ncoast(region=:global, projection=:ortho, figsize=10, land=\"brown\")\narrows!([1 1 6.5 6.5; -1 10 5 10; 10 19 10 15; 21 10 15 10; 19 1 13.5 6.5],\n        lw=2, fill=:darkgreen, ms=\"20p\", endpoint=true, paper=true, noclip=true)\ntext!(text=\"Cupidos Invasion\", x=14, y=15, justify=:BL, font=18, paper=true, show=1)"
  },
  {
    "objectID": "examples/plotting_functions.html",
    "href": "examples/plotting_functions.html",
    "title": "Plotting functions",
    "section": "",
    "text": "Plotting functions\n{{list_folder_with_images plotting_functions}}"
  }
]